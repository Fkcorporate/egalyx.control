import os
import re
import socket
import tempfile
import uuid
import random
import json
import csv
import sys
import time
import hashlib
import io
import traceback
from datetime import datetime, timedelta, timezone
from unicodedata import normalize
from math import atan2, cos, sin, pi
from io import BytesIO, StringIO
from functools import wraps
import math
from flask_babel import Babel, gettext as _, lazy_gettext as _l
import gettext
from sqlalchemy.orm import joinedload, selectinload, lazyload
# ========================
# IMPORTS FLASK ET EXTENSIONS
# ========================
from flask import (
    Flask, render_template, request, redirect, url_for,
    flash, jsonify, session, send_file, Response,
    make_response, abort, Blueprint, g, render_template_string 
)
from flask_login import (
    LoginManager, login_user, logout_user,
    login_required, current_user
)
from flask_wtf.csrf import CSRFProtect
from flask_migrate import Migrate
from werkzeug.utils import secure_filename
from werkzeug.security import generate_password_hash, check_password_hash
from markupsafe import escape, Markup
from sqlalchemy import event, and_, or_, not_, text
from apscheduler.schedulers.background import BackgroundScheduler
from forms_dispositifs import (
    DispositifMaitriseForm, 
    EvaluationDispositifForm,
    VerificationDispositifForm,
    DocumentDispositifForm, SimplePlanActionForm, SousActionForm, CampagneForm
)

# ========================
# NE PAS IMPORTER FLASK-MAIL ICI
# Nous allons utiliser une solution alternative
# ========================
FLASK_MAIL_AVAILABLE = False  # Forcer la d√©sactivation
print("‚ö†Ô∏è Flask-Mail d√©sactiv√© - Utilisation de SMTP direct")

# ========================
# CR√âATION DE L'APPLICATION FLASK
# ========================
app = Flask(__name__)
app.config.from_object('config.Config')

# ========================
# IMPORT DE LA BASE DE DONN√âES
# ========================
try:
    from models import db
    db.init_app(app)
    print("‚úÖ SQLAlchemy initialis√©")
    
    # Import des mod√®les sp√©cifiques apr√®s db
    from models import (
        User, Direction, Service, Cartographie, Risque, EvaluationRisque,
        KRI, MesureKRI, Processus, EtapeProcessus, SousEtapeProcessus, LienProcessus,
        ZoneRisqueProcessus, ControleProcessus, VeilleReglementaire, ActionConformite,
        Audit, Constatation, Recommandation, PlanAction, EtapePlanAction, HistoriqueModification,
        Alerte, ZoneRisqueOrganigramme, PointDecision, LigneOrganisation, TitreOrganisation,
        ConfigurationAudit, TemplateConstatation, TemplateRecommandation,
        ProcessusActivite, ElementLogigramme, LienLogigramme, VeilleDocument, ParametreEvaluation,
        GuideEvaluation, JournalActivite, PermissionTemplate, SystemLog, Notification,
        ConfigurationChampRisque, ConfigurationListeDeroulante, ChampPersonnaliseRisque, 
        FichierRisque, FichierKRI,
        AuditRisque, SousAction, JournalAudit, HistoriqueRecommandation, MatriceMaturite,
        Questionnaire, QuestionnaireCategorie, Question, OptionQuestion, ConditionQuestion,
        ReponseQuestionnaire, ReponseQuestion, ReponseOption, CampagneEvaluation,
        AnalyseIA, FichierMetadata, RecommandationGlobale, JournalActiviteClient, EnvironnementClient, Client,
        FormuleAbonnement, AbonnementClient, FichierRapport, VerificationDispositif, DocumentDispositif,
        DispositifMaitrise, CommentairePlanAction, FichierPlanAction, PlanPluieAudit, MissionAudit, ProgrammeAudit,
        AlerteCollecte, TransformateurDonnee, CollecteDonnee, SourceKRILink, SourceDonnee, ConfigurationOrganigramme
    )
    
    MODELS_IMPORTED = True
    print("‚úÖ Tous les mod√®les import√©s avec succ√®s")
    
except ImportError as e:
    MODELS_IMPORTED = False
    print(f"‚ùå Erreur import mod√®les: {e}")
    traceback.print_exc()

# ========================
# D√âFINIR LA VARIABLE GLOBALE db
# ========================
if 'db' not in locals():
    from flask_sqlalchemy import SQLAlchemy
    db = SQLAlchemy(app)
    print("‚ö†Ô∏è Base de donn√©es cr√©√©e par d√©faut")

# ========================
# CR√âER LES TABLES AU D√âMARRAGE (si elles n'existent pas)
# ========================
with app.app_context():
    try:
        # Cr√©er toutes les tables
        db.create_all()
        print("‚úÖ Tables cr√©√©es/v√©rifi√©es avec succ√®s")
        
        # V√©rifier sp√©cifiquement les tables de collecte
        from sqlalchemy import inspect
        inspector = inspect(db.engine)
        tables_existantes = inspector.get_table_names()
        
        tables_collecte = ['sources_donnees', 'source_kri_links', 'collectes_donnees', 
                          'transformateurs_donnees', 'alertes_collecte']
        
        manquantes = [t for t in tables_collecte if t not in tables_existantes]
        
        if manquantes:
            print(f"‚ö†Ô∏è Tables de collecte manquantes: {', '.join(manquantes)}")
            print("   Elles seront cr√©√©es lors du prochain red√©marrage")
            COLLECTE_DISPONIBLE = False
        else:
            print("‚úÖ Toutes les tables de collecte sont pr√©sentes")
            COLLECTE_DISPONIBLE = True
            
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur lors de la cr√©ation des tables: {e}")
        COLLECTE_DISPONIBLE = False

# ========================
# INITIALISER LE PLANIFICATEUR (UNIQUEMENT SI LES TABLES EXISTENT)
# ========================
if COLLECTE_DISPONIBLE:
    try:
        from tasks import CollecteScheduler
        
        # Tenter d'importer SourceDonnee pour v√©rifier
        try:
            from models import SourceDonnee
            # Test simple pour v√©rifier que la table est accessible
            with app.app_context():
                test_count = SourceDonnee.query.count()
                print(f"üìä {test_count} sources de donn√©es trouv√©es")
                
            collecte_scheduler = CollecteScheduler(app, db)
            collecte_scheduler.demarrer()
            
            @app.teardown_appcontext
            def shutdown_scheduler(exception=None):
                if 'collecte_scheduler' in locals():
                    collecte_scheduler.arreter()
                    
            print("‚úÖ Planificateur de collectes d√©marr√© avec succ√®s")
            
        except Exception as e:
            print(f"‚ö†Ô∏è Impossible d'acc√©der aux sources de donn√©es: {e}")
            print("   Le planificateur ne sera pas d√©marr√© maintenant")
            COLLECTE_DISPONIBLE = False
            
    except ImportError as e:
        print(f"‚ö†Ô∏è CollecteScheduler non disponible: {e}")
        print("   Le planificateur de collecte ne sera pas d√©marr√©")
else:
    print("‚è∏Ô∏è Planificateur de collectes non d√©marr√© (tables manquantes)")
    print("   Les tables seront cr√©√©es au prochain red√©marrage")

# ========================
# INITIALISER LES AUTRES EXTENSIONS
# ========================
csrf = CSRFProtect(app)
login_manager = LoginManager(app)
login_manager.login_view = 'login'
login_manager.login_message = 'Veuillez vous connecter pour acc√©der √† cette page.'
login_manager.login_message_category = 'info'

migrate = Migrate(app, db)
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
IS_RENDER = os.environ.get('RENDER', False)

# ========================
# SOLUTION ALTERNATIVE POUR LES EMAILS (SMTP DIRECT)
# ========================
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.header import Header
from email.utils import formataddr

class EmailService:
    """Service d'email utilisant SMTP direct sans Flask-Mail"""
    
    def __init__(self):
        self.smtp_server = 'smtp.gmail.com'
        self.smtp_port = 587
        self.sender_email = 'contact.fkcorporate@gmail.com'
        self.sender_name = 'FK Corporate Intelligence'
        self.password = os.environ.get('GMAIL_APP_PASSWORD', '')
        
        # V√©rifier si les credentials sont disponibles
        if not self.password:
            print("‚ö†Ô∏è GMAIL_APP_PASSWORD non d√©fini - emails en mode simulation")
            self.simulation_mode = True
        else:
            self.simulation_mode = False
            print(f"‚úÖ Service email SMTP configur√© ({self.sender_email})")
    
    def send_email(self, to_email, subject, body, html_body=None, cc=None, bcc=None):
        """Envoyer un email via SMTP direct"""
        
        # Mode simulation si pas de mot de passe
        if self.simulation_mode:
            print(f"üìß [SIMULATION] Email √†: {to_email}")
            print(f"   Sujet: {subject}")
            print(f"   Contenu: {body[:100]}...")
            return True
        
        try:
            # Cr√©er le message
            msg = MIMEMultipart('alternative')
            msg['Subject'] = subject
            msg['From'] = formataddr((str(Header(self.sender_name, 'utf-8')), self.sender_email))
            
            # G√©rer les destinataires
            if isinstance(to_email, list):
                msg['To'] = ', '.join(to_email)
                recipients = to_email
            else:
                msg['To'] = to_email
                recipients = [to_email]
            
            # Ajouter CC si sp√©cifi√©
            if cc:
                if isinstance(cc, list):
                    msg['Cc'] = ', '.join(cc)
                    recipients.extend(cc)
                else:
                    msg['Cc'] = cc
                    recipients.append(cc)
            
            # Ajouter BCC si sp√©cifi√©
            if bcc:
                if isinstance(bcc, list):
                    recipients.extend(bcc)
                else:
                    recipients.append(bcc)
            
            # Partie texte
            text_part = MIMEText(body, 'plain', 'utf-8')
            msg.attach(text_part)
            
            # Partie HTML si fournie
            if html_body:
                html_part = MIMEText(html_body, 'html', 'utf-8')
                msg.attach(html_part)
            
            # Envoyer via SMTP
            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
                server.starttls()
                server.login(self.sender_email, self.password)
                server.send_message(msg, from_addr=self.sender_email, to_addrs=recipients)
            
            print(f"‚úÖ Email envoy√© √† {to_email}")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur envoi email √† {to_email}: {e}")
            # Fallback en mode simulation
            print(f"üìß [FALLBACK SIMULATION] Email √†: {to_email}")
            print(f"   Sujet: {subject}")
            return False
    
    def send_contact_confirmation(self, nom_complet, email, societe, telephone, sujet, message, reference):
        """Envoyer les emails pour une demande de contact"""
        
        # 1. Email √† l'administrateur
        admin_subject = f"Nouvelle demande: {sujet[:50]}"
        admin_body = f"""
        NOUVELLE DEMANDE DE CONTACT
        
        Nom: {nom_complet}
        Email: {email}
        Soci√©t√©: {societe or 'Non sp√©cifi√©'}
        T√©l√©phone: {telephone or 'Non sp√©cifi√©'}
        
        Sujet: {sujet}
        
        Message:
        {message}
        
        R√©f√©rence: {reference}
        Date: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}
        """
        
        admin_sent = self.send_email(
            to_email='contact.fkcorporate@gmail.com',
            subject=admin_subject,
            body=admin_body
        )
        
        # 2. Email de confirmation au client
        client_subject = "Confirmation de votre demande"
        client_html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <style>
                body {{ font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; }}
                .header {{ background: #0A1929; color: white; padding: 30px; text-align: center; border-radius: 5px 5px 0 0; }}
                .content {{ padding: 30px; background: #f8f9fa; border-radius: 0 0 5px 5px; }}
                .info-box {{ background: white; padding: 20px; border-radius: 5px; margin: 20px 0; border-left: 4px solid #0066CC; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>FK Corporate Intelligence</h1>
                <p>Confirmation de votre demande</p>
            </div>
            <div class="content">
                <h2>Bonjour {nom_complet},</h2>
                <p>Nous avons bien re√ßu votre demande de d√©monstration.</p>
                <div class="info-box">
                    <p><strong>R√©f√©rence :</strong> {reference}</p>
                    <p><strong>Sujet :</strong> {sujet}</p>
                    <p><strong>Date :</strong> {datetime.now().strftime('%d/%m/%Y √† %H:%M')}</p>
                </div>
                <p>Notre √©quipe vous contactera dans les plus brefs d√©lais pour organiser une d√©monstration personnalis√©e.</p>
                <p>Cordialement,<br><strong>L'√©quipe FK Corporate Intelligence</strong></p>
                <hr>
                <p style="font-size: 12px; color: #666;">
                    Cet email a √©t√© envoy√© automatiquement. Merci de ne pas y r√©pondre.<br>
                    FK Corporate Intelligence - contact.fkcorporate@gmail.com
                </p>
            </div>
        </body>
        </html>
        """
        
        client_body = f"""
        Confirmation de votre demande
        
        Bonjour {nom_complet},
        
        Nous avons bien re√ßu votre demande de d√©monstration.
        
        R√©f√©rence : {reference}
        Sujet : {sujet}
        Date : {datetime.now().strftime('%d/%m/%Y √† %H:%M')}
        
        Notre √©quipe vous contactera dans les plus brefs d√©lais.
        
        Cordialement,
        L'√©quipe FK Corporate Intelligence
        """
        
        client_sent = self.send_email(
            to_email=email,
            subject=client_subject,
            body=client_body,
            html_body=client_html
        )
        
        return admin_sent and client_sent

# Initialiser le service email
email_service = EmailService()

# ========================
# AUTRES IMPORTS
# ========================

# AJOUTER CES IMPORTS MANQUANTS
from flask_wtf import FlaskForm
from wtforms import (
    StringField, PasswordField, BooleanField, SelectField, 
    TextAreaField, IntegerField, DateField, DateTimeField,
    DecimalField, FloatField, HiddenField, FieldList, FormField,
    FileField, MultipleFileField, RadioField, SelectMultipleField,
    SubmitField
)
from wtforms.validators import (
    DataRequired, Email, Length, EqualTo, Optional,
    NumberRange, ValidationError, URL, Regexp
)
import secrets

# ========================
# REPORTLAB ‚Äì G√âN√âRATION PDF
# ========================

try:
    from reportlab.lib.pagesizes import letter, A4, landscape
    from reportlab.lib import colors
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch, cm
    from reportlab.platypus import (
        SimpleDocTemplate, Paragraph, Spacer,
        Table, TableStyle, Image, PageBreak
    )
    from reportlab.pdfgen import canvas
    from reportlab.graphics.shapes import (
        Drawing, Line, Rect, Circle,
        Polygon, String
    )
    from reportlab.graphics import renderPDF
    from reportlab.lib.colors import HexColor
    from reportlab.graphics.charts.textlabels import Label

    REPORTLAB_AVAILABLE = True

except ImportError:
    REPORTLAB_AVAILABLE = False
    print("‚ö†Ô∏è ReportLab non disponible ‚Äì g√©n√©ration PDF d√©sactiv√©e")

# ========================
# PYTHON-DOCX ‚Äì G√âN√âRATION WORD
# ========================
try:
    from docx import Document
    from docx.shared import Inches, Pt, RGBColor
    from docx.enum.text import WD_ALIGN_PARAGRAPH
    from docx.enum.style import WD_STYLE_TYPE

    DOCX_AVAILABLE = True

except ImportError:
    DOCX_AVAILABLE = False
    print("‚ö†Ô∏è python-docx non disponible ‚Äì g√©n√©ration Word d√©sactiv√©e")

# ========================
# WINDOWS COM (OPTIONNEL)
# ========================
try:
    import pythoncom  # Utilis√© uniquement sous Windows (export Word/PDF avanc√©)
    WINDOWS_COM_AVAILABLE = True
except ImportError:
    WINDOWS_COM_AVAILABLE = False

# ========================
# IMPORTS DE CONFIGURATION
# ========================
from config import Config

try:
    from services.analyse_ia import ServiceAnalyseIA
    SERVICE_ANALYSE_IA_AVAILABLE = True
except ImportError:
    SERVICE_ANALYSE_IA_AVAILABLE = False
    print("‚ö†Ô∏è Service analyse IA non disponible")

try:
    from services.notification_service import NotificationService
    NOTIFICATION_SERVICE_AVAILABLE = True
    print("‚úÖ Service de notifications import√©")
except ImportError as e:
    print(f"‚ö†Ô∏è Erreur import service notifications: {e}")
    NOTIFICATION_SERVICE_AVAILABLE = False

# Importer le blueprint des notifications
try:
    from routes.notifications import notifications_bp
    NOTIFICATIONS_ROUTES_AVAILABLE = True
    print("‚úÖ Routes notifications import√©es")
except ImportError as e:
    print(f"‚ö†Ô∏è Erreur import routes notifications: {e}")
    NOTIFICATIONS_ROUTES_AVAILABLE = False

# ========================
# IMPORT DES FORMULAIRES
# ========================
try:
    from forms import (
    LoginForm, UserForm, DirectionForm, ServiceForm, CartographieForm, RisqueForm,
    EvaluationForm, KRIForm, ProcessusForm, VeilleReglementaireForm, ActionConformiteForm, 
    EtapeProcessusForm,
    # FORMULAIRES AUDIT
    SimpleAuditForm as AuditForm,
    SimpleRecommandationForm as RecommandationForm,
    SimplePlanActionForm as PlanActionForm,
    SimpleConstatationForm as ConstatationForm,
    EtapePlanActionForm,
    ArchiveRisqueForm, SousEtapeForm, ZoneRisqueForm, ControleForm,
    ConfigurationAuditForm, TemplateConstatationForm, LogigrammeForm,
    DocumentVeilleForm, ConfigurationChampForm, ConfigurationListeForm, UploadFichierForm,
    # FORMULAIRES POUR LES FONCTIONNALIT√âS AUDIT
    EditAuditForm, ArchiveAuditForm, EditConstatationForm, EditRecommandationForm,
    SousActionForm, EditPlanActionForm, AssociationRisquesForm, MatriceMaturiteForm,
    CommentaireForm, NotificationPreferencesForm, ExportRapportForm,
    AnalyseIAForm, ChecklistAuditForm, ExportAuditForm, ConstatationFilterForm, AuditFilterForm,
    # FORMULAIRES POUR LES QUESTIONNAIRES
    QuestionnaireForm, CategorieQuestionnaireForm, QuestionForm,
    OptionQuestionForm, ConditionQuestionForm, ImportQuestionnaireForm, ExportQuestionnaireForm, 
    LienLogigrammeForm, ElementLogigrammeForm, CommentaireSousActionForm, PlanPluieForm, MissionAuditForm, ProgrammeAuditForm
)

    
    FORMS_IMPORTED = True
except ImportError as e:
    print(f"‚ùå Erreur import formulaires: {e}")
    traceback.print_exc()
    FORMS_IMPORTED = False

try:
    from forms_evaluation import EvaluationTriPhaseForm
    
    # IMPORT CRITIQUE - LES FORMULAIRES D'ADMIN DOIVENT √äTRE DISPONIBLES
    try:
        from forms_admin import (
            NouvelUtilisateurForm, EditerUtilisateurForm, PermissionTemplateForm,
            NouveauClientForm, EnvironnementClientForm, FormuleAbonnementForm, FeaturesForm, ModulesForm, RolesForm
        )
        ADMIN_FORMS_IMPORTED = True
        print("‚úÖ Formulaires admin import√©s avec succ√®s")
    except ImportError as e:
        print(f"‚ö†Ô∏è Erreur import formulaires admin: {e}")
        traceback.print_exc()
        
        # Cr√©er des formulaires de secours COMPLETS
        from flask_wtf import FlaskForm
        from wtforms import StringField, PasswordField, SelectField, BooleanField, SubmitField, TextAreaField, IntegerField
        from wtforms.validators import DataRequired, Email, Length, Optional, EqualTo
        
        # FORMULAIRE DE NOUVEL UTILISATEUR COMPLET
        class NouvelUtilisateurForm(FlaskForm):
            username = StringField('Nom d\'utilisateur', validators=[DataRequired()])
            email = StringField('Email', validators=[DataRequired(), Email()])
            password = PasswordField('Mot de passe', validators=[DataRequired(), Length(min=6)])
            confirm_password = PasswordField('Confirmer le mot de passe', 
                validators=[DataRequired(), EqualTo('password', message='Les mots de passe doivent correspondre')])
            role = SelectField('R√¥le', choices=[
                ('utilisateur', 'Utilisateur'),
                ('auditeur', 'Auditeur'),
                ('compliance', 'Responsable Conformit√©'),
                ('manager', 'Manager'),
                ('admin', 'Administrateur'),
                ('consultant', 'Consultant')
            ], default='utilisateur')
            department = StringField('D√©partement')
            is_active = BooleanField('Actif', default=True)
            template_permissions = SelectField('Template de permissions', coerce=int)
            submit = SubmitField('Cr√©er l\'utilisateur')
        
        # FORMULAIRE D'√âDITION D'UTILISATEUR COMPLET
        class EditerUtilisateurForm(FlaskForm):
            username = StringField('Nom d\'utilisateur', validators=[DataRequired()])
            email = StringField('Email', validators=[DataRequired(), Email()])
            password = PasswordField('Nouveau mot de passe (laisser vide pour ne pas changer)', validators=[Optional()])
            confirm_password = PasswordField('Confirmer le mot de passe', validators=[Optional()])
            role = SelectField('R√¥le', choices=[
                ('admin', 'Administrateur'),
                ('manager', 'Manager'),
                ('user', 'Utilisateur'),
                ('auditor', 'Auditeur'),
                ('compliance', 'Conformit√©')
            ])
            department = StringField('D√©partement')
            is_active = BooleanField('Actif')
            template_permissions = SelectField('Template de permissions', coerce=int)
            submit = SubmitField('Mettre √† jour')
        
        # FORMULAIRE DE TEMPLATE DE PERMISSIONS
        class PermissionTemplateForm(FlaskForm):
            name = StringField('Nom du template', validators=[DataRequired()])
            description = TextAreaField('Description')
            role = SelectField('R√¥le associ√©', choices=[
                ('utilisateur', 'Utilisateur'),
                ('auditeur', 'Auditeur'),
                ('manager', 'Manager'),
                ('admin', 'Administrateur'),
                ('compliance', 'Conformit√©'),
                ('consultant', 'Consultant')
            ], default='utilisateur')
            submit = SubmitField('Enregistrer')
        
        # FORMULAIRES CLIENT (nouveaux)
        class NouveauClientForm(FlaskForm):
            nom = StringField('Nom du client', validators=[DataRequired()])
            reference = StringField('R√©f√©rence client', validators=[DataRequired()])
            description = TextAreaField('Description')
            contact_nom = StringField('Nom du contact')
            contact_email = StringField('Email du contact', validators=[Email()])
            contact_telephone = StringField('T√©l√©phone du contact')
            domaine = StringField('Domaine personnalis√©')
            plan = SelectField('Plan', choices=[
                ('standard', 'Standard (10 utilisateurs)'),
                ('premium', 'Premium (50 utilisateurs)'),
                ('enterprise', 'Enterprise (Illimit√©)')
            ], default='standard')
            max_utilisateurs = IntegerField('Limite utilisateurs', default=10)
            max_risques = IntegerField('Limite risques', default=1000)
            max_audits = IntegerField('Limite audits', default=100)
            provisionner_serveur = BooleanField('Provisionner un serveur d√©di√©', default=False)
            environnement_nom = StringField('Nom de l\'environnement')
            sous_domaine = StringField('Sous-domaine')
            submit = SubmitField('Cr√©er le client')
        
        class EnvironnementClientForm(FlaskForm):
            nom = StringField('Nom de l\'environnement', validators=[DataRequired()])
            sous_domaine = StringField('Sous-domaine')
            server_ip = StringField('Adresse IP du serveur')
            server_port = IntegerField('Port SSH', default=22)
            server_ssh_user = StringField('Utilisateur SSH')
            cpu_alloue = StringField('CPU allou√©', default='1 core')
            ram_alloue = StringField('RAM allou√©e', default='1GB')
            stockage_alloue = StringField('Stockage allou√©', default='10GB')
            submit = SubmitField('Mettre √† jour')
        
        ADMIN_FORMS_IMPORTED = False
        print("‚ö†Ô∏è Utilisation des formulaires admin de secours")
    
    OTHER_FORMS_IMPORTED = True
except ImportError as e:
    print(f"‚ö†Ô∏è Erreur import autres formulaires: {e}")
    OTHER_FORMS_IMPORTED = False

    
# ========================
# IMPORT DES SERVICES IA (avec gestion d'erreurs)
# ========================
try:
    # Cr√©er le dossier services s'il n'existe pas
    if not os.path.exists('services'):
        os.makedirs('services', exist_ok=True)
    
    # V√©rifier si les fichiers de services existent
    if os.path.exists('services/analyse_ia.py'):
        from services.analyse_ia import ServiceAnalyseIA
        SERVICE_IA_IMPORTED = True
        print("‚úÖ Service Analyse IA import√©")
    else:
        # Cr√©er un service de simulation
        print("‚ö†Ô∏è services/analyse_ia.py non trouv√©, cr√©ation d'un service de simulation")
        
        # D√©finir le service de simulation inline
        class ServiceAnalyseIA:
            """Service de simulation pour l'analyse IA"""
            
            @staticmethod
            def analyser_audit(audit_id, type_analyse='complet', user_id=None):
                """Simuler une analyse IA"""
                print(f"üîç Simulation analyse IA pour audit {audit_id}")
                
                # R√©sultat simul√©
                resultat = {
                    'type_analyse': type_analyse,
                    'date_analyse': datetime.utcnow().isoformat(),
                    'audit_info': {
                        'reference': f"AUD-{audit_id:04d}",
                        'titre': 'Audit de simulation',
                        'nb_constatations': 3,
                        'nb_recommandations': 2
                    },
                    'recommandations_ia': [
                        {
                            'id': 1,
                            'titre': 'Am√©lioration des proc√©dures',
                            'description': 'Formaliser les proc√©dures documentaires manquantes',
                            'priorite': 'haute',
                            'score_confiance': 85,
                            'delai_suggere': '30 jours'
                        }
                    ],
                    'causes_racines': [
                        {
                            'cause': 'Manque de documentation',
                            'frequence': 2,
                            'impact': 'moyen'
                        }
                    ],
                    'statistiques': {
                        'nb_recommandations_suggerees': 1,
                        'nb_causes_identifiees': 1,
                        'score_global': 75,
                        'temps_analyse': '1.5 secondes'
                    }
                }
                
                return type('obj', (object,), {
                    'id': int(time.time()),
                    'audit_id': audit_id,
                    'type_analyse': type_analyse,
                    'resultat': resultat,
                    'score_confiance': 75.0,
                    'created_by': user_id
                })()
            
            @staticmethod
            def transformer_recommandation_ia_en_recommandation(analyse_id, reco_ia_id, user_id):
                """Transformer une recommandation IA simul√©e"""
                print(f"üîÑ Simulation transformation recommandation IA {reco_ia_id}")
                return type('obj', (object,), {
                    'id': 999,
                    'reference': f"REC-IA-SIM-{int(time.time())}",
                    'description': 'Recommandation simul√©e'
                })()
        
        SERVICE_IA_IMPORTED = True
        print("‚úÖ Service Analyse IA simul√© cr√©√©")
    
    if os.path.exists('services/api_ia.py'):
        try:
            from services.api_ia import APIIntegration
            API_IA_IMPORTED = True
            print("‚úÖ API IA import√©e")
        except ImportError as e:
            print(f"‚ö†Ô∏è Erreur import API IA: {e}")
            API_IA_IMPORTED = False
    else:
        API_IA_IMPORTED = False
        print("‚ö†Ô∏è services/api_ia.py non trouv√©")
        
except Exception as e:
    print(f"‚ùå Erreur import services IA: {e}")
    traceback.print_exc()
    SERVICE_IA_IMPORTED = False
    API_IA_IMPORTED = False


from dotenv import load_dotenv

# Optionnel : charger .env pour le d√©veloppement
load_dotenv()  # Cela ne remplace pas vos variables shell, c'est compl√©mentaire

# R√©cup√©rer la cl√© API
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")

if not OPENAI_API_KEY:
    print("""
    ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è ATTENTION ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è
    
    OPENAI_API_KEY n'est pas d√©finie !
    
    Solutions :
    1. V√©rifiez que ~/.secrets/api_keys.sh est charg√© :
       source ~/.secrets/api_keys.sh
       
    2. Ou d√©finissez-la directement :
       export OPENAI_API_KEY="votre_cl√©"
       
    3. En dernier recours, cr√©ez un fichier .env temporaire
    """)
    # Mode d√©veloppement seulement : simulation
    OPENAI_API_KEY = "mode-simulation"
else:
    print(f"‚úÖ Cl√© API charg√©e ({len(OPENAI_API_KEY)} caract√®res)")
    
    # V√©rification basique
    if OPENAI_API_KEY.startswith("sk-") and len(OPENAI_API_KEY) > 30:
        print("‚úÖ Format de cl√© valide d√©tect√©")
    else:
        print("‚ö†Ô∏è Format de cl√© inhabituel - v√©rifiez votre cl√©")

# ========================
# IMPORT DES UTILS (avec gestion d'erreurs)
# ========================
try:
    from utils import (
        calculer_niveau_risque,
        generer_matrice_risques,
        generer_tableau_bordeaux,
        calculer_tendance_kri,
        generer_rapport_conformite,
        declencher_mise_a_jour_risque,
        synchroniser_cartographie_apres_action,
        recalculer_indicateurs_cartographie,
        generer_matrice_risque_specifique,
        generer_alerte_creation_risque,
        generer_alerte_evaluation_risque,
        notifier_archivage_risque,
        generer_rapport_archivage,
        generer_rapport_suppression,
        historiser_modifications_risque,
        mettre_a_jour_references_croisees,
        nettoyer_donnees_orphelines,
        invalider_cache_cartographie,
        synchroniser_matrices_apres_evaluation_triphase,
        invalider_cache_matrices,
        GestionnaireParametrage, log_activity
    )
    UTILS_IMPORTED = True
    print("‚úÖ Utils import√©s")
except ImportError as e:
    print(f"‚ö†Ô∏è Erreur d'import des utils: {e}")
    traceback.print_exc()
    
    # Fonctions de secours
    def calculer_niveau_risque(*args, **kwargs): return 'Faible', 'green', 0
    def generer_matrice_risques(*args, **kwargs): return ""
    def generer_tableau_bordeaux(*args, **kwargs): return {}
    def calculer_tendance_kri(*args, **kwargs): return 'stable'
    def generer_rapport_conformite(*args, **kwargs): return {}
    def declencher_mise_a_jour_risque(*args, **kwargs): print("üîî Fonction indisponible")
    def synchroniser_cartographie_apres_action(*args, **kwargs): print("üîÑ Fonction indisponible")
    def recalculer_indicateurs_cartographie(*args, **kwargs): print("üìä Fonction indisponible")
    generer_matrice_risque_specifique = None
    def generer_alerte_creation_risque(*args, **kwargs): print("üì¢ Fonction indisponible")
    def generer_alerte_evaluation_risque(*args, **kwargs): print("üì¢ Fonction indisponible")
    def notifier_archivage_risque(*args, **kwargs): print("üì¢ Fonction indisponible")
    def generer_rapport_archivage(*args, **kwargs): print("üìã Fonction indisponible")
    def generer_rapport_suppression(*args, **kwargs): print("üóëÔ∏è Fonction indisponible")
    def historiser_modifications_risque(*args, **kwargs): print("üìù Fonction indisponible")
    def mettre_a_jour_references_croisees(*args, **kwargs): print("üîó Fonction indisponible")
    def nettoyer_donnees_orphelines(*args, **kwargs): print("üßπ Fonction indisponible")
    def invalider_cache_cartographie(*args, **kwargs): print("üóëÔ∏è Fonction indisponible")
    def synchroniser_matrices_apres_evaluation_triphase(*args, **kwargs): print("üîÑ Fonction indisponible")
    def invalider_cache_matrices(*args, **kwargs): print("üóëÔ∏è Fonction indisponible")
    
    class GestionnaireParametrage:
        @staticmethod
        def generer_formulaire_risque(risque_id=None):
            return None
        @staticmethod
        def sauvegarder_champs_personnalises(risque_id, form_data):
            return False
        @staticmethod
        def generer_liste_deroulante_options(nom_liste):
            return []
        @staticmethod
        def televerser_fichier(risque_id, fichier, categorie='document', description=''):
            return None
        @staticmethod
        def get_config_fichiers():
            return {}
        @staticmethod
        def synchroniser_configuration_champ(champ):
            pass
        @staticmethod
        def synchroniser_modification_champ(champ):
            pass
    
    UTILS_IMPORTED = False

# ========================
# FONCTIONS UTILITAIRES POUR LE FORMULAIRE DE CONTACT
# ========================

def send_contact_email(nom_complet, email, societe, telephone, sujet, message, reference):
    """Fonction pour envoyer les emails de contact via notre service SMTP"""
    return email_service.send_contact_confirmation(
        nom_complet=nom_complet,
        email=email,
        societe=societe,
        telephone=telephone,
        sujet=sujet,
        message=message,
        reference=reference
    )

# ========================
# ROUTES POUR LE FORMULAIRE DE CONTACT
# ========================

@app.route('/api/contact/demo-request', methods=['POST'])
def api_contact_demo_request():
    """API pour envoyer les demandes de d√©mo"""
    try:
        # V√©rifier si c'est du JSON ou du form-data
        if request.is_json:
            data = request.get_json()
        else:
            data = request.form
        
        # Extraire les donn√©es
        nom_complet = data.get('nom_complet', '').strip()
        email = data.get('email', '').strip().lower()
        societe = data.get('societe', '').strip()
        telephone = data.get('telephone', '').strip()
        sujet = data.get('sujet', '').strip()
        message = data.get('message', '').strip()
        
        # Validation
        errors = []
        if not nom_complet:
            errors.append("Le nom complet est requis")
        if not email or '@' not in email:
            errors.append("Un email valide est requis")
        if not message:
            errors.append("Le message est requis")
        
        if errors:
            return jsonify({
                'success': False,
                'errors': errors
            }), 400
        
        # Formatage du sujet
        if not sujet:
            sujet = f"Demande de d√©mo - {societe or 'Nouveau prospect'}"
        
        # G√©n√©rer une r√©f√©rence
        reference = f"DEMO-{datetime.now().strftime('%Y%m%d')}-{hashlib.md5(email.encode()).hexdigest()[:8].upper()}"
        
        # Envoyer les emails via notre service SMTP
        email_sent = send_contact_email(nom_complet, email, societe, telephone, sujet, message, reference)
        
        # Sauvegarder dans un fichier log
        with open('demandes_contact.log', 'a', encoding='utf-8') as f:
            log_entry = f"{datetime.now().isoformat()}|{nom_complet}|{email}|{societe}|{telephone}|{sujet}|{reference}\n"
            f.write(log_entry)
        
        # Optionnel: Sauvegarder en base de donn√©es
        if MODELS_IMPORTED:
            try:
                from models import DemandeContact
                demande = DemandeContact(
                    nom_complet=nom_complet,
                    email=email,
                    societe=societe,
                    telephone=telephone,
                    sujet=sujet,
                    message=message,
                    reference=reference,
                    ip_address=request.remote_addr,
                    user_agent=request.user_agent.string
                )
                db.session.add(demande)
                db.session.commit()
                print(f"‚úÖ Demande sauvegard√©e ID: {demande.id}")
            except Exception as db_error:
                print(f"‚ö†Ô∏è Erreur base de donn√©es: {db_error}")
        
        return jsonify({
            'success': True,
            'message': 'Votre demande a √©t√© envoy√©e avec succ√®s !',
            'reference': reference,
            'email_sent': email_sent
        })
        
    except Exception as e:
        print(f"‚ùå Erreur g√©n√©rale: {str(e)}")
        import traceback
        traceback.print_exc()
        
        return jsonify({
            'success': False,
            'message': 'Une erreur est survenue lors de l\'envoi. Veuillez r√©essayer.'
        }), 500

@app.route('/test-formulaire')
def test_formulaire():
    """Page de test pour le formulaire"""
    return '''
    <!DOCTYPE html>
    <html>
    <head>
        <title>Test Formulaire Contact</title>
        <style>
            body { font-family: Arial, sans-serif; padding: 20px; }
            .form-group { margin-bottom: 15px; }
            label { display: block; margin-bottom: 5px; font-weight: bold; }
            input, textarea { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }
            button { background: #0066CC; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; }
            .alert { padding: 10px; margin: 10px 0; border-radius: 4px; }
            .alert-success { background: #d4edda; color: #155724; }
            .alert-error { background: #f8d7da; color: #721c24; }
        </style>
    </head>
    <body>
        <h1>Test Formulaire de Contact</h1>
        <div id="message"></div>
        <form id="contactForm">
            <div class="form-group">
                <label for="nom_complet">Nom complet *</label>
                <input type="text" id="nom_complet" name="nom_complet" required>
            </div>
            <div class="form-group">
                <label for="email">Email *</label>
                <input type="email" id="email" name="email" required>
            </div>
            <div class="form-group">
                <label for="societe">Soci√©t√©</label>
                <input type="text" id="societe" name="societe">
            </div>
            <div class="form-group">
                <label for="telephone">T√©l√©phone</label>
                <input type="tel" id="telephone" name="telephone">
            </div>
            <div class="form-group">
                <label for="sujet">Sujet *</label>
                <input type="text" id="sujet" name="sujet" required>
            </div>
            <div class="form-group">
                <label for="message">Message *</label>
                <textarea id="message" name="message" rows="5" required></textarea>
            </div>
            <button type="submit">Envoyer</button>
        </form>
        
        <script>
        document.getElementById('contactForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const formData = {
                nom_complet: document.getElementById('nom_complet').value,
                email: document.getElementById('email').value,
                societe: document.getElementById('societe').value,
                telephone: document.getElementById('telephone').value,
                sujet: document.getElementById('sujet').value,
                message: document.getElementById('message').value
            };
            
            const button = e.target.querySelector('button');
            const originalText = button.textContent;
            button.textContent = 'Envoi en cours...';
            button.disabled = true;
            
            try {
                const response = await fetch('/api/contact/demo-request', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(formData)
                });
                
                const result = await response.json();
                
                const messageDiv = document.getElementById('message');
                if (result.success) {
                    messageDiv.className = 'alert alert-success';
                    messageDiv.innerHTML = `‚úÖ ${result.message}<br>R√©f√©rence: ${result.reference}`;
                    document.getElementById('contactForm').reset();
                } else {
                    messageDiv.className = 'alert alert-error';
                    messageDiv.innerHTML = `‚ùå ${result.message || result.errors?.join('<br>')}`;
                }
            } catch (error) {
                document.getElementById('message').className = 'alert alert-error';
                document.getElementById('message').innerHTML = '‚ùå Erreur de connexion';
            } finally {
                button.textContent = originalText;
                button.disabled = false;
            }
        });
        </script>
    </body>
    </html>
    '''

# ========================
# ROUTES POUR LE FORMULAIRE DE CONTACT
# ========================
@app.route('/test-api', methods=['POST', 'GET'])
def test_api():
    """Route de test simple"""
    return jsonify({
        'success': True,
        'message': 'API fonctionne',
        'method': request.method,
        'data': request.get_json() if request.is_json else dict(request.form)
    })

@app.route('/check-credentials')
def check_credentials():
    """V√©rifier les credentials email"""
    
    info = []
    
    # V√©rifier la variable d'environnement
    password_from_env = os.environ.get('GMAIL_APP_PASSWORD')
    info.append(f"GMAIL_APP_PASSWORD dans os.environ: {'‚úÖ D√©fini (' + '*'*10 + password_from_env[-4:] + ')' if password_from_env else '‚ùå Non d√©fini'}")
    
    # V√©rifier dans email_service
    info.append(f"email_service.password: {'‚úÖ D√©fini (' + '*'*10 + email_service.password[-4:] + ')' if email_service.password else '‚ùå Non d√©fini'}")
    info.append(f"email_service.simulation_mode: {'‚ö†Ô∏è OUI (mode simulation)' if email_service.simulation_mode else '‚úÖ NON (emails r√©els)'}")
    
    # Tester la connexion SMTP
    if email_service.password:
        info.append("\n=== TEST SMTP ===")
        try:
            import smtplib
            server = smtplib.SMTP(email_service.smtp_server, email_service.smtp_port, timeout=10)
            server.starttls()
            server.login(email_service.sender_email, email_service.password)
            info.append("‚úÖ Connexion SMTP r√©ussie")
            server.quit()
        except Exception as e:
            info.append(f"‚ùå Erreur SMTP: {str(e)}")
    
    return "<h1>V√©rification des credentials</h1><pre>" + "\n".join(info) + "</pre>"
# ========================
# FONCTIONS UTILITAIRES (d√©finies avant l'application)
# ========================

def nl2br(value):
    """Convertit les retours √† la ligne en balises <br> (version s√©curis√©e)."""
    if value is None:
        return ''
    
    escaped = escape(str(value))
    result = escaped.replace('\n', '<br>\n')
    return Markup(result)


def truncate(text, length=100, end='...'):
    """Tronque le texte."""
    if not text:
        return ''
    if len(text) <= length:
        return text
    return text[:length - len(end)] + end

def format_date(value, format='%d/%m/%Y'):
    """Formate une date."""
    if not value:
        return ''
    return value.strftime(format)

def format_datetime(value, format='%d/%m/%Y %H:%M'):
    """Formate une date et heure."""
    if not value:
        return ''
    return value.strftime(format)

def yes_no(value):
    """Convertit un bool√©en en Oui/Non."""
    return 'Oui' if value else 'Non'

def join_list(value, separator=', '):
    """Join a list into a string."""
    if not value:
        return ''
    if isinstance(value, list):
        return separator.join(str(item) for item in value)
    return str(value)

def get_file_size(filepath):
    """Retourne la taille d'un fichier format√©e"""
    try:
        if os.path.exists(filepath):
            size = os.path.getsize(filepath)
            if size < 1024:
                return f"{size} B"
            elif size < 1024 * 1024:
                return f"{size/1024:.1f} KB"
            else:
                return f"{size/(1024*1024):.1f} MB"
        return "N/A"
    except:
        return "N/A"

def slugify(value):
    """
    Convertit une cha√Æne en slug (pour les URLs)
    Exemple: "Hello World 2024!" devient "hello-world-2024"
    """
    if not value:
        return ''
    
    # Normaliser les caract√®res Unicode
    value = normalize('NFKD', str(value)).encode('ascii', 'ignore').decode('ascii')
    
    # Convertir en minuscules
    value = value.lower()
    
    # Remplacer les caract√®res non alphanum√©riques par des tirets
    value = re.sub(r'[^\w\s-]', '', value)
    value = re.sub(r'[-\s]+', '-', value)
    
    # Supprimer les tirets en d√©but et fin
    value = value.strip('-')
    
    return value

def allowed_file(filename):
    """V√©rifie si le fichier a une extension autoris√©e"""
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def permission_required(permission):
    """D√©corateur pour v√©rifier les permissions"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not current_user.is_authenticated:
                flash('Veuillez vous connecter pour acc√©der √† cette page.', 'warning')
                return redirect(url_for('login'))
            
            if hasattr(current_user, 'role'):
                if current_user.role in ['admin', 'manager', 'auditeur']:
                    return f(*args, **kwargs)
            
            flash('Vous n\'avez pas les permissions n√©cessaires.', 'danger')
            return redirect(url_for('index'))
        return decorated_function
    return decorator

# ========================
# CR√âATION DE L'APPLICATION FLASK
# ========================

app = Flask(__name__)
app.config.from_object(Config)


# ========================
# CONFIGURATION SUPPL√âMENTAIRE
# ========================

# Configuration des uploads
app.config.update({
    'UPLOAD_FOLDER': 'uploads',
    'UPLOAD_FOLDER_VEILLE': 'static/uploads/veille',
    'UPLOAD_FOLDER_RISQUES': 'uploads/risques',
    'UPLOAD_FOLDER_AUDITS': 'static/uploads/audits',
    'ALLOWED_EXTENSIONS': {'pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'txt', 'jpg', 'png', 'jpeg', 'gif'},
    'MAX_CONTENT_LENGTH': 16 * 1024 * 1024  # 16MB
})

# ========================
# CR√âATION DES DOSSIERS D'UPLOAD
# ========================

upload_folders = [
    app.config['UPLOAD_FOLDER'],
    app.config['UPLOAD_FOLDER_VEILLE'],
    app.config['UPLOAD_FOLDER_RISQUES'],
    app.config['UPLOAD_FOLDER_AUDITS'],
    'services',
    'static/uploads',
    'logs'
]

for folder in upload_folders:
    try:
        os.makedirs(folder, exist_ok=True)
        print(f"‚úÖ Dossier cr√©√©/v√©rifi√©: {folder}")
    except Exception as e:
        print(f"‚ö†Ô∏è Impossible de cr√©er le dossier {folder}: {e}")

# ========================
# CONFIGURATION MULTILINGUE SANS D√âCORATEURS
# ========================

# Liste des langues support√©es
LANGUAGES = {
    'fr': {'name': 'Fran√ßais', 'flag': 'fr', 'dir': 'ltr'},
    'en': {'name': 'English', 'flag': 'gb', 'dir': 'ltr'}
}

# Configuration de base
app.config['BABEL_DEFAULT_LOCALE'] = 'fr'
app.config['BABEL_DEFAULT_TIMEZONE'] = 'Europe/Paris'

# NE PAS initialiser Babel avec des d√©corateurs
# Utilisez simplement l'objet Babel sans configuration avanc√©e
babel = Babel(app)



# Fonction utilitaire pour obtenir la langue courante
def get_current_locale():
    """Retourne la langue courante"""
    return getattr(g, 'current_lang', 'fr')



# Filtres Jinja2 pour les traductions
@app.template_filter('translate')
def translate_filter(text, lang=None):
    """Filtre pour traduire du texte dans les templates"""
    # Utilisez votre syst√®me de traduction ou retournez le texte tel quel
    if hasattr(g, 'current_lang') and g.current_lang == 'en':
        # Exemple simple - √† remplacer par votre syst√®me de traduction
        translations = {
            'Tableau de bord': 'Dashboard',
            'Gestion des risques': 'Risk Management',
            'Audit': 'Audit',
            'Param√®tres': 'Settings',
            'Utilisateurs': 'Users',
            'D√©connexion': 'Logout',
        }
        return translations.get(text, text)
    return text

# ========================
# INITIALISATION DES EXTENSIONS
# ========================

print("\nüîß INITIALISATION DES EXTENSIONS")
print("=" * 40)

# Initialisation conditionnelle selon l'import des mod√®les
if MODELS_IMPORTED:
    print("‚úÖ Mod√®les import√©s avec succ√®s")
    
    # Initialiser SQLAlchemy
    db.init_app(app)
    print("‚úÖ SQLAlchemy initialis√©")
    
    # Initialiser CSRF Protection
    csrf = CSRFProtect(app)
    print("‚úÖ CSRF Protection initialis√©e")
    
    # Initialiser Flask-Migrate
    migrate = Migrate(app, db)
    print("‚úÖ Flask-Migrate initialis√©")
    
    # Initialiser Flask-Login
    login_manager = LoginManager(app)
    login_manager.login_view = 'login'
    login_manager.login_message = 'Veuillez vous connecter pour acc√©der √† cette page.'
    login_manager.login_message_category = 'info'
    print("‚úÖ Flask-Login initialis√©")
    
    @login_manager.user_loader
    def load_user(user_id):
        """Charge l'utilisateur avec la syntaxe SQLAlchemy 2.0"""
        try:
            return db.session.get(User, int(user_id))
        except (ValueError, TypeError) as e:
            print(f"‚ö†Ô∏è Erreur de conversion user_id: {e}")
            return None
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur lors du chargement utilisateur {user_id}: {e}")
            return None
    
    print("‚úÖ User loader configur√©")
    
else:
    print("‚ùå Mod√®les non import√©s - Mode d√©grad√© activ√©")
    
    # Cr√©er des objets factices pour √©viter les erreurs
    class FakeDB:
        def init_app(self, app): 
            print("‚ö†Ô∏è FakeDB init_app appel√©")
            pass
        
        def create_all(self): 
            print("‚ö†Ô∏è FakeDB create_all appel√©")
            pass
        
        @property
        def session(self):
            session_obj = type('FakeSession', (), {
                'get': lambda cls, user_id: None,
                'add': lambda obj: print(f"‚ö†Ô∏è FakeSession add: {type(obj)}"),
                'commit': lambda: print("‚ö†Ô∏è FakeSession commit"),
                'rollback': lambda: print("‚ö†Ô∏è FakeSession rollback"),
                'query': lambda cls: type('FakeQuery', (), {
                    'filter_by': lambda **kwargs: type('FakeQueryResult', (), {
                        'first': lambda: None,
                        'all': lambda: [],
                        'count': lambda: 0
                    })()
                })()
            })()
            return session_obj
    
    db = FakeDB()
    db.init_app(app)
    
    csrf = type('FakeCSRF', (), {
        'protect': lambda self: None,
        'init_app': lambda app: print("‚ö†Ô∏è FakeCSRF init_app")
    })()
    
    migrate = None
    
    login_manager = type('FakeLoginManager', (), {
        'init_app': lambda app: print("‚ö†Ô∏è FakeLoginManager init_app"),
        'login_view': 'login',
        'login_message': 'Veuillez vous connecter',
        'user_loader': lambda f: f
    })()
    
    print("‚ö†Ô∏è Objets factices cr√©√©s pour √©viter les erreurs")

# ========================
# ENREGISTREMENT DES FILTRES JINJA2
# ========================

print("\nüé® ENREGISTREMENT DES FILTRES JINJA2")
print("=" * 40)

# D√©finition des filtres (doivent √™tre d√©finis avant l'enregistrement)
def nl2br(value):
    """Convertit les retours √† la ligne en balises <br> (version s√©curis√©e)."""
    if value is None:
        return ''
    escaped = escape(str(value))
    result = escaped.replace('\n', '<br>\n')
    return Markup(result)

def safe_nl2br(value):
    """Convertit les retours √† la ligne en balises <br> sans √©chappement HTML."""
    if value is None:
        return ''
    result = str(value).replace('\n', '<br>\n')
    return Markup(result)

def truncate(text, length=100, end='...'):
    """Tronque le texte."""
    if not text:
        return ''
    if len(text) <= length:
        return text
    return text[:length - len(end)] + end

def format_date(value, format='%d/%m/%Y'):
    """Formate une date."""
    if not value:
        return ''
    if isinstance(value, datetime):
        return value.strftime(format)
    return value

def format_datetime(value, format='%d/%m/%Y %H:%M'):
    """Formate une date et heure."""
    if not value:
        return ''
    if isinstance(value, datetime):
        return value.strftime(format)
    return value

def yes_no(value):
    """Convertit un bool√©en en Oui/Non."""
    return 'Oui' if value else 'Non'

def join_list(value, separator=', '):
    """Join a list into a string."""
    if not value:
        return ''
    if isinstance(value, list):
        return separator.join(str(item) for item in value)
    return str(value)

def slugify(value):
    """Convertit une cha√Æne en slug (pour les URLs)."""
    if not value:
        return ''
    value = normalize('NFKD', str(value)).encode('ascii', 'ignore').decode('ascii')
    value = value.lower()
    value = re.sub(r'[^\w\s-]', '', value)
    value = re.sub(r'[-\s]+', '-', value)
    return value.strip('-')

# Enregistrement des filtres
filters = {
    'nl2br': nl2br,
    'safe_nl2br': safe_nl2br,
    'truncate': truncate,
    'format_date': format_date,
    'format_datetime': format_datetime,
    'yes_no': yes_no,
    'join_list': join_list,
    'slugify': slugify
}

for name, func in filters.items():
    app.jinja_env.filters[name] = func
    print(f"‚úÖ Filtre '{name}' enregistr√©")

print("‚úÖ Tous les filtres Jinja2 initialis√©s")

# ========================
# INITIALISATION DES SERVICES
# ========================

print("\nü§ñ INITIALISATION DES SERVICES")
print("=" * 40)

# Service IA
try:
    if 'service_ia' in globals() or SERVICE_IA_IMPORTED:
        if 'service_ia' not in globals():
            from services.analyse_ia import ServiceAnalyseIA
            service_ia = ServiceAnalyseIA()
        
        print("üîç DIAGNOSTIC SERVICE IA")
        print(f"Mode simulation: {getattr(service_ia, 'mode_simulation', 'N/A')}")
        print(f"Client OpenAI initialis√©: {getattr(service_ia, 'client', None) is not None}")
        print(f"Cl√© API disponible: {'Oui' if os.environ.get('OPENAI_API_KEY') else 'Non'}")
        
        # Test du service IA
        try:
            test_result = service_ia.analyser_audit(1, 'test', 1)
            print(f"\nüìä Test analyse audit:")
            print(f"  Type r√©sultat: {type(test_result)}")
            
            if hasattr(test_result, 'to_dict'):
                result_dict = test_result.to_dict()
            elif hasattr(test_result, 'resultat'):
                result_dict = test_result.resultat
            else:
                result_dict = test_result
            
            print(f"  Recommandations: {len(result_dict.get('recommandations_ia', []))}")
            print(f"  Causes racines: {len(result_dict.get('causes_racines', []))}")
            print(f"  Score confiance: {result_dict.get('metadata', {}).get('score_confiance', 'N/A')}")
            
        except Exception as e:
            print(f"‚ùå Erreur test service IA: {e}")
    else:
        print("‚ö†Ô∏è Service IA non disponible")
        service_ia = None
        
except Exception as e:
    print(f"‚ùå Erreur initialisation service IA: {e}")
    service_ia = None

# Blueprint des notifications
try:
    if NOTIFICATIONS_ROUTES_AVAILABLE:
        app.register_blueprint(notifications_bp)
        print("‚úÖ Blueprint notifications enregistr√©")
    else:
        print("‚ö†Ô∏è Blueprint notifications non disponible")
except Exception as e:
    print(f"‚ùå Erreur enregistrement blueprint notifications: {e}")


# ========================
# D√âCORATEURS DE PERMISSIONS (doivent √™tre d√©finis AVANT d'√™tre utilis√©s)
# ========================

print("\nüîê D√âFINITION DES D√âCORATEURS DE PERMISSIONS")
print("=" * 40)

def admin_required(f):
    """D√©corateur qui v√©rifie que l'utilisateur est admin"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            flash('Veuillez vous connecter pour acc√©der √† cette page.', 'error')
            return redirect(url_for('login'))
        
        if current_user.role != 'admin':
            flash('Acc√®s non autoris√©. Cette page est r√©serv√©e aux administrateurs.', 'error')
            return redirect(url_for('dashboard'))
        
        return f(*args, **kwargs)
    return decorated_function

def super_admin_required(f):
    """D√©corateur pour le super admin (acc√®s universel)"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            flash('Acc√®s refus√© : connexion requise', 'error')
            return redirect(url_for('login', next=request.url))
        if current_user.role != 'super_admin':
            flash('Acc√®s refus√© : privil√®ges super administrateur requis', 'error')
            return redirect(url_for('dashboard'))
        return f(*args, **kwargs)
    return decorated_function

def login_required_decorator(f):
    """D√©corateur de connexion requis (compatible avec Flask-Login)"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            flash('Veuillez vous connecter pour acc√©der √† cette page.', 'warning')
            return redirect(url_for('login', next=request.url))
        return f(*args, **kwargs)
    return decorated_function

def permission_required(permission):
    """D√©corateur pour v√©rifier des permissions sp√©cifiques"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not current_user.is_authenticated:
                flash('Veuillez vous connecter pour acc√©der √† cette page.', 'warning')
                return redirect(url_for('login'))
            
            if hasattr(current_user, 'has_permission'):
                if not current_user.has_permission(permission):
                    flash(f'Acc√®s refus√© : permission "{permission}" requise', 'danger')
                    return redirect(url_for('dashboard'))
            elif hasattr(current_user, 'role'):
                # V√©rification bas√©e sur le r√¥le
                allowed_roles = {
                    'can_manage_risks': ['admin', 'manager', 'super_admin'],
                    'can_manage_kri': ['admin', 'manager', 'super_admin'],
                    'can_manage_audit': ['admin', 'manager', 'auditeur', 'super_admin'],
                    'can_manage_users': ['admin', 'super_admin'],
                    'can_view_reports': ['admin', 'manager', 'auditeur', 'utilisateur', 'super_admin'],
                    'can_export_data': ['admin', 'manager', 'super_admin']
                }
                
                if permission in allowed_roles:
                    if current_user.role not in allowed_roles[permission]:
                        flash(f'Acc√®s refus√© : r√¥le {current_user.role} non autoris√©', 'danger')
                        return redirect(url_for('dashboard'))
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator

print("‚úÖ D√©corateurs de permissions d√©finis :")
print("   - admin_required")
print("   - super_admin_required")
print("   - permission_required")

# ========================
# FONCTIONS DE V√âRIFICATION D'ACC√àS
# ========================

def check_client_access(entity):
    """
    V√©rifie l'acc√®s √† une entit√© sp√©cifique - VERSION ULTRA FLEXIBLE
    """
    if not current_user.is_authenticated:
        return False
    
    # 1. SUPER ADMIN a toujours acc√®s
    if current_user.role == 'super_admin':
        return True
    
    user_client_id = current_user.client_id
    
    if not user_client_id:
        print(f"‚ö†Ô∏è {current_user.username} n'a pas de client_id")
        return False
    
    # 2. Si l'entit√© est un Audit
    if isinstance(entity, Audit):
        audit = entity
        
        # Si l'audit n'a pas de client_id
        if audit.client_id is None:
            # V√©rifier si l'utilisateur est le cr√©ateur
            if hasattr(audit, 'created_by') and audit.created_by == current_user.id:
                return True
            # V√©rifier si l'utilisateur est le responsable
            if hasattr(audit, 'responsable_id') and audit.responsable_id == current_user.id:
                return True
            # V√©rifier si l'utilisateur est dans l'√©quipe
            if audit.equipe_audit_ids:
                try:
                    equipe_ids = [int(id.strip()) for id in audit.equipe_audit_ids.split(',') if id.strip()]
                    if current_user.id in equipe_ids:
                        return True
                except:
                    pass
            return False
        
        # Si l'audit a un client_id, v√©rifier la correspondance
        return audit.client_id == user_client_id
    
    # 3. Pour les autres entit√©s
    if hasattr(entity, 'client_id'):
        entity_client_id = entity.client_id
        
        if entity_client_id is None:
            # Pour les entit√©s sans client_id, v√©rifier par created_by
            if hasattr(entity, 'created_by') and entity.created_by:
                creator = User.query.get(entity.created_by)
                if creator:
                    return creator.client_id == user_client_id
            return True  # Ou False selon votre politique
        
        return entity_client_id == user_client_id
    
    # 4. V√©rifier par created_by
    if hasattr(entity, 'created_by') and entity.created_by:
        creator = User.query.get(entity.created_by)
        if creator and hasattr(creator, 'client_id'):
            return creator.client_id == user_client_id
    
    # 5. Par d√©faut, refuser (s√©curit√©)
    return False

@app.route('/fix_audits_client_id')
@login_required
def fix_audits_client_id():
    """Route temporaire pour corriger les client_id des audits"""
    if current_user.role != 'super_admin':
        return "Acc√®s refus√©", 403
    
    audits_sans_client = Audit.query.filter(Audit.client_id == None).all()
    fixed_count = 0
    
    for audit in audits_sans_client:
        # Trouver le cr√©ateur
        creator = User.query.get(audit.created_by)
        if creator and creator.client_id:
            audit.client_id = creator.client_id
            fixed_count += 1
    
    db.session.commit()
    
    return f"{fixed_count} audits corrig√©s avec client_id"

# ========================
# FONCTIONS DE FILTRAGE CLIENT
# ========================

def get_client_filter(model_class, **filters):
    """
    Retourne une requ√™te filtr√©e par client
    """
    query = model_class.query
    
    # SUPER ADMIN : PAS DE FILTRE (sauf s'il visualise un client sp√©cifique)
    if current_user.is_authenticated and current_user.role == 'super_admin':
        viewing_client_id = session.get('viewing_client_id')
        
        # Si le super admin a choisi un client sp√©cifique
        if viewing_client_id is not None:
            if hasattr(model_class, 'client_id'):
                query = query.filter(model_class.client_id == viewing_client_id)
            elif hasattr(model_class, 'created_by'):
                # Pour les tables sans client_id : filtrer par les utilisateurs du client
                user_ids = User.query.filter_by(client_id=viewing_client_id).with_entities(User.id).all()
                user_ids = [uid[0] for uid in user_ids] if user_ids else [-1]
                query = query.filter(model_class.created_by.in_(user_ids))
        # Sinon, super admin voit tout (pas de filtre client)
    
    # UTILISATEURS NORMAUX : filtrer par leur client
    elif current_user.is_authenticated:
        client_id = current_user.client_id
        
        if hasattr(model_class, 'client_id'):
            query = query.filter(model_class.client_id == client_id)
        elif hasattr(model_class, 'created_by'):
            # R√©cup√©rer tous les utilisateurs du m√™me client
            user_ids = db.session.query(User.id).filter_by(client_id=client_id).all()
            user_ids = [uid[0] for uid in user_ids] if user_ids else [-1]
            query = query.filter(model_class.created_by.in_(user_ids))
    
    # Ajouter les filtres suppl√©mentaires
    for key, value in filters.items():
        if hasattr(model_class, key):
            query = query.filter(getattr(model_class, key) == value)
    
    return query





@app.context_processor
def inject_translation_system():
    """Injecte le syst√®me de traduction ultra-simple"""
    def t(text, lang=None):
        target_lang = lang or get_locale()
        return simple_translator.translate(text, target_lang)
    
    return {
        't': t,
        'translate': t,
        'current_lang': get_locale,
        'is_english': lambda: get_locale() == 'en',
        'is_french': lambda: get_locale() == 'fr'
    }


# Mettez √† jour le context processor
@app.context_processor
def inject_translation_utilities():
    """Injecte les utilitaires de traduction"""
    current_lang = get_locale()
    
    def t(text):
        """Fonction de traduction pour les templates"""
        if not text or current_lang == 'fr':
            return text
        return translation_manager.translate(text, current_lang)
    
    return {
        't': t,
        'translate': t,
        'current_lang': current_lang,
        'lang_info': LANGUAGES.get(current_lang, LANGUAGES['fr']),
        'available_langs': LANGUAGES,
        'is_english': current_lang == 'en',
        'is_french': current_lang == 'fr'
    }



# Modifiez vos routes pour supporter la langue
def bilingual_route(f):
    """D√©corateur pour routes bilingues"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # Ex√©cuter la fonction
        response = f(*args, **kwargs)
        
        # Si c'est une r√©ponse de template
        if isinstance(response, str) and '<html' in response:
            # Rien √† faire, le context processor g√®re tout
            pass
        
        return response
    return decorated_function

# Filtres Jinja2 pour la traduction
@app.template_filter('t')
def template_translate(text):
    """Filtre pour traduire dans les templates"""
    current_lang = getattr(g, 'current_lang', 'fr')
    return translation_system.translate(text, current_lang)

@app.template_filter('yes_no')
def yes_no_filter(value):
    """Convertit un bool√©en en Oui/Non ou Yes/No"""
    current_lang = getattr(g, 'current_lang', 'fr')
    if current_lang == 'en':
        return 'Yes' if value else 'No'
    return 'Oui' if value else 'Non'

@app.template_filter('format_date_local')
def format_date_local(value, format='%d/%m/%Y'):
    """Formate une date selon la locale"""
    if not value:
        return ''
    
    current_lang = getattr(g, 'current_lang', 'fr')
    if current_lang == 'en':
        # Format anglais
        if format == '%d/%m/%Y':
            format = '%m/%d/%Y'
        elif format == '%d/%m/%Y %H:%M':
            format = '%m/%d/%Y %H:%M'
    
    return value.strftime(format)

# ========================
# SYST√àME DE TRADUCTION UNIFI√â
# ========================

from collections import OrderedDict


class UnifiedTranslationSystem:
    """Syst√®me de traduction unique et simple"""
    
    def __init__(self, app_root_path='.'):
        self.translations = OrderedDict()
        self.csv_file = os.path.join(app_root_path, 'translations', 'to_translate.csv')
        self.load_translations()
    
    def load_translations(self):
        """Charge les traductions depuis le CSV"""
        if not os.path.exists(self.csv_file):
            print(f"‚ö†Ô∏è Fichier CSV non trouv√©: {self.csv_file}")
            return
        
        try:
            with open(self.csv_file, 'r', encoding='utf-8') as f:
                # Essayer diff√©rents formats
                content = f.read()
                
                # Essayer avec virgule
                if ',' in content:
                    f.seek(0)
                    reader = csv.reader(f)
                    for row in reader:
                        if len(row) >= 2:
                            french = row[0].strip()
                            english = row[1].strip()
                            if french and english and french != english:
                                self.translations[french] = english
                
                # Sinon essayer point-virgule
                elif ';' in content:
                    f.seek(0)
                    reader = csv.reader(f, delimiter=';')
                    for row in reader:
                        if len(row) >= 2:
                            french = row[0].strip().strip('"')
                            english = row[1].strip().strip('"')
                            if french and english and french != english:
                                self.translations[french] = english
            
            print(f"‚úÖ {len(self.translations)} traductions charg√©es")
            
        except Exception as e:
            print(f"‚ùå Erreur chargement CSV: {e}")
    
    def translate(self, text, lang='en'):
        """Traduit un texte (lang='fr' ou 'en')"""
        if not text or lang == 'fr':
            return str(text) if text else ''
        
        text_str = str(text).strip()
        
        # Chercher la traduction exacte
        if text_str in self.translations:
            return self.translations[text_str]
        
        # Chercher avec diff√©rentes capitalisations
        lower_text = text_str.lower()
        for french, english in self.translations.items():
            if french.lower() == lower_text:
                return english
        
        # Chercher une correspondance partielle
        for french, english in self.translations.items():
            if french in text_str:
                return text_str.replace(french, english)
        
        # Retourner l'original si pas de traduction
        return text_str

# Cr√©er l'instance globale
translation_system = UnifiedTranslationSystem()

# Liste des langues support√©es (garder simple)
LANGUAGES = {
    'fr': {'name': 'Fran√ßais', 'flag': 'fr', 'dir': 'ltr'},
    'en': {'name': 'English', 'flag': 'gb', 'dir': 'ltr'}
}

def get_current_language():
    """D√©termine la langue actuelle - SIMPLE ET FONCTIONNEL"""
    try:
        # 1. Param√®tre URL (priorit√© absolue)
        if request and request.args.get('lang'):
            lang = request.args.get('lang')
            if lang in ['fr', 'en']:
                return lang
        
        # 2. Session
        if session and session.get('lang'):
            lang = session.get('lang')
            if lang in ['fr', 'en']:
                return lang
        
        # 3. Cookie
        if request and request.cookies.get('lang'):
            lang = request.cookies.get('lang')
            if lang in ['fr', 'en']:
                return lang
        
        # 4. Par d√©faut
        return 'fr'
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur d√©termination langue: {e}")
        return 'fr'


@app.before_request
def handle_language():
    """G√®re la langue avant chaque requ√™te"""
    try:
        # D√©terminer la langue
        lang = 'fr'
        
        # V√©rifier les sources dans l'ordre
        if request.args.get('lang') in ['fr', 'en']:
            lang = request.args.get('lang')
        elif session.get('lang') in ['fr', 'en']:
            lang = session.get('lang')
        elif request.cookies.get('lang') in ['fr', 'en']:
            lang = request.cookies.get('lang')
        
        # Stocker dans g et session
        g.current_lang = lang
        session['lang'] = lang
        
        print(f"üåê Langue d√©finie: {lang}")
        
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur handle_language: {e}")
        g.current_lang = 'fr'
        session['lang'] = 'fr'

# Injecter dans les templates - VERSION CORRIG√âE
@app.context_processor
def inject_language_info():
    """Injecte les informations de langue dans tous les templates"""
    current_lang = getattr(g, 'current_lang', 'fr')
    
    # Fonction de traduction pour les templates
    def translate_text(text):
        if not text:
            return ''
        return translation_system.translate(text, current_lang)
    
    return {
        'current_lang': current_lang,
        'lang': current_lang,  # alias
        't': translate_text,
        'translate': translate_text,
        '_': translate_text,  # Compatibilit√© Flask-Babel
        'available_langs': LANGUAGES,
        'lang_info': LANGUAGES.get(current_lang, LANGUAGES['fr']),
        'is_english': current_lang == 'en',
        'is_french': current_lang == 'fr'
    }

@app.route('/change-language/<lang_code>')
def change_language(lang_code):
    """Change la langue - Compatibilit√© avec les templates existants"""
    if lang_code not in ['fr', 'en']:
        flash('Langue non support√©e', 'error')
        return redirect(request.referrer or url_for('dashboard'))
    
    print(f"üåê Changement de langue demand√© vers: {lang_code}")
    
    # Sauvegarder
    session['lang'] = lang_code
    response = make_response(redirect(request.referrer or url_for('dashboard')))
    response.set_cookie('lang', lang_code, max_age=365*24*60*60)
    
    flash(f'Langue chang√©e en {LANGUAGES[lang_code]["name"]}', 'success')
    return response

# API pour les traductions JavaScript
@app.route('/api/translations/all')
def api_all_translations():
    """Retourne toutes les traductions pour JavaScript"""
    return jsonify({
        'success': True,
        'count': len(translation_system.translations),
        'translations': dict(translation_system.translations),
        'current_lang': getattr(g, 'current_lang', 'fr')
    })


# Fonction pour obtenir la langue courante
def get_locale():
    """D√©termine la langue - VERSION SIMPLE"""
    # 1. Param√®tre URL (priorit√©)
    lang = request.args.get('lang') if 'request' in globals() else None
    if lang in ['fr', 'en']:
        return lang
    
    # 2. Session
    try:
        lang = session.get('lang') if 'session' in globals() else None
        if lang in ['fr', 'en']:
            return lang
    except:
        pass
    
    # 3. Cookie
    if 'request' in globals():
        lang = request.cookies.get('lang')
        if lang in ['fr', 'en']:
            return lang
    
    # 4. Par d√©faut
    return 'fr'

# Middleware pour g√©rer la langue
@app.before_request
def before_request():
    """Configure la langue avant chaque requ√™te"""
    # D√©terminer la langue
    lang = request.args.get('lang')
    if lang not in ['fr', 'en']:
        lang = session.get('lang')
        if lang not in ['fr', 'en']:
            lang = request.cookies.get('lang', 'fr')
    
    # Normaliser
    if lang not in ['fr', 'en']:
        lang = 'fr'
    
    # Stocker
    g.current_lang = lang
    session['lang'] = lang

# Injecter dans les templates
@app.context_processor
def inject_lang():
    """Injecte les informations de langue dans tous les templates"""
    current_lang = getattr(g, 'current_lang', 'fr')
    
    # Fonction de traduction pour les templates
    def t(text):
        return translation_system.translate(text, current_lang)
    
    return {
        'current_lang': current_lang,
        't': t,
        'translate': t,
        '_': t,  # Compatibilit√© avec Flask-Babel
        'available_langs': LANGUAGES,
        'lang_info': LANGUAGES.get(current_lang, LANGUAGES['fr']),
        'is_english': current_lang == 'en',
        'is_french': current_lang == 'fr'
    }

# Routes pour changer de langue
@app.route('/set-language/<lang>')
def set_language(lang):
    """Change la langue de l'application"""
    if lang not in ['fr', 'en']:
        flash('Langue non support√©e', 'error')
        return redirect(request.referrer or url_for('dashboard'))
    
    # Sauvegarder
    session['lang'] = lang
    response = make_response(redirect(request.referrer or url_for('dashboard')))
    response.set_cookie('lang', lang, max_age=365*24*60*60)
    
    flash(f'üåê Langue chang√©e en {LANGUAGES[lang]["name"]}', 'success')
    return response



@app.context_processor
def inject_lang():
    """Injecte les informations de langue dans tous les templates"""
    def get_current_lang():
        """Fonction pour obtenir la langue courante"""
        try:
            # 1. Param√®tre GET
            lang = request.args.get('lang')
            if lang in ['fr', 'en']:
                session['lang'] = lang
                return lang
            
            # 2. Session
            lang = session.get('lang')
            if lang in ['fr', 'en']:
                return lang
            
            # 3. Par d√©faut
            return 'fr'
        except:
            return 'fr'
    
    current_lang = get_current_lang()
    
    return {
        'current_lang': current_lang,
        'get_locale': get_current_lang,  # <-- IMPORTANT : expose la fonction
        'available_langs': LANGUAGES,
        'lang_info': LANGUAGES.get(current_lang, LANGUAGES['fr']),
        'is_english': current_lang == 'en',
        'is_french': current_lang == 'fr'
    }
# Ajouter √† vos filtres Jinja2
def translate(text, lang=None):
    """Traduit un texte dans la langue sp√©cifi√©e"""
    if not text:
        return ''
    
    # Logique de traduction simplifi√©e - √† remplacer par vos fichiers .mo
    translations = {
        'fr': {
            'Dashboard': 'Tableau de bord',
            'Risk Management': 'Gestion des risques',
            'Audit': 'Audit',
            'Settings': 'Param√®tres',
            'Users': 'Utilisateurs',
            'Logout': 'D√©connexion',
            # ... ajouter toutes vos traductions
        },
        'en': {}  # Par d√©faut anglais
    }
    
    target_lang = lang or get_locale()
    if target_lang == 'en':
        return text  # Texte original en anglais
    
    return translations.get(target_lang, {}).get(text, text)

# Enregistrer le filtre
app.jinja_env.filters['translate'] = translate



# Filtres Jinja2 pour les formats localis√©s
from flask_babel import format_date, format_datetime, format_number

@app.template_filter('local_date')
def local_date(value, format='medium'):
    """Formate une date selon la locale"""
    if not value:
        return ''
    return format_date(value, format=format)

@app.template_filter('local_datetime')
def local_datetime(value, format='medium'):
    """Formate une date/heure selon la locale"""
    if not value:
        return ''
    return format_datetime(value, format=format)

@app.template_filter('local_number')
def local_number(value):
    """Formate un nombre selon la locale"""
    if value is None:
        return ''
    return format_number(value)


# ========================
# FONCTIONS DE GESTION DE LANGUE
# ========================


@app.context_processor
def inject_lang():
    """Injecte les informations de langue dans tous les templates"""
    current_lang = get_locale()  # <-- MAINTENANT D√âFINI
    return {
        'current_lang': current_lang,
        'available_langs': LANGUAGES,
        '_': _,  # Fonction de traduction
        'gettext': _,
        'ngettext': gettext.ngettext
    }



def get_client_all(model_class, **filters):
    """
    R√©cup√®re tous les objets d'un mod√®le avec filtrage client
    """
    query = get_client_filter(model_class)
    
    # Ajouter les filtres suppl√©mentaires
    for key, value in filters.items():
        if hasattr(model_class, key):
            query = query.filter(getattr(model_class, key) == value)
    
    return query.all()

def get_client_count(model_class, **filters):
    """
    Compte les objets d'un mod√®le avec filtrage client
    """
    query = get_client_filter(model_class)
    
    # Ajouter les filtres suppl√©mentaires
    for key, value in filters.items():
        if hasattr(model_class, key):
            query = query.filter(getattr(model_class, key) == value)
    
    return query.count()

def get_client_object_or_404(model_class, object_id, **filters):
    """
    R√©cup√®re un objet par ID avec filtrage client ou retourne 404
    """
    # Construire le filtre complet
    complete_filters = {'id': object_id, **filters}
    
    # Utiliser get_client_filter
    query = get_client_filter(model_class)
    
    # Ajouter le filtre ID
    query = query.filter(model_class.id == object_id)
    
    # Ajouter les filtres suppl√©mentaires
    for key, value in filters.items():
        if hasattr(model_class, key):
            query = query.filter(getattr(model_class, key) == value)
    
    # R√©cup√©rer l'objet
    obj = query.first()
    
    if obj is None:
        abort(404)
    
    return obj

def filter_by_client(query, model_class):
    """Ajoute un filtre client_id √† une requ√™te (sauf pour super admin)"""
    if current_user.role == 'super_admin':
        return query  # Super admin voit TOUT
    
    # Pour les admin clients et utilisateurs normaux
    if hasattr(model_class, 'client_id'):
        return query.filter(model_class.client_id == current_user.client_id)
    elif hasattr(model_class, 'created_by'):
        # R√©cup√©rer tous les utilisateurs du m√™me client
        try:
            utilisateurs_client = User.query.filter_by(
                client_id=current_user.client_id
            ).with_entities(User.id).all()
            user_ids = [u.id for u in utilisateurs_client]
            if user_ids:
                return query.filter(model_class.created_by.in_(user_ids))
            else:
                return query.filter(model_class.created_by == -1)  # Aucun r√©sultat
        except:
            return query.filter(model_class.created_by == current_user.id)
    else:
        return query

print("‚úÖ Fonctions de v√©rification d'acc√®s d√©finies")



    
# ========================
# MIDDLEWARE DE FILTRAGE (doit √™tre apr√®s les d√©corateurs)
# ========================

@app.before_request
def auto_filter_data():
    """Filtre automatiquement les donn√©es par client"""
    # Ne pas filtrer pour super admin
    if current_user.is_authenticated and current_user.role == 'super_admin':
        g.client_id = None  # Super admin voit tout
        return
    
    # Pour les autres utilisateurs
    if current_user.is_authenticated:
        g.client_id = current_user.client_id

@app.route('/admin/parametrage/fichiers/configurer', methods=['POST'])
@login_required
@admin_required
def configurer_types_fichiers():
    """Configurer les types de fichiers autoris√©s"""
    try:
        # R√©cup√©rer les donn√©es du formulaire
        extensions = request.form.get('extensions', '').split(',')
        extensions = [ext.strip().lower() for ext in extensions if ext.strip()]
        
        # Mettre √† jour la configuration
        app.config['ALLOWED_EXTENSIONS'] = set(extensions)
        
        # Journaliser
        log_activity(current_user.id, 'configuration_fichiers',
                    f"Configuration types fichiers: {', '.join(extensions)}",
                    'parametrage', None)
        
        flash('‚úÖ Types de fichiers configur√©s avec succ√®s', 'success')
        
    except Exception as e:
        flash(f'‚ùå Erreur: {str(e)}', 'error')
    
    return redirect(url_for('parametrage_fichiers'))


@app.before_request
def check_permissions_middleware():
    """Middleware pour v√©rifier les permissions sur chaque requ√™te"""
    if current_user.is_authenticated:
        # Si c'est le super admin, BYPASS toutes les v√©rifications de permissions
        if current_user.role == 'super_admin':
            return  # Super admin passe partout sans v√©rification
        
        # Liste des endpoints prot√©g√©s et leurs permissions requises
        protected_endpoints = {
            'liste_cartographies': 'can_manage_risks',
            'nouvelle_cartographie': 'can_manage_risks',
            'liste_kri': 'can_manage_kri',
            'nouveau_kri': 'can_manage_kri',
            'liste_audits': 'can_manage_audit',
            'nouvel_audit': 'can_manage_audit',
            'veille_reglementaire': 'can_manage_regulatory',
            'liste_logigrammes': 'can_manage_logigram',
            'admin_dashboard': 'can_manage_users',
            'admin_utilisateurs': 'can_view_users_list',  # CHANG√â: nouvelle permission
            'rapports': 'can_view_reports',
            'export_risques': 'can_export_data',
            'admin_directions': 'can_view_departments',  # AJOUT√â
            'nouvelle_direction': 'can_manage_departments',  # AJOUT√â
            'modifier_direction': 'can_manage_departments',  # AJOUT√â
            'nouveau_service': 'can_manage_departments',  # AJOUT√â
            'rapports': 'can_view_reports'  # AJOUT√â pour rapports
        }
        
        endpoint = request.endpoint
        
        # V√©rifier si l'endpoint n√©cessite une permission sp√©cifique
        if endpoint in protected_endpoints:
            required_permission = protected_endpoints[endpoint]
            
            # V√©rifier si l'utilisateur a la permission
            if hasattr(current_user, 'has_permission'):
                if not current_user.has_permission(required_permission):
                    flash('Acc√®s refus√© : permissions insuffisantes', 'error')
                    return redirect(url_for('dashboard'))
            else:
                # V√©rification bas√©e sur le r√¥le (fallback)
                role_permissions = {
                    'admin': ['can_manage_risks', 'can_manage_kri', 'can_manage_audit', 
                             'can_manage_regulatory', 'can_manage_logigram', 'can_manage_users',
                             'can_view_users_list', 'can_view_reports', 'can_export_data',
                             'can_view_departments', 'can_manage_departments'],
                    'manager': ['can_manage_risks', 'can_manage_kri', 'can_manage_audit',
                               'can_view_reports', 'can_export_data', 'can_view_departments'],
                    'auditeur': ['can_manage_audit', 'can_view_reports', 'can_view_departments'],
                    'utilisateur': ['can_view_reports', 'can_view_departments'],
                    'consultant': ['can_view_reports', 'can_view_departments']
                }
                
                if current_user.role in role_permissions:
                    if required_permission not in role_permissions[current_user.role]:
                        flash('Acc√®s refus√© : permissions insuffisantes', 'error')
                        return redirect(url_for('dashboard'))
                else:
                    flash('Acc√®s refus√© : r√¥le non reconnu', 'error')
                    return redirect(url_for('dashboard'))

print("‚úÖ Middleware de permissions configur√©")
# ========================
# FONCTIONS DE JOURNALISATION
# ========================

def log_activity(utilisateur_id, action, details=None, entite_type=None, entite_id=None):
    """
    Journalise une activit√© utilisateur
    
    Args:
        utilisateur_id: ID de l'utilisateur
        action: Type d'action ('connexion', 'creation', 'modification', 'suppression', 'consultation')
        details: Description d√©taill√©e de l'action
        entite_type: Type d'entit√© concern√©e ('risque', 'audit', 'kri', 'utilisateur', etc.)
        entite_id: ID de l'entit√© concern√©e
    """
    try:
        # R√©cup√©rer l'adresse IP
        if request:
            if request.headers.get('X-Forwarded-For'):
                ip_address = request.headers.get('X-Forwarded-For').split(',')[0].strip()
            else:
                ip_address = request.remote_addr
        else:
            ip_address = socket.gethostbyname(socket.gethostname())
        
        # R√©cup√©rer l'user agent
        user_agent = request.user_agent.string if request else 'Syst√®me'
        
        # Cr√©er l'entr√©e dans le journal
        journal = JournalActivite(
            utilisateur_id=utilisateur_id,
            action=action,
            details=details,
            entite_type=entite_type,
            entite_id=entite_id,
            ip_address=ip_address,
            user_agent=user_agent
        )
        
        db.session.add(journal)
        db.session.commit()
        
        print(f"üìù Activit√© journalis√©e: {action} - {details}")
        
    except Exception as e:
        print(f"‚ùå Erreur journalisation: {e}")
        try:
            db.session.rollback()
        except:
            pass

def journaliser_action_audit(audit_id, action_type, user_id, details=None):
    """Journaliser les actions sur les audits avec notification optionnelle"""
    try:
        journal = JournalAudit(
            audit_id=audit_id,
            action=action_type,
            details=details or {},
            utilisateur_id=user_id,
            signature=current_user.username if current_user.is_authenticated else 'System'
        )
        
        db.session.add(journal)
        
        # Mettre √† jour la date de modification de l'audit
        if MODELS_IMPORTED:
            audit = Audit.query.get(audit_id)
            if audit:
                audit.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        print(f"üìù Journal audit: {action_type} pour audit {audit_id}")
        
    except Exception as e:
        print(f"‚ùå Erreur journalisation audit: {str(e)}")
        try:
            db.session.rollback()
        except:
            pass

print("‚úÖ Fonctions de journalisation d√©finies")

# ========================
# FONCTIONS UTILITAIRES POUR AUDIT
# ========================

def historiser_action_audit_util(audit_id, action_type, user_id, donnees=None):
    """Historiser les actions sur les audits"""
    try:
        if MODELS_IMPORTED:
            historique = HistoriqueModification(
                entite_type='audit',
                entite_id=audit_id,
                utilisateur_id=user_id,
                modifications={
                    'action': action_type,
                    'donnees': donnees or {},
                    'timestamp': datetime.utcnow().isoformat()
                },
                date_modification=datetime.utcnow()
            )
            
            db.session.add(historique)
            db.session.commit()
            print(f"üìù Action audit historis√©e: {action_type} pour audit {audit_id}")
            
    except Exception as e:
        print(f"‚ùå Erreur historisation action audit: {str(e)}")
        try:
            db.session.rollback()
        except:
            pass

def creer_notification(type_notification, titre, message, destinataire_id, entite_type=None, entite_id=None):
    """Cr√©er une notification"""
    try:
        if MODELS_IMPORTED:
            notification = Notification(
                type_notification=type_notification,
                titre=titre,
                message=message,
                destinataire_id=destinataire_id,
                entite_type=entite_type,
                entite_id=entite_id
            )
            
            db.session.add(notification)
            db.session.commit()
            print(f"üì¢ Notification cr√©√©e: {titre} pour utilisateur {destinataire_id}")
            
    except Exception as e:
        print(f"‚ùå Erreur cr√©ation notification: {str(e)}")
        try:
            db.session.rollback()
        except:
            pass

print("‚úÖ Fonctions utilitaires audit d√©finies")

# ========================
# V√âRIFICATION D'ACC√àS AUX ROUTES
# ========================

# Cette fonction peut √™tre utilis√©e dans les routes pour v√©rifier l'acc√®s
def check_route_access(required_permission=None, required_role=None):
    """V√©rifie l'acc√®s √† une route bas√© sur les permissions ou le r√¥le"""
    if not current_user.is_authenticated:
        flash('Veuillez vous connecter pour acc√©der √† cette page.', 'warning')
        return redirect(url_for('login'))
    
    if required_role and current_user.role != required_role:
        flash(f'Acc√®s refus√© : r√¥le {required_role} requis', 'error')
        return redirect(url_for('dashboard'))
    
    if required_permission:
        if hasattr(current_user, 'has_permission'):
            if not current_user.has_permission(required_permission):
                flash(f'Acc√®s refus√© : permission {required_permission} requise', 'error')
                return redirect(url_for('dashboard'))
        else:
            # Logique de secours bas√©e sur le r√¥le
            pass
    
    return None  # Acc√®s autoris√©

print("‚úÖ Fonction de v√©rification d'acc√®s aux routes d√©finie")
# ========================
# CONFIGURATION DE S√âCURIT√â
# ========================

print("\nüîí CONFIGURATION DE S√âCURIT√â")
print("=" * 40)

# Headers de s√©curit√©
@app.after_request
def add_security_headers(response):
    """Ajoute des headers de s√©curit√© √† toutes les r√©ponses."""
    response.headers['X-Content-Type-Options'] = 'nosniff'
    response.headers['X-Frame-Options'] = 'DENY'
    response.headers['X-XSS-Protection'] = '1; mode=block'
    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'
    response.headers['Referrer-Policy'] = 'strict-origin-when-cross-origin'
    return response

print("‚úÖ Headers de s√©curit√© configur√©s")

# ========================
# GESTION DES ERREURS
# ========================

@app.errorhandler(404)
def page_not_found(e):
    """Gestionnaire d'erreur 404."""
    print(f"‚ö†Ô∏è Page non trouv√©e: {request.path}")
    return render_template('errors/404.html'), 404

@app.errorhandler(403)
def forbidden(e):
    """Gestionnaire d'erreur 403."""
    print(f"‚ö†Ô∏è Acc√®s interdit: {request.path}")
    return render_template('errors/403.html'), 403

@app.errorhandler(500)
def internal_server_error(e):
    """Gestionnaire d'erreur 500."""
    print(f"‚ùå Erreur serveur: {e}")
    return render_template('errors/500.html'), 500

print("‚úÖ Gestionnaires d'erreurs configur√©s")

# ========================
# MIDDLEWARE DE JOURNALISATION
# ========================

@app.before_request
def before_request_logging():
    """Journalise les requ√™tes entrantes."""
    if request.endpoint and not request.endpoint.startswith('static'):
        g.start_time = datetime.now()
        print(f"üåê Requ√™te: {request.method} {request.path}")

@app.after_request
def after_request_logging(response):
    """Journalise les r√©ponses."""
    if hasattr(g, 'start_time'):
        duration = (datetime.now() - g.start_time).total_seconds()
        print(f"‚úÖ R√©ponse: {request.method} {request.path} - {response.status_code} ({duration:.3f}s)")
    return response

print("‚úÖ Middleware de journalisation configur√©")

# ========================
# V√âRIFICATION FINALE
# ========================

print("\nüéâ INITIALISATION TERMIN√âE")
print("=" * 40)
print(f"Nom application: {app.name}")
print(f"Mode debug: {app.debug}")
print(f"Secret key: {'‚úì D√©finie' if app.config.get('SECRET_KEY') else '‚úó Non d√©finie'}")
print(f"Dossier upload: {app.config.get('UPLOAD_FOLDER')}")
print(f"Extensions autoris√©es: {', '.join(app.config.get('ALLOWED_EXTENSIONS', []))}")
print("=" * 40)
print("‚úÖ Application Flask pr√™te √† √™tre utilis√©e")


# ========================
# √âV√âNEMENTS DE BASE DE DONN√âES
# ========================

if MODELS_IMPORTED:
    @event.listens_for(Recommandation, 'before_insert')
    def generate_reference_before_insert(mapper, connection, target):
        """G√©n√®re automatiquement une r√©f√©rence pour les recommandations"""
        if not target.reference:
            print(f"üîÑ G√©n√©ration automatique de r√©f√©rence pour recommandation (audit_id: {target.audit_id})")
            
            from models import Audit
            audit = Audit.query.get(target.audit_id)
            
            if not audit:
                print("‚ùå Audit non trouv√©, utilisation de r√©f√©rence temporaire")
                target.reference = f"REC-TEMP-{datetime.utcnow().strftime('%Y%m%d%H%M%S')}"
                return
            
            audit_ref = audit.reference if audit.reference else f"AUD-{target.audit_id:04d}"
            count = Recommandation.query.filter_by(audit_id=target.audit_id).count()
            next_num = count + 1
            target.reference = f"REC-{audit_ref}-{next_num:03d}"
            print(f"‚úÖ R√©f√©rence g√©n√©r√©e: {target.reference}")

# ========================
# FONCTIONS DE JOURNALISATION
# ========================

def journaliser_action_audit(audit_id, action_type, user_id, details=None):
    """Journaliser les actions sur les audits avec notification optionnelle"""
    try:
        journal = JournalAudit(
            audit_id=audit_id,
            action=action_type,
            details=details or {},
            utilisateur_id=user_id,
            signature=current_user.username if current_user.is_authenticated else 'System'
        )
        
        db.session.add(journal)
        
        # Mettre √† jour la date de modification de l'audit
        audit = Audit.query.get(audit_id)
        if audit:
            audit.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        # Optionnel: cr√©er une notification pour certaines actions
        if action_type in ['creation_constatation', 'creation_recommandation', 'creation_plan_action']:
            try:
                from services.notification_service import NotificationService
                from models import Notification
                
                type_notif = {
                    'creation_constatation': Notification.TYPE_CONSTATATION,
                    'creation_recommandation': Notification.TYPE_RECOMMANDATION,
                    'creation_plan_action': Notification.TYPE_PLAN
                }.get(action_type, Notification.TYPE_INFO)
                
                NotificationService.create(
                    destinataire_id=user_id,
                    type_notif=type_notif,
                    titre=f"Action audit: {action_type}",
                    message=f"L'action '{action_type}' a √©t√© enregistr√©e pour l'audit {audit.reference if audit else audit_id}",
                    entite_type='audit',
                    entite_id=audit_id,
                    user_id=user_id
                )
            except ImportError:
                pass
        
        print(f"üìù Journal audit: {action_type} pour audit {audit_id}")
        
    except Exception as e:
        print(f"‚ùå Erreur journalisation: {str(e)}")
        try:
            db.session.rollback()
        except:
            pass
        
def log_activity(utilisateur_id, action, details=None, entite_type=None, entite_id=None):
    """
    Journalise une activit√© utilisateur
    """
    try:
        if not MODELS_IMPORTED:
            return
        
        if request:
            if request.headers.get('X-Forwarded-For'):
                ip_address = request.headers.get('X-Forwarded-For').split(',')[0].strip()
            else:
                ip_address = request.remote_addr
            user_agent = request.user_agent.string
        else:
            ip_address = socket.gethostbyname(socket.gethostname())
            user_agent = 'Syst√®me'
        
        journal = JournalActivite(
            utilisateur_id=utilisateur_id,
            action=action,
            details=details,
            entite_type=entite_type,
            entite_id=entite_id,
            ip_address=ip_address,
            user_agent=user_agent
        )
        
        db.session.add(journal)
        db.session.commit()
        print(f"üìù Activit√© journalis√©e: {action} - {details}")
        
    except Exception as e:
        print(f"‚ùå Erreur journalisation: {e}")
        try:
            db.session.rollback()
        except:
            pass

# ========================
# FONCTIONS DE CONFIGURATION INITIALE
# ========================

def config_initiales():
    """Cr√©e des configurations initiales pour le param√©trage"""
    if not MODELS_IMPORTED:
        return
    
    try:
        if ConfigurationChampRisque.query.count() == 0:
            champs_base = [
                ConfigurationChampRisque(
                    nom_technique='priorite',
                    nom_affichage='Priorit√©',
                    type_champ='select',
                    est_obligatoire=False,
                    est_actif=True,
                    ordre_affichage=10,
                    section='general',
                    aide_texte='Priorit√© de traitement du risque',
                    valeurs_possibles=['Basse', 'Moyenne', 'Haute', 'Critique']
                ),
            ]
            
            for champ in champs_base:
                db.session.add(champ)
            
            db.session.commit()
            print("‚úÖ Configurations initiales cr√©√©es")
    
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur cr√©ation configurations initiales: {e}")
        try:
            db.session.rollback()
        except:
            pass


@app.context_processor
def inject_clients():
    """Injecte la liste des clients disponibles dans tous les templates"""
    if current_user.is_authenticated and current_user.role == 'super_admin':
        # Pour super admin: tous les clients actifs
        available_clients = Client.query.filter_by(is_active=True)\
            .order_by(Client.nom).all()
    else:
        # Pour autres utilisateurs: seulement leur client
        if hasattr(current_user, 'client_id') and current_user.client_id:
            available_clients = Client.query.filter_by(
                id=current_user.client_id, 
                is_active=True
            ).all()
        else:
            available_clients = []
    
    # Client actuellement visualis√©
    viewing_client_id = session.get('viewing_client_id')
    viewing_client = Client.query.get(viewing_client_id) if viewing_client_id else None
    
    return {
        'available_clients': available_clients,
        'viewing_client': viewing_client,
        'is_viewing_other_client': viewing_client_id and viewing_client_id != getattr(current_user, 'client_id', None)
    }

# ========================
# INITIALISATION DE LA BASE DE DONN√âES
# ========================

with app.app_context():
    if MODELS_IMPORTED:
        try:
            db.create_all()
            print("‚úÖ Tables cr√©√©es ou d√©j√† existantes")
            
            # Cr√©er l'admin si n√©cessaire
            try:
                if User.query.count() == 0:
                    admin = User(
                        username='admin',
                        email='admin@entreprise.com',
                        role='admin',
                        department='Direction G√©n√©rale',
                        is_active=True
                    )
                    admin.set_password('admin123')
                    db.session.add(admin)
                    
                    try:
                        config_initiales()
                    except Exception as e:
                        print(f"‚ö†Ô∏è Erreur configurations initiales: {e}")
                    
                    db.session.commit()
                    print("‚úÖ Admin par d√©faut cr√©√©: admin / admin123")
                else:
                    print(f"‚úÖ Utilisateurs existants: {User.query.count()}")
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur cr√©ation admin: {e}")
                try:
                    db.session.rollback()
                except:
                    pass
                
        except Exception as e:
            print(f"‚ùå Erreur initialisation base de donn√©es: {e}")


def get_niveau_from_score(score):
    """Convertit un score en niveau de risque"""
    if score <= 5:
        return "Faible"
    elif score <= 10:
        return "Moyen"
    elif score <= 15:
        return "√âlev√©"
    else:
        return "Critique"

def get_tendance_color(score):
    """Retourne la couleur de tendance selon le score"""
    if score <= 8:
        return "#10b981"  # Vert
    elif score <= 16:
        return "#f59e0b"  # Orange
    else:
        return "#ef4444"  # Rouge

def get_tendance_text(score):
    """Retourne le texte de tendance"""
    if score <= 8:
        return "Positive"
    elif score <= 16:
        return "Neutre"
    else:
        return "N√©gative"

def generate_cartographie_rows(cartographies):
    """G√©n√®re les lignes du tableau des cartographies"""
    rows = ""
    for idx, (nom, nb_risques, score_moyen) in enumerate(cartographies, 1):
        niveau = get_niveau_from_score(score_moyen or 0)
        priorite = "Haute" if niveau in ["√âlev√©", "Critique"] else "Moyenne"
        
        rows += f"""
        <tr>
            <td><strong>{nom or 'Non nomm√©'}</strong></td>
            <td><span class="alert-badge alert-info">{nb_risques or 0}</span></td>
            <td><strong>{round(score_moyen or 0, 2)}</strong>/25</td>
            <td>
                <span class="alert-badge {'alert-danger' if niveau == 'Critique' else 'alert-warning' if niveau == '√âlev√©' else 'alert-info'}">
                    {niveau}
                </span>
            </td>
            <td>
                <span class="alert-badge {'alert-danger' if priorite == 'Haute' else 'alert-warning'}">
                    {priorite}
                </span>
            </td>
        </tr>
        """
    
    if not rows:
        rows = """
        <tr>
            <td colspan="5" style="text-align: center; padding: 30px; color: #64748b;">
                Aucune donn√©e de cartographie disponible
            </td>
        </tr>
        """
    
    return rows

def get_nouveaux_risques_6_mois(six_mois):
    """Compte les nouveaux risques cr√©√©s dans les 6 mois"""
    try:
        count = Risque.query.filter(
            Risque.is_archived == False,
            Risque.created_at >= six_mois
        ).count()
        return count
    except:
        return 0

def get_risques_clotures_6_mois(six_mois):
    """Compte les risques cl√¥tur√©s dans les 6 mois"""
    try:
        # Recherche des √©valuations avec score r√©duit significativement
        count = db.session.query(Risque).join(EvaluationRisque).filter(
            Risque.is_archived == False,
            EvaluationRisque.created_at >= six_mois,
            EvaluationRisque.score_risque <= 5  # Scores faibles
        ).distinct().count()
        return count
    except:
        return 0

def get_taux_rotation_6_mois(six_mois):
    """Calcule le taux de rotation du portefeuille risques"""
    try:
        nouveaux = get_nouveaux_risques_6_mois(six_mois)
        total = Risque.query.filter_by(is_archived=False).count()
        if total > 0:
            return round((nouveaux / total) * 100, 1)
        return 0
    except:
        return 0

def get_pourcentage_critiques(total_risques, risques_critiques):
    """Calcule le pourcentage de risques critiques"""
    if total_risques > 0:
        return round((risques_critiques / total_risques) * 100, 1)
    return 0

# ========================
# FONCTIONS UTILITAIRES POUR AUDIT (apr√®s les imports)
# ========================

def historiser_action_audit_util(audit_id, action_type, user_id, donnees=None):
    """Historiser les actions sur les audits"""
    try:
        if MODELS_IMPORTED:
            historique = HistoriqueModification(
                entite_type='audit',
                entite_id=audit_id,
                utilisateur_id=user_id,
                modifications={
                    'action': action_type,
                    'donnees': donnees or {},
                    'timestamp': datetime.utcnow().isoformat()
                },
                date_modification=datetime.utcnow()
            )
            
            db.session.add(historique)
            db.session.commit()
            print(f"üìù Action audit historis√©e: {action_type} pour audit {audit_id}")
            
    except Exception as e:
        print(f"‚ùå Erreur historisation action audit: {str(e)}")
        try:
            db.session.rollback()
        except:
            pass

def creer_notification(type_notification, titre, message, destinataire_id, entite_type=None, entite_id=None):
    """Cr√©er une notification"""
    try:
        if MODELS_IMPORTED:
            notification = Notification(
                type_notification=type_notification,
                titre=titre,
                message=message,
                destinataire_id=destinataire_id,
                entite_type=entite_type,
                entite_id=entite_id
            )
            
            db.session.add(notification)
            db.session.commit()
            print(f"üì¢ Notification cr√©√©e: {titre} pour utilisateur {destinataire_id}")
            
    except Exception as e:
        print(f"‚ùå Erreur cr√©ation notification: {str(e)}")
        try:
            db.session.rollback()
        except:
            pass

# ========================
# FONCTIONS D'AUTOMATISATION
# ========================

def automatiser_statuts_audits():
    """Automatise les mises √† jour de statut des audits"""
    if not MODELS_IMPORTED:
        return
    
    print("ü§ñ D√©marrage de l'automatisation des statuts d'audit...")
    with app.app_context():
        try:
            audits = Audit.query.filter_by(is_archived=False).all()
            
            for audit in audits:
                try:
                    # Logique d'automatisation
                    constatations_non_closes = Constatation.query.filter_by(
                        audit_id=audit.id,
                        is_archived=False
                    ).filter(Constatation.statut != 'clos').count()
                    
                    total_constatations = Constatation.query.filter_by(
                        audit_id=audit.id,
                        is_archived=False
                    ).count()
                    
                    if total_constatations > 0 and constatations_non_closes == 0:
                        if audit.statut != 'clos':
                            audit.statut = 'clos'
                            audit.sous_statut = 'cloture'
                            print(f"‚úÖ Audit {audit.reference} automatiquement clos")
                    
                    db.session.commit()
                    
                except Exception as e:
                    print(f"‚ùå Erreur sur audit {audit.reference}: {e}")
                    db.session.rollback()
                    
        except Exception as e:
            print(f"‚ùå Erreur automatisation: {e}")

def verifier_echeances_et_alertes():
    """V√©rifie les √©ch√©ances et g√©n√®re des alertes"""
    if not MODELS_IMPORTED:
        return
    
    print("üîî V√©rification des √©ch√©ances et alertes...")
    with app.app_context():
        try:
            aujourdhui = datetime.utcnow().date()
            recommandations = Recommandation.query.filter_by(is_archived=False).all()
            
            for recommandation in recommandations:
                try:
                    if recommandation.date_echeance:
                        jours_restants = (recommandation.date_echeance - aujourdhui).days
                        
                        if 0 < jours_restants <= 7 and recommandation.statut != 'termine':
                            # Cr√©er une alerte
                            creer_notification(
                                type_notification='echeance_proche',
                                titre=f"√âch√©ance proche pour recommandation",
                                message=f"La recommandation arrive √† √©ch√©ance dans {jours_restants} jours",
                                destinataire_id=recommandation.responsable_id or recommandation.audit.responsable_id,
                                entite_type='recommandation',
                                entite_id=recommandation.id
                            )
                    
                    db.session.commit()
                    
                except Exception as e:
                    print(f"‚ùå Erreur sur recommandation {recommandation.id}: {e}")
                    db.session.rollback()
                    
        except Exception as e:
            print(f"‚ùå Erreur v√©rification √©ch√©ances: {e}")

def demarrer_scheduler():
    """D√©marre le scheduler pour les t√¢ches automatiques"""
    try:
        scheduler = BackgroundScheduler()
        
        scheduler.add_job(
            func=automatiser_statuts_audits,
            trigger="interval",
            hours=1,
            id="verif_statuts",
            name="V√©rification automatique des statuts d'audit",
            replace_existing=True
        )
        
        scheduler.add_job(
            func=verifier_echeances_et_alertes,
            trigger="cron",
            hour=8,
            minute=0,
            id="verif_echeances",
            name="V√©rification des √©ch√©ances et alertes",
            replace_existing=True
        )
        
        scheduler.start()
        print("‚úÖ Scheduler d√©marr√© avec succ√®s")
        
    except Exception as e:
        print(f"‚ùå Erreur lors du d√©marrage du scheduler: {e}")

# D√©marrer le scheduler
with app.app_context():
    try:
        demarrer_scheduler()
    except:
        print("‚ö†Ô∏è Scheduler non d√©marr√© (peut √™tre normal en d√©veloppement)")

# ========================
# MIDDLEWARE ET GESTION DES LANGUES
# ========================



def determine_language():
    """D√©termine la langue √† utiliser"""
    # 1. V√©rifier le param√®tre GET
    lang_from_url = request.args.get('lang')
    if lang_from_url in LANGUAGES:
        return lang_from_url
    
    # 2. V√©rifier la session
    lang_from_session = session.get('lang')
    if lang_from_session in LANGUAGES:
        return lang_from_session
    
    # 3. Par d√©faut
    return 'fr'


@app.route('/toggle_lang')
def toggle_language():
    """Bascule entre fran√ßais et anglais"""
    current = session.get('lang', 'fr')
    new_lang = 'en' if current == 'fr' else 'fr'
    
    return change_language(new_lang)



@app.route('/logigramme/<int:activite_id>/export-pdf')
@login_required
def export_logigramme_pdf(activite_id):
    """Exporter le logigramme en PDF"""
    try:
        print(f"üì• D√©but export PDF pour activite_id: {activite_id}")
        
        # R√©cup√©rer l'activit√©
        activite = ProcessusActivite.query.filter_by(
            id=activite_id, 
            created_by=current_user.id
        ).first_or_404()
        
        print(f"‚úÖ Activit√© trouv√©e: {activite.nom}")
        
        # R√©cup√©rer les √©l√©ments
        elements = ElementLogigramme.query.filter_by(activite_id=activite_id).all()
        print(f"üìä √âl√©ments trouv√©s: {len(elements)}")
        
        # R√©cup√©rer les liens
        liens = LienLogigramme.query.filter_by(activite_id=activite_id).all()
        print(f"üîó Liens trouv√©s: {len(liens)}")
        
        # Cr√©er le PDF
        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=landscape(A4))
        story = []
        
        # Styles
        styles = getSampleStyleSheet()
        
        # Titre
        story.append(Paragraph(f"<b>LOGIGRAMME - {activite.nom}</b>", 
                             ParagraphStyle('Title', parent=styles['Heading1'], fontSize=18, alignment=1)))
        story.append(Spacer(1, 20))
        
        # Informations
        info_data = [
            ['Nom:', activite.nom],
            ['Description:', activite.description or 'Non sp√©cifi√©e'],
            ['Date:', datetime.now().strftime('%d/%m/%Y %H:%M:%S')],
            ['√âl√©ments:', str(len(elements))],
            ['Connexions:', str(len(liens))]
        ]
        
        info_table = Table(info_data, colWidths=[3*cm, 10*cm])
        info_table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (0, -1), 'RIGHT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ('PADDING', (0, 0), (-1, -1), 6)
        ]))
        
        story.append(info_table)
        story.append(Spacer(1, 20))
        
        # Table des √©l√©ments
        if elements:
            story.append(Paragraph("<b>√âL√âMENTS DU LOGIGRAMME</b>", styles['Heading2']))
            
            elements_data = [['Type', 'Libell√©', 'Description', 'Position']]
            for element in elements:
                elements_data.append([
                    element.type_element.capitalize(),
                    element.libelle,
                    element.description or '',
                    f"({element.position_x}, {element.position_y})"
                ])
            
            elements_table = Table(elements_data, colWidths=[3*cm, 5*cm, 6*cm, 3*cm])
            elements_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#3b82f6')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('GRID', (0, 0), (-1, -1), 0.25, colors.grey),
                ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#f8fafc'))
            ]))
            
            story.append(elements_table)
            story.append(Spacer(1, 20))
        
        # Table des liens
        if liens:
            story.append(Paragraph("<b>CONNEXIONS ENTRE √âL√âMENTS</b>", styles['Heading2']))
            
            liens_data = [['Source', 'Cible', 'Type']]
            for lien in liens:
                source = next((e.libelle for e in elements if e.id == lien.element_source_id), f"ID:{lien.element_source_id}")
                cible = next((e.libelle for e in elements if e.id == lien.element_cible_id), f"ID:{lien.element_cible_id}")
                lien_type = 'Normal'
                if lien.style and isinstance(lien.style, dict):
                    lien_type = lien.style.get('type', 'normal').capitalize()
                
                liens_data.append([
                    source[:30] + '...' if len(source) > 30 else source,
                    cible[:30] + '...' if len(cible) > 30 else cible,
                    lien_type
                ])
            
            liens_table = Table(liens_data, colWidths=[6*cm, 6*cm, 3*cm])
            liens_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#10b981')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('GRID', (0, 0), (-1, -1), 0.25, colors.grey),
                ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#f0fdf4'))
            ]))
            
            story.append(liens_table)
        
        # L√©gende
        story.append(Spacer(1, 20))
        story.append(Paragraph("<b>L√âGENDE</b>", styles['Heading2']))
        
        legende_data = [
            ['D√©but', 'Point de d√©part du processus'],
            ['Action', 'Activit√© √† r√©aliser'],
            ['Contr√¥le', 'Point de d√©cision ou validation'],
            ['Risque', 'Risque identifi√©'],
            ['Fin', 'Point de fin du processus'],
            ['Organisation', 'S√©paration organisationnelle']
        ]
        
        legende_table = Table(legende_data, colWidths=[3*cm, 12*cm])
        legende_table.setStyle(TableStyle([
            ('GRID', (0, 0), (-1, -1), 0.25, colors.grey),
            ('PADDING', (0, 0), (-1, -1), 4)
        ]))
        
        story.append(legende_table)
        
        # Pied de page
        story.append(Spacer(1, 30))
        story.append(Paragraph(
            f"<i>Document g√©n√©r√© le {datetime.now().strftime('%d/%m/%Y √† %H:%M')}</i>",
            ParagraphStyle('Footer', fontSize=8, textColor=colors.grey, alignment=1)
        ))
        
        # G√©n√©rer le PDF
        doc.build(story)
        buffer.seek(0)
        
        print(f"‚úÖ PDF g√©n√©r√© avec succ√®s, taille: {len(buffer.getvalue())} bytes")
        
        # Envoyer le fichier
        return send_file(
            buffer,
            as_attachment=True,
            download_name=f"logigramme_{activite.nom}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf",
            mimetype='application/pdf'
        )
        
    except Exception as e:
        print(f"‚ùå Erreur lors de l'export PDF: {str(e)}")
        import traceback
        traceback.print_exc()
        return f"Erreur lors de l'export: {str(e)}", 500
# ========================
# FONCTIONS D'AUTOMATISATION
# ========================

def automatiser_statuts_audits():
    """Automatise les mises √† jour de statut des audits"""
    print("ü§ñ D√©marrage de l'automatisation des statuts d'audit...")
    with app.app_context():
        audits = Audit.query.filter_by(is_archived=False).all()
        
        for audit in audits:
            try:
                # V√©rifier si toutes les constatations sont cl√¥tur√©es
                constatations_non_closes = Constatation.query.filter_by(
                    audit_id=audit.id,
                    is_archived=False
                ).filter(Constatation.statut != 'clos').count()
                
                total_constatations = Constatation.query.filter_by(
                    audit_id=audit.id,
                    is_archived=False
                ).count()
                
                # Si toutes les constatations sont cl√¥tur√©es, clore l'audit
                if total_constatations > 0 and constatations_non_closes == 0:
                    if audit.statut != 'clos':
                        audit.statut = 'clos'
                        audit.sous_statut = 'cloture'
                        print(f"‚úÖ Audit {audit.reference} automatiquement clos")
                        
                        # Notifier le responsable
                        if audit.responsable_id:
                            creer_notification(
                                type_notification='audit_clos',
                                titre=f"Audit {audit.reference} clos",
                                message=f"L'audit {audit.reference} a √©t√© automatiquement clos car toutes les constatations sont trait√©es.",
                                destinataire_id=audit.responsable_id,
                                entite_type='audit',
                                entite_id=audit.id
                            )
                
                # Mettre √† jour le sous-statut en fonction de l'avancement
                if audit.statut != 'clos' and audit.statut != 'archive':
                    if audit.progression_globale < 25:
                        audit.sous_statut = 'planification'
                    elif audit.progression_globale < 50:
                        audit.sous_statut = 'collecte'
                    elif audit.progression_globale < 75:
                        audit.sous_statut = 'analyse'
                    elif audit.progression_globale < 90:
                        audit.sous_statut = 'redaction'
                    elif audit.progression_globale < 100:
                        audit.sous_statut = 'validation'
                
                # Mettre √† jour la date de modification
                audit.updated_at = datetime.utcnow()
                db.session.commit()
                
            except Exception as e:
                print(f"‚ùå Erreur sur audit {audit.reference}: {e}")
                db.session.rollback()

def verifier_echeances_et_alertes():
    """V√©rifie les √©ch√©ances et g√©n√®re des alertes"""
    print("üîî V√©rification des √©ch√©ances et alertes...")
    with app.app_context():
        aujourdhui = datetime.utcnow().date()
        
        # V√©rifier les recommandations
        recommandations = Recommandation.query.filter_by(is_archived=False).all()
        
        for recommandation in recommandations:
            try:
                # Alerte √©ch√©ance proche (7 jours)
                if recommandation.date_echeance:
                    jours_restants = (recommandation.date_echeance - aujourdhui).days
                    
                    if 0 < jours_restants <= 7 and recommandation.statut != 'termine':
                        # V√©rifier si une alerte existe d√©j√†
                        existing_alert = Notification.query.filter_by(
                            type_notification='echeance_proche',
                            entite_id=recommandation.id,
                            est_lue=False
                        ).first()
                        
                        if not existing_alert:
                            creer_notification(
                                type_notification='echeance_proche',
                                titre=f"√âch√©ance proche pour recommandation",
                                message=f"La recommandation arrive √† √©ch√©ance dans {jours_restants} jours",
                                destinataire_id=recommandation.responsable_id or recommandation.audit.responsable_id,
                                entite_type='recommandation',
                                entite_id=recommandation.id
                            )
                    
                    # Alerte retard
                    elif jours_restants < 0 and recommandation.statut != 'termine':
                        recommandation.statut = 'retarde'
                        
                        existing_alert = Notification.query.filter_by(
                            type_notification='retard',
                            entite_id=recommandation.id,
                            est_lue=False
                        ).first()
                        
                        if not existing_alert:
                            creer_notification(
                                type_notification='retard',
                                titre=f"Retard sur recommandation",
                                message=f"La recommandation est en retard de {abs(jours_restants)} jours",
                                destinataire_id=recommandation.responsable_id or recommandation.audit.responsable_id,
                                entite_type='recommandation',
                                entite_id=recommandation.id
                            )
                
                db.session.commit()
                
            except Exception as e:
                print(f"‚ùå Erreur sur recommandation {recommandation.id}: {e}")
                db.session.rollback()
        
        # V√©rifier les plans d'action
        plans = PlanAction.query.filter_by(is_archived=False).all()
        
        for plan in plans:
            try:
                if plan.date_fin_prevue:
                    jours_restants = (plan.date_fin_prevue - aujourdhui).days
                    
                    # Alerte 7 jours avant √©ch√©ance
                    if 0 < jours_restants <= 7 and plan.statut not in ['termine', 'suspendu']:
                        existing_alert = Notification.query.filter_by(
                            type_notification='echeance_proche',
                            entite_id=plan.id,
                            est_lue=False
                        ).first()
                        
                        if not existing_alert:
                            creer_notification(
                                type_notification='echeance_proche',
                                titre=f"√âch√©ance proche pour le plan {plan.nom}",
                                message=f"Le plan {plan.nom} arrive √† √©ch√©ance dans {jours_restants} jours",
                                destinataire_id=plan.responsable_id or plan.audit.responsable_id,
                                entite_type='plan_action',
                                entite_id=plan.id
                            )
                    
                    # Alerte retard
                    elif jours_restants < 0 and plan.statut not in ['termine', 'suspendu']:
                        plan.statut = 'retarde'
                        
                        existing_alert = Notification.query.filter_by(
                            type_notification='retard',
                            entite_id=plan.id,
                            est_lue=False
                        ).first()
                        
                        if not existing_alert:
                            creer_notification(
                                type_notification='retard',
                                titre=f"Retard sur le plan {plan.nom}",
                                message=f"Le plan {plan.nom} est en retard de {abs(jours_restants)} jours",
                                destinataire_id=plan.responsable_id or plan.audit.responsable_id,
                                entite_type='plan_action',
                                entite_id=plan.id
                            )
                
                # Si toutes les sous-actions sont termin√©es, terminer le plan
                if plan.sous_actions:
                    toutes_terminees = all(s.pourcentage_realisation == 100 for s in plan.sous_actions)
                    if toutes_terminees and plan.statut != 'termine':
                        plan.statut = 'termine'
                        plan.date_fin_reelle = datetime.utcnow().date()
                        plan.pourcentage_realisation = 100
                        
                        # Notifier
                        creer_notification(
                            type_notification='plan_termine',
                            titre=f"Plan d'action termin√©: {plan.nom}",
                            message=f"Le plan d'action '{plan.nom}' a √©t√© automatiquement marqu√© comme termin√© car toutes les sous-actions sont compl√®tes.",
                            destinataire_id=plan.responsable_id or plan.audit.responsable_id,
                            entite_type='plan_action',
                            entite_id=plan.id
                        )
                
                db.session.commit()
                
            except Exception as e:
                print(f"‚ùå Erreur sur plan {plan.id}: {e}")
                db.session.rollback()

def demarrer_scheduler():
    """D√©marre le scheduler pour les t√¢ches automatiques"""
    try:
        scheduler = BackgroundScheduler()
        
        # V√©rifier les statuts toutes les heures
        scheduler.add_job(
            func=automatiser_statuts_audits,
            trigger="interval",
            hours=1,
            id="verif_statuts",
            name="V√©rification automatique des statuts d'audit",
            replace_existing=True
        )
        
        # V√©rifier les √©ch√©ances tous les jours √† 8h
        scheduler.add_job(
            func=verifier_echeances_et_alertes,
            trigger="cron",
            hour=8,
            minute=0,
            id="verif_echeances",
            name="V√©rification des √©ch√©ances et alertes",
            replace_existing=True
        )
        
        scheduler.start()
        print("‚úÖ Scheduler d√©marr√© avec succ√®s")
        
    except Exception as e:
        print(f"‚ùå Erreur lors du d√©marrage du scheduler: {e}")


# ========================
# FONCTIONS DE SYNCHRONISATION
# ========================
def synchroniser_organigramme_complet(processus_id):
    try:
        processus = Processus.query.get(processus_id)
        if not processus: return False
        etapes_avec_position = EtapeProcessus.query.filter_by(processus_id=processus_id).filter(
            EtapeProcessus.position_x.isnot(None),
            EtapeProcessus.position_y.isnot(None)
        ).count()
        total_etapes = EtapeProcessus.query.filter_by(processus_id=processus_id).count()
        processus.nb_etapes = total_etapes
        processus.nb_liens = LienProcessus.query.filter_by(processus_id=processus_id).count()
        processus.derniere_sync_organigramme = datetime.utcnow()
        processus.a_besoin_sync = False
        db.session.commit()
        print(f"‚úÖ Synchronisation r√©ussie: {etapes_avec_position}/{total_etapes} √©tapes positionn√©es")
        return True
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur synchronisation processus {processus_id}: {e}")
        return False

def synchroniser_etape_organigramme(etape_id, action_type, user_id):
    try:
        etape = EtapeProcessus.query.get(etape_id)
        if not etape: return False
        synchroniser_organigramme_complet(etape.processus_id)
        return True
    except Exception as e:
        print(f"‚ùå Erreur synchronisation √©tape {etape_id}: {e}")
        return False

from apscheduler.schedulers.background import BackgroundScheduler

def demarrer_scheduler():
    """D√©marre le scheduler pour les t√¢ches automatiques"""
    scheduler = BackgroundScheduler()
    
    # V√©rifier les statuts toutes les heures
    scheduler.add_job(
        func=automatiser_statuts_audits,
        trigger="interval",
        hours=1,
        id="verif_statuts",
        name="V√©rification automatique des statuts d'audit",
        replace_existing=True
    )
    
    # V√©rifier les √©ch√©ances tous les jours √† 8h
    scheduler.add_job(
        func=verifier_echeances_et_alertes,
        trigger="cron",
        hour=8,
        minute=0,
        id="verif_echeances",
        name="V√©rification des √©ch√©ances et alertes",
        replace_existing=True
    )
    
    scheduler.start()
    print("‚úÖ Scheduler d√©marr√©")

# Appeler dans le contexte de l'application
with app.app_context():
    demarrer_scheduler()

# ========================
# MIDDLEWARE MULTI-TENANT SIMPLE
# ========================

@app.before_request
def setup_multi_tenant():
    """Configure le multi-tenant pour chaque requ√™te"""
    if current_user.is_authenticated:
        # Super admin : pas de filtre
        if current_user.role == 'super_admin':
            g.client_id = None
            g.filter_by_client = False
        else:
            # Clients normaux : filtrer par client_id
            g.client_id = current_user.client_id
            g.filter_by_client = True
    else:
        g.client_id = None
        g.filter_by_client = False

def get_client_filter(model_class, **filters):
    """
    Retourne une requ√™te filtr√©e par client
    √Ä utiliser dans TOUTES vos routes
    """
    query = model_class.query
    
    # Super admin : pas de filtre
    if not current_user.is_authenticated or current_user.role == 'super_admin':
        return query.filter_by(**filters)
    
    # Client normal : filtrer
    client_id = current_user.client_id
    
    # 1. Mod√®les avec client_id direct
    if hasattr(model_class, 'client_id'):
        return query.filter_by(client_id=client_id, **filters)
    
    # 2. Mod√®les avec created_by
    elif hasattr(model_class, 'created_by'):
        # R√©cup√©rer tous les utilisateurs du client
        user_ids = db.session.query(User.id).filter_by(client_id=client_id).all()
        user_ids = [uid[0] for uid in user_ids] if user_ids else [-1]
        
        if 'created_by' in filters:
            # V√©rifier que created_by appartient au client
            if filters['created_by'] in user_ids:
                return query.filter_by(**filters)
            else:
                return query.filter_by(id=-1)  # Aucun r√©sultat
        else:
            return query.filter(model_class.created_by.in_(user_ids), **filters)
    
    # 3. Mod√®les sans relation
    else:
        # Par d√©faut : aucun r√©sultat pour la s√©curit√©
        return query.filter_by(id=-1)

def check_client_access(entity):
    """
    V√©rifie l'acc√®s √† une entit√© sp√©cifique
    MAINTENANT : Le super admin n'a plus d'acc√®s universel
    """
    if not current_user.is_authenticated:
        return False
    
    # TOUT LE MONDE doit v√©rifier le client_id
    client_id = current_user.client_id
    
    if not client_id:
        print(f"‚ö†Ô∏è {current_user.username} n'a pas de client_id")
        return False
    
    # V√©rifier client_id direct
    if hasattr(entity, 'client_id'):
        return entity.client_id == client_id
    
    # V√©rifier par created_by
    if hasattr(entity, 'created_by') and entity.created_by:
        creator = User.query.get(entity.created_by)
        if creator and hasattr(creator, 'client_id'):
            return creator.client_id == client_id
    
    # V√©rifier les relations
    if hasattr(entity, 'audit_id'):
        audit = Audit.query.get(entity.audit_id)
        return check_client_access(audit) if audit else False
    
    if hasattr(entity, 'risque_id'):
        risque = Risque.query.get(entity.risque_id)
        return check_client_access(risque) if risque else False
    
    if hasattr(entity, 'cartographie_id'):
        cartographie = Cartographie.query.get(entity.cartographie_id)
        return check_client_access(cartographie) if cartographie else False
    
    # Pour les User, v√©rifier directement
    if isinstance(entity, User):
        return entity.client_id == client_id
    
    # Par d√©faut, refuser
    return False

def get_super_admin_access():
    """
    Donne un acc√®s contr√¥l√© au super admin
    Retourne une liste de client_ids que le super admin peut voir
    """
    if current_user.role == 'super_admin':
        # Option 1: Voir tous les clients (comme avant)
        # return None  # Pas de filtre
        
        # Option 2: Voir seulement certains clients
        # Par exemple, ceux assign√©s explicitement
        assigned_clients = getattr(current_user, 'assigned_client_ids', [])
        if assigned_clients:
            return assigned_clients
        else:
            # Si aucun client assign√©, voir aucun r√©sultat
            return []
    
    # Pour les utilisateurs normaux
    return [current_user.client_id] if hasattr(current_user, 'client_id') else []

def get_controlled_filter(model_class, **filters):
    """
    Filtre contr√¥l√© selon les param√®tres
    """
    query = model_class.query
    
    # V√©rifier si on demande explicitement de tout voir
    show_all = request.args.get('show_all', 'false').lower() == 'true'
    view_as_client = request.args.get('view_as_client')
    
    # SUPER ADMIN avec param√®tre show_all
    if current_user.role == 'super_admin' and show_all:
        return query.filter_by(**filters)  # Voir tout
    
    # SUPER ADMIN se faisant passer pour un client
    if current_user.role == 'super_admin' and view_as_client:
        try:
            client_id = int(view_as_client)
            if hasattr(model_class, 'client_id'):
                return query.filter(model_class.client_id == client_id, **filters)
        except:
            pass
    
    # Par d√©faut, utiliser le filtrage normal
    return get_client_filter(model_class, **filters)

# Script pour assigner un client au super admin
def assign_client_to_super_admin():
    """Assigner un client par d√©faut au super admin"""
    super_admin = User.query.filter_by(role='super_admin').first()
    
    if super_admin and not super_admin.client_id:
        # Trouver ou cr√©er un client par d√©faut
        default_client = Client.query.filter_by(reference='system').first()
        
        if not default_client:
            default_client = Client(
                nom='Syst√®me',
                reference='system',
                description='Client syst√®me pour administration',
                is_active=True
            )
            db.session.add(default_client)
            db.session.flush()
        
        super_admin.client_id = default_client.id
        db.session.commit()
        print(f"‚úÖ Client {default_client.reference} assign√© au super admin")
        

def apply_client_id_before_insert(mapper, connection, target):
    """
    Hook pour ajouter automatiquement client_id aux nouvelles entr√©es
    S'applique AVANT chaque insertion
    """
    from flask_login import current_user
    
    try:
        # V√©rifier si le mod√®le a un champ client_id
        if hasattr(target, 'client_id'):
            # Si client_id n'est pas d√©j√† d√©fini
            if target.client_id is None:
                if current_user.is_authenticated:
                    # SUPER ADMIN : peut cr√©er sans client_id
                    if current_user.role == 'super_admin':
                        # On laisse None ou on prend celui sp√©cifi√©
                        pass
                    else:
                        # Utilisateurs normaux : ajouter leur client_id
                        if hasattr(current_user, 'client_id') and current_user.client_id:
                            target.client_id = current_user.client_id
                            print(f"‚úÖ Client_id {current_user.client_id} assign√© √† {type(target).__name__}")
        
        # Pour les mod√®les avec created_by
        if hasattr(target, 'created_by') and target.created_by is None:
            if current_user.is_authenticated:
                target.created_by = current_user.id
                print(f"‚úÖ Created_by {current_user.id} assign√© √† {type(target).__name__}")
                
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur dans apply_client_id_before_insert: {e}")
        # Ne pas lever l'exception pour √©viter de bloquer l'insertion

@app.route('/test-multi-tenant')
@login_required
def test_multi_tenant():
    """Route pour tester le multi-tenant"""
    from flask import jsonify
    
    # Cr√©er une cartographie de test
    test_cartographie = Cartographie(
        nom=f"Test Tenant {datetime.utcnow().strftime('%H:%M:%S')}",
        description="Cartographie de test pour v√©rifier le multi-tenant"
    )
    
    # Le hook devrait ajouter automatiquement client_id et created_by
    db.session.add(test_cartographie)
    db.session.commit()
    
    # R√©cup√©rer toutes les cartographies
    all_cartographies = Cartographie.query.all()
    
    # R√©cup√©rer les cartographies filtr√©es
    filtered_cartographies = get_client_filtered_query(Cartographie).all()
    
    return jsonify({
        'user': {
            'id': current_user.id,
            'username': current_user.username,
            'role': current_user.role,
            'client_id': current_user.client_id
        },
        'test_cartographie': {
            'id': test_cartographie.id,
            'nom': test_cartographie.nom,
            'client_id': test_cartographie.client_id,
            'created_by': test_cartographie.created_by
        },
        'counts': {
            'all': len(all_cartographies),
            'filtered': len(filtered_cartographies)
        },
        'status': 'Test complet'
    })

# ========================
# TENANT MANAGER SIMPLE
# ========================

class TenantManager:
    """Gestionnaire simple pour le multi-tenant"""
    
    @staticmethod
    def ensure_client_access(model_instance):
        """V√©rifie qu'un utilisateur a acc√®s √† une instance"""
        from flask_login import current_user
        
        if not current_user.is_authenticated:
            return False
        
        if current_user.role == 'super_admin':
            return True
        
        if not hasattr(model_instance, 'client_id'):
            return True  # Si pas de client_id, on autorise
        
        return model_instance.client_id == current_user.client_id
    
    @staticmethod
    def auto_assign_client(model_instance, user=None):
        """Assigne automatiquement le client_id √† une nouvelle instance"""
        from flask_login import current_user
        
        user = user or current_user
        
        if user.is_authenticated and user.client_id:
            if hasattr(model_instance, 'client_id'):
                model_instance.client_id = user.client_id
        
        return model_instance

# Injecter dans les templates
@app.context_processor
def inject_tenant_utils():
    return {
        'tenant_manager': TenantManager,
        'has_tenant_access': TenantManager.ensure_client_access
    }

def declencher_mise_a_jour_risque(risque_id, action, utilisateur_id, donnees_supplementaires=None):
    """D√©clencher une mise √† jour automatique pour un risque"""
    risque = Risque.query.get(risque_id)
    if not risque:
        return
    
    # R√©cup√©rer les informations de la requ√™te si disponibles
    from flask import request
    
    ip_address = None
    user_agent = None
    
    try:
        if request:
            ip_address = request.remote_addr
            user_agent = request.user_agent.string
    except RuntimeError:
        # Pas de contexte de requ√™te (cela peut arriver dans certains cas)
        pass
    
    # Cr√©er la description
    description = None
    if donnees_supplementaires:
        if isinstance(donnees_supplementaires, dict):
            description_parts = []
            for key, value in donnees_supplementaires.items():
                # Formater les valeurs sp√©ciales
                if isinstance(value, list):
                    value = ', '.join(str(v) for v in value)
                elif isinstance(value, dict):
                    value = str(value)
                description_parts.append(f"{key}: {value}")
            description = "\n".join(description_parts)
        else:
            description = str(donnees_supplementaires)
    
    # Journaliser l'action
    journal = JournalActivite(
        utilisateur_id=utilisateur_id,
        action=action,
        description=description,
        entite_type='risque',
        entite_id=risque_id,
        ip_address=ip_address,
        user_agent=user_agent
    )
    db.session.add(journal)
    
    # Synchroniser les matrices si n√©cessaire
    actions_sync = [
        'champ_personnalise_ajoute', 'champ_personnalise_modifie',
        'fichier_ajoute', 'fichier_supprime', 'evaluation_modifiee',
        'kri_associe', 'kri_modifie', 'risque_modifie'
    ]
    
    if action in actions_sync:
        synchroniser_matrices_apres_modification(risque.cartographie_id)
    
    db.session.commit()

    
def journaliser_action(utilisateur_id, action, details=None, entite_type=None, entite_id=None):
    """Fonction utilitaire pour journaliser une action"""
    from flask import request
    
    ip_address = None
    user_agent = None
    
    try:
        if request:
            ip_address = request.remote_addr
            user_agent = request.user_agent.string
    except RuntimeError:
        pass
    
    journal = JournalActivite(
        utilisateur_id=utilisateur_id,
        action=action,
        details=details,  # ‚úÖ CORRIG√â : utilise 'details'
        entite_type=entite_type,
        entite_id=entite_id,
        ip_address=ip_address,
        user_agent=user_agent
    )
    
    db.session.add(journal)
    db.session.commit()
    
    print(f"üìù Activit√© journalis√©e: {action} - {details}")
    
    return journal

def declencher_mise_a_jour_risque(risque_id, action, utilisateur_id, donnees_supplementaires=None):
    """D√©clencher une mise √† jour automatique pour un risque"""
    risque = Risque.query.get(risque_id)
    if not risque:
        return
    
    # Cr√©er la description √† partir des donn√©es suppl√©mentaires
    description = None
    if donnees_supplementaires:
        # Convertir les donn√©es suppl√©mentaires en texte descriptif
        if isinstance(donnees_supplementaires, dict):
            description_parts = []
            for key, value in donnees_supplementaires.items():
                description_parts.append(f"{key}: {value}")
            description = "\n".join(description_parts)
        else:
            description = str(donnees_supplementaires)
    
    # Journaliser l'action
    journal = JournalActivite(
        utilisateur_id=utilisateur_id,
        action=action,
        description=description,  # Utilisez 'description' au lieu de 'details'
        entite_type='risque',
        entite_id=risque_id
    )
    db.session.add(journal)
    
    # Synchroniser les matrices si n√©cessaire
    if action in ['champ_personnalise_ajoute', 'champ_personnalise_modifie', 'fichier_ajoute', 'fichier_supprime']:
        synchroniser_matrices_apres_modification(risque.cartographie_id)
    
    db.session.commit()
    

# ========================
# FONCTIONS DE PARAM√âTRAGE
# ========================


def get_config_fichiers():
    """Retourne la configuration des fichiers"""
    return {
        'extensions': list(app.config.get('ALLOWED_EXTENSIONS', {'pdf', 'doc', 'docx', 'xls', 'xlsx', 'jpg', 'png', 'txt'})),
        'taille_max_mo': app.config.get('MAX_CONTENT_LENGTH', 10 * 1024 * 1024) // (1024 * 1024),
        'categories': ['document', 'image', 'analyse', 'autre']
    }

# Puis dans vos routes, utilisez :
config_fichiers = get_config_fichiers()

def synchroniser_configuration_champ(champ):
    """Synchroniser l'ajout d'un champ avec toutes les fiches de risque"""
    print(f"üîÑ Synchronisation champ ajout√©: {champ.nom_technique}")
    
    # Pour les champs obligatoires, cr√©er des entr√©es vides pour tous les risques existants
    if champ.est_obligatoire and champ.est_actif:
        risques = Risque.query.filter_by(is_archived=False).all()
        
        for risque in risques:
            # V√©rifier si le champ existe d√©j√†
            existing = ChampPersonnaliseRisque.query.filter_by(
                risque_id=risque.id,
                nom_technique=champ.nom_technique
            ).first()
            
            if not existing:
                # Cr√©er une entr√©e vide
                champ_perso = ChampPersonnaliseRisque(
                    risque_id=risque.id,
                    nom_technique=champ.nom_technique
                )
                # D√©finir une valeur par d√©faut si disponible
                if champ.valeurs_possibles and len(champ.valeurs_possibles) > 0:
                    champ_perso.set_valeur(champ.valeurs_possibles[0])
                else:
                    champ_perso.set_valeur('')
                db.session.add(champ_perso)
        
        db.session.commit()
        print(f"‚úÖ Champ ajout√© √† {len(risques)} risques existants")

def synchroniser_modification_champ(champ):
    """Synchroniser la modification d'un champ"""
    print(f"üîÑ Synchronisation modification champ: {champ.nom_technique}")
    
    # Mettre √† jour les champs personnalis√©s existants si le nom d'affichage a chang√©
    # Cette logique peut √™tre √©tendue selon les besoins
    pass

def declencher_mise_a_jour_risque(risque_id, action, utilisateur_id, donnees_supplementaires=None):
    """D√©clencher une mise √† jour automatique pour un risque"""
    risque = Risque.query.get(risque_id)
    if not risque:
        return
    
    # R√©cup√©rer les informations de la requ√™te si disponibles
    from flask import request
    
    ip_address = None
    user_agent = None
    
    try:
        if request:
            ip_address = request.remote_addr
            user_agent = request.user_agent.string
    except RuntimeError:
        # Pas de contexte de requ√™te
        pass
    
    # Cr√©er les d√©tails
    details = None
    if donnees_supplementaires:
        if isinstance(donnees_supplementaires, dict):
            details_parts = []
            for key, value in donnees_supplementaires.items():
                # Formater les valeurs sp√©ciales
                if isinstance(value, list):
                    value = ', '.join(str(v) for v in value)
                elif isinstance(value, dict):
                    value = str(value)
                details_parts.append(f"{key}: {value}")
            details = "\n".join(details_parts)
        else:
            details = str(donnees_supplementaires)
    
    # Journaliser l'action avec 'details' (pas 'description')
    journal = JournalActivite(
        utilisateur_id=utilisateur_id,
        action=action,
        details=details,  # ‚úÖ CORRIG√â : utilise 'details'
        entite_type='risque',
        entite_id=risque_id,
        ip_address=ip_address,
        user_agent=user_agent
    )
    db.session.add(journal)
    
    # Synchroniser les matrices si n√©cessaire
    actions_sync = [
        'champ_personnalise_ajoute', 'champ_personnalise_modifie',
        'fichier_ajoute', 'fichier_supprime', 'evaluation_modifiee',
        'kri_associe', 'kri_modifie', 'risque_modifie'
    ]
    
    if action in actions_sync:
        synchroniser_matrices_apres_modification(risque.cartographie_id)
    
    db.session.commit()
    print(f"üìù Activit√© journalis√©e: {action} pour risque {risque_id}")

def synchroniser_matrices_apres_modification(cartographie_id):
    """Synchroniser les matrices apr√®s modification d'un risque"""
    try:
        # Import local pour √©viter les d√©pendances circulaires
        from utils import synchroniser_matrices_apres_evaluation
        synchroniser_matrices_apres_evaluation(cartographie_id)
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur synchronisation matrices: {e}")

def analyser_constatations_pour_recommandations(constatations):
    """Analyser les constatations pour g√©n√©rer des recommandations intelligentes"""
    if not constatations:
        return []
    
    recommandations = []
    statistiques = {
        'par_type': {},
        'par_gravite': {},
        'themes': set()
    }
    
    # Analyser les constatations
    for constatation in constatations:
        # Compter par type
        if constatation.type_constatation:
            statistiques['par_type'][constatation.type_constatation] = \
                statistiques['par_type'].get(constatation.type_constatation, 0) + 1
        
        # Compter par gravit√©
        if constatation.gravite:
            statistiques['par_gravite'][constatation.gravite] = \
                statistiques['par_gravite'].get(constatation.gravite, 0) + 1
        
        # Extraire les th√®mes des causes racines
        if constatation.cause_racine:
            mots_cles = ['formation', 'proc√©dure', 'documentation', 'contr√¥le', 
                        'surveillance', 'communication', 'ressource', '√©quipement']
            for mot in mots_cles:
                if mot in constatation.cause_racine.lower():
                    statistiques['themes'].add(mot)
    
    # G√©n√©rer des recommandations bas√©es sur l'analyse
    
    # 1. Recommandation bas√©e sur la gravit√©
    if 'critique' in statistiques['par_gravite'] and statistiques['par_gravite']['critique'] > 0:
        recommandations.append({
            'texte': f"Mettre en ≈ìuvre un plan d'action prioritaire pour traiter les {statistiques['par_gravite']['critique']} constatations critiques identifi√©es",
            'priorite': 5,
            'categorie': 'urgence',
            'raison': 'Pr√©sence de constatations critiques'
        })
    
    # 2. Recommandation bas√©e sur les types de constatations
    for type_const, nombre in statistiques['par_type'].items():
        if nombre >= 2:  # Si plusieurs constatations du m√™me type
            recommandations.append({
                'texte': f"Renforcer les contr√¥les concernant les {type_const.replace('_', ' ')} (identifi√©s dans {nombre} constatations)",
                'priorite': 4,
                'categorie': 'prevention',
                'raison': f'R√©currence des {type_const}'
            })
    
    # 3. Recommandations bas√©es sur les th√®mes
    if 'formation' in statistiques['themes']:
        recommandations.append({
            'texte': "Renforcer le programme de formation du personnel sur les proc√©dures identifi√©es comme probl√©matiques",
            'priorite': 4,
            'categorie': 'formation',
            'raison': 'Manque de formation identifi√© dans les causes racines'
        })
    
    if 'proc√©dure' in statistiques['themes'] or 'documentation' in statistiques['themes']:
        recommandations.append({
            'texte': "R√©viser et am√©liorer la documentation des proc√©dures pour une meilleure compr√©hension et application",
            'priorite': 3,
            'categorie': 'documentation',
            'raison': 'D√©ficience proc√©durale identifi√©e'
        })
    
    # 4. Recommandations g√©n√©rales bas√©es sur le volume
    total_constatations = len(constatations)
    if total_constatations >= 5:
        recommandations.append({
            'texte': "Mettre en place un tableau de bord de suivi des actions correctives avec des points de contr√¥le r√©guliers",
            'priorite': 4,
            'categorie': 'suivi',
            'raison': f'Volume important de constatations ({total_constatations})'
        })
    
    # 5. Recommandation de suivi syst√©matique
    recommandations.append({
        'texte': "Planifier un audit de suivi dans les 6 mois pour v√©rifier l'efficacit√© et la p√©rennit√© des actions correctives",
        'priorite': 5,
        'categorie': 'suivi',
        'raison': 'Audit complet r√©alis√©'
    })
    
    # Trier par priorit√©
    recommandations.sort(key=lambda x: x['priorite'], reverse=True)
    
    return recommandations[:5]  # Limiter √† 5 recommandations max

def analyser_tendances_audit(constatations, recommandations):
    """Analyser les tendances de l'audit pour la conclusion"""
    if not constatations:
        return {
            'points_forts': ["Aucune constatation identifi√©e"],
            'points_amelioration': ["Aucun point d'am√©lioration identifi√©"],
            'tendance_globale': 'satisfaisante'
        }
    
    points_forts = []
    points_amelioration = []
    
    # Analyser les constatations closes
    constatations_closes = [c for c in constatations if c.statut == 'clos']
    if constatations_closes:
        points_forts.append(f"{len(constatations_closes)} constatations d√©j√† closes")
    
    # Analyser les constatations de conformit√© (points positifs)
    constatations_conformite = [c for c in constatations if c.type_constatation == 'conformite']
    if constatations_conformite:
        points_forts.append(f"{len(constatations_conformite)} points de conformit√© identifi√©s")
    
    # Analyser les constatations critiques
    constatations_critiques = [c for c in constatations if c.gravite == 'critique']
    if constatations_critiques:
        points_amelioration.append(f"{len(constatations_critiques)} constatations critiques n√©cessitant une attention imm√©diate")
    
    # Analyser les recommandations termin√©es
    recommandations_terminees = [r for r in recommandations if r.statut == 'termine']
    if recommandations_terminees:
        points_forts.append(f"{len(recommandations_terminees)} recommandations d√©j√† mises en ≈ìuvre")
    
    # Analyser les recommandations en retard
    recommandations_en_retard = [r for r in recommandations if hasattr(r, 'est_en_retard') and r.est_en_retard]
    if recommandations_en_retard:
        points_amelioration.append(f"{len(recommandations_en_retard)} recommandations en retard de traitement")
    
    # D√©terminer la tendance globale
    ratio_amelioration = len(points_amelioration) / (len(points_forts) + len(points_amelioration)) if (points_forts or points_amelioration) else 0
    
    if ratio_amelioration > 0.7:
        tendance_globale = 'preoccupante'
    elif ratio_amelioration > 0.4:
        tendance_globale = 'mitigee'
    else:
        tendance_globale = 'satisfaisante'
    
    # Ajouter des points par d√©faut si liste vide
    if not points_forts:
        points_forts.append("Syst√®me d'audit fonctionnel")
    
    if not points_amelioration:
        points_amelioration.append("Maintenir la vigilance sur les processus audit√©s")
    
    return {
        'points_forts': points_forts[:5],  # Limiter √† 5 points
        'points_amelioration': points_amelioration[:5],
        'tendance_globale': tendance_globale
    }

def get_fichier_metadata(constatation_id, filename):
    """R√©cup√®re les m√©tadonn√©es d'un fichier"""
    try:
        from models import FichierMetadata
        metadata = FichierMetadata.query.filter_by(
            nom_fichier=filename,
            entite_type='constatation',
            entite_id=constatation_id
        ).first()
        
        if metadata:
            return {
                'commentaire': metadata.commentaire or '',
                'responsable': metadata.responsable.username if metadata.responsable else 'Non d√©fini',
                'date_upload': metadata.created_at.strftime('%d/%m/%Y') if metadata.created_at else '',
                'taille': f"{metadata.taille / 1024:.1f} KB" if metadata.taille else 'N/A'
            }
    except Exception as e:
        print(f"Erreur m√©tadonn√©es: {e}")
    
    return {
        'commentaire': '',
        'responsable': 'Non d√©fini',
        'date_upload': '',
        'taille': 'N/A'
    }

# ------------------------------------------------------------
# D√âCORATEUR ADMIN
# ------------------------------------------------------------
def veille_permission_required(f):
    """D√©corateur pour la veille r√®glementaire"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            flash('Veuillez vous connecter', 'error')
            return redirect(url_for('login'))
        
        if not current_user.has_permission('can_manage_regulatory'):
            flash('Acc√®s refus√© : permission veille r√®glementaire requise', 'error')
            return redirect(url_for('dashboard'))
        
        return f(*args, **kwargs)
    return decorated_function

def departments_permission_required(manage=False):
    """D√©corateur pour les directions/services"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not current_user.is_authenticated:
                flash('Veuillez vous connecter', 'error')
                return redirect(url_for('login'))
            
            required_permission = 'can_manage_departments' if manage else 'can_view_departments'
            if not current_user.has_permission(required_permission):
                flash(f'Acc√®s refus√© : permission {required_permission} requise', 'error')
                return redirect(url_for('dashboard'))
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator
# ========================
# D√âCORATEURS DE PERMISSIONS
# ========================

def super_admin_required(f):
    """D√©corateur pour le super admin (acc√®s universel)"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            return redirect(url_for('login', next=request.url))
        if current_user.role != 'super_admin':
            flash('Acc√®s refus√© : privil√®ges super administrateur requis', 'error')
            return redirect(url_for('dashboard'))
        return f(*args, **kwargs)
    return decorated_function

def check_super_admin_access():
    """V√©rifie si l'utilisateur courant est super admin"""
    return current_user.is_authenticated and current_user.role == 'super_admin'

@app.before_request
def check_permissions_middleware():
    """Middleware pour v√©rifier les permissions sur chaque requ√™te"""
    if current_user.is_authenticated:
        # Si c'est le super admin, BYPASS toutes les v√©rifications de permissions
        if current_user.role == 'super_admin':
            return  # Super admin passe partout sans v√©rification
        
        # Liste des endpoints prot√©g√©s et leurs permissions requises
        protected_endpoints = {
            'liste_cartographies': 'can_manage_risks',
            'nouvelle_cartographie': 'can_manage_risks',
            'liste_kri': 'can_manage_kri',
            'nouveau_kri': 'can_manage_kri',
            'liste_audits': 'can_manage_audit',
            'nouvel_audit': 'can_manage_audit',
            'veille_reglementaire': 'can_manage_regulatory',
            'liste_logigrammes': 'can_manage_logigram',
            'admin_dashboard': 'can_manage_users',
            'admin_utilisateurs': 'can_manage_users',
            'rapports': 'can_view_reports',
            'export_risques': 'can_export_data'
        }
        
        endpoint = request.endpoint
        
        # V√©rifier si l'endpoint n√©cessite une permission sp√©cifique
        if endpoint in protected_endpoints:
            required_permission = protected_endpoints[endpoint]
            if not current_user.has_permission(required_permission):
                flash('Acc√®s refus√© : permissions insuffisantes', 'error')
                return redirect(url_for('dashboard'))

# ========================
# FONCTION DE FILTRAGE DES DONN√âES
# ========================

def filter_by_client(query, model_class):
    """Ajoute un filtre client_id √† une requ√™te (sauf pour super admin)"""
    if current_user.role == 'super_admin':
        return query  # Super admin voit TOUT
    
    # Pour les admin clients et utilisateurs normaux
    if hasattr(model_class, 'client_id'):
        return query.filter(model_class.client_id == current_user.client_id)
    elif hasattr(model_class, 'created_by'):
        # R√©cup√©rer tous les utilisateurs du m√™me client
        utilisateurs_client = User.query.filter_by(
            client_id=current_user.client_id
        ).with_entities(User.id).all()
        user_ids = [u.id for u in utilisateurs_client]
        return query.filter(model_class.created_by.in_(user_ids))
    else:
        return query


def check_client_access(entite):
    """V√©rifie que l'utilisateur a acc√®s √† l'entit√©"""
    
    # SUPER ADMIN : ACC√àS UNIVERSEL
    if current_user.role == 'super_admin':
        return True
    
    # Si l'entit√© n'existe pas
    if not entite:
        return False
    
    # V√©rifier client_id direct
    if hasattr(entite, 'client_id') and entite.client_id:
        return entite.client_id == current_user.client_id
    
    # V√©rifier par created_by
    if hasattr(entite, 'created_by') and entite.created_by:
        createur = User.query.get(entite.created_by)
        if createur and hasattr(createur, 'client_id'):
            return createur.client_id == current_user.client_id
    
    # V√©rifier les relations
    if hasattr(entite, 'audit_id'):
        audit = Audit.query.get(entite.audit_id)
        return check_client_access(audit) if audit else False
    
    if hasattr(entite, 'risque_id'):
        risque = Risque.query.get(entite.risque_id)
        return check_client_access(risque) if risque else False
    
    if hasattr(entite, 'constatation_id'):
        constatation = Constatation.query.get(entite.constatation_id)
        return check_client_access(constatation) if constatation else False
    
    if hasattr(entite, 'cartographie_id'):
        cartographie = Cartographie.query.get(entite.cartographie_id)
        return check_client_access(cartographie) if cartographie else False
    
    # Pour les User, v√©rifier directement
    if isinstance(entite, User):
        return entite.client_id == current_user.client_id
    
    # Par d√©faut, refuser
    return False


# ========================
# CONFIGURATION DES PERMISSIONS
# ========================

def configurer_permissions_defaut():
    """Configure les permissions par d√©faut pour les templates"""
    if not MODELS_IMPORTED:
        return
    
    # R√©cup√©rer le client par d√©faut
    default_client = Client.query.filter_by(reference='default').first()
    if not default_client:
        print("‚ùå Client par d√©faut non trouv√©")
        return
    
    templates_defaut = [
        {
            'name': 'Super Administrateur',
            'description': 'Acc√®s complet √† toute la plateforme',
            'role': 'super_admin',
            'client_id': None,  # Super admin n'a pas de client sp√©cifique
            'permissions': {
                'can_view_dashboard': True,
                'can_manage_risks': True,
                'can_manage_kri': True,
                'can_manage_audit': True,
                'can_manage_regulatory': True,  # VEILLE
                'can_manage_logigram': True,
                'can_manage_users': True,
                'can_manage_settings': True,
                'can_export_data': True,
                'can_view_reports': True,
                'can_delete_data': True,
                'can_manage_permissions': True,
                'can_access_all_departments': True,
                'can_archive_data': True,
                'can_validate_risks': True,
                'can_confirm_evaluations': True,
                'can_view_departments': True,  # DIRECTION
                'can_manage_departments': True,  # DIRECTION
                'can_view_users_list': True,  # LISTE UTILISATEURS
                'can_edit_users': True,  # √âDITION UTILISATEURS
                'can_manage_clients': True,  # GESTION CLIENTS
                'can_provision_servers': True  # PROVISIONNING
            }
        },
        {
            'name': 'Administrateur Client',
            'description': 'Administration compl√®te pour un client',
            'role': 'admin',
            'client_id': default_client.id,
            'permissions': {
                'can_view_dashboard': True,
                'can_manage_risks': True,
                'can_manage_kri': True,
                'can_manage_audit': True,
                'can_manage_regulatory': True,  # VEILLE
                'can_manage_logigram': True,
                'can_manage_users': True,
                'can_manage_settings': True,
                'can_export_data': True,
                'can_view_reports': True,
                'can_delete_data': True,
                'can_manage_permissions': True,
                'can_access_all_departments': True,
                'can_archive_data': True,
                'can_validate_risks': True,
                'can_confirm_evaluations': True,
                'can_view_departments': True,  # DIRECTION
                'can_manage_departments': True,  # DIRECTION
                'can_view_users_list': True,  # LISTE UTILISATEURS
                'can_edit_users': True,  # √âDITION UTILISATEURS
                # Admin client NE PEUT PAS g√©rer les clients ou provisionner des serveurs
                'can_manage_clients': False,
                'can_provision_servers': False
            }
        },
        {
            'name': 'Manager',
            'description': 'Gestion des risques et audits',
            'role': 'manager',
            'client_id': default_client.id,
            'permissions': {
                'can_view_dashboard': True,
                'can_manage_risks': True,
                'can_manage_kri': True,
                'can_manage_audit': True,
                'can_manage_regulatory': False,  # VEILLE
                'can_manage_logigram': False,
                'can_manage_users': False,
                'can_manage_settings': False,
                'can_export_data': True,
                'can_view_reports': True,
                'can_delete_data': False,
                'can_manage_permissions': False,
                'can_access_all_departments': False,
                'can_archive_data': False,
                'can_validate_risks': True,
                'can_confirm_evaluations': False,
                'can_view_departments': True,  # DIRECTION
                'can_manage_departments': False,  # DIRECTION
                'can_view_users_list': False,  # LISTE UTILISATEURS
                'can_edit_users': False,  # √âDITION UTILISATEURS
            }
        },
        {
            'name': 'Auditeur',
            'description': 'Cr√©ation et suivi des audits',
            'role': 'auditeur',
            'client_id': default_client.id,
            'permissions': {
                'can_view_dashboard': True,
                'can_manage_risks': False,
                'can_manage_kri': False,
                'can_manage_audit': True,
                'can_manage_regulatory': False,  # VEILLE
                'can_manage_logigram': False,
                'can_manage_users': False,
                'can_manage_settings': False,
                'can_export_data': False,
                'can_view_reports': True,
                'can_delete_data': False,
                'can_manage_permissions': False,
                'can_access_all_departments': False,
                'can_archive_data': False,
                'can_validate_risks': False,
                'can_confirm_evaluations': False,
                'can_view_departments': True,  # DIRECTION
                'can_manage_departments': False,  # DIRECTION
                'can_view_users_list': False,  # LISTE UTILISATEURS
                'can_edit_users': False,  # √âDITION UTILISATEURS
            }
        },
        {
            'name': 'Utilisateur Standard',
            'description': 'Acc√®s consultation',
            'role': 'utilisateur',
            'client_id': default_client.id,
            'permissions': {
                'can_view_dashboard': True,
                'can_manage_risks': False,
                'can_manage_kri': False,
                'can_manage_audit': False,
                'can_manage_regulatory': False,  # VEILLE
                'can_manage_logigram': False,
                'can_manage_users': False,
                'can_manage_settings': False,
                'can_export_data': False,
                'can_view_reports': True,
                'can_delete_data': False,
                'can_manage_permissions': False,
                'can_access_all_departments': False,
                'can_archive_data': False,
                'can_validate_risks': False,
                'can_confirm_evaluations': False,
                'can_view_departments': True,  # DIRECTION
                'can_manage_departments': False,  # DIRECTION
                'can_view_users_list': False,  # LISTE UTILISATEURS
                'can_edit_users': False,  # √âDITION UTILISATEURS
            }
        }
    ]
    
    for template_data in templates_defaut:
        existing = PermissionTemplate.query.filter_by(
            name=template_data['name'],
            client_id=template_data['client_id']
        ).first()
        
        if not existing:
            template = PermissionTemplate(
                name=template_data['name'],
                description=template_data['description'],
                role=template_data['role'],
                client_id=template_data['client_id'],
                permissions=template_data['permissions']
            )
            db.session.add(template)
    
    try:
        db.session.commit()
        print("‚úÖ Templates de permissions configur√©s")
    except Exception as e:
        db.session.rollback()
        print(f"‚ö†Ô∏è Erreur configuration permissions: {e}")

# ========================
# D√âCORATEUR MULTI-TENANT
# ========================

def tenant_filtered_query(model_class, **filters):
    """Retourne une requ√™te filtr√©e automatiquement par client"""
    query = model_class.query.filter_by(**filters)
    
    # SUPER ADMIN : PAS DE FILTRE
    if current_user.is_authenticated and current_user.role == 'super_admin':
        return query
    
    # USER NON CONNECT√â
    if not current_user.is_authenticated:
        return query.filter(False)  # Aucun r√©sultat
    
    # USER CONNECT√â AVEC CLIENT_ID
    client_id = current_user.client_id
    
    # MOD√àLES AVEC CLIENT_ID DIRECT
    if hasattr(model_class, 'client_id'):
        return query.filter(model_class.client_id == client_id)
    
    # MOD√àLES AVEC CREATED_BY
    if hasattr(model_class, 'created_by'):
        # R√©cup√©rer les utilisateurs du m√™me client
        user_ids = db.session.query(User.id).filter_by(client_id=client_id).all()
        user_ids = [uid[0] for uid in user_ids] if user_ids else [-1]
        return query.filter(model_class.created_by.in_(user_ids))
    
    # MOD√àLES SP√âCIFIQUES (relations indirectes)
    if model_class == PermissionTemplate:
        # Les templates de permissions peuvent √™tre globaux (client_id=None) ou sp√©cifiques
        return query.filter(
            db.or_(
                PermissionTemplate.client_id == client_id,
                PermissionTemplate.client_id == None
            )
        )
    
    # PAR D√âFAUT : retourner une requ√™te vide
    return query.filter(False)

@app.context_processor
def inject_tenant_filter():
    """Injecte la fonction de filtrage dans tous les templates"""
    return dict(tenant_filtered_query=tenant_filtered_query)

# ========================
# MIDDLEWARE DE FILTRAGE
# ========================

@app.before_request
def auto_filter_data():
    """Filtre automatiquement les donn√©es par client"""
    # Ne pas filtrer pour super admin
    if current_user.is_authenticated and current_user.role == 'super_admin':
        g.client_id = None  # Super admin voit tout
        return
    
    # Pour les autres utilisateurs
    if current_user.is_authenticated:
        g.client_id = current_user.client_id



# ========================
# PATCH TEMPORAIRE POUR MULTI-TENANT
# ========================

# D√©sactiver temporairement la configuration automatique
def skip_permission_setup():
    print("‚è∏Ô∏è  Configuration permissions temporairement d√©sactiv√©e")
    return

# Remplacer la fonction probl√©matique
configurer_permissions_defaut = skip_permission_setup


# ========================
# FILTRE AUTOMATIQUE MULTI-TENANT (NO-CONFIG)
# ========================






# ------------------------------------------------------------
# FONCTION DE JOURNALISATION
# ------------------------------------------------------------

def log_activity(utilisateur_id, action, details=None, entite_type=None, entite_id=None):
    """
    Journalise une activit√© utilisateur
    
    Args:
        utilisateur_id: ID de l'utilisateur
        action: Type d'action ('connexion', 'creation', 'modification', 'suppression', 'consultation')
        details: Description d√©taill√©e de l'action (param√®tre renomm√© de 'description' √† 'details')
        entite_type: Type d'entit√© concern√©e ('risque', 'audit', 'kri', 'utilisateur', etc.)
        entite_id: ID de l'entit√© concern√©e
    """
    try:
        # R√©cup√©rer l'adresse IP
        if request:
            if request.headers.get('X-Forwarded-For'):
                ip_address = request.headers.get('X-Forwarded-For').split(',')[0].strip()
            else:
                ip_address = request.remote_addr
        else:
            ip_address = socket.gethostbyname(socket.gethostname())
        
        # R√©cup√©rer l'user agent
        user_agent = request.user_agent.string if request else 'Syst√®me'
        
        # Cr√©er l'entr√©e dans le journal
        journal = JournalActivite(
            utilisateur_id=utilisateur_id,
            action=action,
            details=details,  # CORRECTION : Utiliser 'details' au lieu de 'description'
            entite_type=entite_type,
            entite_id=entite_id,
            ip_address=ip_address,
            user_agent=user_agent
        )
        
        db.session.add(journal)
        db.session.commit()
        
        print(f"üìù Activit√© journalis√©e: {action} - {details}")
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur journalisation: {e}")


# ------------------------------------------------------------
# ROUTE POUR VOIR LE JOURNAL D'ACTIVIT√â
# ------------------------------------------------------------
def get_filtered_query(model_class, **filters):
    """Version finale avec tous les modes de vue"""
    query = model_class.query
    
    # 1. Vue d'un autre client (super admin seulement)
    if 'viewing_client_id' in session:
        client_id = session['viewing_client_id']
        
        if hasattr(model_class, 'client_id'):
            return query.filter(model_class.client_id == client_id, **filters)
        elif hasattr(model_class, 'created_by'):
            user_ids = [u[0] for u in db.session.query(User.id).filter_by(client_id=client_id).all()]
            return query.filter(model_class.created_by.in_(user_ids), **filters)
        return query.filter_by(**filters)
    
    # 2. Votre propre client_id
    your_client_id = current_user.client_id
    
    if not your_client_id:
        return query.filter(False)
    
    # 3. Mode "Mes donn√©es seulement"
    if session.get('view_mode') == 'my_data_only':
        if hasattr(model_class, 'created_by'):
            return query.filter(
                model_class.created_by == current_user.id,
                **filters
            )
    
    # 4. Mode "Mon client" (par d√©faut)
    if hasattr(model_class, 'client_id'):
        return query.filter(model_class.client_id == your_client_id, **filters)
    
    return query.filter_by(**filters)

def get_multi_tenant_filter(model_class, **filters):
    """Fonction de filtrage multi-tenant CORRIG√âE pour super admin"""
    query = model_class.query
    
    print(f"üîç DEBUG Filtre pour {model_class.__name__}:")
    print(f"   User: {current_user.username} (role: {current_user.role})")
    print(f"   Client ID: {current_user.client_id}")
    print(f"   View mode: {session.get('view_mode')}")
    print(f"   Viewing client: {session.get('viewing_client_id')}")

    # ===== SUPER ADMIN ‚Äì Diff√©rents modes =====
    if current_user.role == 'super_admin':
        # Mode 1: "Mes donn√©es seulement" ‚Üí filtrer par created_by
        if session.get('view_mode') == 'my_data_only':
            print(f"   MODE: Mes donn√©es seulement (filtrer par created_by)")
            if hasattr(model_class, 'created_by'):
                print(f"   ‚û° Filtre: created_by == {current_user.id}")
                return query.filter(model_class.created_by == current_user.id).filter_by(**filters)
            elif hasattr(model_class, 'client_id'):
                # Pour les mod√®les avec client_id, v√©rifier si cr√©√© par super admin
                print(f"   ‚û° Filtre: client_id cr√©√© par super admin")
                # R√©cup√©rer tous les clients cr√©√©s par ce super admin
                clients_crees = Client.query.filter_by(created_by=current_user.id).with_entities(Client.id).all()
                client_ids = [c[0] for c in clients_crees] if clients_crees else [-1]
                return query.filter(model_class.client_id.in_(client_ids)).filter_by(**filters)
            else:
                print(f"   ‚û° Pas de filtre possible, retourne tout")
                return query.filter_by(**filters)
        
        # Mode 2: Visualiser un client sp√©cifique
        elif 'viewing_client_id' in session:
            client_id = session['viewing_client_id']
            print(f"   MODE: Visualisation client {client_id}")
            
            if hasattr(model_class, 'client_id'):
                print(f"   ‚û° Filtre: client_id == {client_id}")
                return query.filter(model_class.client_id == client_id).filter_by(**filters)
            elif hasattr(model_class, 'created_by'):
                # R√©cup√©rer les utilisateurs de ce client
                user_ids = db.session.query(User.id).filter_by(client_id=client_id).all()
                user_ids = [u[0] for u in user_ids] if user_ids else [-1]
                print(f"   ‚û° Filtre: created_by IN {user_ids}")
                return query.filter(model_class.created_by.in_(user_ids)).filter_by(**filters)
            else:
                print(f"   ‚û° Pas de relation client, retourne tout")
                return query.filter_by(**filters)
        
        # Mode 3: Vue globale (par d√©faut) ‚Üí tout voir
        else:
            print(f"   MODE: Vue globale (tout voir)")
            return query.filter_by(**filters)

    # ===== UTILISATEUR NORMAL =====
    your_client_id = current_user.client_id
    if not your_client_id:
        print(f"   ‚ùå User sans client_id, retourne vide")
        return query.filter(False)

    # Mode "Mes donn√©es seulement"
    if session.get('view_mode') == 'my_data_only' and hasattr(model_class, 'created_by'):
        print(f"   MODE: Mes donn√©es seulement (normal user)")
        return query.filter(model_class.created_by == current_user.id).filter_by(**filters)

    # Mode normal : tout son client
    if hasattr(model_class, 'client_id'):
        print(f"   MODE: Tout mon client (client_id: {your_client_id})")
        return query.filter(model_class.client_id == your_client_id).filter_by(**filters)
    elif hasattr(model_class, 'created_by'):
        user_ids = db.session.query(User.id).filter_by(client_id=your_client_id).all()
        user_ids = [u[0] for u in user_ids] if user_ids else [-1]
        print(f"   MODE: Tout mon client (created_by IN {user_ids})")
        return query.filter(model_class.created_by.in_(user_ids)).filter_by(**filters)

    print(f"   ‚ö†Ô∏è  Pas de filtre applicable, retourne vide")
    return query.filter(False)

@app.route('/super-admin/view-my-own-data')
@login_required
@super_admin_required
def super_admin_view_my_own_data():
    """Super admin : voir uniquement ses propres donn√©es"""
    # Activer le mode "mes donn√©es seulement"
    session['view_mode'] = 'my_data_only'
    
    # D√©s√©lectionner tout client de vue
    session.pop('viewing_client_id', None)
    session.pop('viewing_client_name', None)
    
    flash('üîí Mode activ√© : Vue de vos donn√©es personnelles uniquement', 'info')
    return redirect(url_for('super_admin_control_panel'))

def translate(text, lang=None):
    """Traduit un texte selon la langue - VERSION DEBUG"""
    print(f"üîç translate() appel√© avec: text='{text}', lang={lang}")
    
    if not text:
        return ''
    
    # D√©terminer la langue
    target_lang = lang or get_locale()
    print(f"   Langue cible: {target_lang}")
    
    # Si fran√ßais, retourner tel quel
    if target_lang == 'fr':
        print(f"   ‚Üí Retour FR: {text}")
        return text
    
    # Chercher la traduction
    if text in translations['en']:
        result = translations['en'][text]
        print(f"   ‚Üí Traduction trouv√©e: {result}")
        return result
    else:
        print(f"   ‚ö†Ô∏è  Traduction NON TROUV√âE pour: {text}")
        print(f"   Cl√©s disponibles: {list(translations['en'].keys())[:5]}...")
        return text  # Fallback

# √Ä GARDER - La nouvelle API unifi√©e (vers la ligne 4853) :
@app.route('/api/translations')
def api_translations():
    """Retourne toutes les traductions pour JavaScript"""
    return jsonify({
        'success': True,
        'count': len(translation_system.translations),
        'translations': dict(translation_system.translations),
        'current_lang': getattr(g, 'current_lang', 'fr')
    })

@app.route('/super-admin/debug-filter')
@login_required
@super_admin_required
def super_admin_debug_filter():
    """Debug : voir ce que le filtre retourne"""
    
    # Test avec diff√©rents mod√®les
    tests = {
        'risques': {
            'total': Risque.query.count(),
            'filtered': get_multi_tenant_filter(Risque).count(),
            'sample': get_multi_tenant_filter(Risque).limit(5).all()
        },
        'audits': {
            'total': Audit.query.count(),
            'filtered': get_multi_tenant_filter(Audit).count()
        },
        'clients': {
            'total': Client.query.count(),
            'filtered': get_multi_tenant_filter(Client).count()
        },
        'formules': {
            'total': FormuleAbonnement.query.count(),
            'filtered': get_multi_tenant_filter(FormuleAbonnement).count()
        }
    }
    
    return render_template('super_admin/debug_filter.html',
                         tests=tests,
                         current_user=current_user,
                         session=session)

@app.route('/super-admin/fix-data-filter')
@login_required
@super_admin_required
def super_admin_fix_data_filter():
    """Corriger imm√©diatement le filtrage des donn√©es"""
    
    # R√©initialiser toutes les pr√©f√©rences
    session.pop('viewing_client_id', None)
    session.pop('viewing_client_name', None)
    session.pop('view_mode', None)
    
    # Mettre en mode "mes donn√©es seulement"
    session['view_mode'] = 'my_data_only'
    
    flash('‚úÖ Filtre corrig√© : vous voyez maintenant uniquement vos donn√©es', 'success')
    return redirect(url_for('super_admin_control_panel'))


# Ajoutez cette route √† votre app.py
@app.route('/fix-permissions')
@login_required
@super_admin_required
def fix_permissions():
    """Script pour corriger les permissions de tous les utilisateurs"""
    try:
        users = User.query.all()
        fixed_count = 0
        
        for user in users:
            # Pour les admin client
            if user.role == 'admin' or user.is_client_admin:
                # S'assurer qu'ils ont les permissions de base
                base_permissions = [
                    'can_view_dashboard',
                    'can_view_reports',
                    'can_view_departments',
                    'can_view_users_list',
                    'can_edit_users',
                    'can_manage_users',
                    'can_manage_settings'
                ]
                
                for perm in base_permissions:
                    if perm not in user.permissions:
                        user.permissions[perm] = True
                        fixed_count += 1
                
                # Retirer les permissions syst√®me
                if 'can_manage_clients' in user.permissions:
                    user.permissions['can_manage_clients'] = False
                    fixed_count += 1
                if 'can_provision_servers' in user.permissions:
                    user.permissions['can_provision_servers'] = False
                    fixed_count += 1
            
            # Pour les utilisateurs normaux
            elif user.role == 'utilisateur':
                user.permissions.update({
                    'can_view_dashboard': True,
                    'can_view_reports': True,
                    'can_view_departments': True,
                    'can_view_users_list': False,
                    'can_edit_users': False
                })

                fixed_count += 5
        
        db.session.commit()
        flash(f'‚úÖ {fixed_count} permissions corrig√©es pour {len(users)} utilisateurs', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
    
    return redirect(url_for('admin_utilisateurs'))
# ========================
# ROUTES POUR LE SYST√àME DE VUE MULTI-TENANT
# ========================

@app.route('/view_all_clients')
@login_required
def view_all_clients():
    """Permet au super admin de revenir √† la vue globale (tous les clients)"""
    if current_user.role != 'super_admin':
        flash('Acc√®s refus√© : privil√®ges super administrateur requis.', 'error')
        return redirect(url_for('dashboard'))
    
    # Nettoyer la session pour revenir √† la vue globale
    session.pop('viewing_client_id', None)
    session.pop('view_mode', None)
    
    flash("Vous visualisez maintenant tous les clients (vue super admin).", 'success')
    return redirect(request.referrer or url_for('dashboard'))

@app.route('/switch_client/<int:client_id>')
@login_required
def switch_client(client_id):
    """Permet au super admin de visualiser un client sp√©cifique"""
    if current_user.role != 'super_admin':
        flash('Acc√®s refus√© : privil√®ges super administrateur requis.', 'error')
        return redirect(url_for('dashboard'))
    
    client = Client.query.get_or_404(client_id)
    
    # Stocker l'ID du client √† visualiser dans la session
    session['viewing_client_id'] = client_id
    # R√©initialiser le mode "mes donn√©es seulement"
    session['view_mode'] = None
    
    # Mettre √©galement dans `g` pour l'utiliser dans le middleware
    g.viewing_client_id = client_id
    
    flash(f"Vous visualisez maintenant le client : {client.nom}", 'success')
    
    # Rediriger vers la page pr√©c√©dente ou le tableau de bord
    return redirect(request.referrer or url_for('dashboard'))

@app.route('/switch-back')
@login_required
def switch_back():
    """Revenir √† la vue normale (votre propre client)"""
    if 'viewing_client_id' in session:
        client_name = session.get('viewing_client_name', 'inconnu')
        session.pop('viewing_client_id', None)
        session.pop('viewing_client_name', None)
        session.pop('viewing_client_reference', None)
        flash(f'üîô Retour √† votre vue personnelle (client: {client_name} d√©s√©lectionn√©)', 'info')
    else:
        flash('üîô Vous √™tes d√©j√† dans votre vue personnelle', 'info')
    
    return redirect(request.referrer or url_for('dashboard'))

@app.route('/view-my-data-only')
@login_required
def view_my_data_only():
    """Voir uniquement vos propres donn√©es cr√©√©es (isolation stricte)"""
    # D√©s√©lectionner tout client de vue
    session.pop('viewing_client_id', None)
    session.pop('viewing_client_name', None)
    session.pop('viewing_client_reference', None)
    
    # Activer le mode "mes donn√©es seulement"
    session['view_mode'] = 'my_data_only'
    
    flash('üîí Mode: Vue de vos donn√©es personnelles uniquement', 'info')
    return redirect(request.referrer or url_for('dashboard'))

@app.route('/view-my-client')
@login_required
def view_my_client():
    """Voir toutes les donn√©es de votre client (mode normal)"""
    # D√©s√©lectionner tout client de vue
    session.pop('viewing_client_id', None)
    session.pop('viewing_client_name', None)
    session.pop('viewing_client_reference', None)
    
    # Activer le mode "mon client"
    session['view_mode'] = 'my_client'
    
    if current_user.role == 'super_admin' and hasattr(current_user, 'client_id'):
        my_client = Client.query.get(current_user.client_id)
        if my_client:
            flash(f'üè¢ Mode: Vue de votre client ({my_client.nom})', 'info')
    else:
        flash('üè¢ Mode: Vue de votre client', 'info')
    
    return redirect(request.referrer or url_for('dashboard'))

@app.route('/view-reset')
@login_required
def view_reset():
    """R√©initialiser toutes les pr√©f√©rences de vue"""
    # Supprimer toutes les pr√©f√©rences de session
    session.pop('viewing_client_id', None)
    session.pop('viewing_client_name', None)
    session.pop('viewing_client_reference', None)
    session.pop('view_mode', None)
    
    flash('üîÑ Vue r√©initialis√©e aux param√®tres par d√©faut', 'info')
    return redirect(url_for('dashboard'))

@app.route('/super-admin/control-panel')
@login_required
@super_admin_required
def super_admin_control_panel():
    """Panel de contr√¥le pour choisir quel client voir"""
    clients = Client.query.order_by(Client.nom).all()
    
    # Statistiques pour chaque client
    stats = {}
    for client in clients:
        stats[client.id] = {
            'users': User.query.filter_by(client_id=client.id).count(),
            'risques': Risque.query.filter_by(client_id=client.id, is_archived=False).count(),
            'audits': Audit.query.filter_by(client_id=client.id, is_archived=False).count(),
            'cartographies': Cartographie.query.filter_by(client_id=client.id, is_archived=False).count(),
        }
    
    # Client actuellement visualis√©
    viewing_client_id = session.get('viewing_client_id')
    viewing_client = Client.query.get(viewing_client_id) if viewing_client_id else None
    
    # Mode de vue actuel
    view_mode = session.get('view_mode', 'my_client')
    
    return render_template('super_admin/control_panel.html',
                         clients=clients,
                         stats=stats,
                         viewing_client=viewing_client,
                         view_mode=view_mode,
                         current_user=current_user)

@app.context_processor
def inject_view_info():
    """Injecte les informations de vue dans tous les templates"""
    viewing_client = None
    view_mode = session.get('view_mode', 'my_client')
    
    if 'viewing_client_id' in session:
        viewing_client = Client.query.get(session['viewing_client_id'])
    
    # D√©terminer le texte √† afficher
    view_text = "Mon client"
    view_icon = "fas fa-building"
    view_class = "is-info"
    
    if viewing_client:
        view_text = f"Vue: {viewing_client.reference}"
        view_icon = "fas fa-eye"
        view_class = "is-success"
    elif view_mode == 'my_data_only':
        view_text = "Mes donn√©es"
        view_icon = "fas fa-user"
        view_class = "is-warning"
    
    return {
        'viewing_client': viewing_client,
        'view_mode': view_mode,
        'view_text': view_text,
        'view_icon': view_icon,
        'view_class': view_class,
        'is_viewing_other_client': viewing_client is not None
    }


@app.after_request
def restore_original_client(response):
    """Restaurer le client_id original apr√®s la requ√™te"""
    if hasattr(g, 'original_client_id'):
        current_user.client_id = g.original_client_id
    return response

# ========================
# ROUTES POUR GESTION UTILISATEURS CLIENT
# ========================

@app.route('/admin/utilisateur/<int:id>/toggle', methods=['POST'])
@login_required
def api_toggle_user_status(id):
    """Activer/d√©sactiver un utilisateur"""
    if not (current_user.is_client_admin or current_user.role == 'admin'):
        return jsonify({'error': 'Acc√®s non autoris√©'}), 403
    
    user = User.query.get_or_404(id)
    
    # V√©rifier que l'utilisateur appartient au m√™me client
    if user.client_id != current_user.client_id:
        return jsonify({'error': 'Acc√®s non autoris√©'}), 403
    
    # Ne pas pouvoir modifier soi-m√™me
    if user.id == current_user.id:
        return jsonify({'error': 'Vous ne pouvez pas modifier votre propre statut'}), 400
    
    try:
        user.is_active = not user.is_active
        new_status = 'activ√©' if user.is_active else 'd√©sactiv√©'
        
        db.session.commit()
        
        # Journaliser
        log_activity(current_user.id, 'toggle_user_status',
                    f"Utilisateur {user.username} {new_status}",
                    'user', user.id)
        
        return jsonify({
            'success': True,
            'message': f'Utilisateur {user.username} {new_status}',
            'is_active': user.is_active
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/client-admin/utilisateur/<int:id>/toggle', methods=['POST'])
@login_required
def client_api_toggle_user_status(id):
    """Activer/d√©sactiver un utilisateur - version admin client"""
    
    # V√©rifier que c'est un admin client
    if not current_user.is_client_admin:
        return jsonify({'error': 'Acc√®s r√©serv√© aux administrateurs client'}), 403
    
    user = User.query.get_or_404(id)
    client = current_user.client
    
    # V√©rifications
    if not client:
        return jsonify({'error': 'Aucun client associ√© √† votre compte'}), 400
    
    # V√©rifier que l'utilisateur appartient au m√™me client
    if user.client_id != client.id:
        return jsonify({'error': 'Acc√®s non autoris√© √† cet utilisateur'}), 403
    
    # Ne pas pouvoir modifier soi-m√™me
    if user.id == current_user.id:
        return jsonify({'error': 'Vous ne pouvez pas modifier votre propre statut'}), 400
    
    # Emp√™cher de modifier un autre admin client
    if user.is_client_admin and user.id != current_user.id:
        return jsonify({'error': 'Vous ne pouvez pas modifier un autre administrateur client'}), 403
    
    try:
        user.is_active = not user.is_active
        new_status = 'activ√©' if user.is_active else 'd√©sactiv√©'
        
        db.session.commit()
        
        # Journaliser l'action - CORRIG√â : import direct
        journal = JournalActiviteClient(
            client_id=client.id,
            utilisateur_id=current_user.id,
            action='toggle_user_status',
            details={
                'user_id': user.id,
                'username': user.username,
                'nouveau_statut': 'actif' if user.is_active else 'inactif',
                'action_par': current_user.username
            }
        )
        db.session.add(journal)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Utilisateur {user.username} {new_status}',
            'is_active': user.is_active
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/client-admin/utilisateur/<int:id>/supprimer', methods=['POST'])
@login_required
def client_api_delete_user(id):
    """Supprimer un utilisateur - version admin client"""
    
    try:
        print(f"üîç D√©but suppression utilisateur {id}")
        
        # V√©rifier que c'est un admin client
        if not current_user.is_client_admin:
            print("‚ùå Pas admin client")
            return jsonify({'error': 'Acc√®s r√©serv√© aux administrateurs client'}), 403
        
        user = User.query.get_or_404(id)
        client = current_user.client
        
        # V√©rifications
        if not client:
            print("‚ùå Pas de client associ√©")
            return jsonify({'error': 'Aucun client associ√© √† votre compte'}), 400
        
        # V√©rifier que l'utilisateur appartient au m√™me client
        if user.client_id != client.id:
            print(f"‚ùå Mauvais client: user.client_id={user.client_id}, current={client.id}")
            return jsonify({'error': 'Acc√®s non autoris√© √† cet utilisateur'}), 403
        
        # Ne pas pouvoir se supprimer soi-m√™me
        if user.id == current_user.id:
            return jsonify({'error': 'Vous ne pouvez pas vous supprimer vous-m√™me'}), 400
        
        # Emp√™cher de supprimer un autre admin client
        if user.is_client_admin:
            return jsonify({'error': 'Vous ne pouvez pas supprimer un autre administrateur client'}), 403
        
        print(f"‚úÖ V√©rifications OK, suppression de {user.username}")
        
        # Utiliser la fonction de suppression s√©curis√©e
        result = delete_user_safely(id, current_user.id)
        
        if result['success']:
            # Journaliser
            try:
                journal = JournalActiviteClient(
                    client_id=client.id,
                    utilisateur_id=current_user.id,
                    action='suppression_utilisateur',
                    details={
                        'user_id': user.id,
                        'username': user.username,
                        'supprime_par': current_user.username
                    }
                )
                db.session.add(journal)
                db.session.commit()
                print("‚úÖ Journal cr√©√©")
            except Exception as journal_error:
                print(f"‚ö†Ô∏è Erreur journal: {journal_error}")
            
            print(f"‚úÖ Utilisateur {user.username} supprim√© avec succ√®s")
            
            return jsonify({
                'success': True,
                'message': f'Utilisateur {user.username} supprim√© avec succ√®s',
                'dependencies': result.get('dependencies', [])
            })
        else:
            return jsonify({'error': result['error']}), 500
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur suppression: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'Erreur serveur: {str(e)}'}), 500

def refresh_sqlalchemy_cache():
    """Force la r√©initialisation du cache SQLAlchemy pour d√©tecter les nouvelles colonnes"""
    print("üîÑ R√©initialisation du cache SQLAlchemy...")
    
    try:
        # 1. Fermer toutes les sessions
        db.session.close_all()
        
        # 2. R√©initialiser les m√©tadonn√©es
        db.metadata.clear()
        db.metadata.reflect(bind=db.engine)
        
        # 3. R√©initialiser le mapper pour chaque mod√®le probl√©matique
        from sqlalchemy.orm import class_mapper
        
        models_to_refresh = [
            ZoneRisqueProcessus,
            Alerte,
            ZoneRisqueOrganigramme,
            PointDecision,
            ElementLogigramme,
            LienLogigramme,
            ProcessusActivite,
            GuideEvaluation
        ]
        
        for model in models_to_refresh:
            try:
                mapper = class_mapper(model)
                mapper._configure_all()
                print(f"‚úÖ Cache r√©initialis√© pour {model.__name__}")
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur pour {model.__name__}: {e}")
        
        print("‚úÖ Cache SQLAlchemy r√©initialis√©")
        
    except Exception as e:
        print(f"‚ùå Erreur r√©initialisation cache: {e}")
        import traceback
        traceback.print_exc()

app.route('/admin/utilisateur/<int:id>/supprimer', methods=['POST'])
@login_required
def api_delete_user(id):
    """Supprimer un utilisateur"""
    if not current_user.is_client_admin:
        return jsonify({'error': 'Acc√®s r√©serv√© aux administrateurs client'}), 403
    
    user = User.query.get_or_404(id)
    
    # V√©rifier que l'utilisateur appartient au m√™me client
    if user.client_id != current_user.client_id:
        return jsonify({'error': 'Acc√®s non autoris√©'}), 403
    
    # Ne pas pouvoir se supprimer soi-m√™me
    if user.id == current_user.id:
        return jsonify({'error': 'Vous ne pouvez pas vous supprimer vous-m√™me'}), 400
    
    try:
        username = user.username
        
        # Journaliser avant suppression
        log_activity(current_user.id, 'delete_user',
                    f"Suppression utilisateur {username}",
                    'user', user.id)
        
        # Supprimer l'utilisateur
        db.session.delete(user)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Utilisateur {username} supprim√© avec succ√®s'
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500



@app.route('/api/client/environment/<int:env_id>/maintenance', methods=['POST'])
@login_required
@super_admin_required
def api_maintenance_environment(env_id):
    """Mettre un environnement en maintenance"""
    env = EnvironnementClient.query.get_or_404(env_id)
    
    try:
        new_status = 'en_maintenance' if env.statut != 'en_maintenance' else 'actif'
        old_status = env.statut
        env.statut = new_status
        
        if new_status == 'en_maintenance':
            env.date_maintenance = datetime.utcnow()
        
        db.session.commit()
        
        # Journaliser
        journal = JournalActiviteClient(
            client_id=env.client_id,
            utilisateur_id=current_user.id,
            action='environment_maintenance',
            details={
                'env_id': env.id,
                'env_name': env.nom,
                'old_status': old_status,
                'new_status': new_status,
                'by': current_user.username
            }
        )
        db.session.add(journal)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'new_status': new_status,
            'message': f'Environnement {env.nom} pass√© en {new_status}'
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

# Dans app.py, apr√®s les imports et la cr√©ation de l'app

# ==================== MIDDLEWARE SOUS-DOMAIN ====================

@app.before_request
def detect_client_subdomain():
    """D√©tecte le sous-domaine et route vers le client correspondant"""
    host = request.host
    
    # En d√©veloppement : utiliser localhost avec param√®tre client
    if 'localhost' in host or '127.0.0.1' in host:
        # Vous pouvez g√©rer les sous-domaines locaux aussi
        # Ex: client1.localhost:5000
        if 'localhost' in host and ':' in host:
            # Extraire la partie avant .localhost
            parts = host.split(':')[0].split('.')
            if len(parts) > 1 and parts[0] not in ['www', 'api', 'admin']:
                subdomain = parts[0]
                # Trouver le client par r√©f√©rence (pas par sous-domaine en dev)
                client = Client.query.filter_by(reference=subdomain).first()
                if client:
                    g.client_id = client.id
                    g.client_subdomain = subdomain
    
    # En production, extraire le sous-domaine
    elif 'votresociete.com' in host:  # Remplacez par votre vrai domaine
        subdomain = host.replace('.votresociete.com', '')
        
        # Si c'est un sous-domaine client (pas www, pas api)
        if subdomain and subdomain not in ['www', 'api', 'admin']:
            # Trouver le client par sous-domaine
            client = Client.query.filter_by(sous_domaine=f"{subdomain}.votresociete.com").first()
            if client:
                g.client_id = client.id
                g.client_subdomain = subdomain
                
                # Si l'utilisateur n'est pas connect√©, rediriger vers login client
                if not current_user.is_authenticated and request.endpoint not in ['client_login_page', 'static']:
                    return redirect(url_for('client_login_page', client_reference=client.reference))

@app.route('/client-login', methods=['GET', 'POST'])
def client_login_subdomain():
    """Login automatique par sous-domaine"""
    if hasattr(g, 'client_subdomain'):
        # Chercher le client par sous-domaine en production ou r√©f√©rence en dev
        if 'votresociete.com' in request.host:
            client = Client.query.filter(
                Client.sous_domaine.like(f"%{g.client_subdomain}%")
            ).first()
        else:
            # En d√©veloppement, chercher par r√©f√©rence
            client = Client.query.filter_by(reference=g.client_subdomain).first()
        
        if client:
            # Rediriger vers la page de login sp√©cifique
            return redirect(url_for('client_login_page', client_reference=client.reference))
    
    return redirect(url_for('public_home'))

@app.route('/api/client/<int:client_id>/regenerate-api-keys', methods=['POST'])
@login_required
@super_admin_required
def api_regenerate_client_api_keys(client_id):
    """R√©g√©n√©rer les cl√©s API d'un client"""
    client = Client.query.get_or_404(client_id)
    
    try:
        old_api_key = client.api_key
        client.generer_identifiants_api()
        
        db.session.commit()
        
        # Journaliser
        journal = JournalActiviteClient(
            client_id=client_id,
            utilisateur_id=current_user.id,
            action='regenerate_api_keys',
            details={
                'old_key_truncated': old_api_key[:8] + '...' if old_api_key else 'None',
                'new_key_truncated': client.api_key[:8] + '...',
                'by': current_user.username
            }
        )
        db.session.add(journal)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'api_key': client.api_key,
            'api_secret_truncated': client.api_secret[:8] + '...',
            'message': 'Cl√©s API r√©g√©n√©r√©es'
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

def creer_admin_client(client, form_data):
    """Cr√©e un administrateur client avec permissions COMPL√àTES et CORRECTES"""
    try:
        # V√©rifier que le client existe
        if not client:
            return {
                'success': False,
                'error': 'Client non trouv√©',
                'message': 'Impossible de cr√©er un admin sans client'
            }
        
        # 1. Permissions OBLIGATOIRES pour admin client (NON N√âGOCIABLES)
        permissions_admin_obligatoires = {
            # Tableau de bord et reporting
            'can_view_dashboard': True,
            'can_view_reports': True,
            'can_export_data': True,
            
            # Gestion des risques
            'can_manage_risks': True,
            'can_validate_risks': True,
            'can_manage_kri': True,
            
            # Gestion des audits
            'can_manage_audit': True,
            'can_confirm_evaluations': True,
            
            # Gestion des d√©partements
            'can_view_departments': True,
            'can_manage_departments': True,
            
            # Gestion des utilisateurs (CRITIQUE - doit g√©rer SES utilisateurs)
            'can_view_users_list': True,      # Doit voir la liste de SES utilisateurs
            'can_edit_users': True,           # Doit modifier SES utilisateurs
            'can_manage_users': True,         # Doit g√©rer SES utilisateurs
            
            # Administration
            'can_manage_settings': True,
            'can_manage_permissions': True,
            'can_archive_data': True,
            'can_delete_data': True,
            
            # Veille et conformit√© (selon formule)
            'can_manage_regulatory': False,  # Par d√©faut false, ajust√© selon formule
            
            # Processus et logigrammes (selon formule)
            'can_manage_logigram': False,    # Par d√©faut false, ajust√© selon formule
            
            # Permissions syst√®me (TOUJOURS false pour admin client)
            'can_manage_clients': False,      # Jamais pour admin client
            'can_provision_servers': False,   # Jamais pour admin client
            'can_access_all_departments': False  # Par d√©faut false
        }
        
        # 2. R√©cup√©rer les permissions de la formule
        formule_permissions = {}
        if client.formule and hasattr(client.formule, 'permissions_template'):
            formule_permissions = client.formule.permissions_template.copy() if client.formule.permissions_template else {}
        
        # 3. Fusionner intelligemment : permissions admin > formule
        permissions_finales = permissions_admin_obligatoires.copy()
        
        # Ajouter les permissions sp√©cifiques de la formule (sans √©craser les admin obligatoires)
        for perm, value in formule_permissions.items():
            if perm not in permissions_finales:  # N'√©crase pas les permissions admin obligatoires
                permissions_finales[perm] = value
        
        # 4. Ajuster selon les modules de la formule
        if client.formule:
            # Activer veille r√®glementaire si module inclus
            if client.formule.can_access_module('veille'):
                permissions_finales['can_manage_regulatory'] = True
            
            # Activer gestion processus si module inclus
            if client.formule.can_access_module('processus'):
                permissions_finales['can_manage_logigram'] = True
            
            # V√©rifier et ajuster chaque permission selon la formule
            for perm in permissions_finales.keys():
                if perm in formule_permissions:
                    # Si la formule a une valeur sp√©cifique pour une permission non-obligatoire
                    if perm not in permissions_admin_obligatoires:
                        permissions_finales[perm] = formule_permissions[perm]
        
        # 5. G√©n√©rer un mot de passe s√©curis√©
        password = secrets.token_urlsafe(12)
        
        # 6. Cr√©er l'utilisateur admin
        admin = User(
            username=f"admin_{client.reference}",
            email=form_data.get('contact_email') or f"admin.{client.reference}@entreprise.com",
            role='admin',
            client_id=client.id,
            is_client_admin=True,
            is_active=True,
            department='Administration Client',
            permissions=permissions_finales,
            created_at=datetime.utcnow()
        )
        admin.set_password(password)
        
        db.session.add(admin)
        db.session.flush()  # Pour obtenir l'ID
        
        # 7. Mettre √† jour les compteurs du client
        client.nb_utilisateurs = User.query.filter_by(client_id=client.id, is_active=True).count() or 1
        
        # 8. Journaliser la cr√©ation
        journal = JournalActiviteClient(
            client_id=client.id,
            utilisateur_id=current_user.id if current_user.is_authenticated else None,
            action='creation_admin_client',
            details={
                'admin_username': admin.username,
                'admin_email': admin.email,
                'client_reference': client.reference,
                'formule': client.formule.nom if client.formule else 'Aucune',
                'permissions_appliquees': {
                    'obligatoires': len([p for p in permissions_admin_obligatoires.values() if p]),
                    'total': len([p for p in permissions_finales.values() if p]),
                    'modules_actives': {
                        'veille': permissions_finales.get('can_manage_regulatory', False),
                        'processus': permissions_finales.get('can_manage_logigram', False)
                    }
                }
            },
            ip_address=request.remote_addr if request else None,
            user_agent=request.user_agent.string if request else None
        )
        db.session.add(journal)
        
        db.session.commit()
        
        # 9. Log de cr√©ation
        print(f"""
        ===========================================
        ‚úÖ ADMIN CLIENT CR√â√â AVEC SUCC√àS
        ===========================================
        Client: {client.nom} ({client.reference})
        Formule: {client.formule.nom if client.formule else 'Aucune'}
        
        INFORMATIONS ADMIN:
        Username: {admin.username}
        Email: {admin.email}
        Mot de passe: {password}
        
        PERMISSIONS APPLIQU√âES:
        ‚Ä¢ Gestion utilisateurs: ‚úÖ (can_view_users_list, can_edit_users, can_manage_users)
        ‚Ä¢ Gestion risques: { '‚úÖ' if permissions_finales.get('can_manage_risks') else '‚ùå' }
        ‚Ä¢ Gestion audits: { '‚úÖ' if permissions_finales.get('can_manage_audit') else '‚ùå' }
        ‚Ä¢ Veille r√®glementaire: { '‚úÖ' if permissions_finales.get('can_manage_regulatory') else '‚ùå' }
        ‚Ä¢ Logigrammes: { '‚úÖ' if permissions_finales.get('can_manage_logigram') else '‚ùå' }
        
        MODULES ACC√àS:
        ‚Ä¢ Veille: { '‚úÖ Activ√©' if client.formule and client.formule.can_access_module('veille') else '‚ùå D√©sactiv√©' }
        ‚Ä¢ Processus: { '‚úÖ Activ√©' if client.formule and client.formule.can_access_module('processus') else '‚ùå D√©sactiv√©' }
        
        SECURIT√â:
        ‚Ä¢ Peut g√©rer les clients: { '‚ùå NON' if not permissions_finales.get('can_manage_clients') else '‚ö†Ô∏è OUI (ANORMAL)' }
        ‚Ä¢ Peut provisionner serveurs: { '‚ùå NON' if not permissions_finales.get('can_provision_servers') else '‚ö†Ô∏è OUI (ANORMAL)' }
        ===========================================
        """)
        
        return {
            'success': True,
            'admin': {
                'id': admin.id,
                'username': admin.username,
                'email': admin.email,
                'role': admin.role,
                'is_client_admin': admin.is_client_admin,
                'permissions_count': len([p for p in permissions_finales.values() if p])
            },
            'password': password,
            'client_info': {
                'nom': client.nom,
                'reference': client.reference,
                'formule': client.formule.nom if client.formule else 'Aucune',
                'max_utilisateurs': client.formule.max_utilisateurs if client.formule else 10
            },
            'message': f'Admin client cr√©√© avec {len([p for p in permissions_finales.values() if p])} permissions'
        }
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur cr√©ation admin client: {str(e)}")
        import traceback
        traceback.print_exc()
        
        return {
            'success': False,
            'error': str(e),
            'message': f'Erreur cr√©ation admin client: {str(e)}'
        }

def creer_utilisateur_client(client, form_data, role='utilisateur'):
    """Cr√©e un utilisateur normal dans un client avec permissions adapt√©es"""
    try:
        # V√©rifier les limites de la formule
        if client.formule:
            current_users = User.query.filter_by(client_id=client.id, is_active=True).count()
            if current_users >= client.formule.max_utilisateurs:
                return {
                    'success': False,
                    'error': 'Limite utilisateurs atteinte',
                    'message': f'Limite de {client.formule.max_utilisateurs} utilisateurs atteinte'
                }
        
        # 1. Permissions par d√©faut selon le r√¥le
        role_permissions = {
            'utilisateur': {
                'can_view_dashboard': True,
                'can_view_reports': True,
                'can_view_departments': True,
                'can_view_users_list': True,  # Peut voir la liste (lecture seule)
                'can_edit_users': False,      # Ne peut pas modifier
                'can_manage_users': False,    # Ne peut pas g√©rer
                'can_export_data': False,
                'can_manage_risks': False,
                'can_manage_kri': False,
                'can_manage_audit': False,
                'can_manage_regulatory': False,
                'can_manage_logigram': False,
                'can_manage_settings': False,
                'can_delete_data': False,
                'can_manage_permissions': False,
                'can_archive_data': False,
                'can_validate_risks': False,
                'can_confirm_evaluations': False,
                'can_manage_departments': False,
                'can_access_all_departments': False,
                'can_manage_clients': False,
                'can_provision_servers': False
            },
            'auditeur': {
                'can_view_dashboard': True,
                'can_view_reports': True,
                'can_view_departments': True,
                'can_view_users_list': True,
                'can_edit_users': False,
                'can_manage_users': False,
                'can_export_data': True,
                'can_manage_risks': False,
                'can_manage_kri': False,
                'can_manage_audit': True,  # Sp√©cifique auditeur
                'can_manage_regulatory': False,
                'can_manage_logigram': False,
                'can_manage_settings': False,
                'can_delete_data': False,
                'can_manage_permissions': False,
                'can_archive_data': False,
                'can_validate_risks': False,
                'can_confirm_evaluations': False,
                'can_manage_departments': False,
                'can_access_all_departments': False,
                'can_manage_clients': False,
                'can_provision_servers': False
            },
            'manager': {
                'can_view_dashboard': True,
                'can_view_reports': True,
                'can_view_departments': True,
                'can_view_users_list': True,
                'can_edit_users': False,
                'can_manage_users': False,
                'can_export_data': True,
                'can_manage_risks': True,  # Sp√©cifique manager
                'can_manage_kri': True,
                'can_manage_audit': True,
                'can_manage_regulatory': False,
                'can_manage_logigram': False,
                'can_manage_settings': False,
                'can_delete_data': False,
                'can_manage_permissions': False,
                'can_archive_data': False,
                'can_validate_risks': True,
                'can_confirm_evaluations': False,
                'can_manage_departments': False,
                'can_access_all_departments': False,
                'can_manage_clients': False,
                'can_provision_servers': False
            }
        }
        
        # 2. R√©cup√©rer les permissions de base selon le r√¥le
        permissions_base = role_permissions.get(role, role_permissions['utilisateur']).copy()
        
        # 3. Ajuster selon la formule
        if client.formule:
            # Activer veille si module inclus
            if client.formule.can_access_module('veille'):
                permissions_base['can_manage_regulatory'] = True
            
            # Activer processus si module inclus
            if client.formule.can_access_module('processus'):
                permissions_base['can_manage_logigram'] = True
            
            # V√©rifier les permissions template de la formule
            if hasattr(client.formule, 'permissions_template') and client.formule.permissions_template:
                for perm, value in client.formule.permissions_template.items():
                    if perm in permissions_base:
                        # Ne pas d√©sactiver une permission d√©j√† active par r√¥le
                        if not value and permissions_base[perm]:
                            # Garder active si c'est une permission de r√¥le
                            pass
                        else:
                            permissions_base[perm] = value
        
        # 4. G√©n√©rer un mot de passe
        password = secrets.token_urlsafe(10)
        
        # 5. Cr√©er l'utilisateur
        utilisateur = User(
            username=form_data.get('username'),
            email=form_data.get('email'),
            role=role,
            client_id=client.id,
            is_client_admin=False,  # Jamais True pour les utilisateurs normaux
            is_active=True,
            department=form_data.get('department', ''),
            permissions=permissions_base
        )
        utilisateur.set_password(password)
        
        db.session.add(utilisateur)
        
        # 6. Mettre √† jour le compteur client
        client.nb_utilisateurs = User.query.filter_by(client_id=client.id, is_active=True).count()
        
        # 7. Journaliser
        journal = JournalActiviteClient(
            client_id=client.id,
            utilisateur_id=current_user.id if current_user.is_authenticated else None,
            action=f'creation_utilisateur_{role}',
            details={
                'username': utilisateur.username,
                'role': role,
                'permissions_appliquees': len([p for p in permissions_base.values() if p]),
                'par': current_user.username if current_user.is_authenticated else 'system'
            }
        )
        db.session.add(journal)
        
        db.session.commit()
        
        return {
            'success': True,
            'utilisateur': {
                'id': utilisateur.id,
                'username': utilisateur.username,
                'email': utilisateur.email,
                'role': utilisateur.role
            },
            'password': password,
            'message': f'Utilisateur {role} cr√©√© avec succ√®s'
        }
        
    except Exception as e:
        db.session.rollback()
        return {
            'success': False,
            'error': str(e),
            'message': f'Erreur cr√©ation utilisateur: {str(e)}'
        }

# ========================
# FONCTION UTILITAIRE POUR V√âRIFIER LES ROUTES
# ========================

def url_exists(endpoint):
    """V√©rifie si une route Flask existe"""
    try:
        # V√©rifier si l'endpoint existe dans les r√®gles d'URL
        return endpoint in app.view_functions
    except:
        return False

# Injecter la fonction dans le contexte Jinja2
@app.context_processor
def utility_processor():
    """Injecte des fonctions utilitaires dans tous les templates"""
    return {
        'url_exists': url_exists,
        'now': datetime.utcnow
    }



@app.route('/fix-all-manager-permissions')
@login_required
@super_admin_required
def fix_all_manager_permissions():
    """Corrige toutes les permissions des gestionnaires"""
    
    try:
        # Trouver tous les gestionnaires
        managers = User.query.filter_by(role='manager').all()
        
        corrections = 0
        
        for manager in managers:
            print(f"üîß Correction permissions pour {manager.username}")
            
            # Activer le flag can_manage_users
            manager.can_manage_users = True
            
            # Initialiser permissions si n√©cessaire
            if manager.permissions is None:
                manager.permissions = {}
            
            # Permissions OBLIGATOIRES pour gestionnaire
            required_permissions = {
                'can_create_users': True,
                'can_edit_users': True,
                'can_deactivate_users': True,
                'can_delete_users': True,
                'can_view_users_list': True,
                'can_manage_users': True,
                'can_manage_permissions': True,
                'can_block_users': True
            }
            
            # Appliquer les permissions
            for perm, value in required_permissions.items():
                if manager.permissions.get(perm) != value:
                    manager.permissions[perm] = value
                    corrections += 1
        
        db.session.commit()
        
        flash(f'‚úÖ {corrections} permissions corrig√©es pour {len(managers)} gestionnaires', 'success')
        return redirect(url_for('admin_utilisateurs'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
        return redirect(url_for('dashboard'))
    
@app.route('/super-admin/fix-client-permissions/<int:client_id>')
@login_required
@super_admin_required
def fix_client_permissions(client_id):
    """Corrige les permissions de tous les utilisateurs d'un client"""
    client = Client.query.get_or_404(client_id)
    users = User.query.filter_by(client_id=client_id).all()
    
    fixed = 0
    for user in users:
        # Pour les admin client
        if user.is_client_admin or user.role == 'admin':
            user.permissions.update({
                'can_view_users_list': True,
                'can_edit_users': True,
                'can_manage_users': True,
                'can_view_departments': True,
                'can_manage_departments': True
            })
            fixed += 1
        # Pour les utilisateurs normaux
        else:
            user.permissions.update({
                'can_view_users_list': True,  # Peut voir la liste
                'can_edit_users': False,      # Mais pas modifier
                'can_view_departments': True
            })
            fixed += 1
        
        db.session.commit()
    
    flash(f'‚úÖ Permissions corrig√©es pour {fixed} utilisateurs', 'success')
    return redirect(url_for('super_admin_client_detail', id=client_id))

@app.route('/client-admin/utilisateur/creer', methods=['GET', 'POST'])
@login_required
def client_admin_creer_utilisateur():
    """Cr√©er un nouvel utilisateur - version client admin CORRIG√âE"""
    
    print(f"üîç DEBUG: Route appel√©e - client_admin_creer_utilisateur")
    print(f"üìù M√©thode: {request.method}")
    
    if not current_user.is_client_admin:
        flash('Acc√®s r√©serv√© aux administrateurs client', 'error')
        return redirect(url_for('dashboard'))
    
    client = current_user.client
    if not client:
        flash('Aucun client associ√© √† votre compte', 'error')
        return redirect(url_for('dashboard'))
    
    # V√©rifier la limite d'utilisateurs
    current_count = User.query.filter_by(client_id=client.id, is_active=True).count()
    max_users = client.formule.max_utilisateurs if client.formule else 10
    
    if current_count >= max_users:
        flash(f'Limite d\'utilisateurs atteinte ({max_users}). Veuillez mettre √† jour votre formule.', 'error')
        return redirect(url_for('client_admin_utilisateurs'))
    
    # Cr√©er le formulaire
    from flask_wtf import FlaskForm
    from wtforms import StringField, PasswordField, SelectField, BooleanField, SubmitField
    from wtforms.validators import DataRequired, Email, Length, EqualTo
    
    class ClientNouvelUtilisateurForm(FlaskForm):
        username = StringField('Nom d\'utilisateur', validators=[
            DataRequired(message='Le nom d\'utilisateur est requis')
        ])
        email = StringField('Email', validators=[
            DataRequired(message='L\'email est requis'),
            Email(message='Format d\'email invalide')
        ])
        password = PasswordField('Mot de passe', validators=[
            DataRequired(message='Le mot de passe est requis'),
            Length(min=6, message='Le mot de passe doit avoir au moins 6 caract√®res')
        ])
        confirm_password = PasswordField('Confirmer le mot de passe', validators=[
            DataRequired(message='Veuillez confirmer le mot de passe'),
            EqualTo('password', message='Les mots de passe doivent correspondre')
        ])
        
        # R√¥les disponibles pour admin client
        role = SelectField('R√¥le', 
            choices=[
                ('utilisateur', 'Utilisateur Standard'),
                ('auditeur', 'Auditeur'),
                ('compliance', 'Responsable Conformit√©'),
                ('manager', 'Manager'),
                ('consultant', 'Consultant')
            ],
            default='utilisateur',
            validators=[DataRequired()]
        )
        
        department = StringField('D√©partement')
        is_active = BooleanField('Activer le compte imm√©diatement', default=True)
        submit = SubmitField('Cr√©er l\'utilisateur')
    
    # Cr√©er l'instance du formulaire
    form = ClientNouvelUtilisateurForm()
    
    # DEBUG: Afficher le formulaire re√ßu
    if request.method == 'POST':
        print(f"üì® Donn√©es POST re√ßues:")
        print(f"  username: {request.form.get('username')}")
        print(f"  email: {request.form.get('email')}")
        print(f"  password: {'Oui' if request.form.get('password') else 'Non'}")
        print(f"  confirm_password: {'Oui' if request.form.get('confirm_password') else 'Non'}")
        print(f"  role: {request.form.get('role')}")
        print(f"  CSRF token pr√©sent: {'csrf_token' in request.form}")
    
    if form.validate_on_submit():
        print("‚úÖ Formulaire valid√© avec succ√®s!")
        print(f"  Password: {form.password.data[:3]}***")
        print(f"  Confirm: {form.confirm_password.data[:3]}***")
        
        try:
            # V√©rifier √† nouveau les limites avant cr√©ation
            if client.formule:
                current_count = User.query.filter_by(
                    client_id=client.id, 
                    is_active=True
                ).count()
                
                if current_count >= client.formule.max_utilisateurs:
                    flash(f'‚ùå Limite atteinte pendant la cr√©ation. Veuillez r√©essayer.', 'error')
                    return redirect(url_for('client_admin_creer_utilisateur'))
            
            # V√©rifier si l'utilisateur existe d√©j√†
            existing_user = User.query.filter(
                db.or_(
                    User.username == form.username.data,
                    User.email == form.email.data
                ),
                User.client_id == client.id
            ).first()
            
            if existing_user:
                flash(f'Un utilisateur avec ce nom ou email existe d√©j√† dans votre client', 'error')
                return redirect(url_for('client_admin_creer_utilisateur'))
            
            # Cr√©er l'utilisateur (SANS is_client_admin=True)
            user = User(
                username=form.username.data,
                email=form.email.data,
                role=form.role.data,
                department=form.department.data or '',
                is_active=form.is_active.data,
                client_id=client.id,
                is_client_admin=False,  # IMPORTANT: Toujours False pour les utilisateurs normaux
                created_at=datetime.utcnow()
            )
            
            # D√©finir le mot de passe
            user.set_password(form.password.data)
            
            # Sauvegarder
            db.session.add(user)
            db.session.commit()
            
            print(f"‚úÖ Utilisateur cr√©√© avec succ√®s: {user.username}")
            flash(f'‚úÖ Utilisateur {user.username} cr√©√© avec succ√®s', 'success')
            return redirect(url_for('client_admin_utilisateurs'))
            
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Erreur cr√©ation utilisateur: {str(e)}")
            import traceback
            traceback.print_exc()
            flash(f'‚ùå Erreur lors de la cr√©ation: {str(e)}', 'error')
    else:
        # Afficher les erreurs de validation
        if form.errors:
            print("‚ùå Erreurs de validation du formulaire:")
            for field, errors in form.errors.items():
                print(f"  {field}: {errors}")
            
            # Afficher tous les messages d'erreur
            for field, errors in form.errors.items():
                if errors:
                    for error in errors:
                        flash(f'Erreur {field}: {error}', 'error')
    
    # Calculer le pourcentage pour la barre de progression
    pourcentage = (current_count / max_users * 100) if max_users > 0 else 0
    
    # Utilisez le template correct 'client_admin/nouvel_utilisateur.html'
    # et passez toutes les variables n√©cessaires
    return render_template('client_admin/nouvel_utilisateur.html',
                         form=form,
                         client=client,
                         limite=max_users,
                         utilisateurs_actuels=current_count,
                         pourcentage=pourcentage,max_count=max_users,
                         current_count=current_count,  # Important pour le template
                         current_user=current_user)
    


    
@app.route('/debug/create-user-form')
@login_required
def debug_create_user_form():
    """Debug du formulaire de cr√©ation d'utilisateur"""
    
    # Importer les champs WTForms
    from wtforms import StringField, PasswordField, SelectField, BooleanField, SubmitField
    from wtforms.validators import DataRequired, Email, Length, EqualTo, Optional
    
    # Formulaire de d√©bogage
    class DebugUserForm(FlaskForm):
        username = StringField('Nom d\'utilisateur', validators=[DataRequired()])
        email = StringField('Email', validators=[DataRequired(), Email()])
        password = PasswordField('Mot de passe', validators=[DataRequired(), Length(min=6)])
        confirm_password = PasswordField('Confirmer', validators=[DataRequired(), EqualTo('password')])
        role = SelectField('R√¥le', choices=[('utilisateur', 'Utilisateur')])
        submit = SubmitField('Cr√©er')
    
    form = DebugUserForm()
    
    return f"""
    <html>
    <head><title>Debug Formulaire</title></head>
    <body style="padding: 20px; font-family: Arial;">
        <h1>üîç Debug Formulaire Cr√©ation Utilisateur</h1>
        
        <div style="background: #f5f5f5; padding: 20px; margin: 20px 0;">
            <h3>Formulaire simplifi√©</h3>
            <form method="POST" action="/admin/utilisateur/nouveau">
                {form.csrf_token}
                <p>{form.username.label}: {form.username()}</p>
                <p>{form.email.label}: {form.email()}</p>
                <p>{form.password.label}: {form.password()}</p>
                <p>{form.confirm_password.label}: {form.confirm_password()}</p>
                <p>{form.role.label}: {form.role()}</p>
                <p>{form.submit()}</p>
            </form>
        </div>
        
        <div style="background: #e8f5e8; padding: 20px; margin: 20px 0;">
            <h3>Informations de session</h3>
            <p><strong>User ID:</strong> {current_user.id}</p>
            <p><strong>Username:</strong> {current_user.username}</p>
            <p><strong>Role:</strong> {current_user.role}</p>
            <p><strong>Client ID:</strong> {current_user.client_id}</p>
            <p><strong>is_client_admin:</strong> {current_user.is_client_admin}</p>
        </div>
        
        <div style="background: #e3f2fd; padding: 20px; margin: 20px 0;">
            <h3>Test rapide</h3>
            <a href="/admin/utilisateur/nouveau" style="color: blue;">Retour au formulaire normal</a><br>
            <a href="/admin/debug-form-action" style="color: blue;">Test action directe</a>
        </div>
    </body>
    </html>
    """
@app.route('/debug/formule/<int:id>/modules')
@login_required
@super_admin_required
def debug_formule_modules(id):
    """Debug pour voir les modules d'une formule"""
    formule = FormuleAbonnement.query.get_or_404(id)
    
    debug_info = {
        'formule': {
            'id': formule.id,
            'nom': formule.nom,
            'code': formule.code
        },
        'modules_actuels': formule.modules,
        'permissions_template': formule.permissions_template,
        'modules_problematiques': {
            'veille_reglementaire': formule.modules.get('veille_reglementaire', 'NON TROUV√â'),
            'gestion_processus': formule.modules.get('gestion_processus', 'NON TROUV√â'),
            'analyse_ia': formule.modules.get('analyse_ia', 'NON TROUV√â'),
            'tableaux_bord': formule.modules.get('tableaux_bord', 'NON TROUV√â')
        },
        'permissions_associees': {
            'can_manage_regulatory': formule.permissions_template.get('can_manage_regulatory', 'NON TROUV√â'),
            'can_manage_logigram': formule.permissions_template.get('can_manage_logigram', 'NON TROUV√â'),
            'can_use_ia_analysis': formule.permissions_template.get('can_use_ia_analysis', 'NON TROUV√â'),
            'can_view_dashboard': formule.permissions_template.get('can_view_dashboard', 'NON TROUV√â')
        }
    }
    
    return jsonify(debug_info)
    
@app.route('/admin/debug-form-action', methods=['GET', 'POST'])
@login_required
def debug_form_action():
    """Test direct de l'action du formulaire"""
    
    if request.method == 'POST':
        return f"""
        <h2>‚úÖ Formulaire re√ßu!</h2>
        <pre>{request.form}</pre>
        <a href="/admin/debug-form-action">Retour</a>
        """
    
    return """
    <html>
    <head><title>Test Formulaire</title></head>
    <body style="padding: 20px;">
        <h1>Test Formulaire Direct</h1>
        
        <form method="POST">
            <input type="hidden" name="csrf_token" value="test">
            <p>Nom: <input type="text" name="username" value="testuser"></p>
            <p>Email: <input type="email" name="email" value="test@test.com"></p>
            <p>Password: <input type="password" name="password" value="test123"></p>
            <p>Confirm: <input type="password" name="confirm_password" value="test123"></p>
            <p><button type="submit">Tester Soumission</button></p>
        </form>
    </body>
    </html>
    """

@app.route('/api/client/<int:client_id>/provision-server', methods=['POST'])
@login_required
@super_admin_required
def api_provision_server(client_id):
    """Provisionner un serveur d√©di√© pour un client"""
    client = Client.query.get_or_404(client_id)
    
    # V√©rifier si un environnement existe d√©j√†
    existing_env = EnvironnementClient.query.filter_by(client_id=client_id).first()
    if existing_env and existing_env.server_ip:
        return jsonify({
            'warning': True,
            'message': 'Un serveur est d√©j√† provisionn√© pour ce client'
        })
    
    try:
        # Simuler le provisionnement (√† remplacer par votre vrai provisionnement)
        server_ip = f"192.168.{random.randint(1, 254)}.{random.randint(1, 254)}"
        
        if existing_env:
            env = existing_env
        else:
            env = EnvironnementClient(client_id=client_id)
        
        env.nom = f"Serveur {client.reference}"
        env.server_ip = server_ip
        env.server_port = 22
        env.server_ssh_user = f"client_{client.reference}"
        env.cpu_alloue = '2 cores'
        env.ram_alloue = '4GB'
        env.stockage_alloue = '50GB'
        env.statut = 'actif'
        env.date_provision = datetime.utcnow()
        
        db.session.add(env)
        
        # Mettre √† jour le client
        client.has_dedicated_server = True
        
        # Journaliser
        journal = JournalActiviteClient(
            client_id=client_id,
            utilisateur_id=current_user.id,
            action='provision_server',
            details={
                'server_ip': server_ip,
                'specs': f"{env.cpu_alloue}, {env.ram_alloue}, {env.stockage_alloue}",
                'by': current_user.username
            }
        )
        db.session.add(journal)
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'server_ip': server_ip,
            'ssh_user': env.server_ssh_user,
            'specs': {
                'cpu': env.cpu_alloue,
                'ram': env.ram_alloue,
                'storage': env.stockage_alloue
            },
            'message': f'Serveur provisionn√© avec succ√®s: {server_ip}'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/super-admin/client/<int:id>/add-environment', methods=['POST'])
@login_required
@super_admin_required
def super_admin_add_environment(id):
    """Ajouter un environnement √† un client (CORRIG√â)"""
    client = Client.query.get_or_404(id)
    
    # 1. R√©cup√©rer les donn√©es du formulaire
    nom = request.form.get('nom', '').strip()
    sous_domaine = request.form.get('sous_domaine', '').strip()
    type_serveur = request.form.get('type_serveur', 'partage')
    
    print(f"üîç DEBUG - Cr√©ation environnement:")
    print(f"  Client: {client.nom} (ID: {client.id})")
    print(f"  Nom: {nom}")
    print(f"  Sous-domaine: {sous_domaine}")
    print(f"  Type serveur: {type_serveur}")
    
    # 2. Validation
    if not nom:
        flash('Le nom de l\'environnement est requis', 'error')
        return redirect(url_for('super_admin_client_detail', id=id))
    
    if not sous_domaine:
        flash('Le sous-domaine est requis', 'error')
        return redirect(url_for('super_admin_client_detail', id=id))
    
    # 3. V√©rifier si le sous-domaine existe d√©j√†
    existing_env = EnvironnementClient.query.filter_by(sous_domaine=sous_domaine).first()
    if existing_env:
        existing_client = Client.query.get(existing_env.client_id)
        flash(
            f'Le sous-domaine "{sous_domaine}" est d√©j√† utilis√© par ' +
            f'l\'environnement "{existing_env.nom}" du client "{existing_client.nom if existing_client else "Inconnu"}"',
            'error'
        )
        return redirect(url_for('super_admin_client_detail', id=id))
    
    # 4. V√©rifier si le nom existe d√©j√† pour ce client
    existing_name = EnvironnementClient.query.filter_by(
        client_id=client.id,
        nom=nom
    ).first()
    if existing_name:
        flash(f'Un environnement nomm√© "{nom}" existe d√©j√† pour ce client', 'error')
        return redirect(url_for('super_admin_client_detail', id=id))
    
    try:
        # 5. Cr√©er l'environnement
        env = EnvironnementClient(
            client_id=client.id,
            nom=nom,
            sous_domaine=sous_domaine,
            url_acces=f"https://{sous_domaine}",
            statut='actif',
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )
        
        # 6. Configurer selon le type de serveur
        if type_serveur == 'dedie':
            # Serveur d√©di√©
            env.server_ip = request.form.get('server_ip', '').strip()
            env.server_port = int(request.form.get('server_port', 22))
            env.server_ssh_user = request.form.get('server_ssh_user', f"client_{client.reference}")
            env.cpu_alloue = request.form.get('cpu_alloue', '2 cores')
            env.ram_alloue = request.form.get('ram_alloue', '4GB')
            env.stockage_alloue = request.form.get('stockage_alloue', '50GB')
            env.date_provision = datetime.utcnow()
        else:
            # Serveur partag√© (valeurs par d√©faut)
            env.server_ip = None
            env.server_port = None
            env.server_ssh_user = None
            env.cpu_alloue = 'Partag√©'
            env.ram_alloue = 'Partag√©'
            env.stockage_alloue = 'Partag√©'
            env.db_name = f"client_{client.reference}"
            env.db_user = f"user_{client.reference}"
        
        print(f"‚úÖ Configuration finale:")
        print(f"  URL: {env.url_acces}")
        print(f"  Serveur IP: {env.server_ip}")
        print(f"  Type: {'D√©di√©' if type_serveur == 'dedie' else 'Partag√©'}")
        
        # 7. Sauvegarder
        db.session.add(env)
        
        # 8. Journaliser
        journal = JournalActiviteClient(
            client_id=client.id,
            utilisateur_id=current_user.id,
            action='ajout_environment',
            details={
                'env_name': env.nom,
                'sous_domaine': env.sous_domaine,
                'url': env.url_acces,
                'server_type': type_serveur,
                'by': current_user.username
            },
            ip_address=request.remote_addr if request else None
        )
        db.session.add(journal)
        
        db.session.commit()
        
        flash(f'Environnement "{env.nom}" cr√©√© avec succ√®s', 'success')
        print(f"üéâ Environnement cr√©√©: {env.nom} ({env.sous_domaine})")
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur cr√©ation environnement: {str(e)}")
        import traceback
        traceback.print_exc()
        flash(f'Erreur cr√©ation environnement: {str(e)}', 'error')
    
    return redirect(url_for('super_admin_client_detail', id=id))

# ========================
# ROUTES SUPERVISEUR POUR LES FORMULES D'ABONNEMENT
# ========================

@app.route('/check-my-view-mode')
@login_required
def check_my_view_mode():
    """V√©rifier mon mode de vue actuel"""
    
    return f"""
    <html>
    <head><title>Mode de vue</title></head>
    <body style="padding: 20px; font-family: Arial;">
        <h1>üîç V√©rification mode de vue</h1>
        
        <div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
            <h3>Informations utilisateur</h3>
            <p><strong>Username:</strong> {current_user.username}</p>
            <p><strong>Role:</strong> {current_user.role}</p>
            <p><strong>User ID:</strong> {current_user.id}</p>
            <p><strong>Client ID:</strong> {current_user.client_id}</p>
        </div>
        
        <div style="background: #e8f5e8; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
            <h3>Session</h3>
            <p><strong>View mode:</strong> {session.get('view_mode', 'Non d√©fini')}</p>
            <p><strong>Viewing client ID:</strong> {session.get('viewing_client_id', 'Non d√©fini')}</p>
            <p><strong>Viewing client name:</strong> {session.get('viewing_client_name', 'Non d√©fini')}</p>
        </div>
        
        <div style="background: #e3f2fd; padding: 20px; border-radius: 8px;">
            <h3>Actions rapides</h3>
            <div style="display: flex; gap: 10px; margin-top: 10px;">
                <a href="/super-admin/view-my-own-data" 
                   style="padding: 10px 20px; background: #4CAF50; color: white; text-decoration: none; border-radius: 4px;">
                    üîí Activer "Mes donn√©es seulement"
                </a>
                <a href="/view-all-clients" 
                   style="padding: 10px 20px; background: #2196F3; color: white; text-decoration: none; border-radius: 4px;">
                    üåç Activer "Tous les clients"
                </a>
                <a href="/view-reset" 
                   style="padding: 10px 20px; background: #ff9800; color: white; text-decoration: none; border-radius: 4px;">
                    üîÑ R√©initialiser
                </a>
            </div>
        </div>
        
        <div style="margin-top: 30px;">
            <h3>Test de filtrage</h3>
            <a href="/liste_logigrammes" style="color: #2196F3;">Testez la liste des logigrammes</a>
        </div>
    </body>
    </html>
    """

@app.route('/force-my-data-view')
@login_required
@super_admin_required
def force_my_data_view():
    """Forcer le mode "Mes donn√©es seulement" IMM√âDIATEMENT"""
    
    # 1. Nettoyer la session
    session.pop('viewing_client_id', None)
    session.pop('viewing_client_name', None)
    session.pop('viewing_client_reference', None)
    
    # 2. Activer le mode "mes donn√©es seulement"
    session['view_mode'] = 'my_data_only'
    
    # 3. Ajouter un flag pour le debug
    session['debug_mode'] = 'my_data_only_forced'
    
    flash('‚úÖ Mode "Mes donn√©es seulement" activ√© FORC√âMENT', 'success')
    
    return redirect(url_for('liste_logigrammes'))


@app.before_request
def auto_check_view_mode():
    """V√©rifier et corriger automatiquement le mode de vue pour super admin"""
    
    if current_user.is_authenticated and current_user.role == 'super_admin':
        
        endpoint = request.endpoint
        
        # Si on acc√®de √† une liste de donn√©es (logigrammes, risques, etc.)
        list_endpoints = ['liste_logigrammes', 'liste_risques', 'liste_audits', 
                         'super_admin_clients', 'super_admin_formules']
        
        if endpoint in list_endpoints:
            # V√©rifier si on est en mode "vue personnelle"
            current_mode = session.get('view_mode')
            
            print(f"üîç AUTO CHECK: {endpoint}")
            print(f"   Mode actuel: {current_mode}")
            print(f"   Viewing client: {session.get('viewing_client_id')}")
            
            # Si pas de mode d√©fini, sugg√©rer d'activer "mes donn√©es"
            if not current_mode and not session.get('viewing_client_id'):
                print("   ‚ö†Ô∏è  Pas de mode d√©fini, suggestion d'activer 'mes donn√©es'")
                # Ne pas forcer automatiquement, juste logger

                
# ========================
# D√âCORATEURS POUR V√âRIFIER LES LIMITES DE FORMULE
# ========================

def check_formule_limit(limit_type):
    """D√©corateur pour v√©rifier les limites de la formule"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if current_user.is_authenticated:
                client = current_user.client
                
                if client and client.formule:
                    formule = client.formule
                    
                    # V√©rifier les limites
                    if limit_type == 'utilisateurs':
                        current_count = User.query.filter_by(client_id=client.id, is_active=True).count()
                        if current_count >= formule.max_utilisateurs:
                            flash(f'Limite d\'utilisateurs atteinte ({formule.max_utilisateurs}). Veuillez mettre √† niveau votre formule.', 'error')
                            return redirect(request.referrer or url_for('dashboard'))
                    
                    elif limit_type == 'risques':
                        current_count = Risque.query.filter_by(client_id=client.id, is_archived=False).count()
                        if current_count >= formule.max_risques:
                            flash(f'Limite de risques atteinte ({formule.max_risques}). Veuillez mettre √† niveau votre formule.', 'error')
                            return redirect(request.referrer or url_for('dashboard'))
                    
                    elif limit_type == 'audits':
                        current_count = Audit.query.filter_by(client_id=client.id, is_archived=False).count()
                        if current_count >= formule.max_audits:
                            flash(f'Limite d\'audits atteinte ({formule.max_audits}). Veuillez mettre √† niveau votre formule.', 'error')
                            return redirect(request.referrer or url_for('dashboard'))
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator


def check_module_access(module_code):
    """D√©corateur pour v√©rifier l'acc√®s √† un module - VERSION CORRIG√âE"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not current_user.is_authenticated:
                flash('Veuillez vous connecter', 'error')
                return redirect(url_for('login'))
            
            # SUPER ADMIN : TOUT ACC√àS
            if current_user.role == 'super_admin':
                return f(*args, **kwargs)
            
            # V√©rifier si l'utilisateur a un client et une formule
            if not hasattr(current_user, 'client') or not current_user.client:
                flash('Aucun client associ√© √† votre compte', 'error')
                return redirect(url_for('dashboard'))
            
            client = current_user.client
            
            if not client.formule:
                flash('Aucune formule active pour votre client', 'error')
                return redirect(url_for('dashboard'))
            
            formule = client.formule
            
            # MAPPING COMPLET ET COH√âRENT
            # module_code (URL) ‚Üí Nom dans la base de donn√©es ‚Üí Permission
            module_mapping = {
                # ==================== MODULES PROBL√âMATIQUES ====================
                'veille': 'veille_reglementaire',
                'processus': 'gestion_processus',
                'logigrammes': 'gestion_processus',
                'ia_analyse': 'analyse_ia',
                'tableaux_bord_personnalisables': 'tableaux_bord',
                'plans_action': 'plans_action',  # AJOUT√â
                
                # ==================== AUTRES MODULES ====================
                'questionnaires': 'questionnaires',
                'organigramme': 'organigramme',
                'portail_fournisseurs': 'portail_fournisseurs',
                'reporting_avance': 'reporting_avance',
                'matrices_risque': 'matrices_risque',
                'risques': 'cartographie',
                'cartographie': 'cartographie',
                'audit_interne': 'audit_interne',
                'suivi_kri': 'suivi_kri'
            }
            
            # Obtenir le vrai nom du module dans la base de donn√©es
            real_module_db = module_mapping.get(module_code, module_code)
            
            # DEBUG LOG
            print(f"""
            üîç [CHECK_MODULE_ACCESS] DEBUG:
            Module URL: {module_code}
            ‚Üí DB Name: {real_module_db}
            Client: {client.nom} (ID: {client.id})
            Formule: {formule.nom} ({formule.code})
            """)
            
            # V√©rification 1: Module pr√©sent dans la formule
            module_active = False
            
            # Rechercher le module dans la formule (avec diff√©rentes cl√©s possibles)
            for module_key in [real_module_db, module_code]:
                if module_key in formule.modules:
                    module_active = formule.modules[module_key]
                    print(f"  ‚úÖ Module trouv√© avec cl√© '{module_key}': {module_active}")
                    break
            
            # Si le module n'est pas trouv√© du tout
            if real_module_db not in formule.modules and module_code not in formule.modules:
                print(f"  ‚ùå Module '{real_module_db}' NON TROUV√â dans les modules de la formule")
                print(f"     Modules disponibles: {list(formule.modules.keys())}")
                
                # Journaliser
                log_activity(current_user.id, 'tentative_acces_restreint',
                           f"Module '{real_module_db}' non trouv√© dans la formule {formule.nom}",
                           'system', None)
                
                return redirect(url_for('module_restricted', module=module_code))
            
            # Si le module est d√©sactiv√©
            if not module_active:
                print(f"  ‚ùå Module '{real_module_db}' D√âSACTIV√â dans la formule")
                
                # Journaliser
                log_activity(current_user.id, 'tentative_acces_restreint',
                           f"Module '{real_module_db}' d√©sactiv√© dans la formule {formule.nom}",
                           'system', None)
                
                return redirect(url_for('module_restricted', module=module_code))
            
            # V√©rification 2: Permission utilisateur
            # Mapping module ‚Üí permission (pour les modules critiques)
            module_permission_map = {
                'veille_reglementaire': 'can_manage_regulatory',
                'gestion_processus': 'can_manage_logigram',
                'analyse_ia': 'can_use_ia_analysis',
                'suivi_kri': 'can_manage_kri',
                'audit_interne': 'can_manage_audit',
                'cartographie': 'can_manage_risks',
                'reporting_avance': 'can_export_data',
                'tableaux_bord': 'can_view_dashboard',
                'plans_action': 'can_manage_action_plans'  # AJOUT√â
            }
            
            # MODULES SANS PERMISSION SP√âCIFIQUE (acc√®s basique)
            modules_sans_permission = ['questionnaires', 'organigramme', 'portail_fournisseurs', 'matrices_risque']
            
            # Pour les modules sans permission sp√©cifique, v√©rifier les permissions de base
            if real_module_db in modules_sans_permission:
                # V√©rifier au moins une permission de base
                permissions_de_base = ['can_view_dashboard', 'can_view_reports']
                has_basic_access = any(
                    current_user.permissions.get(perm, False)
                    for perm in permissions_de_base
                )
                
                if not has_basic_access:
                    print(f"  ‚ùå Module '{real_module_db}' n√©cessite au moins une permission de base")
                    flash(f'Permission de base requise pour acc√©der √† ce module', 'error')
                    return redirect(url_for('dashboard'))
                
                print(f"  ‚úÖ Module '{real_module_db}' accessible avec permissions de base")
                return f(*args, **kwargs)
            
            # Pour les modules avec permission sp√©cifique
            required_permission = None
            
            # Chercher avec le nom DB d'abord
            if real_module_db in module_permission_map:
                required_permission = module_permission_map[real_module_db]
            # Sinon avec le nom URL
            elif module_code in module_permission_map:
                required_permission = module_permission_map[module_code]
            
            if required_permission:
                print(f"  üîê Permission requise: {required_permission}")
                print(f"  üë§ Permissions utilisateur: {current_user.permissions}")
                
                user_has_permission = current_user.permissions.get(required_permission, False)
                
                if not user_has_permission:
                    print(f"  ‚ùå Utilisateur n'a pas la permission '{required_permission}'")
                    
                    # V√©rifier si c'est un probl√®me de synchronisation
                    if required_permission in formule.permissions_template:
                        formule_has_permission = formule.permissions_template[required_permission]
                        if not formule_has_permission:
                            print(f"  ‚ö†Ô∏è  La formule {formule.nom} n'inclut pas '{required_permission}'")
                            flash(f'Votre formule {formule.nom} n\'inclut pas cette fonctionnalit√©.', 'error')
                        else:
                            print(f"  ‚ö†Ô∏è  Permission '{required_permission}' incluse dans la formule mais non attribu√©e")
                            flash(f'Permission {required_permission} manquante dans votre profil.', 'error')
                    
                    # Sugg√©rer la synchronisation
                    if current_user.role in ['admin', 'super_admin']:
                        flash('Veuillez synchroniser vos permissions avec la formule.', 'info')
                    
                    return redirect(url_for('dashboard'))
                else:
                    print(f"  ‚úÖ Utilisateur a la permission '{required_permission}'")
            
            print(f"  üéâ Acc√®s AUTORIS√â au module '{module_code}' ({real_module_db})")
            return f(*args, **kwargs)
        
        return decorated_function
    return decorator


@app.route('/super-admin/fix-module-inconsistency')
@login_required
@super_admin_required
def fix_module_inconsistency():
    """Corrige imm√©diatement les incoh√©rences de modules"""
    
    try:
        # 1. Corriger les noms des modules dans TOUTES les formules
        formules = FormuleAbonnement.query.all()
        corrections = 0
        
        for formule in formules:
            print(f"üîß Correction formule: {formule.nom}")
            
            # Liste des corrections √† appliquer
            corrections_to_apply = {
                # Ancien nom ‚Üí Nouveau nom (base de donn√©es)
                'veille': 'veille_reglementaire',
                'processus': 'gestion_processus',
                'ia_analyse': 'analyse_ia',
                'tableaux_bord_personnalisables': 'tableaux_bord'
            }
            
            # Appliquer les corrections
            for old_name, new_name in corrections_to_apply.items():
                if old_name in formule.modules:
                    # Transf√©rer la valeur
                    formule.modules[new_name] = formule.modules[old_name]
                    # Supprimer l'ancien
                    del formule.modules[old_name]
                    corrections += 1
                    print(f"  üîÑ {old_name} ‚Üí {new_name}")
            
            # 2. Synchroniser les permissions
            permission_map = {
                'veille_reglementaire': ['can_manage_regulatory'],
                'gestion_processus': ['can_manage_logigram'],
                'analyse_ia': ['can_use_ia_analysis']
            }
            
            for module_db, permissions in permission_map.items():
                is_module_active = formule.modules.get(module_db, False)
                
                for permission in permissions:
                    if permission in formule.permissions_template:
                        if formule.permissions_template[permission] != is_module_active:
                            formule.permissions_template[permission] = is_module_active
                            corrections += 1
                            print(f"  üîÑ {permission}: {not is_module_active} ‚Üí {is_module_active}")
                    else:
                        formule.permissions_template[permission] = is_module_active
                        corrections += 1
                        print(f"  ‚ûï {permission} ajout√©: {is_module_active}")
        
        db.session.commit()
        
        # 3. Synchroniser tous les utilisateurs
        users = User.query.all()
        users_synced = 0
        
        for user in users:
            if user.client and user.client.formule:
                if sync_user_permissions_with_formule(user.id):
                    users_synced += 1
        
        flash(
            f'‚úÖ {corrections} corrections appliqu√©es. '
            f'{users_synced} utilisateurs synchronis√©s.', 
            'success'
        )
        
        return jsonify({
            'success': True,
            'corrections': corrections,
            'users_synced': users_synced
        })
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
        return jsonify({'error': str(e)}), 500


def sync_user_permissions_with_formule(user_id):
    """Synchronise les permissions d'un utilisateur avec sa formule"""
    user = User.query.get(user_id)
    if not user or not user.client or not user.client.formule:
        return False
    
    formule = user.client.formule
    
    # Mapping des permissions critiques
    critical_permissions = {
        'can_manage_regulatory': 'veille_reglementaire',
        'can_manage_logigram': 'gestion_processus',
        'can_use_ia_analysis': 'analyse_ia'
    }
    
    needs_update = False
    
    for permission, module in critical_permissions.items():
        module_active = formule.modules.get(module, False)
        user_has_permission = user.permissions.get(permission, False)
        
        if module_active and not user_has_permission:
            user.permissions[permission] = True
            needs_update = True
            print(f"  ‚ûï {permission} activ√©e (module {module} activ√©)")
        elif not module_active and user_has_permission:
            user.permissions[permission] = False
            needs_update = True
            print(f"  ‚ûñ {permission} d√©sactiv√©e (module {module} d√©sactiv√©)")
    
    if needs_update:
        try:
            db.session.commit()
            print(f"‚úÖ Permissions synchronis√©es pour {user.username}")
            return True
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Erreur synchronisation: {e}")
            return False
    
    return True
def check_feature_access(feature_code):
    """D√©corateur pour v√©rifier l'acc√®s √† une feature"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if current_user.is_authenticated:
                client = current_user.client
                
                if client and client.formule:
                    if not client.formule.can_use_feature(feature_code):
                        flash(f'Fonctionnalit√© non incluse dans votre formule actuelle ({client.formule.nom}).', 'error')
                        return redirect(url_for('dashboard'))
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator


def exporter_json_questionnaire(questionnaire, form):
    """Exporter un questionnaire au format JSON"""
    data = {
        'titre': questionnaire.titre,
        'description': questionnaire.description,
        'code': questionnaire.code,
        'instructions': questionnaire.instructions,
        'date_creation': questionnaire.date_creation.isoformat() if questionnaire.date_creation else None,
        'est_actif': questionnaire.est_actif,
        'est_public': questionnaire.est_public,
        'categories': [],
        'statistiques': {
            'total_reponses': len(questionnaire.reponses),
            'reponses_completes': len([r for r in questionnaire.reponses if r.statut == 'complet']),
            'reponses_en_cours': len([r for r in questionnaire.reponses if r.statut == 'en_cours']),
        }
    }
    
    # Filtrage par dates
    date_debut = form.date_debut.data
    date_fin = form.date_fin.data
    reponses_filtrees = questionnaire.reponses
    
    if date_debut:
        reponses_filtrees = [r for r in reponses_filtrees if r.date_debut and r.date_debut.date() >= date_debut]
    if date_fin:
        reponses_filtrees = [r for r in reponses_filtrees if r.date_debut and r.date_debut.date() <= date_fin]
    
    if form.inclure_questions.data:
        for categorie in questionnaire.categories:
            cat_data = {
                'titre': categorie.titre,
                'description': categorie.description,
                'ordre': categorie.ordre,
                'questions': []
            }
            
            for question in categorie.questions:
                q_data = {
                    'texte': question.texte,
                    'description': question.description,
                    'type': question.type,
                    'ordre': question.ordre,
                    'est_obligatoire': question.est_obligatoire,
                    'options': []
                }
                
                for option in question.options:
                    q_data['options'].append({
                        'valeur': option.valeur,
                        'texte': option.texte,
                        'ordre': option.ordre,
                        'score': option.score
                    })
                
                cat_data['questions'].append(q_data)
            
            data['categories'].append(cat_data)
    
    if form.inclure_reponses.data:
        data['reponses'] = []
        for reponse in reponses_filtrees:
            rep_data = {
                'session_id': reponse.session_id,
                'statut': reponse.statut,
                'date_debut': reponse.date_debut.isoformat() if reponse.date_debut else None,
                'date_fin': reponse.date_fin.isoformat() if reponse.date_fin else None,
                'duree': reponse.duree,
                'email_repondant': reponse.email_repondant,
                'nom_repondant': reponse.nom_repondant,
                'reponses': []
            }
            
            for rep_question in reponse.reponses:
                rep_q_data = {
                    'question_id': rep_question.question_id,
                    'valeur_texte': rep_question.valeur_texte,
                    'valeur_numerique': rep_question.valeur_numerique,
                    'valeur_date': rep_question.valeur_date.isoformat() if rep_question.valeur_date else None,
                    'options_selectionnees': []
                }
                
                for opt in rep_question.options_selectionnees:
                    rep_q_data['options_selectionnees'].append({
                        'option_id': opt.option_id,
                        'valeur': opt.option.valeur if opt.option else None,
                        'texte': opt.option.texte if opt.option else None
                    })
                
                rep_data['reponses'].append(rep_q_data)
            
            data['reponses'].append(rep_data)
    
    response = make_response(json.dumps(data, indent=2, ensure_ascii=False, default=str))
    response.headers['Content-Type'] = 'application/json'
    response.headers['Content-Disposition'] = f'attachment; filename=questionnaire_{questionnaire.code}_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json'
    return response

def exporter_csv_reponses(questionnaire, form):
    """Exporter les r√©ponses au format CSV"""
    # Filtrage par dates
    date_debut = form.date_debut.data
    date_fin = form.date_fin.data
    reponses_filtrees = questionnaire.reponses
    
    if date_debut:
        reponses_filtrees = [r for r in reponses_filtrees if r.date_debut and r.date_debut.date() >= date_debut]
    if date_fin:
        reponses_filtrees = [r for r in reponses_filtrees if r.date_debut and r.date_debut.date() <= date_fin]
    
    # Pr√©parer les donn√©es CSV
    output = io.StringIO()
    writer = csv.writer(output)
    
    # En-t√™tes
    headers = ['Session ID', 'Statut', 'Date d√©but', 'Date fin', 'Dur√©e (s)', 'Email', 'Nom']
    
    # Ajouter les questions comme colonnes
    for categorie in questionnaire.categories:
        for question in categorie.questions:
            headers.append(f"{categorie.titre} - {question.texte[:50]}")
    
    writer.writerow(headers)
    
    # Donn√©es
    for reponse in reponses_filtrees:
        row = [
            reponse.session_id,
            reponse.statut,
            reponse.date_debut.strftime('%Y-%m-%d %H:%M:%S') if reponse.date_debut else '',
            reponse.date_fin.strftime('%Y-%m-%d %H:%M:%S') if reponse.date_fin else '',
            reponse.duree or '',
            reponse.email_repondant or '',
            reponse.nom_repondant or ''
        ]
        
        for categorie in questionnaire.categories:
            for question in categorie.questions:
                # Trouver la r√©ponse √† cette question
                rep_question = next((rq for rq in reponse.reponses if rq.question_id == question.id), None)
                valeur = ''
                
                if rep_question:
                    if rep_question.valeur_texte:
                        valeur = rep_question.valeur_texte
                    elif rep_question.valeur_numerique is not None:
                        valeur = str(rep_question.valeur_numerique)
                    elif rep_question.valeur_date:
                        valeur = rep_question.valeur_date.strftime('%Y-%m-%d')
                
                row.append(valeur)
        
        writer.writerow(row)
    
    response = make_response(output.getvalue())
    response.headers['Content-Type'] = 'text/csv; charset=utf-8'
    response.headers['Content-Disposition'] = f'attachment; filename=reponses_{questionnaire.code}_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv'
    return response

def exporter_excel_reponses(questionnaire, form):
    """Exporter les r√©ponses au format Excel"""
    try:
        import pandas as pd
        from io import BytesIO
        
        # Filtrage par dates
        date_debut = form.date_debut.data
        date_fin = form.date_fin.data
        reponses_filtrees = questionnaire.reponses
        
        if date_debut:
            reponses_filtrees = [r for r in reponses_filtrees if r.date_debut and r.date_debut.date() >= date_debut]
        if date_fin:
            reponses_filtrees = [r for r in reponses_filtrees if r.date_debut and r.date_debut.date() <= date_fin]
        
        # Pr√©parer les donn√©es
        data = []
        
        for reponse in reponses_filtrees:
            row = {
                'Session ID': reponse.session_id,
                'Statut': reponse.statut,
                'Date d√©but': reponse.date_debut.strftime('%Y-%m-%d %H:%M:%S') if reponse.date_debut else '',
                'Date fin': reponse.date_fin.strftime('%Y-%m-%d %H:%M:%S') if reponse.date_fin else '',
                'Dur√©e (secondes)': reponse.duree or '',
                'Email': reponse.email_repondant or '',
                'Nom': reponse.nom_repondant or '',
                'IP': reponse.ip_address or '',
                'User Agent': reponse.user_agent or ''
            }
            
            for categorie in questionnaire.categories:
                for question in categorie.questions:
                    # Trouver la r√©ponse √† cette question
                    rep_question = next((rq for rq in reponse.reponses if rq.question_id == question.id), None)
                    valeur = ''
                    
                    if rep_question:
                        if rep_question.valeur_texte:
                            valeur = rep_question.valeur_texte
                        elif rep_question.valeur_numerique is not None:
                            valeur = rep_question.valeur_numerique
                        elif rep_question.valeur_date:
                            valeur = rep_question.valeur_date.strftime('%Y-%m-%d')
                        
                        # Pour les cases √† cocher
                        if question.type == 'checkbox' and rep_question.options_selectionnees:
                            options = [opt.option.texte for opt in rep_question.options_selectionnees if opt.option]
                            valeur = ', '.join(options)
                    
                    row[f"{categorie.titre} - {question.texte[:50]}"] = valeur
            
            data.append(row)
        
        # Cr√©er DataFrame
        df = pd.DataFrame(data)
        
        # Cr√©er un fichier Excel en m√©moire
        output = BytesIO()
        with pd.ExcelWriter(output, engine='openpyxl') as writer:
            # Feuille principale
            df.to_excel(writer, sheet_name='R√©ponses', index=False)
            
            # Feuille de statistiques
            stats_data = {
                'M√©trique': ['Total r√©ponses', 'R√©ponses compl√®tes', 'R√©ponses en cours', 'Taux de compl√©tion'],
                'Valeur': [
                    len(reponses_filtrees),
                    len([r for r in reponses_filtrees if r.statut == 'complet']),
                    len([r for r in reponses_filtrees if r.statut == 'en_cours']),
                    f"{len([r for r in reponses_filtrees if r.statut == 'complet']) / len(reponses_filtrees) * 100:.1f}%" if reponses_filtrees else '0%'
                ]
            }
            stats_df = pd.DataFrame(stats_data)
            stats_df.to_excel(writer, sheet_name='Statistiques', index=False)
            
            # Ajuster la largeur des colonnes
            for sheet_name in writer.sheets:
                worksheet = writer.sheets[sheet_name]
                for column in worksheet.columns:
                    max_length = 0
                    column_letter = column[0].column_letter
                    for cell in column:
                        try:
                            if len(str(cell.value)) > max_length:
                                max_length = len(str(cell.value))
                        except:
                            pass
                    adjusted_width = min(max_length + 2, 50)
                    worksheet.column_dimensions[column_letter].width = adjusted_width
        
        output.seek(0)
        
        response = make_response(output.getvalue())
        response.headers['Content-Type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        response.headers['Content-Disposition'] = f'attachment; filename=reponses_{questionnaire.code}_{datetime.now().strftime("%Y%m%d_%H%M%S")}.xlsx'
        return response
        
    except ImportError:
        flash('Le module pandas est requis pour l\'export Excel', 'error')
        return redirect(url_for('exporter_questionnaire', id=questionnaire.id))



def correct_module_mapping_for_formule(formule_id):
    """Corrige le mapping des modules pour une formule sp√©cifique"""
    formule = FormuleAbonnement.query.get(formule_id)
    
    if not formule:
        return
    
    # MAPPING COMPLET entre noms de formulaire et noms en base
    template_to_db_mapping = {
        # Formulaire -> Base de donn√©es
        'veille': 'veille_reglementaire',
        'processus': 'gestion_processus',
        'ia_analyse': 'analyse_ia',
        'tableaux_bord_personnalisables': 'tableaux_bord'
    }
    
    corrections = {}
    
    # V√©rifier chaque module probl√©matique
    for template_key, db_key in template_to_db_mapping.items():
        # Si le module est activ√© dans le formulaire mais pas en base
        if formule.modules.get(template_key, False) and not formule.modules.get(db_key, False):
            formule.modules[db_key] = True
            corrections[db_key] = True
            print(f"‚úÖ Correction: {template_key} ‚Üí {db_key} = True")
        
        # Synchroniser les permissions associ√©es
        if db_key in formule.modules:
            # Mapping module ‚Üí permission
            module_permission_map = {
                'veille_reglementaire': ['can_manage_regulatory'],
                'gestion_processus': ['can_manage_logigram'],
                'analyse_ia': ['can_use_ia_analysis']
            }
            
            for module_key, permissions in module_permission_map.items():
                if module_key in formule.modules and formule.modules[module_key]:
                    for perm in permissions:
                        if perm in formule.permissions_template:
                            formule.permissions_template[perm] = True
                            print(f"  üîÑ Permission activ√©e: {perm} (module {module_key} activ√©)")
    
    if corrections:
        db.session.commit()
        print(f"üéâ Formule {formule.nom} corrig√©e: {len(corrections)} modules synchronis√©s")
    
    return corrections
@app.route('/super-admin/correct-modules-mapping')
@login_required
@super_admin_required
def correct_modules_mapping():
    """Corrige le mapping des modules pour toutes les formules"""
    formules = FormuleAbonnement.query.all()
    total_corrections = 0
    
    for formule in formules:
        corrections = correct_module_mapping_for_formule(formule.id)
        if corrections:
            total_corrections += len(corrections)
    
    # Synchroniser tous les utilisateurs
    users_synced = 0
    users = User.query.all()
    
    for user in users:
        if user.client and user.client.formule:
            if sync_user_permissions_with_formule(user.id):
                users_synced += 1
    
    flash(
        f'‚úÖ {total_corrections} modules corrig√©s. '
        f'{users_synced} utilisateurs synchronis√©s.', 
        'success'
    )
    
    return redirect(url_for('super_admin_formules'))

# ========================
# UTILITAIRES POUR LES FORMULES
# ========================

def get_client_usage_stats(client_id):
    """R√©cup√®re les statistiques d'utilisation d'un client"""
    client = Client.query.get(client_id)
    if not client or not client.formule:
        return None
    
    formule = client.formule
    
    stats = {
        'utilisateurs': {
            'current': User.query.filter_by(client_id=client_id, is_active=True).count(),
            'limit': formule.max_utilisateurs,
            'percent': 0
        },
        'risques': {
            'current': Risque.query.filter_by(client_id=client_id, is_archived=False).count(),
            'limit': formule.max_risques,
            'percent': 0
        },
        'audits': {
            'current': Audit.query.filter_by(client_id=client_id, is_archived=False).count(),
            'limit': formule.max_audits,
            'percent': 0
        },
        'processus': {
            'current': Processus.query.filter_by(client_id=client_id).count(),
            'limit': formule.max_processus,
            'percent': 0
        },
        'logigrammes': {
            'current': ProcessusActivite.query.filter_by(client_id=client_id).count(),
            'limit': formule.max_logigrammes,
            'percent': 0
        }
    }
    
    # Calculer les pourcentages
    for key, data in stats.items():
        if data['limit'] > 0:
            data['percent'] = min((data['current'] / data['limit']) * 100, 100)
        else:
            data['percent'] = 0
        
        # Ajouter une classe CSS pour la couleur
        if data['percent'] >= 90:
            data['color_class'] = 'danger'
        elif data['percent'] >= 70:
            data['color_class'] = 'warning'
        else:
            data['color_class'] = 'success'
    
    return stats


def apply_formule_permissions(user):
    """Applique les permissions de la formule √† un utilisateur"""
    if not user.client or not user.client.formule:
        return
    
    formule = user.client.formule
    
    # Mettre √† jour les permissions selon la formule et le r√¥le
    formule_permissions = formule.get_role_permissions(user.role)
    
    # Fusionner avec les permissions existantes (la formule prime)
    if formule_permissions:
        user.permissions.update(formule_permissions)
    
    # Journaliser
    print(f"‚úÖ Permissions formule appliqu√©es pour {user.username}")


def check_route_access_by_formule():
    """Middleware pour v√©rifier l'acc√®s aux routes selon la formule"""
    if current_user.is_authenticated and current_user.client and current_user.client.formule:
        formule = current_user.client.formule
        
        # Mapping des routes vers les modules/features
        route_module_map = {
            'veille_reglementaire': ['veille_reglementaire', 'liste_veilles', 'nouvelle_veille'],
            'liste_logigrammes': ['logigrammes', 'nouveau_logigramme', 'editer_logigramme'],
            'questionnaires': ['questionnaires', 'nouveau_questionnaire'],
            'organigramme': ['organigramme']
        }
        
        current_route = request.endpoint
        
        # V√©rifier chaque route
        for module_code, routes in route_module_map.items():
            if current_route in routes:
                if not formule.can_access_module(module_code):
                    flash(f'Cette fonctionnalit√© n√©cessite la formule {formule.next_level_name() or "sup√©rieure"}', 'error')
                    return redirect(url_for('dashboard'))
                
def init_default_formules():
    """Initialiser les formules par d√©faut avec STRUCTURE CLAIRE ET COH√âRENTE"""
    
    # D√âFINITION CLAIRE DES √âL√âMENTS
    modules_fonctionnels = {
        'cartographie': 'Cartographie des risques',
        'matrices_risque': 'Matrices de risque',
        'suivi_kri': 'Suivi des indicateurs KRI',
        'audit_interne': 'Audit interne',
        'plans_action': 'Plans d\'action',
        'veille_reglementaire': 'Veille r√®glementaire',
        'gestion_processus': 'Gestion des processus',
        'organigramme': 'Organigramme',
        'questionnaires': 'Questionnaires',
        'portail_fournisseurs': 'Portail fournisseurs',
        'reporting_avance': 'Reporting avanc√©',
        'tableaux_bord': 'Tableaux de bord personnalisables',
        'analyse_ia': 'Analyse IA'
    }
    
    features_techniques = {
        'api_avancee': 'API avanc√©e',
        'multi_sites': 'Multi-sites',
        'sauvegardes_auto': 'Sauvegardes automatiques',
        'support_prioritaire': 'Support prioritaire',
        'custom_domain': 'Domaine personnalis√©',
        'sso': 'SSO (Single Sign-On)',
        'import_export': 'Import/Export avanc√©',
        'workflow': 'Workflow personnalisable',
        'notifications': 'Syst√®me de notifications'
    }
    
    roles_autorises = {
        'utilisateur': 'Utilisateur Standard',
        'auditeur': 'Auditeur',
        'manager': 'Manager',
        'admin': 'Administrateur Client',
        'compliance': 'Responsable Conformit√©',
        'consultant': 'Consultant'
    }
    
    permissions_par_module = {
        'cartographie': ['can_manage_risks', 'can_validate_risks'],
        'suivi_kri': ['can_manage_kri'],
        'audit_interne': ['can_manage_audit', 'can_confirm_evaluations'],
        'veille_reglementaire': ['can_manage_regulatory'],
        'gestion_processus': ['can_manage_logigram'],
        'analyse_ia': ['can_use_ia_analysis'],
        'reporting_avance': ['can_export_data', 'can_view_reports'],
        'tableaux_bord': ['can_view_dashboard']
    }
    
    # ============================================
    # FORMULES AVEC STRUCTURE LOGIQUE
    # ============================================
    
    formules = [
        {
            'nom': 'Standard',
            'code': 'standard',
            'description': 'Formule de base pour petites √©quipes - Essentials',
            'prix_mensuel': 99,
            'prix_annuel': 950,
            
            # LIMITES
            'max_utilisateurs': 10,
            'max_risques': 1000,
            'max_audits': 100,
            'max_processus': 20,
            'max_logigrammes': 10,
            'stockage_upload': 1024,  # Mo
            'stockage_documents': 512,  # Mo
            
            # MODULES INCLUS (fonctionnels)
            'modules': {
                'cartographie': True,          # ‚úÖ INCLUS
                'matrices_risque': True,       # ‚úÖ INCLUS
                'suivi_kri': True,             # ‚úÖ INCLUS
                'audit_interne': True,         # ‚úÖ INCLUS
                'plans_action': True,          # ‚úÖ INCLUS
                'veille_reglementaire': False, # ‚ùå EXCLU
                'gestion_processus': False,    # ‚ùå EXCLU
                'organigramme': False,         # ‚ùå EXCLU
                'questionnaires': False,       # ‚ùå EXCLU
                'portail_fournisseurs': False, # ‚ùå EXCLU
                'reporting_avance': False,     # ‚ùå EXCLU
                'tableaux_bord': False,        # ‚ùå EXCLU
                'analyse_ia': True            # ‚ùå EXCLU
            },
            
            # FEATURES TECHNIQUES
            'features': {
                'api_avancee': False,
                'multi_sites': False,
                'sauvegardes_auto': False,
                'support_prioritaire': False,
                'custom_domain': False,
                'sso': False,
                'import_export': True,      # ‚úÖ Basique
                'workflow': False,
                'notifications': True       # ‚úÖ Basique
            },
            
            # R√îLES AUTORIS√âS
            'roles_autorises': ['utilisateur', 'auditeur', 'manager'],
            
            # PERMISSIONS D√âDUITES AUTOMATIQUEMENT DES MODULES
            'permissions_template': {
                # ==================== PERMISSIONS DE BASE ====================
                'can_view_dashboard': True,
                'can_view_reports': True,
                'can_view_departments': True,
                'can_view_users_list': True,   # Peut voir la liste (lecture seule)
                
                # ==================== PERMISSIONS MODULAIRES ====================
                # Cartographie (‚úÖ INCLUS)
                'can_manage_risks': True,
                'can_validate_risks': True,
                
                # KRI (‚úÖ INCLUS)
                'can_manage_kri': True,
                
                # Audit (‚úÖ INCLUS)
                'can_manage_audit': True,
                'can_confirm_evaluations': True,
                
                # Veille r√®glementaire (‚ùå EXCLU)
                'can_manage_regulatory': False,
                
                # Processus (‚ùå EXCLU)
                'can_manage_logigram': False,
                
                # Analyse IA (‚ùå EXCLU)
                'can_use_ia_analysis': True,
                
                # ==================== ADMINISTRATION ====================
                'can_manage_settings': False,
                'can_manage_permissions': False,
                'can_manage_users': False,
                'can_edit_users': False,
                'can_manage_departments': False,
                'can_access_all_departments': False,
                'can_delete_data': False,
                'can_archive_data': False,
                'can_export_data': False,  # Reporting avanc√© exclu
                
                # ==================== PARAM√âTRAGE ====================
                'can_manage_lists': False,
                'can_manage_fields': False,
                'can_manage_files': False,
                'can_manage_templates': False,
                
                # ==================== SYST√àME ====================
                'can_manage_clients': False,
                'can_provision_servers': False
            }
        },
        {
            'nom': 'Premium',
            'code': 'premium',
            'description': 'Formule compl√®te pour entreprises - Tous les modules essentiels',
            'prix_mensuel': 299,
            'prix_annuel': 2990,
            
            # LIMITES
            'max_utilisateurs': 50,
            'max_risques': 5000,
            'max_audits': 500,
            'max_processus': 100,
            'max_logigrammes': 50,
            'stockage_upload': 5120,  # 5 Go
            'stockage_documents': 2048,  # 2 Go
            
            # MODULES INCLUS (TOUS les modules fonctionnels)
            'modules': {
                'cartographie': True,          # ‚úÖ INCLUS
                'matrices_risque': True,       # ‚úÖ INCLUS
                'suivi_kri': True,             # ‚úÖ INCLUS
                'audit_interne': True,         # ‚úÖ INCLUS
                'plans_action': True,          # ‚úÖ INCLUS
                'veille_reglementaire': True,  # ‚úÖ INCLUS
                'gestion_processus': True,     # ‚úÖ INCLUS
                'organigramme': True,          # ‚úÖ INCLUS
                'questionnaires': True,        # ‚úÖ INCLUS
                'portail_fournisseurs': True,  # ‚úÖ INCLUS
                'reporting_avance': True,      # ‚úÖ INCLUS
                'tableaux_bord': True,         # ‚úÖ INCLUS
                'analyse_ia': True             # ‚úÖ INCLUS
            },
            
            # FEATURES TECHNIQUES (avanc√©es)
            'features': {
                'api_avancee': True,
                'multi_sites': True,
                'sauvegardes_auto': True,
                'support_prioritaire': True,
                'custom_domain': True,
                'sso': False,
                'import_export': True,
                'workflow': True,
                'notifications': True
            },
            
            # R√îLES AUTORIS√âS (tous sauf super_admin)
            'roles_autorises': ['utilisateur', 'auditeur', 'manager', 'admin', 'compliance', 'consultant'],
            
            # PERMISSIONS (TOUTES activ√©es sauf syst√®me)
            'permissions_template': {
                # ==================== PERMISSIONS DE BASE ====================
                'can_view_dashboard': True,
                'can_view_reports': True,
                'can_view_departments': True,
                'can_view_users_list': True,
                
                # ==================== PERMISSIONS MODULAIRES ====================
                # Cartographie
                'can_manage_risks': True,
                'can_validate_risks': True,
                
                # KRI
                'can_manage_kri': True,
                
                # Audit
                'can_manage_audit': True,
                'can_confirm_evaluations': True,
                
                # Veille r√®glementaire
                'can_manage_regulatory': True,
                
                # Processus
                'can_manage_logigram': True,
                
                # Analyse IA
                'can_use_ia_analysis': True,
                
                # ==================== ADMINISTRATION ====================
                'can_manage_settings': True,
                'can_manage_permissions': True,
                'can_manage_users': True,
                'can_edit_users': True,
                'can_manage_departments': True,
                'can_access_all_departments': True,
                'can_delete_data': True,
                'can_archive_data': True,
                'can_export_data': True,
                
                # ==================== PARAM√âTRAGE ====================
                'can_manage_lists': True,
                'can_manage_fields': True,
                'can_manage_files': True,
                'can_manage_templates': True,
                
                # ==================== SYST√àME ====================
                'can_manage_clients': False,      # ‚ùå Jamais pour admin client
                'can_provision_servers': False    # ‚ùå Jamais pour admin client
            }
        },
        {
            'nom': 'Enterprise',
            'code': 'enterprise',
            'description': 'Formule sur mesure pour grandes organisations - Solution compl√®te',
            'prix_mensuel': 899,
            'prix_annuel': 8990,
            
            # LIMITES (illimit√©es)
            'max_utilisateurs': 1000,
            'max_risques': 100000,
            'max_audits': 10000,
            'max_processus': 1000,
            'max_logigrammes': 500,
            'stockage_upload': 0,      # 0 = illimit√©
            'stockage_documents': 0,   # 0 = illimit√©
            
            # MODULES INCLUS (TOUT + personnalisation)
            'modules': {key: True for key in modules_fonctionnels.keys()},
            
            # FEATURES TECHNIQUES (TOUTES)
            'features': {key: True for key in features_techniques.keys()},
            
            # R√îLES AUTORIS√âS (TOUS)
            'roles_autorises': list(roles_autorises.keys()),
            
            # PERMISSIONS (TOUTES sauf super_admin exclusives)
            'permissions_template': {
                # ==================== PERMISSIONS DE BASE ====================
                'can_view_dashboard': True,
                'can_view_reports': True,
                'can_view_departments': True,
                'can_view_users_list': True,
                
                # ==================== PERMISSIONS MODULAIRES ====================
                'can_manage_risks': True,
                'can_validate_risks': True,
                'can_manage_kri': True,
                'can_manage_audit': True,
                'can_confirm_evaluations': True,
                'can_manage_regulatory': True,
                'can_manage_logigram': True,
                'can_use_ia_analysis': True,
                
                # ==================== ADMINISTRATION ====================
                'can_manage_settings': True,
                'can_manage_permissions': True,
                'can_manage_users': True,
                'can_edit_users': True,
                'can_manage_departments': True,
                'can_access_all_departments': True,
                'can_delete_data': True,
                'can_archive_data': True,
                'can_export_data': True,
                
                # ==================== PARAM√âTRAGE ====================
                'can_manage_lists': True,
                'can_manage_fields': True,
                'can_manage_files': True,
                'can_manage_templates': True,
                
                # ==================== SYST√àME ====================
                'can_manage_clients': False,      # ‚ùå R√©serv√© super_admin
                'can_provision_servers': False    # ‚ùå R√©serv√© super_admin
            }
        }
    ]
    
    for data in formules:
        existing = FormuleAbonnement.query.filter_by(code=data['code']).first()
        if not existing:
            formule = FormuleAbonnement(
                nom=data['nom'],
                code=data['code'],
                description=data['description'],
                prix_mensuel=data['prix_mensuel'],
                prix_annuel=data['prix_annuel'],
                max_utilisateurs=data['max_utilisateurs'],
                max_risques=data['max_risques'],
                max_audits=data['max_audits'],
                max_processus=data['max_processus'],
                max_logigrammes=data['max_logigrammes'],
                stockage_upload=data['stockage_upload'],
                stockage_documents=data['stockage_documents'],
                features=data['features'],
                modules=data['modules'],
                roles_autorises=data['roles_autorises'],
                permissions_template=data['permissions_template'],
                is_active=True,
                is_public=True,
                ordre_affichage=0
            )
            db.session.add(formule)
            print(f"‚úÖ Formule {data['nom']} cr√©√©e avec structure coh√©rente")
    
    db.session.commit()
    print("‚úÖ Toutes les formules ont √©t√© initialis√©es avec structure claire")

@app.route('/module-restricted/<module>')
@login_required
def module_restricted(module):
    """Page affich√©e quand un module est restreint"""
    
    module_names = {
        'veille': 'Veille r√®glementaire',
        'processus': 'Gestion des processus',
        'logigrammes': 'Logigrammes',
        'questionnaires': 'Questionnaires',
        'organigramme': 'Organigramme',
        'portail_fournisseurs': 'Portail fournisseurs',
        'reporting_avance': 'Reporting avanc√©',
        'tableaux_bord_personnalisables': 'Tableaux de bord personnalisables'
    }
    
    module_name = module_names.get(module, module)
    
    # Suggestions d'upgrade
    upgrade_suggestions = []
    if current_user.client and current_user.client.formule:
        current_formule = current_user.client.formule
        
        # CORRECTION ICI : Utiliser cast_text pour les champs JSON
        try:
            # M√©thode 1 : Filtrer en Python apr√®s r√©cup√©ration
            better_formules = FormuleAbonnement.query.filter(
                FormuleAbonnement.is_active == True,
                FormuleAbonnement.is_public == True
            ).all()
            
            # Filtrer en Python pour celles qui ont le module
            upgrade_suggestions = []
            for formule in better_formules:
                # V√©rifier si la formule a acc√®s au module
                if formule.modules.get(module, False):
                    # V√©rifier si c'est mieux que la formule actuelle
                    if formule.max_utilisateurs > current_formule.max_utilisateurs:
                        upgrade_suggestions.append(formule)
            
            # Limiter √† 3 r√©sultats
            upgrade_suggestions = upgrade_suggestions[:3]
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur recherche upgrade: {e}")
    
    return render_template('errors/formule_restricted.html',
                         module_name=module_name,
                         module_code=module,
                         upgrade_suggestions=upgrade_suggestions)

@app.route('/client-admin/usage')
@login_required
def client_admin_usage():
    """Tableau d'utilisation pour l'admin client"""
    if not current_user.is_client_admin:
        abort(403)
    
    stats = get_client_usage_stats(current_user.client_id)
    
    # Historique des abonnements
    abonnements = AbonnementClient.query.filter_by(
        client_id=current_user.client_id
    ).order_by(AbonnementClient.date_debut.desc()).all()
    
    # Formules disponibles pour upgrade
    formules_upgrade = FormuleAbonnement.query.filter(
        FormuleAbonnement.is_active == True,
        FormuleAbonnement.max_utilisateurs > current_user.client.formule.max_utilisateurs
    ).order_by(FormuleAbonnement.prix_mensuel).all()
    
    return render_template('client_admin/usage.html',
                         stats=stats,
                         abonnements=abonnements,
                         formules_upgrade=formules_upgrade,
                         current_user=current_user)
# ========================
# ROUTES POUR LA GESTION DES LIMITES
# ========================

@app.route('/api/formule/check-limits')
@login_required
def api_check_formule_limits():
    """V√©rifier les limites de la formule actuelle"""
    if not current_user.client or not current_user.client.formule:
        return jsonify({'error': 'Pas de formule active'}), 400
    
    formule = current_user.client.formule
    client = current_user.client
    
    stats = {
        'utilisateurs': {
            'current': User.query.filter_by(client_id=client.id, is_active=True).count(),
            'limit': formule.max_utilisateurs,
            'percent': 0
        },
        'risques': {
            'current': Risque.query.filter_by(client_id=client.id, is_archived=False).count(),
            'limit': formule.max_risques,
            'percent': 0
        },
        'audits': {
            'current': Audit.query.filter_by(client_id=client.id, is_archived=False).count(),
            'limit': formule.max_audits,
            'percent': 0
        }
    }
    
    # Calculer les pourcentages
    for key, data in stats.items():
        if data['limit'] > 0:
            data['percent'] = min((data['current'] / data['limit']) * 100, 100)
        else:
            data['percent'] = 0
        
        data['near_limit'] = data['percent'] > 80
        data['critical'] = data['percent'] > 90
    
    return jsonify({
        'formule': {
            'nom': formule.nom,
            'code': formule.code,
            'limits': {
                'utilisateurs': formule.max_utilisateurs,
                'risques': formule.max_risques,
                'audits': formule.max_audits,
                'processus': formule.max_processus,
                'logigrammes': formule.max_logigrammes
            }
        },
        'stats': stats,
        'can_upgrade': FormuleAbonnement.query.filter(
            FormuleAbonnement.is_active == True,
            FormuleAbonnement.max_utilisateurs > formule.max_utilisateurs
        ).count() > 0
    })


@app.route('/api/formule/modules/<module_code>/access')
@login_required
def api_check_module_access(module_code):
    """V√©rifier l'acc√®s √† un module sp√©cifique"""
    if not current_user.client or not current_user.client.formule:
        return jsonify({'has_access': False, 'reason': 'Pas de formule active'})
    
    formule = current_user.client.formule
    has_access = formule.can_access_module(module_code)
    
    result = {
        'has_access': has_access,
        'module': module_code,
        'formule': {
            'nom': formule.nom,
            'code': formule.code
        }
    }
    
    if not has_access:
        # Proposer des alternatives
        upgrade_options = FormuleAbonnement.query.filter(
            FormuleAbonnement.is_active == True,
            FormuleAbonnement.modules[module_code] == True
        ).order_by(FormuleAbonnement.prix_mensuel).all()
        
        result['upgrade_options'] = [{
            'id': f.id,
            'nom': f.nom,
            'code': f.code,
            'prix_mensuel': f.prix_mensuel,
            'prix_annuel': f.prix_annuel
        } for f in upgrade_options]
    
    return jsonify(result)


# ========================
# MIDDLEWARE POUR V√âRIFIER LES LIMITES
# ========================

@app.before_request
def check_formule_limits_middleware():
    """Middleware pour v√©rifier les limites de formule avant certaines actions"""
    if not current_user.is_authenticated:
        return
    
    # V√©rifier seulement pour les actions de cr√©ation
    if request.method not in ['POST', 'PUT']:
        return
    
    # Liste des endpoints √† v√©rifier
    limit_check_endpoints = {
        'admin_nouvel_utilisateur': 'utilisateurs',
        'nouveau_risque': 'risques',
        'nouvel_audit': 'audits',
        'nouveau_processus': 'processus',
        'nouveau_logigramme': 'logigrammes'
    }
    
    endpoint = request.endpoint
    if endpoint in limit_check_endpoints:
        limit_type = limit_check_endpoints[endpoint]
        
        if current_user.client and current_user.client.formule:
            formule = current_user.client.formule
            
            # Obtenir le compteur actuel
            if limit_type == 'utilisateurs':
                current_count = User.query.filter_by(client_id=current_user.client_id, is_active=True).count()
                limit = formule.max_utilisateurs
            elif limit_type == 'risques':
                current_count = Risque.query.filter_by(client_id=current_user.client_id, is_archived=False).count()
                limit = formule.max_risques
            elif limit_type == 'audits':
                current_count = Audit.query.filter_by(client_id=current_user.client_id, is_archived=False).count()
                limit = formule.max_audits
            elif limit_type == 'processus':
                current_count = Processus.query.filter_by(client_id=current_user.client_id).count()
                limit = formule.max_processus
            elif limit_type == 'logigrammes':
                current_count = ProcessusActivite.query.filter_by(client_id=current_user.client_id).count()
                limit = formule.max_logigrammes
            else:
                return
            
            # V√©rifier la limite
            if current_count >= limit:
                flash(f'Limite de {limit_type} atteinte ({limit}). Veuillez mettre √† niveau votre formule.', 'error')
                
                # Stocker les donn√©es du formulaire pour ne pas les perdre
                if request.method == 'POST':
                    for key, value in request.form.items():
                        if key != 'csrf_token':
                            session[f'form_data_{key}'] = value
                
                return redirect(request.referrer or url_for('dashboard'))


# ========================
# ROUTES POUR LES UPGRADES
# ========================

@app.route('/client/request-upgrade', methods=['POST'])
@login_required
def client_request_upgrade():
    """Demande d'upgrade de formule par un client"""
    if not current_user.is_client_admin:
        flash('Seuls les administrateurs client peuvent demander un upgrade', 'error')
        return redirect(url_for('dashboard'))
    
    formule_id = request.form.get('formule_id')
    
    if not formule_id:
        flash('Veuillez s√©lectionner une formule', 'error')
        return redirect(url_for('client_admin_usage'))
    
    try:
        formule = FormuleAbonnement.query.get_or_404(formule_id)
        
        # Cr√©er une demande d'upgrade
        demande = {
            'client_id': current_user.client_id,
            'client_nom': current_user.client.nom,
            'current_formule': current_user.client.formule.nom if current_user.client.formule else 'Aucune',
            'requested_formule': formule.nom,
            'requested_by': current_user.username,
            'timestamp': datetime.utcnow().isoformat(),
            'status': 'pending'
        }
        
        # Ici, vous pourriez :
        # 1. Envoyer un email au support
        # 2. Cr√©er une notification pour les super admins
        # 3. Enregistrer dans une table de demandes
        
        # Pour l'instant, on simule
        flash(f'Demande d\'upgrade vers {formule.nom} envoy√©e au support. Notre √©quipe vous contactera rapidement.', 'success')
        
        # Journaliser
        log_activity(current_user.id, 'upgrade_request',
                    f"Demande d'upgrade vers {formule.nom}",
                    'client', current_user.client_id)
        
        return redirect(url_for('client_admin_usage'))
        
    except Exception as e:
        flash(f'Erreur: {str(e)}', 'error')
        return redirect(url_for('client_admin_usage'))


# ========================
# API POUR LE FRONTEND
# ========================

@app.route('/api/client/formule/details')
@login_required
def api_client_formule_details():
    """D√©tails de la formule du client actuel"""
    if not current_user.client or not current_user.client.formule:
        return jsonify({'error': 'Pas de formule active'}), 404
    
    formule = current_user.client.formule
    
    return jsonify({
        'formule': {
            'id': formule.id,
            'nom': formule.nom,
            'code': formule.code,
            'description': formule.description,
            'prix_mensuel': formule.prix_mensuel,
            'prix_annuel': formule.prix_annuel,
            'modules': formule.get_modules_list(),
            'features': formule.get_features_list(),
            'limits': {
                'utilisateurs': formule.max_utilisateurs,
                'risques': formule.max_risques,
                'audits': formule.max_audits,
                'processus': formule.max_processus,
                'logigrammes': formule.max_logigrammes
            }
        },
        'abonnement': {
            'date_debut': current_user.client.abonnements[0].date_debut.isoformat() if current_user.client.abonnements else None,
            'statut': current_user.client.abonnements[0].statut if current_user.client.abonnements else None
        } if current_user.client.abonnements else None
    })


@app.route('/api/formule/<int:formule_id>/comparison')
@login_required
def api_formule_comparison(formule_id):
    """Comparaison entre la formule actuelle et une autre formule"""
    if not current_user.client or not current_user.client.formule:
        return jsonify({'error': 'Pas de formule active'}), 404
    
    current_formule = current_user.client.formule
    target_formule = FormuleAbonnement.query.get_or_404(formule_id)
    
    comparison = {
        'current': {
            'nom': current_formule.nom,
            'code': current_formule.code,
            'prix_mensuel': current_formule.prix_mensuel,
            'limits': {
                'utilisateurs': current_formule.max_utilisateurs,
                'risques': current_formule.max_risques,
                'audits': current_formule.max_audits
            },
            'modules_count': len(current_formule.get_modules_list()),
            'features_count': len(current_formule.get_features_list())
        },
        'target': {
            'nom': target_formule.nom,
            'code': target_formule.code,
            'prix_mensuel': target_formule.prix_mensuel,
            'limits': {
                'utilisateurs': target_formule.max_utilisateurs,
                'risques': target_formule.max_risques,
                'audits': target_formule.max_audits
            },
            'modules_count': len(target_formule.get_modules_list()),
            'features_count': len(target_formule.get_features_list())
        },
        'differences': {
            'price_difference': target_formule.prix_mensuel - current_formule.prix_mensuel,
            'users_increase': target_formule.max_utilisateurs - current_formule.max_utilisateurs,
            'risks_increase': target_formule.max_risques - current_formule.max_risques,
            'audits_increase': target_formule.max_audits - current_formule.max_audits,
            'new_modules': list(set(target_formule.get_modules_list()) - set(current_formule.get_modules_list())),
            'new_features': list(set(target_formule.get_features_list()) - set(current_formule.get_features_list()))
        }
    }
    
    return jsonify(comparison)


# ========================
# UTILITAIRES POUR LES TEMPLATES
# ========================

@app.context_processor
def inject_formule_info():
    """Injecter les informations de formule dans tous les templates"""
    formule_info = {
        'current_formule': None,
        'has_formule': False,
        'formule_limits': {},
        'can_upgrade': False,
        'is_module_restricted': lambda module: False
    }
    
    if current_user.is_authenticated and current_user.client and current_user.client.formule:
        formule = current_user.client.formule
        formule_info['current_formule'] = formule
        formule_info['has_formule'] = True
        formule_info['formule_limits'] = {
            'utilisateurs': formule.max_utilisateurs,
            'risques': formule.max_risques,
            'audits': formule.max_audits
        }
        
        # V√©rifier s'il y a des options d'upgrade
        formule_info['can_upgrade'] = FormuleAbonnement.query.filter(
            FormuleAbonnement.is_active == True,
            FormuleAbonnement.max_utilisateurs > formule.max_utilisateurs
        ).count() > 0
        
        # Fonction pour v√©rifier l'acc√®s aux modules
        def check_module_access(module_code):
            return formule.can_access_module(module_code)
        
        formule_info['is_module_restricted'] = check_module_access
    
    return formule_info


@app.route('/super-admin/formules')
@login_required
@super_admin_required
def super_admin_formules():
    """Liste des formules d'abonnement"""
    formules = FormuleAbonnement.query.order_by(FormuleAbonnement.ordre_affichage).all()
    return render_template('super_admin/formules/liste.html', formules=formules)


@app.route('/super-admin/formule/nouvelle', methods=['GET', 'POST'])
@login_required
@super_admin_required
def super_admin_nouvelle_formule():
    """Cr√©er une nouvelle formule"""
    form = FormuleAbonnementForm()
    
    if form.validate_on_submit():
        try:
            formule = FormuleAbonnement(
                nom=form.nom.data,
                code=form.code.data,
                description=form.description.data,
                prix_mensuel=form.prix_mensuel.data,
                prix_annuel=form.prix_annuel.data,
                max_utilisateurs=form.max_utilisateurs.data,
                max_risques=form.max_risques.data,
                max_audits=form.max_audits.data,
                max_processus=form.max_processus.data or 50,
                max_logigrammes=form.max_logigrammes.data or 20,
                stockage_upload=form.stockage_upload.data,
                stockage_documents=form.stockage_documents.data,
                is_active=form.is_active.data,
                is_public=form.is_public.data,
                ordre_affichage=form.ordre_affichage.data
            )
            
            # Features par d√©faut selon le code
            if formule.code in ['standard', 'premium', 'enterprise']:
                if formule.code == 'standard':
                    formule.features['veille_reglementaire'] = False
                    formule.features['logigrammes'] = False
                    formule.features['ia_analyse'] = False
                    formule.modules['veille'] = False
                    formule.modules['processus'] = False
                    formule.roles_autorises = ['utilisateur', 'auditeur', 'manager', 'admin']
                
                elif formule.code == 'premium':
                    formule.features['veille_reglementaire'] = True
                    formule.features['logigrammes'] = True
                    formule.features['ia_analyse'] = True
                    formule.modules['veille'] = True
                    formule.modules['processus'] = True
                    formule.roles_autorises = ['utilisateur', 'auditeur', 'manager', 'admin', 'compliance']
                
                elif formule.code == 'enterprise':
                    # Toutes les features activ√©es
                    for feature in formule.features.keys():
                        formule.features[feature] = True
                    for module in formule.modules.keys():
                        formule.modules[module] = True
                    formule.roles_autorises = ['utilisateur', 'auditeur', 'manager', 'admin', 'compliance', 'consultant']
            
            db.session.add(formule)
            db.session.commit()
            
            flash(f'Formule {formule.nom} cr√©√©e avec succ√®s', 'success')
            return redirect(url_for('super_admin_editer_formule', id=formule.id))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur cr√©ation formule: {str(e)}', 'error')
    
    return render_template('super_admin/formules/nouvelle.html', form=form)


@app.route('/super-admin/formule/<int:id>', methods=['GET', 'POST'])
@login_required
@super_admin_required
def super_admin_editer_formule(id):
    """√âditer une formule d'abonnement"""
    formule = FormuleAbonnement.query.get_or_404(id)
    
    # Formulaire principal
    form = FormuleAbonnementForm(obj=formule)
    
    # Formulaires pour les d√©tails
    features_form = FeaturesForm(data=formule.features)
    modules_form = ModulesForm(data=formule.modules)
    roles_form = RolesForm()
    
    # Pr√©-remplir roles_form
    for role in ['utilisateur', 'auditeur', 'manager', 'admin', 'compliance', 'consultant']:
        if hasattr(roles_form, role):
            getattr(roles_form, role).data = (role in formule.roles_autorises)
    
    # Statistiques d'utilisation
    clients_count = Client.query.filter_by(formule_id=formule.id).count()
    
    if form.validate_on_submit():
        try:
            # Mettre √† jour les donn√©es de base
            formule.nom = form.nom.data
            formule.code = form.code.data
            formule.description = form.description.data
            formule.prix_mensuel = form.prix_mensuel.data
            formule.prix_annuel = form.prix_annuel.data
            formule.max_utilisateurs = form.max_utilisateurs.data
            formule.max_risques = form.max_risques.data
            formule.max_audits = form.max_audits.data
            formule.max_processus = form.max_processus.data
            formule.max_logigrammes = form.max_logigrammes.data
            formule.stockage_upload = form.stockage_upload.data
            formule.stockage_documents = form.stockage_documents.data
            formule.is_active = form.is_active.data
            formule.is_public = form.is_public.data
            formule.ordre_affichage = form.ordre_affichage.data
            formule.updated_at = datetime.utcnow()
            
            db.session.commit()
            flash('Formule mise √† jour avec succ√®s', 'success')
            return redirect(url_for('super_admin_editer_formule', id=id))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur: {str(e)}', 'error')
    
    return render_template('super_admin/formules/editer.html',
                         formule=formule,
                         form=form,
                         features_form=features_form,
                         modules_form=modules_form,
                         roles_form=roles_form,
                         clients_count=clients_count)


def verify_user_permissions(user_id):
    """V√©rifie et corrige les permissions probl√©matiques d'un utilisateur"""
    user = User.query.get(user_id)
    if not user or not user.client or not user.client.formule:
        return False
    
    formule = user.client.formule
    problems = []
    
    # V√©rifier chaque permission
    for perm_key, is_active in user.permissions.items():
        # V√©rifier si la formule permet cette permission
        if perm_key in formule.permissions_template:
            if not formule.permissions_template[perm_key] and is_active:
                problems.append({
                    'permission': perm_key,
                    'user_has': True,
                    'formule_allows': False
                })
        
        # V√©rifier les permissions li√©es aux modules
        permission_module_map = {
            'can_manage_regulatory': 'veille',
            'can_manage_logigram': 'processus'
        }
        
        if perm_key in permission_module_map:
            module = permission_module_map[perm_key]
            if not formule.can_access_module(module) and is_active:
                problems.append({
                    'permission': perm_key,
                    'user_has': True,
                    'module_accessible': False,
                    'module': module
                })
    
    # Si probl√®mes, corriger automatiquement
    if problems:
        print(f"‚ö†Ô∏è Probl√®mes d√©tect√©s pour {user.username}:")
        for problem in problems:
            print(f"  - {problem['permission']}: activ√©e mais non autoris√©e")
        
        # Corriger
        for problem in problems:
            user.permissions[problem['permission']] = False
        
        user.updated_at = datetime.utcnow()
        
        try:
            db.session.commit()
            print(f"‚úÖ Permissions corrig√©es pour {user.username}")
            return True
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Erreur correction: {e}")
            return False
    
    return True


# Route pour v√©rifier tous les utilisateurs d'un client
@app.route('/admin/verify-permissions/<int:client_id>')
@login_required
@super_admin_required
def admin_verify_permissions(client_id):
    """V√©rifie les permissions de tous les utilisateurs d'un client"""
    client = Client.query.get_or_404(client_id)
    users = User.query.filter_by(client_id=client_id).all()
    
    fixed_count = 0
    for user in users:
        if verify_user_permissions(user.id):
            fixed_count += 1
    
    flash(f'‚úÖ {fixed_count}/{len(users)} utilisateurs v√©rifi√©s et corrig√©s si n√©cessaire', 'success')
    return redirect(url_for('super_admin_client_detail', id=client_id))

def update_permissions_based_on_features(formule):
    """Met √† jour les permissions template en fonction des features activ√©es"""
    
    # Copier les permissions existantes
    permissions = formule.permissions_template.copy()
    
    # Mapper features ‚Üí permissions
    feature_to_permission = {
        'veille_reglementaire': 'can_manage_regulatory',
        'logigrammes': 'can_manage_logigram',
        'ia_analyse': 'can_view_reports',  # Exemple
        'reports_avances': 'can_export_data',
        'api_avancee': 'can_export_data',
        'multi_sites': 'can_access_all_departments'
    }
    
    # Mettre √† jour les permissions
    for feature, perm in feature_to_permission.items():
        if feature in formule.features:
            permissions[perm] = formule.features[feature]
    
    # Permissions de base selon la formule
    if formule.code == 'standard':
        # Standard a des limitations
        permissions.update({
            'can_manage_regulatory': False,
            'can_manage_logigram': False,
            'can_manage_permissions': False,
            'can_manage_settings': False,
            'can_delete_data': False,
            'can_archive_data': False,
            'can_manage_departments': False,
            'can_access_all_departments': False,
            'can_view_users_list': True,  # Admin client peut voir
            'can_edit_users': True,       # Admin client peut √©diter
            'can_manage_clients': False,  # Jamais pour admin client
            'can_provision_servers': False
        })
    elif formule.code == 'premium':
        # Premium a plus d'acc√®s
        permissions.update({
            'can_manage_regulatory': True,
            'can_manage_logigram': True,
            'can_manage_permissions': True,
            'can_manage_settings': True,
            'can_delete_data': True,
            'can_archive_data': True,
            'can_manage_departments': True,
            'can_access_all_departments': False,
            'can_view_users_list': True,
            'can_edit_users': True,
            'can_manage_clients': False,
            'can_provision_servers': False
        })
    elif formule.code == 'enterprise':
        # Enterprise a tout (sauf super admin)
        for key in permissions.keys():
            if key not in ['can_manage_clients', 'can_provision_servers']:
                permissions[key] = True
    
    formule.permissions_template = permissions
    return formule

# CORRECTION dans super_admin_update_formule_modules
@app.route('/super-admin/formule/<int:id>/modules', methods=['POST'])
@login_required
@super_admin_required
def super_admin_update_formule_modules(id):
    """Mettre √† jour les modules d'une formule - VERSION CORRIG√âE"""
    formule = FormuleAbonnement.query.get_or_404(id)
    
    try:
        print("üîç D√©but traitement formulaire modules")
        
        # Liste COMPL√àTE des modules avec leurs noms EXACTS du formulaire
        modules_list = [
            # Modules standards
            'cartographie',
            'matrices_risque', 
            'suivi_kri',
            'audit_interne',
            'plans_action',  # <-- IMPORTANT: plans_action EST ICI
            'organigramme',
            'questionnaires',
            'portail_fournisseurs',
            'reporting_avance',
            # Modules probl√©matiques (noms CORRECTS du formulaire)
            'veille_reglementaire',
            'gestion_processus',  
            'analyse_ia',
            'tableaux_bord'
        ]
        
        # R√©cup√©rer les donn√©es
        modules_data = {}
        for module_name in modules_list:
            input_name = f"modules-{module_name}"
            is_checked = request.form.get(input_name) == 'on'
            modules_data[module_name] = is_checked
            
            print(f"  üì¶ {input_name}: {is_checked}")
        
        # ============================================
        # ATTENTION : Vous avez `plans_action: False` !
        # C'est pourquoi l'acc√®s est refus√© !
        # ============================================
        
        # Mettre √† jour la formule
        formule.modules = modules_data
        formule.updated_at = datetime.utcnow()  # <-- CORRECTION ICI
        
        # ============================================
        # SYNCHRONISATION CRITIQUE DES PERMISSIONS
        # ============================================
        print("üîÑ Synchronisation des permissions...")
        
        # Mappage COMPLET module ‚Üí permissions (INCLUANT plans_action)
        module_permission_map = {
            'cartographie': ['can_manage_risks', 'can_validate_risks'],
            'suivi_kri': ['can_manage_kri'],
            'audit_interne': ['can_manage_audit', 'can_confirm_evaluations'],
            'plans_action': ['can_manage_action_plans', 'can_view_action_plans'],  # CRITIQUE
            'veille_reglementaire': ['can_manage_regulatory'],
            'gestion_processus': ['can_manage_logigram'], 
            'analyse_ia': ['can_use_ia_analysis'],
            'tableaux_bord': ['can_view_dashboard'],
            'reporting_avance': ['can_export_data'],
            'questionnaires': ['can_manage_questionnaires'],
            'organigramme': ['can_manage_organigramme']
        }
        
        # Initialiser permissions_template si n√©cessaire
        if formule.permissions_template is None:
            formule.permissions_template = {}
        
        # Synchroniser chaque module
        for module_name, permission_list in module_permission_map.items():
            is_module_active = modules_data.get(module_name, False)
            
            for permission in permission_list:
                current_value = formule.permissions_template.get(permission, False)
                
                # FORCER la synchronisation
                if current_value != is_module_active:
                    formule.permissions_template[permission] = is_module_active
                    print(f"  üîÑ {permission}: {current_value} ‚Üí {is_module_active} (module: {module_name})")
        
        # Assurer que toutes les permissions de base sont pr√©sentes
        base_permissions = {
            'can_view_dashboard': True,
            'can_view_reports': True,
            'can_view_departments': True,
            'can_view_users_list': True
        }
        
        for perm, value in base_permissions.items():
            if perm not in formule.permissions_template:
                formule.permissions_template[perm] = value
                print(f"  ‚ûï {perm} ajout√©: {value}")
        
        db.session.commit()
        print("‚úÖ Modules et permissions mis √† jour avec succ√®s")
        
        # ============================================
        # CRITIQUE : VOTRE PROBLEME EST ICI !
        # plans_action EST D√âSACTIV√â (False) !
        # ============================================
        if not modules_data.get('plans_action', False):
            print("""
            ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è ATTENTION ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è
            Le module 'plans_action' est D√âSACTIV√â !
            Les utilisateurs n'auront PAS acc√®s aux plans d'action.
            
            Pour corriger :
            1. Allez dans Super Admin ‚Üí Formules
            2. √âditez votre formule
            3. Cochez "Plans d'action" dans les modules
            4. Sauvegardez
            """)
        
        # ============================================
        # SYNCHRONISER TOUS LES UTILISATEURS
        # ============================================
        print("üîÑ Synchronisation des utilisateurs...")
        
        users_synced = 0
        for client in formule.clients:
            users = User.query.filter_by(client_id=client.id).all()
            
            for user in users:
                if sync_user_permissions_with_formule(user.id):
                    users_synced += 1
        
        flash(
            f'‚úÖ Modules mis √† jour avec succ√®s. '
            f'{users_synced} utilisateurs synchronis√©s.', 
            'success'
        )
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur: {str(e)}")
        import traceback
        traceback.print_exc()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
    
    return redirect(url_for('super_admin_editer_formule', id=id))

@app.route('/sync-all-super-admin-permissions')
@login_required
@super_admin_required
def sync_all_super_admin_permissions():
    """Synchroniser TOUTES les permissions pour TOUS les super admins"""
    
    try:
        super_admins = User.query.filter_by(role='super_admin').all()
        
        for user in super_admins:
            print(f"üîÑ Synchronisation super admin: {user.username}")
            
            if user.permissions is None:
                user.permissions = {}
            
            # Permissions COMPL√àTES pour super admin
            all_permissions = {
                # Permissions de base
                'can_view_dashboard': True,
                'can_view_reports': True,
                'can_view_departments': True,
                'can_view_users_list': True,
                'can_view_action_plans': True,
                
                # Permissions modules
                'can_manage_risks': True,
                'can_validate_risks': True,
                'can_manage_kri': True,
                'can_manage_audit': True,
                'can_confirm_evaluations': True,
                'can_manage_regulatory': True,
                'can_manage_logigram': True,
                'can_use_ia_analysis': True,
                'can_manage_action_plans': True,
                
                # Administration
                'can_manage_settings': True,
                'can_manage_permissions': True,
                'can_manage_users': True,
                'can_edit_users': True,
                'can_manage_departments': True,
                'can_access_all_departments': True,
                'can_delete_data': True,
                'can_archive_data': True,
                'can_export_data': True,
                
                # Param√©trage
                'can_manage_lists': True,
                'can_manage_fields': True,
                'can_manage_files': True,
                'can_manage_templates': True,
                
                # Syst√®me
                'can_manage_clients': True,
                'can_provision_servers': True
            }
            
            # Mettre √† jour TOUTES les permissions
            user.permissions.update(all_permissions)
            
            # S'assurer qu'il n'y a pas de valeurs null
            for key in list(user.permissions.keys()):
                if user.permissions[key] is None:
                    user.permissions[key] = True
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'synced_count': len(super_admins),
            'message': f'{len(super_admins)} super admins synchronis√©s'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/debug/complete-access-check')
@login_required
def debug_complete_access_check():
    """Diagnostic complet de l'acc√®s aux plans d'action"""
    
    user = current_user
    
    # 1. V√©rifier les permissions directes
    user_permissions = user.permissions or {}
    
    # 2. V√©rifier la formule
    formule_info = None
    if user.client and user.client.formule:
        formule = user.client.formule
        formule_info = {
            'nom': formule.nom,
            'code': formule.code,
            'modules': formule.modules,
            'permissions_template': formule.permissions_template
        }
    
    # 3. V√©rifier get_all_permissions_with_formule_check
    all_perms_check = get_all_permissions_with_formule_check(user)
    plans_in_all_perms = False
    plans_permission_status = {}
    
    for category_name, category_perms in all_perms_check.items():
        for perm_key, perm_data in category_perms.items():
            if 'action' in perm_key.lower():
                plans_in_all_perms = True
                plans_permission_status[perm_key] = perm_data
    
    # 4. V√©rifier le d√©corateur check_module_access
    from flask import request
    original_endpoint = request.endpoint
    
    # 5. Simuler l'acc√®s au module
    module_code = 'plans_action'
    
    return jsonify({
        'user': {
            'id': user.id,
            'username': user.username,
            'role': user.role,
            'is_client_admin': getattr(user, 'is_client_admin', False),
            'permissions_count': len(user_permissions),
            'specific_permissions': {
                'can_manage_action_plans': user_permissions.get('can_manage_action_plans'),
                'can_view_action_plans': user_permissions.get('can_view_action_plans'),
                'can_manage_risks': user_permissions.get('can_manage_risks'),
                'can_view_dashboard': user_permissions.get('can_view_dashboard')
            }
        },
        'client': {
            'id': user.client_id,
            'nom': user.client.nom if user.client else None
        } if user.client else None,
        'formule': formule_info,
        'all_permissions_check': {
            'contains_plans': plans_in_all_perms,
            'plans_permissions': plans_permission_status,
            'total_categories': len(all_perms_check)
        },
        'module_access_simulation': {
            'module_code': module_code,
            'in_all_perms': plans_in_all_perms,
            'mapping_in_decorator': 'plans_action' in {
                'veille': 'veille_reglementaire',
                'processus': 'gestion_processus',
                'logigrammes': 'gestion_processus',
                'ia_analyse': 'analyse_ia',
                'tableaux_bord_personnalisables': 'tableaux_bord',
                'plans_action': 'plans_action'
            }
        },
        'check_module_access_function': str(check_module_access.__name__ if hasattr(check_module_access, '__name__') else 'Unknown')
    })

@app.route('/force-fix-now-ultimate')
@login_required
@super_admin_required
def force_fix_now_ultimate():
    """Correction ULTIME - Force les permissions manquantes"""
    
    try:
        user = current_user
        
        print(f"üö® CORRECTION ULTIME pour {user.username}")
        print(f"   Avant: {user.permissions}")
        
        # RECR√âER compl√®tement les permissions
        ultimate_permissions = {
            # Permissions de base
            'can_view_dashboard': True,
            'can_view_reports': True,
            'can_view_departments': True,
            'can_view_users_list': True,
            'can_view_action_plans': True,  # ‚Üê FORCER
            'can_edit_users': True,
            
            # Modules
            'can_manage_risks': True,
            'can_validate_risks': True,
            'can_manage_kri': True,
            'can_manage_audit': True,
            'can_confirm_evaluations': True,
            'can_manage_regulatory': True,
            'can_manage_logigram': True,
            'can_use_ia_analysis': True,
            'can_manage_action_plans': True,  # ‚Üê FORCER
            
            # Administration
            'can_manage_settings': True,
            'can_manage_permissions': True,
            'can_manage_users': True,
            'can_manage_departments': True,
            'can_access_all_departments': True,
            'can_delete_data': True,
            'can_archive_data': True,
            'can_export_data': True,
            
            # Param√©trage
            'can_manage_lists': True,
            'can_manage_fields': True,
            'can_manage_files': True,
            'can_manage_templates': True,
            
            # Syst√®me
            'can_manage_clients': True,
            'can_provision_servers': True
        }
        
        # REMPLACER compl√®tement les permissions
        user.permissions = ultimate_permissions
        
        # FORCER le commit
        db.session.commit()
        
        # RAFRA√éCHIR l'objet depuis la base
        db.session.refresh(user)
        
        print(f"‚úÖ Apr√®s: {user.permissions}")
        
        return jsonify({
            'success': True,
            'message': 'Permissions ULTIME appliqu√©es',
            'permissions_verify': {
                'can_manage_action_plans': user.permissions.get('can_manage_action_plans'),
                'can_view_action_plans': user.permissions.get('can_view_action_plans'),
                'total_permissions': len(user.permissions)
            }
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500

@app.route('/debug-module-state/<int:formule_id>')
@login_required
@super_admin_required
def debug_module_state(formule_id):
    """Debug l'√©tat des modules d'une formule"""
    formule = FormuleAbonnement.query.get_or_404(formule_id)
    
    debug_info = {
        'formule': {
            'id': formule.id,
            'nom': formule.nom,
            'code': formule.code
        },
        'modules': formule.modules,
        'permissions': formule.permissions_template,
        'modules_problematiques': {
            'veille_reglementaire': {
                'actif': formule.modules.get('veille_reglementaire', False),
                'permission': formule.permissions_template.get('can_manage_regulatory', False),
                'synchronise': formule.modules.get('veille_reglementaire', False) == formule.permissions_template.get('can_manage_regulatory', False)
            },
            'gestion_processus': {
                'actif': formule.modules.get('gestion_processus', False),
                'permission': formule.permissions_template.get('can_manage_logigram', False),
                'synchronise': formule.modules.get('gestion_processus', False) == formule.permissions_template.get('can_manage_logigram', False)
            },
            'analyse_ia': {
                'actif': formule.modules.get('analyse_ia', False),
                'permission': formule.permissions_template.get('can_use_ia_analysis', False),
                'synchronise': formule.modules.get('analyse_ia', False) == formule.permissions_template.get('can_use_ia_analysis', False)
            }
        }
    }
    
    return jsonify(debug_info)

def fix_all_formules_modules_mapping():
    """Corrige le mapping des modules pour toutes les formules"""
    with app.app_context():
        formules = FormuleAbonnement.query.all()
        
        for formule in formules:
            print(f"üîß Correction formule: {formule.nom}")
            
            # V√©rifier et corriger les modules probl√©matiques
            corrections = []
            
            # V√©rifier veille
            if 'veille' in formule.modules and 'veille_reglementaire' not in formule.modules:
                formule.modules['veille_reglementaire'] = formule.modules['veille']
                corrections.append('veille ‚Üí veille_reglementaire')
            
            # V√©rifier processus
            if 'processus' in formule.modules and 'gestion_processus' not in formule.modules:
                formule.modules['gestion_processus'] = formule.modules['processus']
                corrections.append('processus ‚Üí gestion_processus')
            
            # V√©rifier ia_analyse
            if 'ia_analyse' in formule.modules and 'analyse_ia' not in formule.modules:
                formule.modules['analyse_ia'] = formule.modules['ia_analyse']
                corrections.append('ia_analyse ‚Üí analyse_ia')
            
            # V√©rifier tableaux_bord_personnalisables
            if 'tableaux_bord_personnalisables' in formule.modules and 'tableaux_bord' not in formule.modules:
                formule.modules['tableaux_bord'] = formule.modules['tableaux_bord_personnalisables']
                corrections.append('tableaux_bord_personnalisables ‚Üí tableaux_bord')
            
            if corrections:
                print(f"  ‚úÖ Corrections: {', '.join(corrections)}")
                
                # Mettre √† jour les permissions
                update_permissions_based_on_modules(formule)
        
        db.session.commit()
        print("üéâ Toutes les formules corrig√©es")


def sync_user_permissions_with_formule(user_id):
    """Synchronise les permissions d'un utilisateur avec sa formule - VERSION CORRIG√âE"""
    user = User.query.get(user_id)
    if not user or not user.client or not user.client.formule:
        return False
    
    formule = user.client.formule
    needs_update = False
    
    # Initialiser les permissions
    if user.permissions is None:
        user.permissions = {}
    
    # Mappage COMPLET module ‚Üí permission
    module_permission_map = {
        'veille_reglementaire': 'can_manage_regulatory',
        'gestion_processus': 'can_manage_logigram',
        'analyse_ia': 'can_use_ia_analysis',
        'tableaux_bord': 'can_view_dashboard',
        'suivi_kri': 'can_manage_kri',
        'audit_interne': 'can_manage_audit',
        'reporting_avance': 'can_export_data'
    }
    
    # Synchroniser chaque permission
    for module_name, permission in module_permission_map.items():
        is_module_active = formule.modules.get(module_name, False)
        user_has_permission = user.permissions.get(permission, False)
        
        # Correction n√©cessaire ?
        if user_has_permission != is_module_active:
            user.permissions[permission] = is_module_active
            needs_update = True
            print(f"  üîÑ {permission}: {user_has_permission} ‚Üí {is_module_active}")
    
    if needs_update:
        try:
            user.updated_at = datetime.utcnow()
            db.session.commit()
            print(f"‚úÖ Permissions synchronis√©es pour {user.username}")
            return True
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Erreur: {e}")
            return False
    
    return True


@app.route('/super-admin/correct-modules-permissions')
@login_required
@super_admin_required
def correct_modules_permissions():
    """Correction imm√©diate des permissions pour les modules probl√©matiques"""
    try:
        # R√©cup√©rer toutes les formules
        formules = FormuleAbonnement.query.all()
        total_corrections = 0
        
        for formule in formules:
            print(f"üîß Correction formule: {formule.nom}")
            
            # V√©rifier les modules probl√©matiques
            problem_modules = {
                'veille_reglementaire': ['can_manage_regulatory'],
                'gestion_processus': ['can_manage_logigram'],
                'analyse_ia': ['can_use_ia_analysis']
            }
            
            # S'assurer que permissions_template existe
            if formule.permissions_template is None:
                formule.permissions_template = {}
            
            # Corriger chaque module
            for module_db, permissions in problem_modules.items():
                is_module_active = formule.modules.get(module_db, False)
                
                for permission in permissions:
                    if permission in formule.permissions_template:
                        current_value = formule.permissions_template[permission]
                        
                        # Si incoh√©rence, corriger
                        if current_value != is_module_active:
                            formule.permissions_template[permission] = is_module_active
                            total_corrections += 1
                            print(f"  üîÑ {permission}: {current_value} ‚Üí {is_module_active} (module: {module_db})")
        
        db.session.commit()
        
        # Maintenant synchroniser tous les utilisateurs
        users = User.query.all()
        users_synced = 0
        
        for user in users:
            if user.client and user.client.formule:
                if sync_user_permissions_with_formule(user.id):
                    users_synced += 1
        
        flash(
            f'‚úÖ {total_corrections} permissions corrig√©es dans les formules. '
            f'{users_synced} utilisateurs synchronis√©s.', 'success'
        )
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
    
    return redirect(url_for('super_admin_formules'))

@app.route('/super-admin/formule/<int:id>/roles', methods=['POST'])
@login_required
@super_admin_required
def super_admin_update_formule_roles(id):
    """Mettre √† jour les r√¥les autoris√©s"""
    formule = FormuleAbonnement.query.get_or_404(id)
    
    try:
        # R√©cup√©rer les r√¥les depuis le formulaire
        roles_autorises = []
        for role in ['utilisateur', 'auditeur', 'manager', 'admin', 'compliance', 'consultant']:
            if request.form.get(f'roles-{role}') == 'on':
                roles_autorises.append(role)
        
        formule.roles_autorises = roles_autorises
        formule.updated_at = datetime.utcnow()
        
        db.session.commit()
        flash('R√¥les autoris√©s mis √† jour avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur: {str(e)}', 'error')
    
    return redirect(url_for('super_admin_editer_formule', id=id))


@app.route('/super-admin/formule/<int:id>/dupliquer')
@login_required
@super_admin_required
def super_admin_dupliquer_formule(id):
    """Dupliquer une formule"""
    source = FormuleAbonnement.query.get_or_404(id)
    
    try:
        # Cr√©er une copie
        nouvelle_formule = FormuleAbonnement(
            nom=f"{source.nom} (Copie)",
            code=f"{source.code}_copie_{datetime.utcnow().strftime('%Y%m%d_%H%M')}",
            description=source.description,
            prix_mensuel=source.prix_mensuel,
            prix_annuel=source.prix_annuel,
            max_utilisateurs=source.max_utilisateurs,
            max_risques=source.max_risques,
            max_audits=source.max_audits,
            max_processus=source.max_processus,
            max_logigrammes=source.max_logigrammes,
            stockage_upload=source.stockage_upload,
            stockage_documents=source.stockage_documents,
            features=source.features.copy(),
            modules=source.modules.copy(),
            roles_autorises=source.roles_autorises.copy(),
            permissions_template=source.permissions_template.copy(),
            is_active=False,  # D√©sactiv√©e par d√©faut pour modification
            is_public=False,
            ordre_affichage=source.ordre_affichage + 1
        )
        
        db.session.add(nouvelle_formule)
        db.session.commit()
        
        flash(f'Formule dupliqu√©e avec succ√®s', 'success')
        return redirect(url_for('super_admin_editer_formule', id=nouvelle_formule.id))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur duplication: {str(e)}', 'error')
        return redirect(url_for('super_admin_formules'))


@app.route('/super-admin/formule/<int:id>/supprimer')
@login_required
@super_admin_required
def super_admin_supprimer_formule(id):
    """Supprimer une formule (si aucun client ne l'utilise)"""
    formule = FormuleAbonnement.query.get_or_404(id)
    
    # V√©rifier si des clients utilisent cette formule
    clients_count = Client.query.filter_by(formule_id=formule.id).count()
    
    if clients_count > 0:
        flash(f'Impossible de supprimer: {clients_count} clients utilisent cette formule', 'error')
        return redirect(url_for('super_admin_formules'))
    
    try:
        db.session.delete(formule)
        db.session.commit()
        flash('Formule supprim√©e avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur: {str(e)}', 'error')
    
    return redirect(url_for('super_admin_formules'))


@app.route('/super-admin/client/<int:client_id>/upgrade', methods=['GET', 'POST'])
@login_required
@super_admin_required
def super_admin_upgrade_client(client_id):
    """Changer la formule d'un client"""
    client = Client.query.get_or_404(client_id)
    
    # R√©cup√©rer les formules disponibles
    formules = FormuleAbonnement.query.filter_by(is_active=True).order_by(FormuleAbonnement.ordre_affichage).all()
    
    form = ClientUpgradeForm()
    form.formule_id.choices = [(f.id, f"{f.nom} - {f.prix_mensuel}‚Ç¨/mois") for f in formules]
    
    if form.validate_on_submit():
        try:
            nouvelle_formule = FormuleAbonnement.query.get(form.formule_id.data)
            
            # Cr√©er un nouvel abonnement
            nouvel_abonnement = AbonnementClient(
                client_id=client.id,
                formule_id=nouvelle_formule.id,
                date_debut=form.date_effet.data,
                periode=form.periode.data,
                statut='actif',
                is_renouvellement_auto=form.is_renouvellement_auto.data,
                montant=nouvelle_formule.prix_mensuel if form.periode.data == 'mensuel' else nouvelle_formule.prix_annuel
            )
            
            # Mettre √† jour le client
            client.formule_id = nouvelle_formule.id
            
            # Fermer l'ancien abonnement s'il existe
            ancien_abonnement = AbonnementClient.query.filter_by(
                client_id=client.id, 
                statut='actif'
            ).first()
            
            if ancien_abonnement:
                ancien_abonnement.statut = 'resilie'
                ancien_abonnement.date_fin = form.date_effet.data
                ancien_abonnement.updated_at = datetime.utcnow()
            
            db.session.add(nouvel_abonnement)
            
            # Journaliser
            journal = JournalActiviteClient(
                client_id=client.id,
                utilisateur_id=current_user.id,
                action='changement_formule',
                details={
                    'ancienne_formule': client.formule.nom if client.formule else 'Aucune',
                    'nouvelle_formule': nouvelle_formule.nom,
                    'periode': form.periode.data,
                    'montant': nouvel_abonnement.montant
                }
            )
            db.session.add(journal)
            
            db.session.commit()
            
            flash(f'Client mis √† niveau vers {nouvelle_formule.nom}', 'success')
            return redirect(url_for('super_admin_client_detail', id=client.id))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur: {str(e)}', 'error')
    
    return render_template('super_admin/clients/upgrade.html',
                         client=client,
                         form=form,
                         formules=formules)

@app.route('/admin/journal-activite')
@login_required
@admin_required
def admin_journal_activite():
    """Page d'administration du journal d'activit√©"""
    # R√©cup√©rer les activit√©s r√©centes
    activites = JournalActivite.query.order_by(
        JournalActivite.date_creation.desc()
    ).limit(100).all()
    
    return render_template('admin/journal_activite.html',
                         activites=activites)

@app.route('/api/super-admin/user/<int:user_id>/details')
@login_required
@super_admin_required
def api_super_admin_user_details(user_id):
    """D√©tails d'un utilisateur (super admin uniquement)"""
    user = User.query.get_or_404(user_id)
    
    return jsonify({
        'id': user.id,
        'username': user.username,
        'email': user.email,
        'role': user.role,
        'role_display': user.get_role_display_name(),
        'role_color': {
            'super_admin': 'danger',
            'admin': 'primary',
            'manager': 'success',
            'auditeur': 'warning',
            'utilisateur': 'secondary',
            'consultant': 'info'
        }.get(user.role, 'secondary'),
        'client': {
            'id': user.client_id,
            'nom': user.client.nom if user.client else None,
            'reference': user.client.reference if user.client else None
        } if user.client else None,
        'department': user.department,
        'is_active': user.is_active,
        'is_client_admin': user.is_client_admin,
        'created_at': user.created_at.isoformat(),
        'last_login': user.last_login.isoformat() if user.last_login else None,
        'permissions': user.permissions
    })

@app.route('/super-admin/user/<int:id>/edit', methods=['GET', 'POST'])
@login_required
@super_admin_required
def super_admin_edit_user(id):
    """√âditer un utilisateur (super admin) - VERSION CORRIG√âE"""
    user = User.query.get_or_404(id)
    
    # Utiliser le formulaire corrig√©
    from forms_admin import EditerUtilisateurForm
    form = EditerUtilisateurForm(obj=user)
    
    # Peupler les choix des champs SelectField
    clients = Client.query.order_by(Client.nom).all()
    form.client_id.choices = [(0, 'Sans client')] + [(c.id, f"{c.nom} ({c.reference})") for c in clients]
    
    templates = PermissionTemplate.query.all()
    form.template_permissions.choices = [(0, 'Aucun template')] + [(t.id, t.name) for t in templates]
    
    # Remplir les r√¥les disponibles
    form.role.choices = [
        ('super_admin', 'Super Administrateur'),
        ('admin', 'Administrateur Client'),
        ('manager', 'Manager'),
        ('auditeur', 'Auditeur'),
        ('compliance', 'Responsable Conformit√©'),
        ('utilisateur', 'Utilisateur Standard'),
        ('consultant', 'Consultant')
    ]
    
    if form.validate_on_submit():
        try:
            # Mettre √† jour les champs de base
            user.username = form.username.data
            user.email = form.email.data
            user.role = form.role.data
            user.department = form.department.data
            user.is_active = form.is_active.data
            
            # G√©rer le client_id
            if form.client_id.data and int(form.client_id.data) != 0:
                user.client_id = int(form.client_id.data)
            else:
                user.client_id = None
            
            # G√©rer le mot de passe
            if form.password.data:
                user.set_password(form.password.data)
            
            # G√©rer les permissions
            if form.template_permissions.data and int(form.template_permissions.data) != 0:
                template = PermissionTemplate.query.get(form.template_permissions.data)
                if template:
                    user.permissions = template.permissions
            
            db.session.commit()
            
            # Journaliser
            log_activity(current_user.id, 'modification',
                        f"Modification utilisateur {user.username} par super admin",
                        'utilisateur', user.id)
            
            flash('Utilisateur mis √† jour avec succ√®s', 'success')
            return redirect(url_for('admin_utilisateurs'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur: {str(e)}', 'error')
    
    # Pr√©-remplir les champs pour GET
    form.client_id.data = user.client_id if user.client_id else 0
    form.template_permissions.data = 0  # Par d√©faut
    
    return render_template('super_admin/editer_utilisateur.html', form=form, user=user)


# ========================
# ROUTE POUR LE FORMULAIRE DE CONTACT
# ========================

@app.route('/envoyer-demande', methods=['POST'])
def envoyer_demande():
    """Route pour traiter les demandes de contact"""
    try:
        # R√©cup√©rer les donn√©es
        if request.is_json:
            data = request.get_json()
        else:
            data = request.form
        
        nom_complet = data.get('nom_complet', '').strip()
        email = data.get('email', '').strip().lower()
        societe = data.get('societe', '').strip()
        telephone = data.get('telephone', '').strip()
        sujet = data.get('sujet', '').strip()
        message = data.get('message', '').strip()
        
        # Validation
        errors = []
        if not nom_complet:
            errors.append("Le nom complet est requis")
        if not email or '@' not in email:
            errors.append("Un email valide est requis")
        if not sujet:
            errors.append("Le sujet est requis")
        if not message:
            errors.append("Le message est requis")
        
        if errors:
            return jsonify({
                'success': False,
                'message': 'Veuillez corriger les erreurs :',
                'errors': errors
            }), 400
        
        # G√©n√©rer une r√©f√©rence
        reference = f"DEMO-{datetime.now().strftime('%Y%m%d')}-{hashlib.md5(email.encode()).hexdigest()[:8].upper()}"
        
        # Envoyer les emails
        email_sent = send_contact_email(nom_complet, email, societe, telephone, sujet, message, reference)
        
        # Sauvegarder le log
        try:
            os.makedirs('logs', exist_ok=True)
            log_entry = f"{datetime.now().isoformat()}|{reference}|{email}|{sujet}|{email_sent}\n"
            with open('logs/demandes_contact.log', 'a', encoding='utf-8') as f:
                f.write(log_entry)
        except:
            pass
        
        return jsonify({
            'success': True,
            'message': 'Votre demande a √©t√© envoy√©e avec succ√®s !',
            'reference': reference,
            'email_sent': email_sent
        })
        
    except Exception as e:
        print(f"Erreur: {e}")
        return jsonify({
            'success': False,
            'message': 'Une erreur est survenue. Veuillez r√©essayer.'
        }), 500

# Exempter de CSRF
csrf.exempt(envoyer_demande)

    

@app.route('/api/export/users/csv')
@login_required
@super_admin_required
def export_users_csv():
    """Exporter tous les utilisateurs en CSV (super admin uniquement)"""
    try:
        import csv
        from io import StringIO
        
        users = User.query.order_by(User.client_id, User.role, User.username).all()
        
        output = StringIO()
        writer = csv.writer(output, delimiter=';', quoting=csv.QUOTE_ALL)
        
        # En-t√™te
        writer.writerow([
            'ID', 'Username', 'Email', 'R√¥le', 'Client', 
            'D√©partement', 'Actif', 'Admin Client', 
            'Date cr√©ation', 'Derni√®re connexion'
        ])
        
        # Donn√©es
        for user in users:
            writer.writerow([
                user.id,
                user.username,
                user.email,
                user.get_role_display_name(),
                user.client.nom if user.client else '',
                user.department or '',
                'Oui' if user.is_active else 'Non',
                'Oui' if user.is_client_admin else 'Non',
                user.created_at.strftime('%d/%m/%Y %H:%M'),
                user.last_login.strftime('%d/%m/%Y %H:%M') if user.last_login else ''
            ])
        
        output.seek(0)
        
        return Response(
            output.getvalue(),
            mimetype='text/csv; charset=utf-8',
            headers={
                'Content-Disposition': f'attachment; filename=utilisateurs_{datetime.now().strftime("%Y%m%d_%H%M")}.csv'
            }
        )
        
    except Exception as e:
        flash(f'Erreur export: {str(e)}', 'error')
        return redirect(url_for('admin_utilisateurs'))
    





# ------------------------------------------------------------
# ROUTES D'ADMINISTRATION
# ------------------------------------------------------------

def admin_required(f):
    """D√©corateur qui v√©rifie que l'utilisateur est admin"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            flash('Veuillez vous connecter pour acc√©der √† cette page.', 'error')
            return redirect(url_for('login'))
        
        if current_user.role != 'admin':
            flash('Acc√®s non autoris√©. Cette page est r√©serv√©e aux administrateurs.', 'error')
            return redirect(url_for('dashboard'))
        
        return f(*args, **kwargs)
    return decorated_function

@app.route('/admin/dashboard')
@login_required
@admin_required
def admin_dashboard():
    """Tableau de bord administration avec isolation multi-tenant"""
    
    # V√©rifier si c'est un super admin ou un admin client
    is_super_admin = (current_user.role == 'super_admin')
    is_client_admin = (current_user.role == 'admin' and current_user.is_client_admin)
    
    # R√©cup√©rer les statistiques AVEC ISOLATION
    if is_super_admin:
        # SUPER ADMIN : voit tout
        stats = {
            'users_active': User.query.filter_by(is_active=True).count(),
            'users_total': User.query.count(),
            'clients_total': Client.query.filter_by(is_active=True).count(),
            'risques_actifs': Risque.query.filter_by(is_archived=False).count(),
            'audits_en_cours': Audit.query.filter_by(statut='en_cours').count(),
            'kri_actifs': KRI.query.filter_by(est_actif=True).count(),
            'veilles_actives': VeilleReglementaire.query.filter_by(statut='en_vigueur').count(),
            'formules_actives': FormuleAbonnement.query.filter_by(is_active=True).count()
        }
        
        # Utilisateurs r√©cents
        users = User.query.order_by(User.created_at.desc()).limit(50).all()
        
        # Clients r√©cents
        recent_clients = Client.query.order_by(Client.created_at.desc()).limit(10).all()
        
        # Statistiques par formule
        formules_stats = []
        for formule in FormuleAbonnement.query.filter_by(is_active=True).all():
            clients_count = Client.query.filter_by(formule_id=formule.id, is_active=True).count()
            formules_stats.append({
                'nom': formule.nom,
                'clients': clients_count,
                'prix_mensuel': formule.prix_mensuel
            })
        
    else:
        # ADMIN CLIENT : voit seulement son client
        client_id = current_user.client_id
        
        if not client_id:
            flash('Aucun client associ√© √† votre compte', 'error')
            return redirect(url_for('dashboard'))
        
        # R√©cup√©rer les utilisateurs DU CLIENT
        users = get_client_filter(User)\
            .filter_by(is_active=True)\
            .order_by(User.created_at.desc())\
            .limit(20).all()
        
        # Statistiques DU CLIENT
        stats = {
            'users_active': len(users),
            'users_total': get_client_filter(User).count(),
            'risques_actifs': get_client_filter(Risque).filter_by(is_archived=False).count(),
            'audits_en_cours': get_client_filter(Audit).filter_by(statut='en_cours').count(),
            'kri_actifs': get_client_filter(KRI).filter_by(est_actif=True).count(),
            'veilles_actives': get_client_filter(VeilleReglementaire).filter_by(statut='en_vigueur').count(),
            'clients_total': 1,  # Uniquement son propre client
            'formule': current_user.client.formule.nom if current_user.client.formule else 'Aucune'
        }
        
        # Client info
        client = current_user.client
        recent_clients = []  # Admin client ne voit pas d'autres clients
        
        # Formule info
        formules_stats = []
        if client and client.formule:
            formule = client.formule
            formules_stats.append({
                'nom': formule.nom,
                'utilisation_utilisateurs': f"{stats['users_active']}/{formule.max_utilisateurs}",
                'utilisation_risques': f"{stats['risques_actifs']}/{formule.max_risques}",
                'pourcentage_utilisateurs': round((stats['users_active'] / max(formule.max_utilisateurs, 1)) * 100),
                'pourcentage_risques': round((stats['risques_actifs'] / max(formule.max_risques, 1)) * 100)
            })
    
    # R√©cup√©rer les templates de permissions AVEC ISOLATION
    if is_super_admin:
        # Super admin voit tous les templates
        permission_templates = PermissionTemplate.query\
            .order_by(PermissionTemplate.name)\
            .all()
    else:
        # Admin client voit seulement les templates de son client OU globaux
        permission_templates = get_client_filter(PermissionTemplate)\
            .order_by(PermissionTemplate.name)\
            .all()
    
    # Activit√©s r√©centes
    if is_super_admin:
        # Super admin voit toutes les activit√©s syst√®me
        recent_activities = JournalActivite.query\
            .order_by(JournalActivite.date_creation.desc())\
            .limit(20)\
            .all()
    else:
        # Admin client voit seulement les activit√©s de son client
        recent_activities = get_client_filter(JournalActivite)\
            .order_by(JournalActivite.date_creation.desc())\
            .limit(20)\
            .all()
    
    return render_template('admin/dashboard.html',
                         stats=stats,
                         users=users,
                         recent_clients=recent_clients if is_super_admin else [],
                         formules_stats=formules_stats,
                         permission_templates=permission_templates,
                         recent_activities=recent_activities,
                         is_super_admin=is_super_admin,
                         is_client_admin=is_client_admin,
                         current_user=current_user,
                         datetime=datetime)

@app.route('/admin/utilisateur/nouveau', methods=['GET', 'POST'])
@login_required
@admin_required
def admin_nouvel_utilisateur():
    """Cr√©er un nouvel utilisateur - VERSION CORRIG√âE"""
    
    # V√âRIFICATION 1: Permission pour cr√©er des utilisateurs
    if not current_user.has_permission('can_edit_users'):
        flash('Acc√®s refus√© : permission de cr√©er des utilisateurs requise', 'error')
        return redirect(url_for('admin_utilisateurs'))
    
    # V√âRIFICATION 2: V√©rifier les limites de la formule
    if current_user.client and current_user.client.formule:
        formule = current_user.client.formule
        current_count = User.query.filter_by(
            client_id=current_user.client_id, 
            is_active=True
        ).count()
        
        if current_count >= formule.max_utilisateurs:
            flash(
                f'‚ùå Limite d\'utilisateurs atteinte ({formule.max_utilisateurs}). ' +
                f'Veuillez mettre √† niveau votre formule ({formule.nom}).',
                'error'
            )
            return redirect(url_for('admin_utilisateurs'))
    
    # Formulaire SIMPLIFI√â et CORRIG√â
    from flask_wtf import FlaskForm
    from wtforms import StringField, PasswordField, SelectField, BooleanField, SubmitField
    from wtforms.validators import DataRequired, Email, Length, EqualTo, Optional
    
    class NouvelUtilisateurFormCorrige(FlaskForm):
        username = StringField('Nom d\'utilisateur', validators=[
            DataRequired(message='Le nom d\'utilisateur est requis')
        ])
        email = StringField('Email', validators=[
            DataRequired(message='L\'email est requis'),
            Email(message='Format d\'email invalide')
        ])
        password = PasswordField('Mot de passe', validators=[
            DataRequired(message='Le mot de passe est requis'),
            Length(min=6, message='Le mot de passe doit avoir au moins 6 caract√®res')
        ])
        confirm_password = PasswordField('Confirmer le mot de passe', validators=[
            DataRequired(message='Veuillez confirmer le mot de passe'),
            EqualTo('password', message='Les mots de passe doivent correspondre')
        ])
        
        # R√¥les disponibles selon la formule
        role = SelectField('R√¥le', 
            choices=[('utilisateur', 'Utilisateur Standard')],  # Par d√©faut seulement utilisateur
            default='utilisateur', 
            validators=[DataRequired()])
        
        department = StringField('D√©partement')
        is_active = BooleanField('Activer le compte imm√©diatement', default=True)
        
        # Template de permissions
        template_permissions = SelectField('Template de permissions', 
            choices=[(0, 'Aucun template')],  # Par d√©faut vide
            coerce=int, 
            default=0,
            validators=[Optional()])
        
        submit = SubmitField('Cr√©er l\'utilisateur')
    
    # Cr√©er l'instance du formulaire
    form = NouvelUtilisateurFormCorrige()
    
    # Remplir les choix dynamiquement - VERSION SIMPLIFI√âE
    try:
        # R√¥les disponibles selon la formule
        roles_disponibles = [('utilisateur', 'Utilisateur Standard')]
        
        if current_user.client and current_user.client.formule:
            formule = current_user.client.formule
            
            # Ajouter les r√¥les autoris√©s par la formule
            if 'manager' in formule.roles_autorises:
                roles_disponibles.append(('manager', 'Manager'))
            
            if 'compliance' in formule.roles_autorises:
                roles_disponibles.append(('compliance', 'Responsable Conformit√©'))
            
            if 'auditeur' in formule.roles_autorises:
                roles_disponibles.append(('auditeur', 'Auditeur'))
            
            if 'consultant' in formule.roles_autorises:
                roles_disponibles.append(('consultant', 'Consultant'))
            
            # Admin client peut cr√©er d'autres admin seulement si super admin
            if current_user.role == 'super_admin' and 'admin' in formule.roles_autorises:
                roles_disponibles.append(('admin', 'Administrateur Client'))
        
        form.role.choices = roles_disponibles
        
        # Templates de permissions disponibles
        if current_user.role == 'super_admin':
            templates = PermissionTemplate.query.all()
        else:
            templates = PermissionTemplate.query.filter(
                db.or_(
                    PermissionTemplate.client_id == current_user.client_id,
                    PermissionTemplate.client_id == None  # Templates globaux
                )
            ).all()
        
        if templates:
            form.template_permissions.choices = [(0, 'Aucun template')] + [(t.id, t.name) for t in templates]
        else:
            form.template_permissions.choices = [(0, 'Aucun template disponible')]
            
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur chargement templates/r√¥les: {e}")
        form.role.choices = [('utilisateur', 'Utilisateur Standard')]
        form.template_permissions.choices = [(0, 'Erreur chargement templates')]
    
    # DEBUG: Log des informations
    print(f"üîç DEBUG admin_nouvel_utilisateur:")
    print(f"  Method: {request.method}")
    print(f"  Form is submitted: {form.is_submitted()}")
    print(f"  Form validate on submit: {form.validate_on_submit()}")
    print(f"  Current user: {current_user.username} (role: {current_user.role})")
    print(f"  Has permission can_edit_users: {current_user.has_permission('can_edit_users')}")
    
    if request.method == 'POST':
        print(f"üì® FORM DATA re√ßu: {request.form}")
        
        if form.validate_on_submit():
            print("‚úÖ Formulaire valid√© avec succ√®s!")
            
            try:
                # V√©rifier √† nouveau les limites avant cr√©ation
                if current_user.client and current_user.client.formule:
                    formule = current_user.client.formule
                    current_count = User.query.filter_by(
                        client_id=current_user.client_id, 
                        is_active=True
                    ).count()
                    
                    if current_count >= formule.max_utilisateurs:
                        flash(f'‚ùå Limite atteinte pendant la cr√©ation. Veuillez r√©essayer.', 'error')
                        return redirect(url_for('admin_nouvel_utilisateur'))
                
                # V√©rifier le r√¥le s√©lectionn√©
                role_selectionne = form.role.data
                roles_valides = [role[0] for role in form.role.choices]
                
                if role_selectionne not in roles_valides:
                    flash(f'‚ùå R√¥le non autoris√©: {role_selectionne}', 'error')
                    return redirect(url_for('admin_nouvel_utilisateur'))
                
                # Cr√©er l'utilisateur
                user = User(
                    username=form.username.data,
                    email=form.email.data,
                    role=role_selectionne,
                    department=form.department.data,
                    is_active=form.is_active.data,
                    client_id=current_user.client_id,
                    is_client_admin=False  # Par d√©faut, pas admin client
                )
                user.set_password(form.password.data)
                
                # Appliquer des permissions de base selon le r√¥le
                permissions_de_base = {
                    'can_view_dashboard': True,
                    'can_view_reports': True,
                    'can_view_departments': True,
                    'can_view_users_list': True  # Peut voir la liste des utilisateurs
                }
                
                # Ajouter des permissions sp√©cifiques selon le r√¥le
                if role_selectionne == 'manager':
                    permissions_de_base.update({
                        'can_manage_risks': True,
                        'can_manage_kri': True,
                        'can_manage_audit': True,
                        'can_export_data': True
                    })
                elif role_selectionne == 'auditeur':
                    permissions_de_base.update({
                        'can_manage_audit': True
                    })
                elif role_selectionne == 'admin':
                    permissions_de_base.update({
                        'can_manage_risks': True,
                        'can_manage_kri': True,
                        'can_manage_audit': True,
                        'can_manage_users': True,
                        'can_edit_users': True,
                        'can_manage_settings': True,
                        'can_export_data': True
                    })
                
                user.permissions = permissions_de_base
                
                # Appliquer template de permissions si s√©lectionn√©
                if form.template_permissions.data and int(form.template_permissions.data) != 0:
                    template = PermissionTemplate.query.get(form.template_permissions.data)
                    if template:
                        # Fusionner avec les permissions de base
                        user.permissions.update(template.permissions)
                        print(f"‚úÖ Template '{template.name}' appliqu√©")
                
                # Sauvegarder
                db.session.add(user)
                
                # Journaliser
                log_activity(current_user.id, 'creation_utilisateur',
                            f"Cr√©ation utilisateur {user.username} ({user.role})",
                            'utilisateur', user.id)
                
                db.session.commit()
                
                # Mettre √† jour les statistiques du client
                if current_user.client:
                    current_user.client.nb_utilisateurs = User.query.filter_by(
                        client_id=current_user.client_id, 
                        is_active=True
                    ).count()
                    db.session.commit()
                
                flash(f'‚úÖ Utilisateur {user.username} cr√©√© avec succ√®s', 'success')
                return redirect(url_for('admin_utilisateurs'))
                
            except Exception as e:
                db.session.rollback()
                print(f"‚ùå Erreur cr√©ation utilisateur: {str(e)}")
                import traceback
                traceback.print_exc()
                flash(f'‚ùå Erreur lors de la cr√©ation: {str(e)}', 'error')
        else:
            # Afficher les erreurs de validation
            print("‚ùå Erreurs de validation du formulaire:")
            for field, errors in form.errors.items():
                print(f"  {field}: {errors}")
            flash('Veuillez corriger les erreurs ci-dessous', 'error')
    
    # Calculer les statistiques pour le template
    try:
        if current_user.client and current_user.client.formule:
            total_users = User.query.filter_by(
                client_id=current_user.client_id, 
                is_active=True
            ).count()
            max_users = current_user.client.formule.max_utilisateurs
            pourcentage = (total_users / max_users * 100) if max_users > 0 else 0
        else:
            total_users = 0
            max_users = 10  # Valeur par d√©faut
            pourcentage = 0
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur calcul statistiques: {e}")
        total_users = 0
        max_users = 10
        pourcentage = 0
    
    # Informations sur la formule actuelle
    formule_info = None
    if current_user.client and current_user.client.formule:
        formule = current_user.client.formule
        formule_info = {
            'nom': formule.nom,
            'code': formule.code,
            'max_users': formule.max_utilisateurs,
            'roles_autorises': formule.roles_autorises,
            'modules': formule.get_modules_list(),
            'features': formule.get_features_list()
        }
    
    return render_template('admin/nouvel_utilisateur.html',
                         form=form,
                         total_users=total_users,
                         max_users=max_users,
                         pourcentage=pourcentage,
                         formule_info=formule_info,
                         current_user=current_user)

def refresh_sqlalchemy_metadata():
    """R√©initialiser le cache de m√©tadonn√©es SQLAlchemy"""
    print("üîÑ R√©initialisation du cache SQLAlchemy...")
    
    from sqlalchemy import event
    from sqlalchemy.schema import MetaData
    
    # R√©initialiser les m√©tadonn√©es
    db.metadata.clear()
    db.metadata.reflect(bind=db.engine)
    
    # R√©initialiser le cache de chaque mod√®le
    from models import ZoneRisqueProcessus, Notification
    
    # R√©initialiser le mapper
    try:
        from sqlalchemy.orm import class_mapper
        for model in [ZoneRisqueProcessus, Notification]:
            try:
                mapper = class_mapper(model)
                mapper._configure_all()
                print(f"‚úÖ Cache r√©initialis√© pour {model.__name__}")
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur pour {model.__name__}: {e}")
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur r√©initialisation mappers: {e}")
    
    print("‚úÖ Cache SQLAlchemy r√©initialis√©")

# Appeler au d√©marrage
with app.app_context():
    refresh_sqlalchemy_metadata()
    

@app.route('/admin/utilisateurs')
@csrf.exempt
@login_required
def admin_utilisateurs():
    """Liste des utilisateurs avec filtrage correct"""
    
    if not current_user.has_permission('can_view_users_list'):
        flash('Acc√®s refus√© : permission requise', 'error')
        return redirect(url_for('dashboard'))
    
    # SUPER ADMIN : voir tous les utilisateurs (sauf autres super admin)
    if current_user.role == 'super_admin':
        users = User.query.filter(
            User.role != 'super_admin'  # Ne montre pas les autres super admin
        ).order_by(User.client_id, User.username).all()
        
        return render_template(
            'admin/utilisateurs_super_admin.html',
            users=users,
            role_display="SUPER ADMIN - Vue globale",
            total_clients=Client.query.count(),
            clients_actifs=Client.query.filter_by(is_active=True).count()
        )
    
    # ADMIN CLIENT : voir les utilisateurs de son client
    elif current_user.role == 'admin' and current_user.is_client_admin:
        users = User.query.filter_by(
            client_id=current_user.client_id
        ).filter(
            User.role != 'super_admin'  # Ne montre pas les super admin
        ).order_by(User.username).all()
        
        # Filtrer pour ne pas montrer d'autres admin client (sauf lui-m√™me)
        filtered_users = []
        for user in users:
            if not user.is_client_admin or user.id == current_user.id:
                filtered_users.append(user)
        
        return render_template(
            'admin/utilisateurs.html',  # Template normal
            users=filtered_users,
            role_display=f"Admin Client: {current_user.client.reference if current_user.client else 'Mon client'}"
        )
    
    # UTILISATEURS NORMAUX : voir la liste (lecture seule)
    elif current_user.has_permission('can_view_users_list'):
        users = User.query.filter_by(
            client_id=current_user.client_id
        ).filter(
            User.role != 'super_admin',  # Pas de super admin
            User.is_client_admin == False  # Pas d'admin client
        ).order_by(User.username).all()
        
        # Utiliser le template normal mais ajouter un indicateur
        return render_template(
            'admin/utilisateurs.html',  # M√™me template
            users=users,
            role_display="Liste des utilisateurs"
        )
    
    else:
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))


@app.route('/admin/utilisateur/<int:id>/toggle', methods=['POST'])
@login_required
def admin_toggle_user_status(id):
    """Activer/d√©sactiver un utilisateur"""
    
    # V√©rifier la permission
    if not current_user.has_permission('can_edit_users'):
        return jsonify({'success': False, 'error': 'Permission non autoris√©e'}), 403
    
    user = User.query.get_or_404(id)
    
    # V√©rifier l'acc√®s
    if current_user.role != 'super_admin':
        if user.client_id != current_user.client_id:
            return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
        
        # Emp√™cher un admin client de modifier un autre admin client
        if user.is_client_admin and user.id != current_user.id:
            return jsonify({'success': False, 'error': 'Vous ne pouvez pas modifier un autre administrateur client'}), 403
        
        # Emp√™cher un admin client de se d√©sactiver lui-m√™me
        if user.id == current_user.id:
            return jsonify({'success': False, 'error': 'Vous ne pouvez pas vous d√©sactiver vous-m√™me'}), 403
    
    try:
        old_status = user.is_active
        user.is_active = not user.is_active
        user.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        # Journaliser
        log_activity(current_user.id, 'toggle_status',
                    f"Statut utilisateur {user.username} chang√© de {old_status} √† {user.is_active}",
                    'utilisateur', user.id)
        
        return jsonify({
            'success': True,
            'is_active': user.is_active,
            'message': f'Utilisateur {user.username} est maintenant {"actif" if user.is_active else "inactif"}'
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

# Dans la section des filtres Jinja2 (cherchez o√π sont vos autres filtres)
@app.template_filter('format_datetime')
def format_datetime_filter(value, format='%d/%m/%Y %H:%M'):
    """Formate une date et heure."""
    if not value:
        return ''
    if isinstance(value, datetime):
        return value.strftime(format)
    return value



@app.route('/admin/utilisateur/<int:id>/editer', methods=['GET', 'POST'])
@login_required
def admin_editer_utilisateur(id):
    """√âditer un utilisateur avec restrictions pour admin clients"""
    
    # V√©rifier la permission de modifier les utilisateurs
    if not current_user.has_permission('can_edit_users'):
        flash('Acc√®s refus√© : permission de modifier les utilisateurs requise', 'error')
        return redirect(url_for('admin_utilisateurs'))
    
    # R√©cup√©rer l'utilisateur
    user = User.query.get_or_404(id)
    
    # V√©rifier l'acc√®s
    if current_user.role != 'super_admin':
        # Admin client ne peut modifier que les utilisateurs de son client
        if user.client_id != current_user.client_id:
            flash('Acc√®s non autoris√© √† cet utilisateur', 'error')
            return redirect(url_for('admin_utilisateurs'))
        
        # Emp√™cher un admin client de modifier un autre admin client
        if user.is_client_admin and user.id != current_user.id:
            flash('Vous ne pouvez pas modifier un autre administrateur client', 'error')
            return redirect(url_for('admin_utilisateurs'))
    
    # Cr√©er le formulaire d'√©dition
    from flask_wtf import FlaskForm
    from wtforms import StringField, PasswordField, SelectField, BooleanField, SubmitField
    from wtforms.validators import DataRequired, Email, Length, EqualTo, Optional
    
    class EditerUtilisateurForm(FlaskForm):
        username = StringField('Nom d\'utilisateur', validators=[
            DataRequired(message='Le nom d\'utilisateur est requis')
        ])
        email = StringField('Email', validators=[
            DataRequired(message='L\'email est requis'),
            Email(message='Format d\'email invalide')
        ])
        password = PasswordField('Nouveau mot de passe', validators=[
            Optional(),
            Length(min=6, message='Le mot de passe doit avoir au moins 6 caract√®res')
        ])
        confirm_password = PasswordField('Confirmer le mot de passe', validators=[
            Optional(),
            EqualTo('password', message='Les mots de passe doivent correspondre')
        ])
        role = SelectField('R√¥le', choices=[
            ('utilisateur', 'Utilisateur Standard'),
            ('auditeur', 'Auditeur'),
            ('compliance', 'Responsable Conformit√©'),
            ('manager', 'Manager'),
            ('consultant', 'Consultant'),
            ('admin', 'Administrateur Client') if current_user.role == 'super_admin' else None  # Seul super admin peut cr√©er d'autres admin
        ], validators=[DataRequired()])
        department = StringField('D√©partement')
        is_active = BooleanField('Activer le compte')
        template_permissions = SelectField('Template de permissions', 
            choices=[],  # Vide pour l'instant
            coerce=int, 
            default=0,
            validators=[Optional()])
        submit = SubmitField('Mettre √† jour')
    
    # Cr√©er l'instance du formulaire avec les donn√©es actuelles
    form = EditerUtilisateurForm(
        username=user.username,
        email=user.email,
        role=user.role,
        department=user.department or '',
        is_active=user.is_active
    )
    
    # Filtrer les r√¥les selon les permissions
    if current_user.role != 'super_admin':
        # Admin client ne peut pas cr√©er d'autres admin client
        form.role.choices = [
            ('utilisateur', 'Utilisateur Standard'),
            ('auditeur', 'Auditeur'),
            ('compliance', 'Responsable Conformit√©'),
            ('manager', 'Manager'),
            ('consultant', 'Consultant')
        ]
    
    # Remplir les templates de permissions
    try:
        # Filtrer les templates par client
        if current_user.role == 'super_admin':
            templates = PermissionTemplate.query.all()
        else:
            templates = PermissionTemplate.query.filter(
                db.or_(
                    PermissionTemplate.client_id == current_user.client_id,
                    PermissionTemplate.client_id == None  # Templates globaux
                )
            ).all()
        
        if templates:
            form.template_permissions.choices = [(0, 'Aucun template')] + [(t.id, t.name) for t in templates]
        else:
            form.template_permissions.choices = [(0, 'Aucun template disponible')]
        
        # D√©finir la valeur actuelle si un template est appliqu√©
        if user.permissions:
            # Chercher si les permissions correspondent √† un template
            for template in templates:
                if template.permissions == user.permissions:
                    form.template_permissions.data = template.id
                    break
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur chargement templates: {e}")
        form.template_permissions.choices = [(0, 'Erreur chargement templates')]
    
    if form.validate_on_submit():
        print("‚úÖ Formulaire d'√©dition valid√©!")
        
        try:
            # Mettre √† jour les champs de base
            user.username = form.username.data
            user.email = form.email.data
            user.role = form.role.data
            user.department = form.department.data
            user.is_active = form.is_active.data
            
            # Mettre √† jour le mot de passe si fourni
            if form.password.data:
                print("üîÑ Mise √† jour du mot de passe")
                user.set_password(form.password.data)
            
            # Appliquer template de permissions si s√©lectionn√©
            if form.template_permissions.data and int(form.template_permissions.data) != 0:
                print(f"üîç Application template ID: {form.template_permissions.data}")
                template = PermissionTemplate.query.get(form.template_permissions.data)
                if template:
                    user.permissions = template.permissions
                    print(f"‚úÖ Template '{template.name}' appliqu√©")
            elif form.template_permissions.data == 0:
                # Si "Aucun template" est s√©lectionn√©, ne pas modifier les permissions
                pass
            
            user.updated_at = datetime.utcnow()
            
            db.session.commit()
            
            log_activity(current_user.id, 'modification',
                        f"Modification utilisateur {user.username}",
                        'utilisateur', user.id)
            
            print(f"‚úÖ Utilisateur {user.username} mis √† jour avec succ√®s")
            flash(f'‚úÖ Utilisateur {user.username} mis √† jour avec succ√®s', 'success')
            return redirect(url_for('admin_utilisateurs'))
            
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Erreur mise √† jour utilisateur: {str(e)}")
            import traceback
            traceback.print_exc()
            flash(f'‚ùå Erreur lors de la mise √† jour: {str(e)}', 'error')
    else:
        if form.errors:
            print("‚ùå Erreurs de validation du formulaire d'√©dition:")
            for field, errors in form.errors.items():
                print(f"  {field}: {errors}")
            flash('Veuillez corriger les erreurs ci-dessous', 'error')
    
    return render_template('admin/editer_utilisateur.html', 
                         form=form, 
                         user=user,
                         is_client_admin=current_user.is_client_admin,
                         can_edit_permissions=current_user.role == 'super_admin')




@app.route('/admin/utilisateur/<int:id>/permissions', methods=['GET', 'POST'])
@login_required
@admin_required
def admin_gerer_permissions(id):
    """G√©rer les permissions d'un utilisateur - VERSION CORRIG√âE"""
    
    # R√©cup√©rer l'utilisateur avec v√©rification d'acc√®s
    user = User.query.get_or_404(id)
    
    # V√©rifier l'acc√®s
    if current_user.role != 'super_admin':
        if user.client_id != current_user.client_id:
            flash('Acc√®s non autoris√© √† cet utilisateur', 'error')
            return redirect(url_for('admin_utilisateurs'))
    
    # V√©rifier les permissions de l'admin
    if not current_user.has_permission('can_manage_permissions'):
        flash('Permission refus√©e pour g√©rer les permissions', 'error')
        return redirect(url_for('admin_utilisateurs'))
    
    # Permissions disponibles avec v√©rification formule
    all_permissions = get_all_permissions_with_formule_check(user)
    
    from flask_wtf import FlaskForm
    class SimpleForm(FlaskForm):
        pass
    
    form = SimpleForm()
    
    if request.method == 'POST':
        try:
            # R√©cup√©rer les permissions depuis le formulaire
            new_permissions = {}
            
            for category in all_permissions.values():
                for perm_key, perm_data in category.items():
                    # V√©rifier si la permission est autoris√©e par la formule
                    if perm_data['allowed']:
                        new_permissions[perm_key] = request.form.get(perm_key) == 'on'
                    else:
                        # Forcer √† False si non autoris√©e
                        new_permissions[perm_key] = False
            
            # Pour les admin clients, emp√™cher certaines permissions
            if current_user.role == 'admin' and not current_user.is_client_admin:
                # Emp√™cher les admin normaux de donner des permissions syst√®me
                new_permissions['can_manage_clients'] = False
                new_permissions['can_provision_servers'] = False
            
            # Mettre √† jour l'utilisateur
            user.permissions = new_permissions
            user.updated_at = datetime.utcnow()
            db.session.commit()
            
            # Journaliser
            log_activity(current_user.id, 'modification_permissions',
                        f"Modification permissions utilisateur {user.username}",
                        'utilisateur', user.id)
            
            flash('‚úÖ Permissions mises √† jour avec succ√®s', 'success')
            return redirect(url_for('admin_utilisateurs'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'‚ùå Erreur: {str(e)}', 'error')
    
    # Calculer les statistiques pour le template
    stats = {
        'total_users': User.query.filter_by(
            client_id=user.client_id, 
            is_active=True
        ).count() if user.client_id else 0,
        'max_users': user.client.formule.max_utilisateurs if user.client and user.client.formule else 0
    }
    
    return render_template('admin/gerer_permissions.html', 
                         user=user, 
                         form=form,
                         all_permissions=all_permissions,
                         stats=stats)  # <-- AJOUTER stats ici


def get_all_permissions_with_formule_check(user):
    """Retourne les permissions avec v√©rification COH√âRENTE avec les modules - VERSION CORRIG√âE"""
    
    # STRUCTURE UNIQUE ET CLAIRE
    all_permissions = {
        'visualisation': {
            'can_view_dashboard': 'Voir le tableau de bord',
            'can_view_reports': 'Consulter les rapports',
            'can_view_departments': 'Voir les directions/services'
        },
        'cartographie_risques': {
            'can_manage_risks': 'G√©rer les risques',
            'can_validate_risks': 'Valider les risques'
        },
        'kri': {
            'can_manage_kri': 'G√©rer les indicateurs KRI'
        },
        'audit': {
            'can_manage_audit': 'G√©rer les audits',
            'can_confirm_evaluations': 'Confirmer les √©valuations'
        },
        'veille': {
            'can_manage_regulatory': 'G√©rer la veille r√®glementaire'
        },
        'processus': {
            'can_manage_logigram': 'G√©rer les processus/logigrammes'
        },
        'analyse_ia': {
            'can_use_ia_analysis': 'Utiliser l\'analyse IA'
        },
        'plans_action': {  # AJOUT√â
            'can_manage_action_plans': 'G√©rer les plans d\'action',
            'can_view_action_plans': 'Consulter les plans d\'action'
        },
        'administration': {
            'can_manage_users': 'G√©rer les utilisateurs',
            'can_edit_users': 'Modifier les utilisateurs',
            'can_view_users_list': 'Voir la liste des utilisateurs',
            'can_manage_departments': 'G√©rer les directions/services',
            'can_access_all_departments': 'Acc√®s √† tous les d√©partements',
            'can_delete_data': 'Supprimer des donn√©es',
            'can_archive_data': 'Archiver des donn√©es',
            'can_export_data': 'Exporter des donn√©es'
        },
        'parametrage': {
            'can_manage_settings': 'G√©rer les param√®tres g√©n√©raux',
            'can_manage_permissions': 'G√©rer les permissions',
            'can_manage_lists': 'G√©rer les listes d√©roulantes',
            'can_manage_fields': 'G√©rer les champs personnalis√©s',
            'can_manage_files': 'G√©rer les fichiers',
            'can_manage_templates': 'G√©rer les templates de permissions'
        },
        'systeme': {
            'can_manage_clients': 'G√©rer les clients',
            'can_provision_servers': 'Provisionner des serveurs'
        }
    }
    
    # Initialiser la structure
    for category_name, category_perms in all_permissions.items():
        for perm_key, perm_label in list(category_perms.items()):
            all_permissions[category_name][perm_key] = {
                'label': perm_label,
                'allowed': True,  # Par d√©faut autoris√©
                'can_activate': True,  # Par d√©faut activable
                'reason': 'Permission de base'
            }
    
    # ============================================
    # DEBUG: LOG INITIAL
    # ============================================
    print(f"\n{'='*60}")
    print(f"üîç [PERMISSIONS DEBUG] D√©but v√©rification pour {user.username} (r√¥le: {user.role})")
    print(f"{'='*60}")
    
    # ============================================
    # 2. V√âRIFICATION FORMULE ET MODULES (CRITIQUE)
    # ============================================
    
    has_formule = False
    formule = None
    
    # V√©rifier si l'utilisateur a un client ET une formule
    if user.client:
        print(f"‚úÖ Utilisateur a un client: {user.client.nom}")
        if hasattr(user.client, 'formule') and user.client.formule:
            formule = user.client.formule
            has_formule = True
            print(f"‚úÖ Formule trouv√©e: {formule.nom} ({formule.code})")
            print(f"üì¶ Modules dans la base: {list(formule.modules.keys())}")
        else:
            print(f"‚ö†Ô∏è  Client n'a pas de formule associ√©e")
    else:
        print(f"‚ö†Ô∏è  Utilisateur n'a pas de client associ√©")
    
    if has_formule and formule:
        # MAPPING DIRECT PERMISSION ‚Üí MODULE (NOMS DE LA BASE DE DONN√âES)
        permission_to_module = {
            # Cartographie risques
            'can_manage_risks': 'cartographie',
            'can_validate_risks': 'cartographie',
            
            # KRI
            'can_manage_kri': 'suivi_kri',
            
            # Audit
            'can_manage_audit': 'audit_interne',
            'can_confirm_evaluations': 'audit_interne',
            
            # Veille r√®glementaire
            'can_manage_regulatory': 'veille_reglementaire',
            
            # Processus
            'can_manage_logigram': 'gestion_processus',
            
            # Analyse IA
            'can_use_ia_analysis': 'analyse_ia',
            
            # Plans d'action - AJOUT√â
            'can_manage_action_plans': 'plans_action',
            'can_view_action_plans': 'plans_action',
            
            # Reporting avanc√©
            'can_export_data': 'reporting_avance',
            'can_view_reports': 'reporting_avance',
            
            # Tableaux de bord
            'can_view_dashboard': 'tableaux_bord'
        }
        
        print(f"\nüîë V√©rification des permissions bas√©es sur les modules:")
        print(f"{'-'*40}")
        
        # V√âRIFIER CHAQUE PERMISSION
        for category_name, category_perms in all_permissions.items():
            for perm_key, perm_data in category_perms.items():
                
                # A. V√©rifier si la permission n√©cessite un module
                if perm_key in permission_to_module:
                    module_requis = permission_to_module[perm_key]
                    
                    # V√©rifier si le module existe dans la formule
                    if module_requis not in formule.modules:
                        print(f"‚ùå {perm_key}: Module '{module_requis}' NON TROUV√â dans {list(formule.modules.keys())}")
                        perm_data['allowed'] = False
                        perm_data['can_activate'] = False
                        perm_data['reason'] = f'Module "{module_requis}" manquant dans la formule'
                        continue
                    
                    # V√©rifier si le module est activ√©
                    is_module_active = formule.modules[module_requis]
                    
                    if not is_module_active:
                        print(f"‚ùå {perm_key}: Module '{module_requis}' D√âSACTIV√â (valeur: {is_module_active})")
                        perm_data['allowed'] = False
                        perm_data['can_activate'] = False
                        perm_data['reason'] = f'Module "{module_requis}" non inclus dans votre formule'
                    else:
                        print(f"‚úÖ {perm_key}: Module '{module_requis}' ACTIV√â")
                        perm_data['allowed'] = True
                        perm_data['can_activate'] = True
                        perm_data['reason'] = f'Module "{module_requis}" activ√© dans la formule'
                
                # B. V√©rifier le template de permissions de la formule (priorit√© ABSOLUE)
                if hasattr(formule, 'permissions_template') and perm_key in formule.permissions_template:
                    template_value = formule.permissions_template[perm_key]
                    
                    # Le template a toujours la priorit√© finale
                    if template_value is False:
                        print(f"üîÑ {perm_key}: Template FORCE la D√âSACTIVATION")
                        perm_data['allowed'] = False
                        perm_data['can_activate'] = False
                        perm_data['reason'] = f'D√©sactiv√©e explicitement dans la formule {formule.nom}'
                    elif template_value is True:
                        print(f"üîÑ {perm_key}: Template FORCE l'ACTIVATION (m√™me si module d√©sactiv√©)")
                        perm_data['allowed'] = True
                        perm_data['can_activate'] = True
                        perm_data['reason'] = f'Activ√©e explicitement dans la formule {formule.nom}'
    
    # ============================================
    # 3. V√âRIFICATION R√îLES ET PERMISSIONS OBLIGATOIRES
    # ============================================
    
    print(f"\nüë§ V√©rification r√¥le: {user.role} (is_client_admin: {getattr(user, 'is_client_admin', False)})")
    
    # ADMIN CLIENT : permissions obligatoires
    if getattr(user, 'is_client_admin', False) or user.role == 'admin':
        admin_permissions_obligatoires = [
            'can_view_users_list', 'can_edit_users', 'can_manage_users',
            'can_view_departments', 'can_manage_departments',
            'can_manage_settings'
        ]
        
        print(f"üëë For√ßage permissions admin:")
        
        for perm in admin_permissions_obligatoires:
            for category_name, category_perms in all_permissions.items():
                if perm in category_perms:
                    # Forcer l'activation pour les admins clients
                    category_perms[perm]['allowed'] = True
                    category_perms[perm]['can_activate'] = True
                    category_perms[perm]['reason'] = 'Obligatoire pour admin client'
                    print(f"   ‚úÖ {perm}: forc√©e pour admin client")
    
    # ============================================
    # 4. PERMISSIONS SUPER ADMIN EXCLUSIVES
    # ============================================
    
    if user.role != 'super_admin':
        print(f"\nüîí Blocage permissions super_admin:")
        permissions_super_admin = ['can_manage_clients', 'can_provision_servers']
        for perm in permissions_super_admin:
            for category_name, category_perms in all_permissions.items():
                if perm in category_perms:
                    category_perms[perm]['allowed'] = False
                    category_perms[perm]['can_activate'] = False
                    category_perms[perm]['reason'] = 'R√©serv√© au super admin'
                    print(f"   ‚ùå {perm}: r√©serv√©e au super admin")
    
    # ============================================
    # 5. DEBUG FINAL: PERMISSIONS R√âSULTANTES
    # ============================================
    
    print(f"\n{'='*60}")
    print(f"üìã R√âSUM√â FINAL pour {user.username}:")
    print(f"{'='*60}")
    
    total_permissions = 0
    allowed_permissions = 0
    
    for category_name, category_perms in all_permissions.items():
        permissions_actives = [k for k, v in category_perms.items() if v['allowed']]
        total_permissions += len(category_perms)
        allowed_permissions += len(permissions_actives)
        
        if permissions_actives:
            print(f"üìÅ {category_name}: {len(permissions_actives)}/{len(category_perms)} perm(s) active(s)")
    
    print(f"\nüìä TOTAL: {allowed_permissions}/{total_permissions} permissions activ√©es")
    
    # V√©rification sp√©cifique des permissions probl√©matiques
    check_perms = {
        'can_manage_regulatory': 'Veille r√®glementaire',
        'can_use_ia_analysis': 'Analyse IA',
        'can_manage_logigram': 'Processus',
        'can_view_dashboard': 'Tableau de bord',
        'can_export_data': 'Export donn√©es',
        'can_manage_action_plans': 'Plans d\'action',  # AJOUT√â
        'can_view_action_plans': 'Consultation plans d\'action'  # AJOUT√â
    }
    
    print(f"\nüîç V√âRIFICATION D√âTAILL√âE:")
    print(f"{'-'*40}")
    
    for perm_key, perm_name in check_perms.items():
        found = False
        for category_name, category_perms in all_permissions.items():
            if perm_key in category_perms:
                found = True
                status = "‚úÖ AUTORIS√â" if category_perms[perm_key]['allowed'] else "‚ùå REFUS√â"
                reason = category_perms[perm_key]['reason'] or "Pas de raison sp√©cifi√©e"
                print(f"{status} {perm_name} ({perm_key}): {reason}")
                break
        
        if not found:
            print(f"‚ö†Ô∏è  {perm_name}: Permission non trouv√©e dans la structure")
    
    print(f"{'='*60}\n")

    for category_name, category_perms in all_permissions.items():
        for perm_key, perm_data in category_perms.items():
            perm_data['affects_display'] = perm_key in [
                'can_manage_risks', 'can_manage_kri', 'can_manage_audit',
                'can_manage_regulatory', 'can_manage_logigram', 'can_manage_action_plans',
                'can_view_users_list', 'can_view_departments', 'can_manage_settings',
                'can_view_dashboard', 'can_view_reports'
            ]
    
    return all_permissions




@app.route('/super-admin/sync-all-users-permissions')
@login_required
@super_admin_required
def sync_all_users_permissions():
    """Synchronise les permissions de TOUS les utilisateurs avec leurs formules"""
    
    try:
        users = User.query.all()
        synced_count = 0
        
        for user in users:
            if user.client and user.client.formule:
                formule = user.client.formule
                
                # Initialiser permissions si n√©cessaire
                if user.permissions is None:
                    user.permissions = {}
                
                # Synchroniser chaque permission du template
                template_permissions = formule.permissions_template or {}
                updated = False
                
                for perm_key, perm_value in template_permissions.items():
                    if user.permissions.get(perm_key) != perm_value:
                        user.permissions[perm_key] = perm_value
                        updated = True
                
                # Ajouter les permissions manquantes sp√©cifiques
                missing_permissions = {
                    'can_manage_action_plans': True,
                    'can_view_action_plans': True
                }
                
                for perm_key, perm_value in missing_permissions.items():
                    if perm_key not in user.permissions:
                        user.permissions[perm_key] = perm_value
                        updated = True
                
                if updated:
                    user.updated_at = datetime.utcnow()
                    synced_count += 1
                    print(f"‚úÖ {user.username} synchronis√©")
        
        db.session.commit()
        
        flash(f'‚úÖ {synced_count} utilisateurs synchronis√©s avec leurs formules', 'success')
        return jsonify({
            'success': True,
            'synced_count': synced_count,
            'total_users': len(users)
        })
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
        return jsonify({'error': str(e)}), 500

@app.route('/super-admin/sync-client-permissions/<int:client_id>')
@login_required
@super_admin_required
def sync_client_permissions(client_id):
    """Synchronise tous les utilisateurs d'un client sp√©cifique"""
    
    client = Client.query.get_or_404(client_id)
    
    try:
        users = User.query.filter_by(client_id=client_id).all()
        synced_count = 0
        
        for user in users:
            if client.formule:
                formule = client.formule
                
                if user.permissions is None:
                    user.permissions = {}
                
                # FORCER les permissions plans_action
                user.permissions['can_manage_action_plans'] = True
                user.permissions['can_view_action_plans'] = True
                
                # Synchroniser autres permissions
                for perm_key, perm_value in (formule.permissions_template or {}).items():
                    user.permissions[perm_key] = perm_value
                
                user.updated_at = datetime.utcnow()
                synced_count += 1
                print(f"‚úÖ {user.username} synchronis√©")
        
        db.session.commit()
        
        flash(f'‚úÖ {synced_count} utilisateurs du client {client.nom} synchronis√©s', 'success')
        return redirect(url_for('super_admin_client_detail', id=client_id))
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
        return redirect(url_for('super_admin_client_detail', id=client_id))

@app.before_request
def auto_sync_user_permissions():
    """Synchronise automatiquement les permissions manquantes"""
    if current_user.is_authenticated:
        # V√©rifier toutes les 10 requ√™tes
        session_key = f'permission_sync_{current_user.id}'
        request_count = session.get(session_key, 0) + 1
        session[session_key] = request_count
        
        if request_count % 10 == 0:  # Toutes les 10 requ√™tes
            if current_user.client and current_user.client.formule:
                formule = current_user.client.formule
                
                # V√©rifier et ajouter les permissions manquantes
                if current_user.permissions is None:
                    current_user.permissions = {}
                
                missing_permissions = [
                    'can_manage_action_plans',
                    'can_view_action_plans'
                ]
                
                updated = False
                for perm in missing_permissions:
                    if perm not in current_user.permissions:
                        current_user.permissions[perm] = True
                        updated = True
                
                if updated:
                    try:
                        db.session.commit()
                        print(f"üîÑ Permissions auto-synchronis√©es pour {current_user.username}")
                    except:
                        db.session.rollback()


def check_module_access(module_code):
    """D√©corateur pour v√©rifier l'acc√®s √† un module - VERSION CORRIG√âE"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not current_user.is_authenticated:
                flash('Veuillez vous connecter', 'error')
                return redirect(url_for('login'))
            
            # SUPER ADMIN : TOUT ACC√àS
            if current_user.role == 'super_admin':
                return f(*args, **kwargs)
            
            # V√©rifier si l'utilisateur a un client et une formule
            if not hasattr(current_user, 'client') or not current_user.client:
                flash('Aucun client associ√© √† votre compte', 'error')
                return redirect(url_for('dashboard'))
            
            client = current_user.client
            
            if not client.formule:
                flash('Aucune formule active pour votre client', 'error')
                return redirect(url_for('dashboard'))
            
            formule = client.formule
            
            # MAPPING COMPLET ET COH√âRENT
            # module_code (URL) ‚Üí Nom dans la base de donn√©es ‚Üí Permission
            module_mapping = {
                # ==================== MODULES PROBL√âMATIQUES ====================
                'veille': 'veille_reglementaire',
                'processus': 'gestion_processus',
                'logigrammes': 'gestion_processus',
                'ia_analyse': 'analyse_ia',
                'tableaux_bord_personnalisables': 'tableaux_bord',
                'plans_action': 'plans_action',  # AJOUT√â
                
                # ==================== AUTRES MODULES ====================
                'questionnaires': 'questionnaires',
                'organigramme': 'organigramme',
                'portail_fournisseurs': 'portail_fournisseurs',
                'reporting_avance': 'reporting_avance',
                'matrices_risque': 'matrices_risque',
                'risques': 'cartographie',
                'cartographie': 'cartographie',
                'audit_interne': 'audit_interne',
                'suivi_kri': 'suivi_kri'
            }
            
            # Obtenir le vrai nom du module dans la base de donn√©es
            real_module_db = module_mapping.get(module_code, module_code)
            
            # DEBUG LOG
            print(f"""
            üîç [CHECK_MODULE_ACCESS] DEBUG:
            Module URL: {module_code}
            ‚Üí DB Name: {real_module_db}
            Client: {client.nom} (ID: {client.id})
            Formule: {formule.nom} ({formule.code})
            """)
            
            # V√©rification 1: Module pr√©sent dans la formule
            module_active = False
            
            # Rechercher le module dans la formule (avec diff√©rentes cl√©s possibles)
            for module_key in [real_module_db, module_code]:
                if module_key in formule.modules:
                    module_active = formule.modules[module_key]
                    print(f"  ‚úÖ Module trouv√© avec cl√© '{module_key}': {module_active}")
                    break
            
            # Si le module n'est pas trouv√© du tout
            if real_module_db not in formule.modules and module_code not in formule.modules:
                print(f"  ‚ùå Module '{real_module_db}' NON TROUV√â dans les modules de la formule")
                print(f"     Modules disponibles: {list(formule.modules.keys())}")
                
                # Journaliser
                log_activity(current_user.id, 'tentative_acces_restreint',
                           f"Module '{real_module_db}' non trouv√© dans la formule {formule.nom}",
                           'system', None)
                
                return redirect(url_for('module_restricted', module=module_code))
            
            # Si le module est d√©sactiv√©
            if not module_active:
                print(f"  ‚ùå Module '{real_module_db}' D√âSACTIV√â dans la formule")
                
                # Journaliser
                log_activity(current_user.id, 'tentative_acces_restreint',
                           f"Module '{real_module_db}' d√©sactiv√© dans la formule {formule.nom}",
                           'system', None)
                
                return redirect(url_for('module_restricted', module=module_code))
            
            # V√©rification 2: Permission utilisateur
            # Mapping module ‚Üí permission (pour les modules critiques)
            module_permission_map = {
                'veille_reglementaire': 'can_manage_regulatory',
                'gestion_processus': 'can_manage_logigram',
                'analyse_ia': 'can_use_ia_analysis',
                'suivi_kri': 'can_manage_kri',
                'audit_interne': 'can_manage_audit',
                'cartographie': 'can_manage_risks',
                'reporting_avance': 'can_export_data',
                'tableaux_bord': 'can_view_dashboard',
                'plans_action': 'can_manage_action_plans'  # AJOUT√â
            }
            
            # MODULES SANS PERMISSION SP√âCIFIQUE (acc√®s basique)
            modules_sans_permission = ['questionnaires', 'organigramme', 'portail_fournisseurs', 'matrices_risque']
            
            # Pour les modules sans permission sp√©cifique, v√©rifier les permissions de base
            if real_module_db in modules_sans_permission:
                # V√©rifier au moins une permission de base
                permissions_de_base = ['can_view_dashboard', 'can_view_reports']
                has_basic_access = any(
                    current_user.permissions.get(perm, False)
                    for perm in permissions_de_base
                )
                
                if not has_basic_access:
                    print(f"  ‚ùå Module '{real_module_db}' n√©cessite au moins une permission de base")
                    flash(f'Permission de base requise pour acc√©der √† ce module', 'error')
                    return redirect(url_for('dashboard'))
                
                print(f"  ‚úÖ Module '{real_module_db}' accessible avec permissions de base")
                return f(*args, **kwargs)
            
            # Pour les modules avec permission sp√©cifique
            required_permission = None
            
            # Chercher avec le nom DB d'abord
            if real_module_db in module_permission_map:
                required_permission = module_permission_map[real_module_db]
            # Sinon avec le nom URL
            elif module_code in module_permission_map:
                required_permission = module_permission_map[module_code]
            
            if required_permission:
                print(f"  üîê Permission requise: {required_permission}")
                print(f"  üë§ Permissions utilisateur: {current_user.permissions}")
                
                user_has_permission = current_user.permissions.get(required_permission, False)
                
                if not user_has_permission:
                    print(f"  ‚ùå Utilisateur n'a pas la permission '{required_permission}'")
                    
                    # V√©rifier si c'est un probl√®me de synchronisation
                    if required_permission in formule.permissions_template:
                        formule_has_permission = formule.permissions_template[required_permission]
                        if not formule_has_permission:
                            print(f"  ‚ö†Ô∏è  La formule {formule.nom} n'inclut pas '{required_permission}'")
                            flash(f'Votre formule {formule.nom} n\'inclut pas cette fonctionnalit√©.', 'error')
                        else:
                            print(f"  ‚ö†Ô∏è  Permission '{required_permission}' incluse dans la formule mais non attribu√©e")
                            flash(f'Permission {required_permission} manquante dans votre profil.', 'error')
                    
                    # Sugg√©rer la synchronisation
                    if current_user.role in ['admin', 'super_admin']:
                        flash('Veuillez synchroniser vos permissions avec la formule.', 'info')
                    
                    return redirect(url_for('dashboard'))
                else:
                    print(f"  ‚úÖ Utilisateur a la permission '{required_permission}'")
            
            print(f"  üéâ Acc√®s AUTORIS√â au module '{module_code}' ({real_module_db})")
            return f(*args, **kwargs)
        
        return decorated_function
    return decorator


@app.route('/super-admin/fix-all-plans-action')
@login_required
@super_admin_required
def fix_all_plans_action():
    """Correction globale pour tous les plans_action"""
    try:
        formules = FormuleAbonnement.query.all()
        corrections = 0
        
        for formule in formules:
            # Activer le module plans_action dans toutes les formules
            if not formule.modules.get('plans_action', False):
                formule.modules['plans_action'] = True
                corrections += 1
            
            # Ajouter les permissions manquantes
            if formule.permissions_template is None:
                formule.permissions_template = {}
            
            if 'can_manage_action_plans' not in formule.permissions_template:
                formule.permissions_template['can_manage_action_plans'] = True
                corrections += 1
            
            if 'can_view_action_plans' not in formule.permissions_template:
                formule.permissions_template['can_view_action_plans'] = True
                corrections += 1
        
        db.session.commit()
        
        # Synchroniser tous les utilisateurs
        users = User.query.all()
        users_synced = 0
        
        for user in users:
            if user.permissions is None:
                user.permissions = {}
            
            # Ajouter les permissions manquantes
            if 'can_manage_action_plans' not in user.permissions:
                user.permissions['can_manage_action_plans'] = True
                users_synced += 1
            
            if 'can_view_action_plans' not in user.permissions:
                user.permissions['can_view_action_plans'] = True
                users_synced += 1
        
        db.session.commit()
        
        flash(f'‚úÖ {corrections} corrections appliqu√©es. {users_synced} utilisateurs synchronis√©s.', 'success')
        return redirect(url_for('super_admin_formules'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
        return redirect(url_for('super_admin_formules'))

@app.route('/fix-super-admin-permissions')
@login_required
@super_admin_required
def fix_super_admin_permissions():
    """Correction sp√©cifique pour les permissions super admin"""
    try:
        # 1. R√©cup√©rer tous les super admins
        super_admins = User.query.filter_by(role='super_admin').all()
        
        for user in super_admins:
            print(f"üîß Correction pour super admin: {user.username}")
            
            # Initialiser les permissions si n√©cessaire
            if user.permissions is None:
                user.permissions = {}
            
            # Liste COMPL√àTE des permissions pour super admin
            super_admin_permissions = {
                # ==================== PERMISSIONS DE BASE ====================
                'can_view_dashboard': True,
                'can_view_reports': True,
                'can_view_departments': True,
                'can_view_users_list': True,
                'can_view_action_plans': True,  # AJOUT√â
                
                # ==================== PERMISSIONS MODULAIRES ====================
                'can_manage_risks': True,
                'can_validate_risks': True,
                'can_manage_kri': True,
                'can_manage_audit': True,
                'can_confirm_evaluations': True,
                'can_manage_regulatory': True,
                'can_manage_logigram': True,
                'can_use_ia_analysis': True,
                'can_manage_action_plans': True,  # AJOUT√â
                
                # ==================== ADMINISTRATION ====================
                'can_manage_settings': True,
                'can_manage_permissions': True,
                'can_manage_users': True,
                'can_edit_users': True,
                'can_manage_departments': True,
                'can_access_all_departments': True,
                'can_delete_data': True,
                'can_archive_data': True,
                'can_export_data': True,
                
                # ==================== PARAM√âTRAGE ====================
                'can_manage_lists': True,
                'can_manage_fields': True,
                'can_manage_files': True,
                'can_manage_templates': True,
                
                # ==================== SYST√àME ====================
                'can_manage_clients': True,
                'can_provision_servers': True
            }
            
            # Mettre √† jour toutes les permissions
            user.permissions.update(super_admin_permissions)
            user.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        flash(f'‚úÖ {len(super_admins)} super admins mis √† jour avec permissions compl√®tes', 'success')
        return redirect(url_for('admin_utilisateurs'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
        return redirect(url_for('dashboard'))


@app.route('/add-missing-permissions')
@login_required
@super_admin_required
def add_missing_permissions():
    """Ajouter uniquement les permissions manquantes"""
    try:
        user = current_user
        
        print(f"üîß Ajout permissions manquantes pour: {user.username}")
        
        if user.permissions is None:
            user.permissions = {}
        
        # Permissions manquantes d√©tect√©es
        missing_permissions = {
            'can_manage_action_plans': True,
            'can_view_action_plans': True,
            'can_use_ia_analysis': True,
            'can_edit_users': True,
            'can_manage_lists': True,
            'can_manage_fields': True,
            'can_manage_files': True,
            'can_manage_templates': True
        }
        
        added_count = 0
        for perm_key, perm_value in missing_permissions.items():
            if perm_key not in user.permissions:
                user.permissions[perm_key] = perm_value
                added_count += 1
                print(f"  ‚ûï {perm_key} = {perm_value}")
        
        if added_count > 0:
            user.updated_at = datetime.utcnow()
            db.session.commit()
            flash(f'‚úÖ {added_count} permissions manquantes ajout√©es', 'success')
        else:
            flash('‚úÖ Toutes les permissions sont d√©j√† pr√©sentes', 'info')
        
        return redirect(url_for('dashboard'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
        return redirect(url_for('dashboard'))

@app.route('/debug/plans-action-deep')
@login_required
def debug_plans_action_deep():
    """Diagnostic profond pour Plans d'action"""
    
    user = current_user
    
    # 1. V√©rifier les permissions de l'utilisateur
    user_perms = user.permissions or {}
    
    # 2. V√©rifier la formule
    formule_info = None
    if user.client and user.client.formule:
        formule = user.client.formule
        formule_info = {
            'nom': formule.nom,
            'code': formule.code,
            'modules': formule.modules,
            'permissions_template': formule.permissions_template
        }
    
    # 3. V√©rifier si le module est dans la formule
    module_in_formule = False
    if formule_info:
        # Chercher avec diff√©rentes cl√©s
        possible_keys = ['plans_action', 'plans_action_d_audit', 'action_plans']
        for key in possible_keys:
            if key in formule_info['modules']:
                module_in_formule = True
                module_value = formule_info['modules'][key]
                print(f"‚úÖ Module trouv√© avec cl√© '{key}': {module_value}")
                break
    
    # 4. V√©rifier la route actuelle
    from flask import request
    route_info = {
        'endpoint': request.endpoint,
        'path': request.path,
        'method': request.method
    }
    
    # 5. V√©rifier le d√©corateur check_module_access
    import inspect
    decorator_info = None
    try:
        # Obtenir la fonction de la route
        func = app.view_functions['liste_plans_action']
        source = inspect.getsource(func)
        decorator_info = {
            'has_check_module_access': '@check_module_access' in source or 'check_module_access(' in source,
            'function_name': func.__name__
        }
    except:
        pass
    
    return jsonify({
        'user': {
            'id': user.id,
            'username': user.username,
            'role': user.role,
            'client_id': user.client_id,
            'permissions_count': len(user_perms),
            'specific_plans_permissions': {
                'can_manage_action_plans': user_perms.get('can_manage_action_plans'),
                'can_view_action_plans': user_perms.get('can_view_action_plans')
            },
            'all_permissions': user_perms
        },
        'client': {
            'id': user.client_id,
            'nom': user.client.nom if user.client else None
        } if user.client else None,
        'formule': formule_info,
        'module_check': {
            'plans_action_in_formule': module_in_formule,
            'module_keys_searched': ['plans_action', 'plans_action_d_audit', 'action_plans'],
            'all_module_keys': list(formule_info['modules'].keys()) if formule_info else []
        },
        'route_info': route_info,
        'decorator_info': decorator_info,
        'current_url': url_for('liste_plans_action')
    })

@app.route('/force-enable-plans-action-now')
@login_required
def force_enable_plans_action_now():
    """Force l'activation des permissions Plans d'action IMM√âDIATEMENT"""
    
    user = current_user
    
    print(f"üö® FORCE ACTIVATION pour {user.username}")
    print(f"   Avant: {user.permissions}")
    
    # FORCER les permissions
    if user.permissions is None:
        user.permissions = {}
    
    user.permissions['can_manage_action_plans'] = True
    user.permissions['can_view_action_plans'] = True
    user.permissions['can_manage_audit'] = True  # Souvent requis pour plans d'action
    
    db.session.commit()
    
    # Rafra√Æchir
    db.session.refresh(user)
    
    print(f"‚úÖ Apr√®s: {user.permissions}")
    
    flash('üö® Permissions Plans d\'action FORC√âES. Essayez maintenant.', 'warning')
    return redirect(url_for('liste_plans_action'))


@app.route('/super-admin/fix-plans-action-specific/<int:id>')
@login_required
@super_admin_required
def fix_plans_action_specific(id):
    """Corrige sp√©cifiquement le module Plans d'action pour une formule"""
    formule = FormuleAbonnement.query.get_or_404(id)
    
    try:
        print(f"üîß Correction sp√©cifique Plans d'action pour formule {formule.nom}")
        
        # 1. Activer le module dans la formule
        formule.modules['plans_action'] = True
        print(f"  ‚úÖ Module 'plans_action' activ√©")
        
        # 2. Activer les permissions correspondantes dans le template
        if formule.permissions_template is None:
            formule.permissions_template = {}
        
        formule.permissions_template['can_manage_action_plans'] = True
        formule.permissions_template['can_view_action_plans'] = True
        print(f"  ‚úÖ Permissions plans d'action activ√©es dans le template")
        
        # 3. Synchroniser tous les utilisateurs de cette formule
        users_synced = 0
        for client in formule.clients:
            for user in client.users:
                if user.permissions is None:
                    user.permissions = {}
                
                user.permissions['can_manage_action_plans'] = True
                user.permissions['can_view_action_plans'] = True
                users_synced += 1
        
        db.session.commit()
        
        flash(
            f'‚úÖ Module Plans d\'action activ√© pour la formule {formule.nom}. '
            f'{users_synced} utilisateurs synchronis√©s.',
            'success'
        )
        
        return redirect(url_for('super_admin_editer_formule', id=id))
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
        return redirect(url_for('super_admin_editer_formule', id=id))

@app.route('/debug-user-plans-action')
@login_required
def debug_user_plans_action():
    """Debug sp√©cifique pour plans_action"""
    
    user = current_user
    
    return jsonify({
        'username': user.username,
        'role': user.role,
        'client_id': user.client_id,
        'client': user.client.nom if user.client else None,
        'formule_id': user.client.formule_id if user.client else None,
        'formule': user.client.formule.nom if user.client and user.client.formule else None,
        'formule_code': user.client.formule.code if user.client and user.client.formule else None,
        
        # Modules de la formule
        'formule_modules': user.client.formule.modules if user.client and user.client.formule else None,
        'plans_action_module': user.client.formule.modules.get('plans_action') if user.client and user.client.formule else None,
        
        # Permissions de la formule
        'formule_permissions': user.client.formule.permissions_template if user.client and user.client.formule else None,
        'can_manage_action_plans_formule': user.client.formule.permissions_template.get('can_manage_action_plans') if user.client and user.client.formule else None,
        'can_view_action_plans_formule': user.client.formule.permissions_template.get('can_view_action_plans') if user.client and user.client.formule else None,
        
        # Permissions de l'utilisateur
        'user_permissions': user.permissions,
        'can_manage_action_plans_user': user.permissions.get('can_manage_action_plans'),
        'can_view_action_plans_user': user.permissions.get('can_view_action_plans'),
        
        # V√©rification fonction get_all_permissions_with_formule_check
        'all_permissions_keys': list(get_all_permissions_with_formule_check(user).keys()) if hasattr(current_user, 'id') else None,
        'plans_action_in_all_permissions': 'plans_action' in get_all_permissions_with_formule_check(user) if hasattr(current_user, 'id') else None
    })

def sync_formule_permissions_from_modules():
    """Synchronise automatiquement les permissions bas√©es sur les modules activ√©s"""
    with app.app_context():
        formules = FormuleAbonnement.query.all()
        
        for formule in formules:
            print(f"üîÑ Synchronisation formule: {formule.nom}")
            
            # Mappage module ‚Üí permission
            module_permission_map = {
                'analyse_ia': 'can_use_ia_analysis',
                'suivi_kri': 'can_manage_kri',
                'audit_interne': 'can_manage_audit',
                'veille_reglementaire': 'can_manage_regulatory',
                'gestion_processus': 'can_manage_logigram',
                'reporting_avance': 'can_export_data',
                'tableaux_bord': 'can_view_dashboard'
            }
            
            changes = 0
            for module_key, permission_key in module_permission_map.items():
                if permission_key in formule.permissions_template:
                    module_active = formule.modules.get(module_key, False)
                    current_permission = formule.permissions_template.get(permission_key, False)
                    
                    # Si le module est activ√© mais la permission ne l'est pas
                    if module_active and not current_permission:
                        formule.permissions_template[permission_key] = True
                        changes += 1
                        print(f"  ‚ûï {permission_key} = True (module {module_key} activ√©)")
                    
                    # Si le module est d√©sactiv√© mais la permission est activ√©e
                    elif not module_active and current_permission:
                        formule.permissions_template[permission_key] = False
                        changes += 1
                        print(f"  ‚ûñ {permission_key} = False (module {module_key} d√©sactiv√©)")
            
            if changes > 0:
                db.session.commit()
                print(f"  ‚úÖ {changes} permissions synchronis√©es")
        
        print("üéâ Synchronisation termin√©e")


def verify_and_correct_user_permissions(user_id):
    """V√©rifie et corrige automatiquement les permissions d'un utilisateur"""
    
    user = User.query.get(user_id)
    if not user or not user.client or not user.client.formule:
        return False
    
    formule = user.client.formule
    needs_correction = False
    
    # R√©cup√©rer les permissions autoris√©es
    all_permissions = get_all_permissions_with_formule_check(user)
    
    # V√©rifier chaque permission de l'utilisateur
    for perm_key, user_has_perm in (user.permissions or {}).items():
        # Trouver si cette permission est autoris√©e
        permission_authorized = True
        
        for category_name, category_perms in all_permissions.items():
            if perm_key in category_perms:
                permission_authorized = category_perms[perm_key]['allowed']
                break
        
        # Si l'utilisateur a une permission non autoris√©e
        if user_has_perm and not permission_authorized:
            user.permissions[perm_key] = False
            needs_correction = True
    
    if needs_correction:
        try:
            user.updated_at = datetime.utcnow()
            db.session.commit()
            print(f"‚úÖ Permissions corrig√©es pour {user.username}")
            return True
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Erreur correction permissions: {e}")
            return False
    
    return True

@app.route('/admin/sync-permissions/<int:user_id>')
@login_required
@admin_required
def admin_sync_permissions(user_id):
    """Synchroniser automatiquement les permissions avec la formule"""
    
    user = User.query.get_or_404(user_id)
    
    # V√©rifier l'acc√®s
    if current_user.role != 'super_admin':
        if user.client_id != current_user.client_id:
            flash('Acc√®s non autoris√©', 'error')
            return redirect(url_for('admin_utilisateurs'))
    
    try:
        # R√©cup√©rer les permissions filtr√©es par formule
        all_permissions = get_all_permissions_with_formule_check(user)
        
        # Appliquer automatiquement les restrictions
        new_permissions = user.permissions.copy() if user.permissions else {}
        
        # Pour chaque permission
        for category_name, category_perms in all_permissions.items():
            for perm_key, perm_data in category_perms.items():
                # Si la permission n'est pas autoris√©e par la formule
                if not perm_data['allowed']:
                    # Forcer √† False dans les permissions de l'utilisateur
                    new_permissions[perm_key] = False
        
        # Mettre √† jour l'utilisateur
        user.permissions = new_permissions
        user.updated_at = datetime.utcnow()
        db.session.commit()
        
        flash(f'‚úÖ Permissions de {user.username} synchronis√©es avec la formule', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur synchronisation: {str(e)}', 'error')
    
    return redirect(url_for('admin_gerer_permissions', id=user_id))

def verify_user_permissions_on_update(user_id):
    """V√©rifie et corrige les permissions lors de la mise √† jour"""
    user = User.query.get(user_id)
    if not user or not user.client or not user.client.formule:
        return
    
    formule = user.client.formule
    all_permissions = get_all_permissions_with_formule_check(user)
    
    # V√©rifier chaque permission
    for category_name, category_perms in all_permissions.items():
        for perm_key, perm_data in category_perms.items():
            # Si l'utilisateur a une permission non autoris√©e
            if user.permissions.get(perm_key, False) and not perm_data['allowed']:
                # D√©sactiver la permission
                user.permissions[perm_key] = False

@app.before_request
def auto_verify_permissions():
    """V√©rifie automatiquement les permissions pour les requ√™tes POST"""
    if request.method == 'POST' and current_user.is_authenticated:
        # V√©rifier que request.endpoint n'est pas None avant de l'utiliser
        if request.endpoint and 'permissions' in request.endpoint:
            # R√©cup√©rer l'ID utilisateur depuis l'URL
            user_id = request.view_args.get('id') if request.view_args else None
            if user_id:
                verify_user_permissions_on_update(user_id)
                
@app.route('/webhook/formule-updated/<int:formule_id>', methods=['POST'])
@login_required
@super_admin_required
def webhook_formule_updated(formule_id):
    """Webhook appel√© quand une formule est modifi√©e"""
    
    formule = FormuleAbonnement.query.get_or_404(formule_id)
    
    # Synchroniser tous les utilisateurs de cette formule
    for client in formule.clients:
        for user in client.users:
            verify_and_correct_user_permissions(user.id)
    
    return jsonify({'success': True, 'message': f'Permissions synchronis√©es pour la formule {formule.nom}'})


@app.before_request
def auto_correct_permissions():
    """Corrige automatiquement les permissions √† chaque requ√™te pour les admin client"""
    
    if current_user.is_authenticated and current_user.role in ['admin', 'manager']:
        # V√©rifier les permissions toutes les 5 minutes
        last_check = session.get('last_permission_check')
        now = datetime.utcnow().timestamp()
        
        if not last_check or (now - last_check > 300):  # 5 minutes
            verify_and_correct_user_permissions(current_user.id)
            session['last_permission_check'] = now
            

def migrate_and_correct_all_formules():
    """Migrer et corriger TOUTES les formules pour avoir une structure coh√©rente"""
    with app.app_context():
        try:
            formules = FormuleAbonnement.query.all()
            corrections_appliquees = 0
            
            for formule in formules:
                print(f"üîß Correction formule: {formule.nom} ({formule.code})")
                
                # ==================== CORRECTION DES MODULES ====================
                # S'assurer que tous les modules existent avec la nouvelle structure
                modules_corriges = {
                    'cartographie': formule.modules.get('cartographie', False),
                    'matrices_risque': formule.modules.get('matrices_risque', False),
                    'suivi_kri': formule.modules.get('suivi_kri', False) or formule.modules.get('kri', False),
                    'audit_interne': formule.modules.get('audit_interne', False) or formule.modules.get('audit', False),
                    'plans_action': formule.modules.get('plans_action', True),  # Toujours True
                    'veille_reglementaire': formule.modules.get('veille_reglementaire', False) or formule.modules.get('veille', False),
                    'gestion_processus': formule.modules.get('gestion_processus', False) or formule.modules.get('processus', False),
                    'organigramme': formule.modules.get('organigramme', False),
                    'questionnaires': formule.modules.get('questionnaires', False),
                    'portail_fournisseurs': formule.modules.get('portail_fournisseurs', False),
                    'reporting_avance': formule.modules.get('reporting_avance', False),
                    'tableaux_bord': formule.modules.get('tableaux_bord', False) or formule.modules.get('tableaux_bord_personnalisables', False),
                    'analyse_ia': formule.modules.get('analyse_ia', False) or formule.modules.get('ia_analyse', False)
                }
                
                # Appliquer les corrections
                formule.modules = modules_corriges
                corrections_appliquees += 1
                print(f"  ‚úÖ Modules corrig√©s: {sum(1 for v in modules_corriges.values() if v)}/13")
                
                # ==================== CORRECTION DES PERMISSIONS ====================
                if formule.permissions_template is None:
                    formule.permissions_template = {}
                
                # Permissions √† ajouter si manquantes
                permissions_manquantes = {
                    'can_manage_lists': False,
                    'can_manage_fields': False,
                    'can_manage_files': False,
                    'can_manage_templates': False,
                    'can_use_ia_analysis': False
                }
                
                for perm, default_value in permissions_manquantes.items():
                    if perm not in formule.permissions_template:
                        # D√©terminer la valeur selon la formule
                        if formule.code == 'standard':
                            formule.permissions_template[perm] = False
                        elif formule.code in ['premium', 'enterprise']:
                            formule.permissions_template[perm] = True
                        else:
                            formule.permissions_template[perm] = default_value
                        print(f"  ‚ûï Permission ajout√©e: {perm} = {formule.permissions_template[perm]}")
                        corrections_appliquees += 1
                
                # ==================== GARANTIR LA COH√âRENCE MODULE ‚Üí PERMISSION ====================
                # Si un module est activ√©, activer automatiquement ses permissions
                module_permission_map = {
                    'suivi_kri': ['can_manage_kri'],
                    'audit_interne': ['can_manage_audit', 'can_confirm_evaluations'],
                    'veille_reglementaire': ['can_manage_regulatory'],
                    'gestion_processus': ['can_manage_logigram'],
                    'analyse_ia': ['can_use_ia_analysis'],
                    'reporting_avance': ['can_export_data', 'can_view_reports']
                }
                
                for module, permissions in module_permission_map.items():
                    if formule.modules.get(module, False):
                        for perm in permissions:
                            if perm in formule.permissions_template and not formule.permissions_template[perm]:
                                formule.permissions_template[perm] = True
                                print(f"  üîÑ Permission activ√©e: {perm} (module {module} activ√©)")
                                corrections_appliquees += 1
                
                # ==================== CORRECTION SP√âCIFIQUE POUR LES ADMIN CLIENT ====================
                if formule.code in ['premium', 'enterprise']:
                    permissions_admin_obligatoires = [
                        'can_view_users_list', 'can_edit_users', 'can_manage_users',
                        'can_manage_departments', 'can_manage_settings'
                    ]
                    
                    for perm in permissions_admin_obligatoires:
                        if perm in formule.permissions_template and not formule.permissions_template[perm]:
                            formule.permissions_template[perm] = True
                            print(f"  üîß Permission admin activ√©e: {perm}")
                            corrections_appliquees += 1
            
            db.session.commit()
            print(f"üéâ Migration termin√©e: {corrections_appliquees} corrections appliqu√©es")
            
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Erreur migration: {e}")
            import traceback
            traceback.print_exc()

@app.route('/admin/correct-formules')
@login_required
@super_admin_required
def admin_correct_formules():
    """Ex√©cuter la correction des formules"""
    migrate_and_correct_all_formules()
    flash('‚úÖ Correction des formules termin√©e avec succ√®s', 'success')
    return redirect(url_for('super_admin_formules'))
            
def apply_default_permissions_based_on_role(user):
    """Applique les permissions par d√©faut selon le r√¥le"""
    
    # Permissions par d√©faut selon le r√¥le
    role_default_permissions = {
        'admin': {
            'can_view_dashboard': True,
            'can_view_reports': True,
            'can_export_data': True,
            'can_manage_risks': True,
            'can_manage_kri': True,
            'can_manage_audit': True,
            'can_view_departments': True,
            'can_manage_departments': True,
            'can_view_users_list': True,
            'can_edit_users': True,
            'can_manage_users': True,
            'can_manage_settings': True,
            'can_validate_risks': True,
            'can_confirm_evaluations': True,
            'can_archive_data': True,
            'can_manage_permissions': True
        },
        'manager': {
            'can_view_dashboard': True,
            'can_view_reports': True,
            'can_export_data': True,
            'can_manage_risks': True,
            'can_manage_kri': True,
            'can_manage_audit': True,
            'can_view_departments': True,
            'can_validate_risks': True
        },
        'utilisateur': {
            'can_view_dashboard': True,
            'can_view_reports': True,
            'can_view_departments': True,
            'can_view_users_list': True  # Peut voir la liste
        },
        'auditeur': {
            'can_view_dashboard': True,
            'can_view_reports': True,
            'can_view_departments': True,
            'can_manage_audit': True,
            'can_view_users_list': True
        }
    }
    
    # Appliquer les permissions du r√¥le
    if user.role in role_default_permissions:
        user.permissions.update(role_default_permissions[user.role])
    
    return user

def filter_users_by_permissions(users_list, current_user):
    """Filtre la liste des utilisateurs selon les permissions du viewer"""
    
    if not users_list:
        return []
    
    filtered_users = []
    
    for user in users_list:
        # Super admin voit tous les utilisateurs (sauf autres super admin)
        if current_user.role == 'super_admin':
            if user.role != 'super_admin':  # Ne pas montrer les autres super admin
                filtered_users.append(user)
        
        # Admin client voit ses utilisateurs
        elif current_user.is_client_admin or current_user.role == 'admin':
            if user.client_id == current_user.client_id and user.role != 'super_admin':
                # Admin client ne peut pas voir d'autres admin client (sauf lui-m√™me)
                if not user.is_client_admin or user.id == current_user.id:
                    filtered_users.append(user)
        
        # Utilisateur normal voit la liste (mais pas les admin)
        elif current_user.has_permission('can_view_users_list'):
            if user.client_id == current_user.client_id:
                # Ne pas montrer les super admin ni les admin client
                if user.role != 'super_admin' and not user.is_client_admin:
                    filtered_users.append(user)
    
    return filtered_users


def sync_user_permissions_with_formule(client_id):
    """Synchronise les permissions de tous les utilisateurs d'un client avec la formule"""
    client = Client.query.get(client_id)
    if not client or not client.formule:
        return
    
    formule = client.formule
    users = User.query.filter_by(client_id=client_id).all()
    
    for user in users:
        try:
            # Mettre √† jour les permissions selon la formule
            formule_permissions = formule.get_role_permissions(user.role)
            
            # Fusionner intelligemment
            # 1. Garder les permissions personnelles qui sont autoris√©es par la formule
            current_permissions = user.permissions.copy()
            
            for perm, allowed in formule_permissions.items():
                if not allowed:
                    # Si la formule d√©sactive une permission, la d√©sactiver
                    current_permissions[perm] = False
                elif perm not in current_permissions:
                    # Si nouvelle permission autoris√©e, l'ajouter
                    current_permissions[perm] = True
            
            # 2. Emp√™cher certaines permissions selon le r√¥le
            if user.role == 'admin' or user.is_client_admin:
                current_permissions['can_manage_clients'] = False
                current_permissions['can_provision_servers'] = False
            
            user.permissions = current_permissions
            user.updated_at = datetime.utcnow()
            
            print(f"‚úÖ Permissions synchronis√©es pour {user.username}")
            
        except Exception as e:
            print(f"‚ùå Erreur synchronisation {user.username}: {e}")
    
    try:
        db.session.commit()
        print(f"‚úÖ {len(users)} utilisateurs synchronis√©s avec la formule {formule.nom}")
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur commit: {e}")

@app.cli.command('create-missing-tables')
def create_missing_tables():
    """Cr√©e les tables manquantes identifi√©es"""
    from sqlalchemy import create_engine, text
    import os
    
    print("üîß Cr√©ation des tables manquantes...")
    
    # Liste des tables √† cr√©er avec leur SQL
    tables_sql = {
        'notifications': """
            CREATE TABLE IF NOT EXISTS notifications (
                id SERIAL PRIMARY KEY,
                type_notification VARCHAR(50) NOT NULL,
                titre VARCHAR(200) NOT NULL,
                message TEXT,
                urgence VARCHAR(20) DEFAULT 'normal',
                destinataire_id INTEGER REFERENCES "user"(id),
                entite_type VARCHAR(50),
                entite_id INTEGER,
                est_lue BOOLEAN DEFAULT FALSE,
                est_envoyee_email BOOLEAN DEFAULT FALSE,
                est_envoyee_push BOOLEAN DEFAULT FALSE,
                actions_possibles JSON,
                donnees_supplementaires JSON,
                expires_at TIMESTAMP,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                read_at TIMESTAMP,
                client_id INTEGER REFERENCES clients(id)
            )
        """,
        'journal_activites': """
            CREATE TABLE IF NOT EXISTS journal_activites (
                id SERIAL PRIMARY KEY,
                utilisateur_id INTEGER REFERENCES "user"(id),
                action VARCHAR(100) NOT NULL,
                details TEXT,
                entite_type VARCHAR(50),
                entite_id INTEGER,
                ip_address VARCHAR(45),
                user_agent TEXT,
                date_creation TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                client_id INTEGER REFERENCES clients(id)
            )
        """,
        'journal_activites_client': """
            CREATE TABLE IF NOT EXISTS journal_activites_client (
                id SERIAL PRIMARY KEY,
                client_id INTEGER REFERENCES clients(id) NOT NULL,
                utilisateur_id INTEGER REFERENCES "user"(id),
                action VARCHAR(100) NOT NULL,
                details JSON,
                ip_address VARCHAR(45),
                user_agent TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """,
        'ligne_organisation': """
            CREATE TABLE IF NOT EXISTS ligne_organisation (
                id SERIAL PRIMARY KEY,
                nom VARCHAR(200) NOT NULL,
                description TEXT,
                couleur VARCHAR(20),
                ordre INTEGER DEFAULT 0,
                client_id INTEGER REFERENCES clients(id),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """,
        'titre_organisation': """
            CREATE TABLE IF NOT EXISTS titre_organisation (
                id SERIAL PRIMARY KEY,
                nom VARCHAR(200) NOT NULL,
                description TEXT,
                niveau INTEGER DEFAULT 1,
                client_id INTEGER REFERENCES clients(id),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """,
        'parametre_evaluation': """
            CREATE TABLE IF NOT EXISTS parametre_evaluation (
                id SERIAL PRIMARY KEY,
                nom VARCHAR(200) NOT NULL,
                valeur TEXT,
                categorie VARCHAR(100),
                client_id INTEGER REFERENCES clients(id),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """
    }
    
    try:
        # R√©cup√©rer l'URL de la base de donn√©es
        db_url = app.config['SQLALCHEMY_DATABASE_URI']
        engine = create_engine(db_url)
        
        with engine.connect() as conn:
            for table_name, sql in tables_sql.items():
                print(f"  üìã Cr√©ation de la table '{table_name}'...")
                try:
                    conn.execute(text(sql))
                    conn.commit()
                    print(f"    ‚úÖ Table '{table_name}' cr√©√©e avec succ√®s")
                except Exception as e:
                    print(f"    ‚ö†Ô∏è Erreur cr√©ation table '{table_name}': {e}")
        
        print("‚úÖ Toutes les tables ont √©t√© cr√©√©es avec succ√®s")
        
    except Exception as e:
        print(f"‚ùå Erreur g√©n√©rale: {e}")
        raise
    
@app.route('/super-admin/formule/<int:id>/features', methods=['POST'])
@login_required
@super_admin_required
def super_admin_update_formule_features(id):
    """Mettre √† jour les features d'une formule ET synchroniser les utilisateurs"""
    formule = FormuleAbonnement.query.get_or_404(id)
    
    try:
        # R√©cup√©rer les features depuis le formulaire
        features = {}
        for key in formule.features.keys():
            features[key] = request.form.get(f'features-{key}') == 'on'
        
        formule.features = features
        formule.updated_at = datetime.utcnow()
        
        # ============================================
        # CORRECTION CRITIQUE : MAPPING FEATURES ‚Üí PERMISSIONS
        # ============================================
        print("üîÑ Mise √† jour features avec mapping permissions:")
        
        # MAPPING COMPLET FEATURE ‚Üí PERMISSIONS
        feature_permission_map = {
            'veille_reglementaire': ['can_manage_regulatory'],
            'logigrammes': ['can_manage_logigram'],
            'ia_analyse': ['can_use_ia_analysis'],  # ‚Üê CRITIQUE - manquant !
            'reports_avances': ['can_export_data', 'can_view_reports'],
            'risques': ['can_manage_risks', 'can_validate_risks'],
            'kri': ['can_manage_kri'],
            'audit': ['can_manage_audit', 'can_confirm_evaluations'],
            'tableaux_bord_personnalisables': ['can_view_dashboard']
        }
        
        # S'assurer que le template de permissions existe
        if formule.permissions_template is None:
            formule.permissions_template = {}
        
        # Synchroniser chaque feature avec les permissions
        for feature_key, permission_list in feature_permission_map.items():
            is_feature_active = features.get(feature_key, False)
            
            for permission_key in permission_list:
                if permission_key in formule.permissions_template:
                    old_value = formule.permissions_template[permission_key]
                    new_value = is_feature_active
                    
                    # Appliquer la nouvelle valeur
                    formule.permissions_template[permission_key] = new_value
                    
                    if old_value != new_value:
                        print(f"  üîÑ {permission_key}: {old_value} ‚Üí {new_value} (feature: {feature_key})")
                else:
                    # Si la permission n'existe pas, l'ajouter
                    formule.permissions_template[permission_key] = is_feature_active
                    print(f"  ‚ûï {permission_key} ajout√©: {is_feature_active} (feature: {feature_key})")
        
        db.session.commit()
        
        # ============================================
        # SYNCHRONISER TOUS LES CLIENTS UTILISANT CETTE FORMULE
        # ============================================
        total_users_synced = 0
        
        for client in formule.clients:
            users_synced = sync_user_permissions_with_formule_for_client(client.id)
            total_users_synced += users_synced
        
        flash(f'‚úÖ Features mises √† jour et {total_users_synced} utilisateurs synchronis√©s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
    
    return redirect(url_for('super_admin_editer_formule', id=id))

def sync_user_permissions_with_formule_for_client(client_id):
    """Synchronise les permissions de tous les utilisateurs d'un client"""
    
    client = Client.query.get(client_id)
    if not client or not client.formule:
        return 0
    
    formule = client.formule
    users_synced = 0
    
    # R√©cup√©rer tous les utilisateurs du client
    users = User.query.filter_by(client_id=client_id).all()
    
    for user in users:
        try:
            # Synchroniser les permissions
            if sync_user_permissions_with_formule(user.id):
                users_synced += 1
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur synchronisation {user.username}: {e}")
    
    print(f"‚úÖ {users_synced}/{len(users)} utilisateurs synchronis√©s pour client {client.nom}")
    return users_synced



def check_specific_permissions():
    """V√©rifier les permissions probl√©matiques"""
    with app.app_context():
        formules = FormuleAbonnement.query.all()
        
        for formule in formules:
            print(f"\nüîç V√©rification formule: {formule.nom} ({formule.code})")
            
            # V√©rifier les 3 permissions probl√©matiques
            problematic_perms = {
                'can_use_ia_analysis': 'analyse_ia',
                'can_manage_logigram': 'gestion_processus',
                'can_manage_regulatory': 'veille_reglementaire'
            }
            
            for perm_key, module_key in problematic_perms.items():
                module_active = formule.modules.get(module_key, False)
                perm_active = formule.permissions_template.get(perm_key, False)
                
                status = "‚úÖ OK" if module_active == perm_active else "‚ùå INCOH√âRENT"
                print(f"  {status} {perm_key}:")
                print(f"    Module '{module_key}': {module_active}")
                print(f"    Permission: {perm_active}")
                
                if module_active != perm_active:
                    print(f"    ‚ö†Ô∏è  CORRECTION: permission doit √™tre {module_active}")

# Ajouter automatiquement client_id aux nouvelles zones de risque
@event.listens_for(ZoneRisqueProcessus, 'before_insert')
def add_client_id_to_zone_risque(mapper, connection, target):
    """Ajoute automatiquement client_id aux nouvelles zones de risque"""
    try:
        if hasattr(target, 'client_id') and target.client_id is None:
            if current_user and current_user.is_authenticated:
                # Si la zone est li√©e √† un processus, prendre le client_id du processus
                if target.processus_id:
                    processus = Processus.query.get(target.processus_id)
                    if processus and hasattr(processus, 'client_id'):
                        target.client_id = processus.client_id
                # Sinon, prendre le client_id de l'utilisateur courant
                elif hasattr(current_user, 'client_id'):
                    target.client_id = current_user.client_id
                    
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur ajout client_id zone_risque: {e}")



def delete_user_safely(user_id, current_user_id):
    """Supprime un utilisateur en g√©rant toutes les d√©pendances"""
    
    user = User.query.get(user_id)
    if not user:
        return {'success': False, 'error': 'Utilisateur non trouv√©'}
    
    current_user = User.query.get(current_user_id)
    
    try:
        # Liste des d√©pendances √† v√©rifier et r√©assigner
        dependencies = []
        
        # 1. NOTIFICATIONS - Supprimer ou r√©assigner les notifications
        try:
            # Option A : Supprimer les notifications de l'utilisateur
            notifications_to_delete = Notification.query.filter_by(
                destinataire_id=user.id
            ).all()
            
            if notifications_to_delete:
                for notification in notifications_to_delete:
                    db.session.delete(notification)
                dependencies.append(f'{len(notifications_to_delete)} notification(s) supprim√©e(s)')
                print(f"‚úÖ {len(notifications_to_delete)} notifications supprim√©es")
                
            # Option B : OU r√©assigner √† l'admin (d√©commentez si pr√©f√©rez cette option)
            """
            notifications_to_reassign = Notification.query.filter_by(
                destinataire_id=user.id
            ).all()
            
            if notifications_to_reassign:
                for notification in notifications_to_reassign:
                    notification.destinataire_id = current_user.id
                dependencies.append(f'{len(notifications_to_reassign)} notification(s) r√©assign√©e(s)')
            """
                
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur gestion notifications: {e}")
        
        # 2. Directions
        directions = Direction.query.filter_by(responsable_id=user.id).all()
        if directions:
            for direction in directions:
                direction.responsable_id = current_user.id
            dependencies.append(f'{len(directions)} direction(s)')
        
        # 3. Services
        services = Service.query.filter_by(responsable_id=user.id).all()
        if services:
            for service in services:
                service.responsable_id = current_user.id
            dependencies.append(f'{len(services)} service(s)')
        
        # 4. Zone risque processus
        try:
            # V√©rifier la colonne client_id dynamiquement
            from sqlalchemy import inspect, text
            inspector = inspect(db.engine)
            
            if 'zone_risque_processus' in inspector.get_table_names():
                columns = [col['name'] for col in inspector.get_columns('zone_risque_processus')]
                
                if 'client_id' in columns:
                    zones_count = db.session.execute(text(
                        "SELECT COUNT(*) FROM zone_risque_processus WHERE responsable_id = :user_id AND client_id = :client_id"
                    ), {'user_id': user.id, 'client_id': current_user.client_id}).scalar()
                    
                    if zones_count > 0:
                        db.session.execute(text(
                            "UPDATE zone_risque_processus SET responsable_id = :new_id WHERE responsable_id = :old_id AND client_id = :client_id"
                        ), {'new_id': current_user.id, 'old_id': user.id, 'client_id': current_user.client_id})
                        
                        dependencies.append(f'{zones_count} zone(s) risque')
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur zone_risque_processus: {e}")
        
        # 5. Alertes
        try:
            from sqlalchemy import inspect, text
            inspector = inspect(db.engine)
            
            if 'alertes' in inspector.get_table_names():
                columns = [col['name'] for col in inspector.get_columns('alertes')]
                
                if 'client_id' in columns:
                    alertes_count = db.session.execute(text(
                        "SELECT COUNT(*) FROM alertes WHERE created_by = :user_id AND client_id = :client_id"
                    ), {'user_id': user.id, 'client_id': current_user.client_id}).scalar()
                    
                    if alertes_count > 0:
                        db.session.execute(text(
                            "UPDATE alertes SET est_lue = 1, lue_le = CURRENT_TIMESTAMP WHERE created_by = :user_id AND client_id = :client_id"
                        ), {'user_id': user.id, 'client_id': current_user.client_id})
                        
                        dependencies.append(f'{alertes_count} alerte(s) marqu√©e(s) comme lues')
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur alertes: {e}")
        
        # 6. √âvaluations de risques
        evaluations = EvaluationRisque.query.filter_by(created_by=user.id).all()
        if evaluations:
            for eval in evaluations:
                eval.created_by = current_user.id
            dependencies.append(f'{len(evaluations)} √©valuation(s)')
        
        # 7. Supprimer l'utilisateur AVANT le commit
        username = user.username
        
        # IMPORTANT: Supprimer l'utilisateur avant de commit
        db.session.delete(user)
        
        # Mettre √† jour les statistiques du client
        if user.client_id and current_user.client_id == user.client_id:
            client = Client.query.get(user.client_id)
            if client:
                client.nb_utilisateurs = User.query.filter_by(
                    client_id=user.client_id, 
                    is_active=True
                ).count()
        
        # COMMIT unique apr√®s toutes les modifications
        db.session.commit()
        
        return {
            'success': True,
            'message': f'Utilisateur {username} supprim√©',
            'dependencies': dependencies,
            'username': username
        }
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur suppression utilisateur: {str(e)}")
        import traceback
        traceback.print_exc()
        return {'success': False, 'error': str(e)}


    
def should_display_module(permission_key, user=None):
    """
    D√©termine si un module doit √™tre affich√© en fonction des permissions utilisateur
    """
    if user is None:
        user = current_user
    
    if not user.is_authenticated:
        return False
    
    # SUPER ADMIN : tout voir (optionnel)
    if user.role == 'super_admin':
        return True
    
    # V√©rifier si l'utilisateur a la permission
    return user.permissions.get(permission_key, False)

def get_visible_modules(user=None):
    """
    Retourne la liste des modules visibles pour un utilisateur
    """
    if user is None:
        user = current_user
    
    if not user.is_authenticated:
        return set()
    
    visible_modules = set()
    
    # Permissions de base toujours visibles
    base_modules = {
        'dashboard',  # Tableau de bord toujours visible
        'profil_utilisateur',
        'logout'
    }
    
    # Ajouter les modules selon les permissions
    permission_modules = {
        'can_view_dashboard': ['dashboard'],
        'can_view_reports': ['rapports'],
        'can_manage_risks': ['cartographie', 'risques'],
        'can_manage_kri': ['kri', 'indicateurs'],
        'can_manage_audit': ['audit', 'audits'],
        'can_manage_regulatory': ['veille', 'reglementation'],
        'can_manage_logigram': ['logigrammes', 'processus'],
        'can_manage_action_plans': ['plans_action'],
        'can_view_users_list': ['liste_utilisateurs'],
        'can_view_departments': ['directions', 'services'],
        'can_manage_settings': ['parametrage']
    }
    
    for perm, modules in permission_modules.items():
        if user.permissions.get(perm, False):
            visible_modules.update(modules)
    
    # Toujours ajouter les modules de base
    visible_modules.update(base_modules)
    
    return visible_modules

def filter_menu_items(menu_items, user=None):
    """
    Filtre les √©l√©ments de menu en fonction des permissions
    """
    if user is None:
        user = current_user
    
    visible_modules = get_visible_modules(user)
    filtered_menu = []
    
    for item in menu_items:
        # Si l'item a un attribut 'permission_required'
        if hasattr(item, 'permission_key'):
            if should_display_module(item.permission_key, user):
                filtered_menu.append(item)
        # Si l'item a un attribut 'module_name'
        elif hasattr(item, 'module_name'):
            if item.module_name in visible_modules:
                filtered_menu.append(item)
        # Sinon, on garde l'item (pas de restriction)
        else:
            filtered_menu.append(item)
    
    return filtered_menu


# Filtrer Jinja2 pour v√©rifier l'affichage
@app.template_filter('has_module_access')
def has_module_access_filter(permission_key):
    """Filtre Jinja pour v√©rifier l'acc√®s √† un module"""
    return should_display_module(permission_key)

@app.template_filter('can_view')
def can_view_filter(endpoint):
    """V√©rifie si l'utilisateur peut voir une route sp√©cifique"""
    # Mapping endpoint ‚Üí permission
    endpoint_permission_map = {
        'liste_cartographies': 'can_manage_risks',
        'nouvelle_cartographie': 'can_manage_risks',
        'liste_kri': 'can_manage_kri',
        'nouveau_kri': 'can_manage_kri',
        'liste_audits': 'can_manage_audit',
        'nouvel_audit': 'can_manage_audit',
        'veille_reglementaire': 'can_manage_regulatory',
        'liste_logigrammes': 'can_manage_logigram',
        'nouveau_logigramme': 'can_manage_logigram',
        'liste_plans_action': 'can_manage_action_plans',
        'admin_utilisateurs': 'can_view_users_list',
        'admin_nouvel_utilisateur': 'can_edit_users',
        'admin_directions': 'can_view_departments',
        'parametrage_risque': 'can_manage_settings',
        'parametrage_champs': 'can_manage_settings'
    }
    
    permission_key = endpoint_permission_map.get(endpoint)
    if permission_key:
        return should_display_module(permission_key)
    
    # Si pas dans la map, autoriser par d√©faut (s√©curit√©)
    return True

# Injecter dans tous les templates
@app.context_processor
def inject_permission_helpers():
    """Injecte les helpers de permissions dans tous les templates"""
    return {
        'should_display_module': should_display_module,
        'get_visible_modules': get_visible_modules,
        'has_permission': lambda perm: current_user.permissions.get(perm, False) if current_user.is_authenticated else False,
        'can_access_route': lambda endpoint: can_view_filter(endpoint)
    }

@app.before_request
def check_module_access_middleware():
    """
    Middleware pour v√©rifier l'acc√®s aux routes en fonction des permissions
    - VERSION CORRIG√âE pour gestionnaire aussi
    """
    if not current_user.is_authenticated:
        return
    
    # Ne pas v√©rifier pour certaines routes
    exempt_routes = ['static', 'login', 'logout', 'public_home']
    if request.endpoint in exempt_routes:
        return
    
    # Liste des endpoints qui n√©cessitent une permission sp√©cifique
    protected_endpoints = {
        # Risques
        'liste_cartographies': 'can_manage_risks',
        'nouvelle_cartographie': 'can_manage_risks',
        'modifier_cartographie': 'can_manage_risks',
        'detail_cartographie': 'can_manage_risks',
        
        # KRI
        'liste_kri': 'can_manage_kri',
        'nouveau_kri': 'can_manage_kri',
        'modifier_kri': 'can_manage_kri',
        
        # Audit
        'liste_audits': 'can_manage_audit',
        'nouvel_audit': 'can_manage_audit',
        'detail_audit': 'can_manage_audit',
        
        # Veille
        'veille_reglementaire': 'can_manage_regulatory',
        'nouvelle_veille': 'can_manage_regulatory',
        
        # Logigrammes
        'liste_logigrammes': 'can_manage_logigram',
        'nouveau_logigramme': 'can_manage_logigram',
        'editer_logigramme': 'can_manage_logigram',
        
        # Plans d'action
        'liste_plans_action': 'can_view_action_plans',
        
        # Utilisateurs - CORRECTION ICI
        'admin_utilisateurs': 'can_view_users_list',
        'admin_nouvel_utilisateur': 'can_create_users',  # CHANG√â de 'can_edit_users' √† 'can_create_users'
        'admin_editer_utilisateur': 'can_edit_users',
        
        # Routes GESTIONNAIRE sp√©cifiques
        'gestionnaire_utilisateurs': 'can_view_users_list',
        'gestionnaire_creer_utilisateur': 'can_create_users',  # AJOUT√â
        'gestionnaire_editer_utilisateur': 'can_edit_users',   # AJOUT√â
        'gestionnaire_gerer_permissions': 'can_manage_permissions',  # AJOUT√â
        
        # Directions
        'admin_directions': 'can_view_departments',
        'nouvelle_direction': 'can_manage_departments',
        
        # Param√©trage
        'parametrage_risque': 'can_manage_settings',
        'parametrage_champs': 'can_manage_settings',
        'parametrage_fichiers': 'can_manage_settings'
    }
    
    endpoint = request.endpoint
    
    if endpoint in protected_endpoints:
        required_permission = protected_endpoints[endpoint]
        
        # DEBUG
        print(f"üîç [MIDDLEWARE] V√©rification endpoint: {endpoint}")
        print(f"   Permission requise: {required_permission}")
        print(f"   Utilisateur: {current_user.username} (r√¥le: {current_user.role})")
        
        # V√©rifier la permission
        has_perm = current_user.has_permission(required_permission)
        print(f"   R√©sultat permission: {has_perm}")
        
        if not has_perm:
            print(f"   ‚ùå Permission refus√©e par middleware")
            
            # Si c'est une route gestionnaire, proposer une solution
            if endpoint.startswith('gestionnaire_'):
                flash(f'Permission "{required_permission}" manquante. Les gestionnaires doivent avoir "can_manage_users = True" pour acc√©der √† cette fonctionnalit√©.', 'error')
            else:
                flash(f'Acc√®s non autoris√© au module {endpoint}. Permission "{required_permission}" requise.', 'error')
            
            return redirect(url_for('dashboard'))
        else:
            print(f"   ‚úÖ Permission accord√©e par middleware")


@app.route('/activate-gestionnaire-permissions')
@login_required
def activate_gestionnaire_permissions():
    """Active les permissions de gestionnaire pour l'utilisateur courant"""
    
    if current_user.role != 'manager':
        flash('Cette fonction est r√©serv√©e aux gestionnaires', 'error')
        return redirect(url_for('dashboard'))
    
    try:
        # Activer le flag can_manage_users
        current_user.can_manage_users = True
        
        # Ajouter les permissions manquantes
        if current_user.permissions is None:
            current_user.permissions = {}
        
        gestionnaire_permissions = {
            'can_create_users': True,
            'can_edit_users': True,
            'can_deactivate_users': True,
            'can_delete_users': True,
            'can_view_users_list': True,
            'can_manage_permissions': True,
            'can_manage_risks': True,
            'can_manage_kri': True,
            'can_manage_audit': True,
            'can_manage_action_plans': True,
            'can_view_action_plans': True
        }
        
        for perm, value in gestionnaire_permissions.items():
            current_user.permissions[perm] = value
        
        db.session.commit()
        
        flash('‚úÖ Permissions de gestionnaire activ√©es avec succ√®s!', 'success')
        
        # Tester imm√©diatement
        test_url = url_for('gestionnaire_utilisateurs') if url_exists('gestionnaire_utilisateurs') else url_for('admin_utilisateurs')
        return redirect(test_url)
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
        return redirect(url_for('dashboard'))

@app.route('/api/user/modules/visible')
@login_required
def api_get_visible_modules():
    """API pour r√©cup√©rer les modules visibles"""
    return jsonify({
        'visible_modules': list(get_visible_modules()),
        'permissions': current_user.permissions
    })

@app.route('/api/user/can-access/<module_name>')
@login_required
def api_can_access_module(module_name):
    """API pour v√©rifier l'acc√®s √† un module sp√©cifique"""
    
    module_permission_map = {
        'cartographie': 'can_manage_risks',
        'kri': 'can_manage_kri',
        'audit': 'can_manage_audit',
        'veille': 'can_manage_regulatory',
        'logigrammes': 'can_manage_logigram',
        'plans_action': 'can_manage_action_plans',
        'utilisateurs': 'can_view_users_list',
        'directions': 'can_view_departments',
        'parametrage': 'can_manage_settings'
    }
    
    permission_key = module_permission_map.get(module_name)
    
    if permission_key:
        can_access = should_display_module(permission_key)
        return jsonify({
            'module': module_name,
            'can_access': can_access,
            'required_permission': permission_key,
            'user_has_permission': current_user.permissions.get(permission_key, False)
        })
    
    return jsonify({
        'module': module_name,
        'can_access': True,  # Par d√©faut si module non r√©pertori√©
        'message': 'Module non r√©pertori√© dans les contr√¥les d\'acc√®s'
    })


@app.route('/admin/refresh-sqlalchemy-cache')
@login_required
def refresh_sqlalchemy_cache_route():
    """Route pour r√©initialiser manuellement le cache SQLAlchemy"""
    
    # Autoriser super admin et admin client
    if not (current_user.role == 'super_admin' or 
            (current_user.role == 'admin' and current_user.is_client_admin)):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    try:
        refresh_sqlalchemy_cache()
        
        # Tester une requ√™te sur alertes
        from sqlalchemy import text
        
        try:
            # V√©rifier que la requ√™te fonctionne maintenant
            test_result = db.session.execute(text(
                "SELECT id, titre, client_id FROM alertes WHERE created_by = :user_id LIMIT 1"
            ), {'user_id': current_user.id}).fetchone()
            
            test_success = test_result is not None
            
            return jsonify({
                'success': True,
                'message': 'Cache SQLAlchemy r√©initialis√© avec succ√®s',
                'test_query': 'OK' if test_success else 'Erreur',
                'test_result': str(test_result) if test_result else None
            })
            
        except Exception as test_error:
            return jsonify({
                'success': False,
                'message': 'Cache r√©initialis√© mais requ√™te test √©chou√©e',
                'error': str(test_error)
            })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    
        
@app.route('/admin/utilisateur/<int:id>/supprimer', methods=['POST'])
@login_required
def admin_supprimer_utilisateur(id):
    """Supprimer un utilisateur avec gestion des d√©pendances"""
    
    # V√©rifier la permission
    if not current_user.has_permission('can_edit_users'):
        flash('Permission non autoris√©e', 'error')
        return redirect(url_for('admin_utilisateurs'))
    
    user = User.query.get_or_404(id)
    
    # V√©rifier l'acc√®s
    if current_user.role != 'super_admin':
        if user.client_id != current_user.client_id:
            flash('Acc√®s non autoris√© √† cet utilisateur', 'error')
            return redirect(url_for('admin_utilisateurs'))
        
        # Emp√™cher un admin client de supprimer un autre admin client
        if user.is_client_admin and user.id != current_user.id:
            flash('Vous ne pouvez pas supprimer un autre administrateur client', 'error')
            return redirect(url_for('admin_utilisateurs'))
    
    # Emp√™cher l'utilisateur de se supprimer lui-m√™me
    if user.id == current_user.id:
        flash('Vous ne pouvez pas supprimer votre propre compte', 'error')
        return redirect(url_for('admin_utilisateurs'))
    
    # Utiliser la fonction de suppression s√©curis√©e
    result = delete_user_safely(id, current_user.id)
    
    if result['success']:
        # Journaliser
        log_activity(current_user.id, 'suppression_utilisateur',
                    f"Suppression utilisateur {result['username']}",
                    'utilisateur', id)
        
        flash(f"‚úÖ Utilisateur {result['username']} supprim√© avec succ√®s", 'success')
        
        # Afficher les d√©pendances g√©r√©es
        if result.get('dependencies'):
            flash(f"üìã D√©pendances g√©r√©es: {', '.join(result['dependencies'])}", 'info')
    else:
        flash(f'‚ùå Erreur lors de la suppression: {result["error"]}', 'error')
    
    return redirect(url_for('admin_utilisateurs'))


def has_permission(self, permission):
    """V√©rifie si l'utilisateur a une permission sp√©cifique - VERSION CORRIG√âE"""
    
    print(f"üîê [DEBUG] V√©rification permission '{permission}' pour {self.username} (r√¥le: {self.role}, client_admin: {self.is_client_admin})")
    
    # 1. SUPER ADMIN : TOUJOURS AUTORIS√â
    if self.role == 'super_admin':
        print(f"   ‚úÖ Super admin - acc√®s imm√©diat")
        return True
    
    # 2. V√©rifier si l'utilisateur est un ADMIN CLIENT
    is_admin_client = (self.role == 'admin') or (getattr(self, 'is_client_admin', False))
    
    if is_admin_client:
        print(f"   üëë Utilisateur est un ADMIN CLIENT")
        
        # ‚úÖ CORRECTION : Liste des permissions OBLIGATOIRES pour admin client
        permissions_admin_obligatoires = {
            # Tableau de bord et visualisation
            'can_view_dashboard': True,
            'can_view_reports': True,
            'can_view_departments': True,
            'can_view_notifications': True,
            
            # Gestion des utilisateurs - AJOUT IMPORTANT
            'can_view_users_list': True,      # ‚Üê VOIR LA LISTE DES UTILISATEURS
            'can_edit_users': True,            # ‚Üê MODIFIER DES UTILISATEURS
            'can_create_users': True,          # ‚Üê CR√âER DES UTILISATEURS
            'can_deactivate_users': True,      # ‚Üê D√âSACTIVER DES UTILISATEURS
            'can_delete_users': True,          # ‚Üê SUPPRIMER DES UTILISATEURS
            'can_manage_users': True,          # ‚Üê G√âRER LES UTILISATEURS
            
            # Gestion des risques
            'can_manage_risks': True,
            'can_validate_risks': True,
            
            # Gestion des KRI
            'can_manage_kri': True,            # ‚Üê G√âRER LES KRI
            
            # Gestion des audits
            'can_manage_audit': True,
            'can_confirm_evaluations': True,
            
            # Plans d'action
            'can_manage_action_plans': True,
            'can_view_action_plans': True,
            
            # Gestion des d√©partements
            'can_manage_departments': True,
            'can_access_all_departments': True,
            
            # Administration
            'can_manage_settings': True,
            'can_archive_data': True,
            'can_export_data': True,
            
            # Veille r√®glementaire
            'can_manage_regulatory': True if self.client and self.client.formule and 
                                           self.client.formule.modules.get('veille_reglementaire', False) else False,
            
            # Processus
            'can_manage_logigram': True if self.client and self.client.formule and 
                                         self.client.formule.modules.get('gestion_processus', False) else False,
            
            # Permissions √† TOUJOURS FALSE pour admin client
            'can_manage_clients': False,
            'can_provision_servers': False,
        }
        
        if permission in permissions_admin_obligatoires:
            value = permissions_admin_obligatoires[permission]
            print(f"   üìã Permission admin obligatoire '{permission}': {value}")
            return value
    
    # 3. V√©rifier si l'utilisateur est un GESTIONNAIRE (manager)
    if self.role == 'manager':
        print(f"   üë§ Utilisateur est un GESTIONNAIRE (manager)")
        
        permissions_manager_base = {
            # Visualisation de base
            'can_view_dashboard': True,
            'can_view_reports': True,
            'can_view_departments': True,
            'can_view_notifications': True,
            
            # Gestion des risques
            'can_manage_risks': True,
            'can_validate_risks': True,
            
            # KRI
            'can_manage_kri': True,
            
            # Audit
            'can_manage_audit': True,
            
            # Plans d'action
            'can_view_action_plans': True,
            'can_manage_action_plans': True,
            
            # Acc√®s aux d√©partements
            'can_access_all_departments': True,
            
            # Export
            'can_export_data': True,
            
            # ‚úÖ Gestion des utilisateurs - pour les managers
            'can_view_users_list': True,       # ‚Üê VOIR LA LISTE DES UTILISATEURS
            'can_edit_users': True,             # ‚Üê MODIFIER DES UTILISATEURS
            'can_create_users': True,            # ‚Üê CR√âER DES UTILISATEURS
            
            # Administration limit√©e
            'can_manage_settings': True,
            'can_manage_departments': True,
            
            # Permissions r√©serv√©es aux admin
            'can_manage_clients': False,
            'can_provision_servers': False,
        }
        
        if permission in permissions_manager_base:
            value = permissions_manager_base[permission]
            print(f"   üìã Permission manager '{permission}': {value}")
            return value
    
    # 4. V√©rifier les permissions EXPLICITES dans user.permissions
    if self.permissions and permission in self.permissions:
        value = bool(self.permissions[permission])
        print(f"   üìã Permission explicite dans DB: {value}")
        return value
    
    # 5. Permissions par D√âFAUT selon le r√¥le
    role_defaults = {
        'auditeur': {
            'can_view_dashboard': True,
            'can_view_reports': True,
            'can_view_departments': True,
            'can_view_notifications': True,
            'can_manage_audit': True,
            'can_view_action_plans': True,
            'can_view_users_list': True,  # ‚Üê AJOUT
        },
        'utilisateur': {
            'can_view_dashboard': True,
            'can_view_reports': True,
            'can_view_departments': True,
            'can_view_notifications': True,
            'can_view_action_plans': True,
            'can_view_users_list': True,  # ‚Üê AJOUT (pour voir les coll√®gues)
        },
        'compliance': {
            'can_view_dashboard': True,
            'can_view_reports': True,
            'can_view_departments': True,
            'can_view_notifications': True,
            'can_manage_regulatory': True,
            'can_view_users_list': True,  # ‚Üê AJOUT
        },
        'consultant': {
            'can_view_dashboard': True,
            'can_view_reports': True,
            'can_view_departments': True,
            'can_create_users': True,
            'can_view_users_list': True,  # ‚Üê AJOUT
        }
    }
    
    if self.role in role_defaults and permission in role_defaults[self.role]:
        value = role_defaults[self.role][permission]
        print(f"   üìã Permission par d√©faut pour r√¥le '{self.role}': {value}")
        return value
    
    print(f"   ‚ùå Permission '{permission}' REFUS√âE par d√©faut")
    return False


@app.route('/api/fix-all-managers-now')
@login_required
@super_admin_required
def fix_all_managers_now():
    """Corrige TOUS les gestionnaires imm√©diatement"""
    
    try:
        # Trouver tous les gestionnaires
        managers = User.query.filter(
            db.or_(
                User.role == 'manager',
                User.can_manage_users == True
            )
        ).all()
        
        print(f"üîß Correction de {len(managers)} gestionnaires...")
        
        for manager in managers:
            print(f"  üë§ {manager.username} (r√¥le: {manager.role})")
            
            # Initialiser permissions si n√©cessaire
            if manager.permissions is None:
                manager.permissions = {}
            
            # Permissions OBLIGATOIRES pour gestionnaire
            required_permissions = {
                'can_create_users': True,
                'can_edit_users': True,
                'can_deactivate_users': True,
                'can_delete_users': True,
                'can_view_users_list': True,
                'can_manage_users': True,
                'can_manage_permissions': True,
                'can_block_users': True,
                'can_manage_risks': True,
                'can_manage_kri': True,
                'can_manage_audit': True,
                'can_manage_action_plans': True,
                'can_view_action_plans': True,
                'can_view_dashboard': True,
                'can_view_reports': True,
                'can_view_departments': True,
                'can_export_data': True,
                'can_archive_data': True
            }
            
            # Appliquer toutes les permissions manquantes
            for perm, value in required_permissions.items():
                if not manager.permissions.get(perm, False):
                    manager.permissions[perm] = value
                    print(f"    ‚ûï {perm} = {value}")
            
            # Activer le flag
            manager.can_manage_users = True
            
            manager.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        flash(f'‚úÖ {len(managers)} gestionnaires corrig√©s avec succ√®s !', 'success')
        
        return jsonify({
            'success': True,
            'managers_fixed': len(managers),
            'message': f'{len(managers)} gestionnaires corrig√©s'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500

@app.route('/emergency-fix-manager-now/<int:manager_id>')
@login_required
def emergency_fix_manager_now(manager_id):
    """Correction d'urgence pour un gestionnaire sp√©cifique"""
    
    # V√©rifier que c'est bien un manager
    if current_user.role != 'manager' or current_user.id != manager_id:
        if current_user.role != 'super_admin':
            flash('Acc√®s non autoris√©', 'error')
            return redirect(url_for('dashboard'))
    
    manager = User.query.get_or_404(manager_id)
    
    try:
        print(f"üö® CORRECTION D'URGENCE pour {manager.username}")
        
        # 1. Activer le flag can_manage_users
        manager.can_manage_users = True
        
        # 2. Initialiser permissions
        if manager.permissions is None:
            manager.permissions = {}
        
        # 3. FORCER toutes les permissions de gestionnaire
        emergency_permissions = {
            # Permissions de gestion utilisateurs
            'can_create_users': True,
            'can_edit_users': True,
            'can_deactivate_users': True,
            'can_delete_users': True,
            'can_view_users_list': True,
            'can_manage_users': True,
            'can_manage_permissions': True,
            'can_block_users': True,
            
            # Permissions de base
            'can_view_dashboard': True,
            'can_view_reports': True,
            'can_view_departments': True,
            'can_view_action_plans': True,
            'can_view_notifications': True,
            
            # Permissions m√©tier
            'can_manage_risks': True,
            'can_manage_kri': True,
            'can_manage_audit': True,
            'can_manage_action_plans': True,
            
            # Administration
            'can_export_data': True,
            'can_archive_data': True
        }
        
        # Remplacer compl√®tement les permissions
        manager.permissions.update(emergency_permissions)
        
        # 4. Commit
        db.session.commit()
        
        # 5. Rafra√Æchir
        db.session.refresh(manager)
        
        flash('üö® PERMISSIONS DE GESTIONNAIRE FORC√âES AVEC SUCC√àS !', 'success')
        
        # V√©rifier imm√©diatement
        test_url = url_for('gestionnaire_utilisateurs')
        return f"""
        <html>
        <head><title>Correction d'urgence</title></head>
        <body style="padding: 20px; font-family: Arial;">
            <h1>‚úÖ Correction appliqu√©e !</h1>
            <p>Permissions mises √† jour pour {manager.username}</p>
            <p><strong>can_manage_users:</strong> {manager.can_manage_users}</p>
            <p><strong>can_create_users:</strong> {manager.permissions.get('can_create_users')}</p>
            <p><strong>can_edit_users:</strong> {manager.permissions.get('can_edit_users')}</p>
            <p><a href="{test_url}">‚Üí Tester maintenant ‚Üê</a></p>
        </body>
        </html>
        """
        
    except Exception as e:
        db.session.rollback()
        return f"‚ùå Erreur: {str(e)}"

@app.route('/test-gestionnaire-permissions')
@login_required
def test_gestionnaire_permissions():
    """Testez vos permissions de gestionnaire"""
    
    if current_user.role != 'manager':
        return "‚ùå Pas un gestionnaire"
    
    tests = [
        ('can_create_users', 'Cr√©er utilisateurs'),
        ('can_edit_users', 'Modifier utilisateurs'),
        ('can_deactivate_users', 'D√©sactiver utilisateurs'),
        ('can_delete_users', 'Supprimer utilisateurs'),
        ('can_view_users_list', 'Voir liste utilisateurs'),
        ('can_manage_permissions', 'G√©rer permissions'),
        ('can_manage_users', 'G√©rer utilisateurs')
    ]
    
    results = []
    for perm_code, perm_name in tests:
        has_perm = current_user.has_permission(perm_code)
        results.append({
            'permission': perm_code,
            'name': perm_name,
            'has': has_perm,
            'icon': '‚úÖ' if has_perm else '‚ùå'
        })
    
    html = f"""
    <html>
    <head><title>Test Permissions Gestionnaire</title></head>
    <body style="padding: 20px; font-family: Arial;">
        <h1>üîß Test des permissions pour {current_user.username}</h1>
        <p><strong>R√¥le:</strong> {current_user.role}</p>
        <p><strong>can_manage_users:</strong> {current_user.can_manage_users}</p>
        
        <h2>Permissions de gestion des utilisateurs :</h2>
        <table border="1" style="border-collapse: collapse; width: 100%;">
            <tr style="background: #f5f5f5;">
                <th style="padding: 10px;">Permission</th>
                <th style="padding: 10px;">Description</th>
                <th style="padding: 10px;">Status</th>
            </tr>
    """
    
    for r in results:
        html += f"""
            <tr>
                <td style="padding: 10px;"><code>{r['permission']}</code></td>
                <td style="padding: 10px;">{r['name']}</td>
                <td style="padding: 10px; text-align: center; color: {'green' if r['has'] else 'red'}">
                    {r['icon']} {r['has']}
                </td>
            </tr>
        """
    
    html += """
        </table>
        
        <div style="margin-top: 30px; padding: 20px; background: #e8f5e8;">
            <h3>Actions :</h3>
            <ul>
                <li><a href="/force-activate-gestionnaire-permissions" style="color: blue;">üîß FORCER l'activation de toutes les permissions</a></li>
                <li><a href="/gestionnaire/utilisateurs" style="color: blue;">üìã Tester l'acc√®s √† la gestion des utilisateurs</a></li>
                <li><a href="/" style="color: blue;">üè† Retour au dashboard</a></li>
            </ul>
        </div>
    </body>
    </html>
    """
    
    return html
@app.route('/api/force-update-my-permissions', methods=['POST'])
@login_required
def api_force_update_my_permissions():
    """Force la mise √† jour des permissions de l'utilisateur courant"""
    
    try:
        print(f"üîß Force update permissions pour {current_user.username}")
        
        # S'assurer que permissions existe
        if current_user.permissions is None:
            current_user.permissions = {}
        
        # Permissions OBLIGATOIRES pour gestionnaire
        required_permissions = {
            'can_create_users': True,
            'can_edit_users': True,
            'can_deactivate_users': True,
            'can_delete_users': True,
            'can_manage_users': True,
            'can_block_users': True,
            'can_manage_permissions': True,
            'can_view_users_list': True
        }
        
        # Remplacer compl√®tement les permissions
        current_user.permissions.update(required_permissions)
        
        # Activer le flag
        current_user.can_manage_users = True
        
        # Forcer la sauvegarde
        db.session.commit()
        
        # Rafra√Æchir l'objet depuis la base
        db.session.refresh(current_user)
        
        return jsonify({
            'success': True,
            'message': 'Permissions mises √† jour avec force',
            'permissions': current_user.permissions,
            'can_manage_users': current_user.can_manage_users
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500



@app.route('/force-reset-all-manager-permissions')
@login_required
def force_reset_all_manager_permissions():
    """R√©initialise COMPL√àTEMENT toutes les permissions pour les managers"""
    
    # Seulement pour managers
    if current_user.role != 'manager':
        flash('Cette fonction est r√©serv√©e aux gestionnaires', 'error')
        return redirect(url_for('dashboard'))
    
    try:
        print(f"üö® FORCE RESET pour {current_user.username}")
        
        # 1. R√âINITIALISER COMPL√àTEMENT les permissions
        current_user.permissions = {
            # ==================== GESTION UTILISATEURS ====================
            'can_create_users': True,
            'can_edit_users': True,
            'can_deactivate_users': True,
            'can_delete_users': True,
            'can_view_users_list': True,
            'can_manage_users': True,
            'can_block_users': True,
            'can_manage_permissions': True,
            
            # ==================== VISUALISATION ====================
            'can_view_dashboard': True,
            'can_view_reports': True,
            'can_view_departments': True,
            'can_view_notifications': True,
            'can_view_action_plans': True,
            'can_view_users_list': True,
            
            # ==================== GESTION RISQUES ====================
            'can_manage_risks': True,
            'can_validate_risks': True,
            'can_manage_kri': True,
            
            # ==================== GESTION AUDIT ====================
            'can_manage_audit': True,
            'can_confirm_evaluations': True,
            'can_manage_action_plans': True,
            
            # ==================== ADMINISTRATION ====================
            'can_export_data': True,
            'can_archive_data': True,
            
            # ==================== PARAM√âTRAGE ====================
            'can_manage_settings': False,
            'can_manage_departments': False,
            
            # ==================== SYST√àME ====================
            'can_manage_clients': False,
            'can_provision_servers': False
        }
        
        # 2. Activer le flag can_manage_users
        current_user.can_manage_users = True
        
        # 3. FORCER le commit
        db.session.commit()
        
        # 4. Rafra√Æchir depuis la base
        db.session.refresh(current_user)
        
        flash('üö® PERMISSIONS R√âINITIALIS√âES AVEC SUCC√àS!', 'success')
        
        # 5. Tester imm√©diatement
        return redirect(url_for('gestionnaire_utilisateurs'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
        return redirect(url_for('dashboard'))
    

@app.route('/force-activate-gestionnaire-permissions')
@login_required
def force_activate_gestionnaire_permissions():
    """Force l'activation de TOUTES les permissions pour gestionnaire"""
    
    if current_user.role != 'manager':
        flash('R√©serv√© aux gestionnaires', 'error')
        return redirect(url_for('dashboard'))
    
    try:
        # Initialiser permissions
        if current_user.permissions is None:
            current_user.permissions = {}
        
        # Liste compl√®te des permissions pour gestionnaire
        all_permissions = [
            # Gestion utilisateurs
            'can_view_users_list', 'can_create_users', 'can_edit_users',
            'can_deactivate_users', 'can_delete_users', 'can_manage_users',
            'can_manage_permissions', 'can_block_users',
            
            # Visualisation
            'can_view_dashboard', 'can_view_reports', 'can_view_departments',
            'can_view_notifications', 'can_view_action_plans',
            
            # Gestion risques
            'can_manage_risks', 'can_validate_risks', 'can_manage_kri',
            
            # Gestion audits
            'can_manage_audit', 'can_confirm_evaluations', 'can_manage_action_plans',
            
            # Administration
            'can_export_data', 'can_archive_data'
        ]
        
        # Activer TOUTES les permissions
        for perm in all_permissions:
            current_user.permissions[perm] = True
        
        # Activer le flag
        current_user.can_manage_users = True
        
        db.session.commit()
        
        flash('‚úÖ TOUTES les permissions activ√©es ! Vous pouvez maintenant g√©rer les utilisateurs.', 'success')
        return redirect(url_for('gestionnaire_utilisateurs'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
        return redirect(url_for('dashboard'))

@app.route('/fix-all-admin-permissions')
@login_required
@super_admin_required
def fix_all_admin_permissions():
    """Corrige toutes les permissions des admin clients"""
    
    try:
        # Trouver tous les admin clients
        admin_clients = User.query.filter(
            (User.role == 'admin') | (User.is_client_admin == True)
        ).all()
        
        corrections = 0
        
        for admin in admin_clients:
            print(f"üîß Correction permissions pour {admin.username}")
            
            # Initialiser permissions si n√©cessaire
            if admin.permissions is None:
                admin.permissions = {}
            
            # Permissions OBLIGATOIRES pour admin client
            required_permissions = {
                'can_view_dashboard': True,
                'can_view_reports': True,
                'can_view_departments': True,
                'can_view_users_list': True,
                'can_edit_users': True,
                'can_manage_users': True,
                'can_manage_settings': True,
                'can_manage_risks': True,
                'can_manage_kri': True,
                'can_manage_audit': True,
                'can_view_notifications': True,  # CRITIQUE
                'can_manage_action_plans': True,
                'can_view_action_plans': True,
                'can_export_data': True,
                'can_validate_risks': True,
                'can_confirm_evaluations': True
            }
            
            # Appliquer les permissions
            for perm, value in required_permissions.items():
                if admin.permissions.get(perm) != value:
                    admin.permissions[perm] = value
                    corrections += 1
                    print(f"  ‚ûï {perm}: {admin.permissions.get(perm)} ‚Üí {value}")
        
        db.session.commit()
        
        flash(f'‚úÖ {corrections} permissions corrig√©es pour {len(admin_clients)} admin clients', 'success')
        return jsonify({
            'success': True,
            'corrections': corrections,
            'admins_fixed': len(admin_clients)
        })
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
        return jsonify({'error': str(e)}), 500


@app.before_request
def ensure_admin_client_permissions():
    """Garantit que les admin clients ont toujours les permissions de base"""
    
    if current_user.is_authenticated:
        # V√©rifier toutes les 5 minutes seulement
        last_check = session.get('last_admin_check', 0)
        now = datetime.utcnow().timestamp()
        
        if (current_user.is_client_admin or current_user.role == 'admin') and (now - last_check > 300):
            session['last_admin_check'] = now
            
            # Permissions obligatoires
            required_permissions = [
                'can_view_notifications',
                'can_view_dashboard',
                'can_view_reports',
                'can_view_departments',
                'can_view_users_list'
            ]
            
            needs_update = False
            
            if current_user.permissions is None:
                current_user.permissions = {}
            
            for perm in required_permissions:
                if not current_user.permissions.get(perm, False):
                    current_user.permissions[perm] = True
                    needs_update = True
                    print(f"üîÑ Permission ajout√©e pour {current_user.username}: {perm}")
            
            if needs_update:
                try:
                    db.session.commit()
                    print(f"‚úÖ Permissions garanties pour admin client: {current_user.username}")
                except Exception as e:
                    db.session.rollback()
                    print(f"‚ö†Ô∏è Erreur garantie permissions: {e}")


@app.route('/debug/admin-permissions')
@login_required
def debug_admin_permissions():
    """D√©bogage sp√©cifique pour les permissions admin"""
    
    html = f"""
    <html>
    <head><title>Debug Permissions Admin</title></head>
    <body style="padding: 20px; font-family: Arial;">
        <h1>üîç Debug Permissions Admin Client</h1>
        
        <div style="background: #f5f5f5; padding: 20px; margin: 20px 0;">
            <h3>Utilisateur: {current_user.username}</h3>
            <p><strong>R√¥le:</strong> {current_user.role}</p>
            <p><strong>is_client_admin:</strong> {current_user.is_client_admin}</p>
            <p><strong>Client ID:</strong> {current_user.client_id}</p>
            <p><strong>can_manage_users:</strong> {current_user.can_manage_users}</p>
        </div>
        
        <div style="background: #e8f5e8; padding: 20px; margin: 20px 0;">
            <h3>Permissions critiques:</h3>
            <ul>
                <li>can_view_notifications: {current_user.has_permission('can_view_notifications')}</li>
                <li>can_view_dashboard: {current_user.has_permission('can_view_dashboard')}</li>
                <li>can_view_reports: {current_user.has_permission('can_view_reports')}</li>
                <li>can_view_departments: {current_user.has_permission('can_view_departments')}</li>
                <li>can_view_users_list: {current_user.has_permission('can_view_users_list')}</li>
            </ul>
        </div>
        
        <div style="background: #fff3cd; padding: 20px; margin: 20px 0;">
            <h3>Actions rapides:</h3>
            <a href="/fix-all-admin-permissions" style="color: blue;">Corriger TOUTES les permissions admin</a><br>
            <a href="/client-admin/dashboard" style="color: blue;">Retour au dashboard admin</a><br>
            <a href="/notifications" style="color: blue;">Tester les notifications</a>
        </div>
    </body>
    </html>
    """
    
    return html

# Filtre Jinja pour v√©rifier les permissions dans les templates
@app.template_filter('has_permission')
def has_permission_filter(user, permission):
    return user.has_permission(permission)

# Filtre pour formater les permissions
@app.template_filter('format_permissions')
def format_permissions_filter(permissions_dict):
    readable = {
        'can_view_dashboard': 'Voir tableau de bord',
        'can_manage_risks': 'G√©rer les risques',
        'can_manage_kri': 'G√©rer les KRI',
        'can_manage_audit': 'G√©rer les audits',
        'can_manage_regulatory': 'G√©rer la veille r√©glementaire',
        'can_manage_logigram': 'G√©rer les logigrammes',
        'can_manage_users': 'G√©rer les utilisateurs',
        'can_manage_settings': 'G√©rer les param√®tres',
        'can_export_data': 'Exporter des donn√©es',
        'can_view_reports': 'Consulter les rapports',
        'can_delete_data': 'Supprimer des donn√©es',
        'can_manage_permissions': 'G√©rer les permissions'
    }
    
    result = []
    for perm, has_perm in permissions_dict.items():
        if has_perm and perm in readable:
            result.append(readable[perm])
    
    return result

@app.before_request
def check_permissions():
    """V√©rifie les permissions pour chaque requ√™te"""
    if current_user.is_authenticated:
        # Liste des endpoints prot√©g√©s et leurs permissions requises
        protected_endpoints = {
            'liste_cartographies': 'can_manage_risks',
            'nouvelle_cartographie': 'can_manage_risks',
            'liste_kri': 'can_manage_kri',
            'nouveau_kri': 'can_manage_kri',
            'liste_audits': 'can_manage_audit',
            'nouvel_audit': 'can_manage_audit',
            'veille_reglementaire': 'can_manage_regulatory',
            'liste_logigrammes': 'can_manage_logigram',
            'admin_dashboard': 'can_manage_users',
            'admin_utilisateurs': 'can_manage_users',
            'rapports': 'can_view_reports',
            'export_risques': 'can_export_data'
        }
        
        endpoint = request.endpoint
        if endpoint in protected_endpoints:
            required_permission = protected_endpoints[endpoint]
            if not current_user.has_permission(required_permission):
                flash('Acc√®s refus√© : permissions insuffisantes', 'error')
                return redirect(url_for('dashboard'))

            


# ========================
# ROUTES SUPERVISEUR CLIENT
# ========================

@app.route('/super-admin/clients')
@login_required
@super_admin_required
def super_admin_clients():
    """Liste des clients (super admin uniquement)"""
    clients = Client.query.order_by(Client.created_at.desc()).all()
    return render_template('super_admin/clients.html', clients=clients)

@app.route('/super-admin/client/nouveau', methods=['GET', 'POST'])
@login_required
@super_admin_required
def super_admin_nouveau_client():
    """Cr√©er un nouveau client avec gestion des formules"""
    from forms_admin import NouveauClientForm
    
    form = NouveauClientForm()
    
    # R√©cup√©rer les formules disponibles
    formules_disponibles = FormuleAbonnement.query.filter_by(is_active=True).order_by(FormuleAbonnement.ordre_affichage).all()
    
    # Mettre √† jour les choix du champ plan
    form.plan.choices = [(f.code, f"{f.nom} ({f.prix_mensuel}‚Ç¨/mois)") for f in formules_disponibles]
    
    print(f"üîç DEBUG: M√©thode HTTP = {request.method}")
    print(f"üîç DEBUG: Formulaire soumis = {form.is_submitted()}")
    print(f"üîç DEBUG: Validation = {form.validate_on_submit()}")
    
    if form.validate_on_submit():
        print("‚úÖ Formulaire valid√© avec succ√®s")
        try:
            # Trouver la formule s√©lectionn√©e
            formule_selectionnee = FormuleAbonnement.query.filter_by(code=form.plan.data).first()
            if not formule_selectionnee:
                flash('Formule s√©lectionn√©e introuvable', 'error')
                return redirect(url_for('super_admin_nouveau_client'))
            
            print(f"üîç Formule s√©lectionn√©e: {formule_selectionnee.nom}")
            
            # Cr√©er le client
            client = Client(
                nom=form.nom.data,
                reference=form.reference.data,
                description=form.description.data,
                contact_nom=form.contact_nom.data,
                contact_email=form.contact_email.data,
                contact_telephone=form.contact_telephone.data,
                domaine=form.domaine.data if form.domaine.data else None,
                plan=form.plan.data,
                formule_id=formule_selectionnee.id,  # IMPORTANT: Lier √† la formule
                max_utilisateurs=formule_selectionnee.max_utilisateurs,  # Utiliser les limites de la formule
                max_risques=formule_selectionnee.max_risques,
                max_audits=formule_selectionnee.max_audits,
                date_activation=datetime.utcnow(),
                is_active=True
            )
            
            # G√©n√©rer les identifiants API
            client.generer_identifiants_api()
            
            db.session.add(client)
            db.session.flush()  # Pour obtenir l'ID du client
            print(f"‚úÖ Client cr√©√© avec ID: {client.id}")
            
            # Cr√©er le premier abonnement
            abonnement = AbonnementClient(
                client_id=client.id,
                formule_id=formule_selectionnee.id,
                date_debut=datetime.utcnow().date(),
                periode='mensuel',
                statut='actif',
                is_renouvellement_auto=True,
                montant=formule_selectionnee.prix_mensuel,
                methode_paiement='manuel',
                reference_paiement=f"CREATION-{client.reference}"
            )
            db.session.add(abonnement)
            print(f"‚úÖ Abonnement cr√©√©: {formule_selectionnee.nom}")
            
            # Cr√©er l'admin client avec les permissions de la formule
            admin_password = secrets.token_urlsafe(12)
            admin = User(
                username=f"admin_{client.reference}",
                email=client.contact_email,
                role='admin',
                client_id=client.id,
                is_client_admin=True,
                is_active=True,
                department='Administration',
                permissions=formule_selectionnee.get_role_permissions('admin')  # Permissions selon formule
            )
            admin.set_password(admin_password)
            db.session.add(admin)
            print(f"‚úÖ Admin cr√©√©: {admin.username}")
            
            # Cr√©er l'environnement si demand√©
            if form.provisionner_serveur.data:
                sous_domaine = form.sous_domaine.data or f"{client.reference}.votreplateforme.com"
                env = EnvironnementClient(
                    client_id=client.id,
                    nom=form.environnement_nom.data or f"Environnement {client.reference}",
                    sous_domaine=sous_domaine,
                    url_acces=f"https://{sous_domaine}",
                    server_ip='127.0.0.1',
                    server_port=22,
                    server_ssh_user=f"client_{client.reference}",
                    cpu_alloue='2 cores',
                    ram_alloue='4GB',
                    stockage_alloue='50GB',
                    date_provision=datetime.utcnow(),
                    statut='actif'
                )
                db.session.add(env)
                print(f"‚úÖ Environnement cr√©√©: {env.nom}")
            
            # Mettre √† jour les m√©triques
            client.nb_utilisateurs = 1  # L'admin compte comme 1 utilisateur
            
            # Journaliser
            journal = JournalActiviteClient(
                client_id=client.id,
                utilisateur_id=current_user.id,
                action='creation_client',
                details={
                    'nom': client.nom,
                    'reference': client.reference,
                    'formule': formule_selectionnee.nom,
                    'plan': client.plan,
                    'admin_created': True,
                    'admin_username': admin.username,
                    'modules_accessibles': formule_selectionnee.get_modules_list(),
                    'features_actives': formule_selectionnee.get_features_list()
                },
                ip_address=request.remote_addr if request else None,
                user_agent=request.user_agent.string if request else None
            )
            db.session.add(journal)
            
            db.session.commit()
            
            # Afficher les identifiants (dans les logs uniquement)
            print(f"""
            ===========================================
            ‚úÖ CLIENT CR√â√â AVEC SUCC√àS
            ===========================================
            Client: {client.nom}
            R√©f√©rence: {client.reference}
            Formule: {formule_selectionnee.nom} ({formule_selectionnee.code})
            URL: https://{sous_domaine if form.provisionner_serveur.data else client.reference + '.votreplateforme.com'}
            
            FORMULE INCLUS:
            ‚Ä¢ Modules: {', '.join(formule_selectionnee.get_modules_list()[:5])}...
            ‚Ä¢ Features: {', '.join(formule_selectionnee.get_features_list()[:5])}...
            ‚Ä¢ Limites: {formule_selectionnee.max_utilisateurs} users, {formule_selectionnee.max_risques} risques
            
            ADMIN CLIENT:
            Username: {admin.username}
            Password: {admin_password}
            Email: {admin.email}
            
            API ACCESS:
            API Key: {client.api_key}
            Secret Key: {client.secret_key}
            ===========================================
            """)
            
            # Rediriger vers la page de d√©tails avec l'ID du client
            flash(f'Client {client.nom} cr√©√© avec succ√®s avec la formule {formule_selectionnee.nom}!', 'success')
            return redirect(url_for('super_admin_client_detail', id=client.id))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur cr√©ation client: {str(e)}', 'error')
            print(f"‚ùå Erreur cr√©ation client: {e}")
            import traceback
            traceback.print_exc()
    else:
        # Afficher les erreurs de validation
        if form.errors:
            print("‚ùå Erreurs de validation du formulaire:")
            for field, errors in form.errors.items():
                print(f"  {field}: {errors}")
            flash('Veuillez corriger les erreurs du formulaire', 'error')
    
    return render_template('super_admin/nouveau_client.html', 
                         form=form, 
                         formules=formules_disponibles)

@app.route('/super-admin/client/<int:id>')
@login_required
@super_admin_required
def super_admin_client_detail(id):
    """D√©tail d'un client"""
    client = Client.query.get_or_404(id)
    environnements = EnvironnementClient.query.filter_by(client_id=id).all()
    utilisateurs = User.query.filter_by(client_id=id).order_by(User.username).all()
    activites = JournalActiviteClient.query.filter_by(client_id=id)\
        .order_by(JournalActiviteClient.created_at.desc())\
        .limit(50).all()
    
    # Cr√©er un formulaire simple pour la mise √† jour
    class SimpleClientUpdateForm(FlaskForm):
        contact_email = StringField('Email de contact', validators=[DataRequired(), Email()])
        contact_nom = StringField('Nom du contact')
        contact_telephone = StringField('T√©l√©phone du contact')
        plan = SelectField('Plan', choices=[
            ('standard', 'Standard (10 utilisateurs)'),
            ('premium', 'Premium (50 utilisateurs)'),
            ('enterprise', 'Enterprise (Illimit√©)')
        ], validators=[DataRequired()])
        max_utilisateurs = IntegerField('Limite utilisateurs', validators=[DataRequired()])
        max_risques = IntegerField('Limite risques', validators=[DataRequired()])
        max_audits = IntegerField('Limite audits', validators=[DataRequired()])
        domaine = StringField('Domaine personnalis√©')
        description = TextAreaField('Description')
        is_active = BooleanField('Client actif')
        submit = SubmitField('Mettre √† jour')
    
    # Initialiser le formulaire
    form = SimpleClientUpdateForm(
        contact_email=client.contact_email,
        contact_nom=client.contact_nom or '',
        contact_telephone=client.contact_telephone or '',
        plan=client.plan,
        max_utilisateurs=client.max_utilisateurs,
        max_risques=client.max_risques,
        max_audits=client.max_audits,
        domaine=client.domaine or '',
        description=client.description or '',
        is_active=client.is_active
    )
    
    return render_template('super_admin/client_detail.html',
                         client=client,
                         environnements=environnements,
                         utilisateurs=utilisateurs,
                         activites=activites,
                         form=form)

@app.route('/super-admin/my-profile', methods=['GET', 'POST'])
@login_required
@super_admin_required
def super_admin_my_profile():
    """Page pour modifier son propre profil Super Admin"""
    
    # Import des champs WTForms
    from wtforms import StringField, PasswordField, SubmitField
    from wtforms.validators import DataRequired, Email, Length, EqualTo, Optional
    
    # Formulaire pour modifier le profil
    class EditSuperAdminProfileForm(FlaskForm):
        username = StringField('Nom d\'utilisateur', validators=[DataRequired()])
        email = StringField('Email', validators=[DataRequired(), Email()])
        current_password = PasswordField('Mot de passe actuel', validators=[Optional()])
        new_password = PasswordField('Nouveau mot de passe', validators=[Optional(), Length(min=8)])
        confirm_password = PasswordField('Confirmer nouveau mot de passe', 
                                       validators=[Optional(), EqualTo('new_password')])
        submit = SubmitField('Mettre √† jour mon profil')
    
    form = EditSuperAdminProfileForm(
        username=current_user.username,
        email=current_user.email
    )
    
    if form.validate_on_submit():
        try:
            # V√©rifier le mot de passe actuel si on veut le changer
            if form.new_password.data:
                if not form.current_password.data:
                    flash('Veuillez entrer votre mot de passe actuel pour changer de mot de passe', 'error')
                    return redirect(url_for('super_admin_my_profile'))
                
                if not current_user.check_password(form.current_password.data):
                    flash('Mot de passe actuel incorrect', 'error')
                    return redirect(url_for('super_admin_my_profile'))
                
                # Changer le mot de passe
                current_user.set_password(form.new_password.data)
                flash('Mot de passe mis √† jour avec succ√®s', 'success')
            
            # V√©rifier si le nom d'utilisateur a chang√©
            if form.username.data != current_user.username:
                # V√©rifier si le nouveau nom d'utilisateur est disponible
                existing = User.query.filter(
                    User.username == form.username.data,
                    User.id != current_user.id
                ).first()
                
                if existing:
                    flash(f'Le nom d\'utilisateur {form.username.data} est d√©j√† pris', 'error')
                    return redirect(url_for('super_admin_my_profile'))
                
                current_user.username = form.username.data
                flash('Nom d\'utilisateur mis √† jour', 'success')
            
            # Mettre √† jour l'email
            if form.email.data != current_user.email:
                current_user.email = form.email.data
                flash('Email mis √† jour', 'success')
            
            # Sauvegarder les changements
            db.session.commit()
            
            # Journaliser
            log_activity(current_user.id, 'update_super_admin_profile',
                        f"Profil super admin mis √† jour",
                        'user', current_user.id)
            
            flash('Votre profil a √©t√© mis √† jour avec succ√®s', 'success')
            return redirect(url_for('super_admin_my_profile'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur mise √† jour profil: {str(e)}', 'error')
    
    return render_template('super_admin/my_profile.html',
                         form=form,
                         current_user=current_user)



@app.route('/super-admin/client/<int:id>/update', methods=['POST'])
@login_required
@super_admin_required
def super_admin_update_client(id):
    """Mettre √† jour un client"""
    client = Client.query.get_or_404(id)
    
    try:
        client.contact_email = request.form.get('contact_email', client.contact_email)
        client.contact_nom = request.form.get('contact_nom', client.contact_nom)
        client.contact_telephone = request.form.get('contact_telephone', client.contact_telephone)
        client.plan = request.form.get('plan', client.plan)
        client.max_utilisateurs = int(request.form.get('max_utilisateurs', client.max_utilisateurs))
        client.max_risques = int(request.form.get('max_risques', client.max_risques))
        client.max_audits = int(request.form.get('max_audits', client.max_audits))
        client.domaine = request.form.get('domaine', client.domaine)
        client.description = request.form.get('description', client.description)
        client.is_active = request.form.get('is_active') == 'true'
        client.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        # Journaliser
        journal = JournalActiviteClient(
            client_id=client.id,
            utilisateur_id=current_user.id,
            action='modification_client',
            details={
                'par': current_user.username,
                'champs_modifies': {
                    'contact_email': client.contact_email,
                    'plan': client.plan,
                    'max_utilisateurs': client.max_utilisateurs,
                    'max_risques': client.max_risques,
                    'max_audits': client.max_audits,
                    'domaine': client.domaine,
                    'is_active': client.is_active
                }
            },
            ip_address=request.remote_addr if request else None
        )
        db.session.add(journal)
        db.session.commit()
        
        flash('Client mis √† jour avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur mise √† jour: {str(e)}', 'error')
    
    return redirect(url_for('super_admin_client_detail', id=id))

@app.route('/super-admin/client/<int:id>/suspendre')
@login_required
@super_admin_required
def super_admin_suspendre_client(id):
    """Suspendre un client"""
    client = Client.query.get_or_404(id)
    
    try:
        client.is_active = False
        client.updated_at = datetime.utcnow()
        
        # Suspendre les environnements
        environnements = EnvironnementClient.query.filter_by(client_id=id).all()
        for env in environnements:
            env.statut = 'suspendu'
            env.date_suspension = datetime.utcnow()
        
        # Journaliser
        journal = JournalActiviteClient(
            client_id=client.id,
            utilisateur_id=current_user.id,
            action='suspension_client',
            details={
                'raison': 'Manuelle',
                'par': current_user.username
            },
            ip_address=request.remote_addr if request else None
        )
        db.session.add(journal)
        
        db.session.commit()
        
        flash(f'Client {client.nom} suspendu', 'warning')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur suspension: {str(e)}', 'error')
    
    return redirect(url_for('super_admin_client_detail', id=id))

@app.route('/super-admin/client/<int:id>/reactiver')
@login_required
@super_admin_required
def super_admin_reactiver_client(id):
    """R√©activer un client"""
    client = Client.query.get_or_404(id)
    
    try:
        client.is_active = True
        client.updated_at = datetime.utcnow()
        
        # R√©activer les environnements
        environnements = EnvironnementClient.query.filter_by(client_id=id).all()
        for env in environnements:
            env.statut = 'actif'
            env.date_suspension = None
        
        # Journaliser
        journal = JournalActiviteClient(
            client_id=client.id,
            utilisateur_id=current_user.id,
            action='reactivation_client',
            details={
                'par': current_user.username
            },
            ip_address=request.remote_addr if request else None
        )
        db.session.add(journal)
        
        db.session.commit()
        
        flash(f'Client {client.nom} r√©activ√©', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur r√©activation: {str(e)}', 'error')
    
    return redirect(url_for('super_admin_client_detail', id=id))


# ========================
# ROUTES CLIENT ADMIN
# ========================

@app.route('/check-admin-status')
def check_admin_status():
    """V√©rifie le statut de l'utilisateur connect√©"""
    if not current_user.is_authenticated:
        return jsonify({
            'authenticated': False,
            'message': 'Non connect√©'
        })
    
    return jsonify({
        'authenticated': True,
        'username': current_user.username,
        'role': current_user.role,
        'is_super_admin': current_user.role == 'super_admin',
        'permissions': current_user.permissions,
        'client_id': current_user.client_id
    })
# ========================
# PAGE DE GESTION SUPER ADMIN
# ========================

@app.route('/super-admin/management', methods=['GET', 'POST'])
@login_required
def super_admin_management():
    """Page pour g√©rer les super admins"""
    
    # Seul fabricekonan peut acc√©der √† cette page
    if current_user.username != 'fabricekonan':
        flash('Acc√®s r√©serv√© √† fabricekonan', 'error')
        return redirect(url_for('dashboard'))
    
    # V√©rifier qu'il est bien super admin
    if current_user.role != 'super_admin':
        flash('Vous devez √™tre super admin', 'error')
        return redirect(url_for('dashboard'))
    
    # IMPORT DES CHAMPS WTForms MANQUANTS
    from wtforms import StringField, PasswordField, SubmitField
    from wtforms.validators import DataRequired, Email, Length, EqualTo
    
    # R√©cup√©rer tous les super admins
    super_admins = User.query.filter_by(role='super_admin').all()
    
    # Formulaire pour cr√©er un nouveau super admin
    class CreateSuperAdminForm(FlaskForm):
        username = StringField('Nom d\'utilisateur', validators=[DataRequired()])
        email = StringField('Email', validators=[DataRequired(), Email()])
        password = PasswordField('Mot de passe', validators=[DataRequired(), Length(min=8)])
        confirm_password = PasswordField('Confirmer le mot de passe', 
                                       validators=[DataRequired(), EqualTo('password')])
        submit = SubmitField('Cr√©er Super Admin')
    
    form = CreateSuperAdminForm()
    
    if form.validate_on_submit():
        try:
            # V√©rifier si l'utilisateur existe d√©j√†
            existing = User.query.filter_by(username=form.username.data).first()
            if existing:
                flash(f'L\'utilisateur {form.username.data} existe d√©j√†', 'error')
                return redirect(url_for('super_admin_management'))
            
            # Cr√©er le super admin
            new_super_admin = User(
                username=form.username.data,
                email=form.email.data,
                role='super_admin',
                is_active=True,
                is_client_admin=False,
                client_id=None,  # Super admin n'a pas de client
                department='Super Administration',
                permissions={
                    'can_view_dashboard': True,
                    'can_manage_risks': True,
                    'can_manage_kri': True,
                    'can_manage_audit': True,
                    'can_manage_regulatory': True,
                    'can_manage_logigram': True,
                    'can_manage_users': True,
                    'can_manage_settings': True,
                    'can_export_data': True,
                    'can_view_reports': True,
                    'can_delete_data': True,
                    'can_manage_permissions': True,
                    'can_access_all_departments': True,
                    'can_archive_data': True,
                    'can_validate_risks': True,
                    'can_confirm_evaluations': True,
                    'can_manage_clients': True,
                    'can_provision_servers': True
                }
            )
            new_super_admin.set_password(form.password.data)
            
            db.session.add(new_super_admin)
            db.session.commit()
            
            flash(f'Super admin {form.username.data} cr√©√© avec succ√®s', 'success')
            
            # Journaliser
            log_activity(current_user.id, 'creation_super_admin',
                        f"Cr√©ation super admin {form.username.data}",
                        'user', new_super_admin.id)
            
            return redirect(url_for('super_admin_management'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur cr√©ation super admin: {str(e)}', 'error')
    
    return render_template('super_admin/management.html',
                         super_admins=super_admins,
                         form=form,
                         current_user=current_user)

@app.route('/debug-routes')
def debug_routes():
    """Affiche toutes les routes disponibles"""
    routes = []
    for rule in app.url_map.iter_rules():
        routes.append({
            'endpoint': rule.endpoint,
            'methods': list(rule.methods),
            'rule': rule.rule
        })
    
    # Filtrer pour voir les routes li√©es √† login
    login_routes = [r for r in routes if 'login' in r['endpoint'].lower() or 'login' in r['rule']]
    
    return jsonify({
        'all_routes_count': len(routes),
        'login_routes': login_routes,
        'current_user': {
            'authenticated': current_user.is_authenticated,
            'username': current_user.username if current_user.is_authenticated else None
        }
    })
# AJOUTER CES ROUTES API DANS app.py


@app.route('/api/client/<int:client_id>/reset-admin-password', methods=['POST'])
@login_required
@super_admin_required
@csrf.exempt  # D√©sactiver CSRF pour cette API
def api_reset_client_admin_password(client_id):
    """R√©initialiser le mot de passe admin d'un client"""
    try:
        client = Client.query.get_or_404(client_id)
        
        # Trouver l'admin client (le premier admin cr√©√© pour ce client)
        admin_user = User.query.filter_by(
            client_id=client_id,
            is_client_admin=True
        ).first()
        
        if not admin_user:
            # Chercher aussi par r√¥le admin
            admin_user = User.query.filter_by(
                client_id=client_id,
                role='admin'
            ).first()
            
        if not admin_user:
            return jsonify({
                'success': False,
                'error': 'Admin client non trouv√©'
            }), 404
        
        # G√©n√©rer un nouveau mot de passe
        import secrets
        new_password = secrets.token_urlsafe(12)
        admin_user.set_password(new_password)
        admin_user.updated_at = datetime.utcnow()
        
        # Journaliser
        journal = JournalActiviteClient(
            client_id=client_id,
            utilisateur_id=current_user.id,
            action='reset_admin_password',
            details={
                'admin_username': admin_user.username,
                'by': current_user.username,
                'timestamp': datetime.utcnow().isoformat()
            },
            ip_address=request.remote_addr if request else None,
            user_agent=request.user_agent.string if request else None
        )
        db.session.add(journal)
        
        db.session.commit()
        
        print(f"‚úÖ Mot de passe r√©initialis√© pour admin client: {admin_user.username}")
        
        return jsonify({
            'success': True,
            'username': admin_user.username,
            'email': admin_user.email,
            'password': new_password,  # √Ä utiliser imm√©diatement puis effacer
            'message': f'Mot de passe r√©initialis√© pour {admin_user.username}',
            'warning': 'Notez ce mot de passe car il ne sera plus affich√©'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur r√©initialisation mot de passe: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500




@app.route('/api/client/<int:client_id>/show-credentials')
@login_required
@super_admin_required
def api_show_client_credentials(client_id):
    """Afficher les identifiants d'un client"""
    client = Client.query.get_or_404(client_id)
    
    # Trouver l'admin client
    admin_user = User.query.filter_by(
        client_id=client_id,
        is_client_admin=True
    ).first()
    
    if not admin_user:
        return jsonify({'error': 'Admin client non trouv√©'}), 404
    
    return jsonify({
        'success': True,
        'client': {
            'nom': client.nom,
            'reference': client.reference,
            'api_key': client.api_key,
            'secret_key': client.secret_key[:8] + '...' if client.secret_key else None
        },
        'admin': {
            'username': admin_user.username,
            'email': admin_user.email
        },
        'access_url': f"http://localhost:5000/client-login/{client.reference}"
    })


@app.route('/client-login/<string:client_reference>', methods=['GET', 'POST'])
def client_login_page(client_reference):
    """Page de connexion sp√©cifique √† un client"""
    from forms import LoginForm
    
    # Trouver le client
    client = Client.query.filter_by(reference=client_reference).first_or_404()
    
    # V√©rifier si le client est actif
    if not client.is_active:
        return render_template('auth/client_inactive.html', client=client)
    
    form = LoginForm()
    
    if form.validate_on_submit():
        # Rechercher l'utilisateur DANS CE CLIENT
        user = User.query.filter_by(
            username=form.username.data,
            client_id=client.id
        ).first()
        
        if user and user.check_password(form.password.data):
            if not user.is_active:
                flash('Votre compte est d√©sactiv√©', 'error')
            else:
                login_user(user, remember=form.remember_me.data)
                flash(f'Bienvenue {user.username} !', 'success')
                
                # Mettre √† jour derni√®re connexion
                user.last_login = datetime.utcnow()
                db.session.commit()
                
                # Rediriger vers le dashboard client
                return redirect(url_for('client_dashboard'))
        else:
            flash('Nom d\'utilisateur ou mot de passe incorrect', 'error')
    
    return render_template('auth/client_login.html', 
                         form=form, 
                         client=client)



# ========================
# API POUR GESTION SUPER ADMINS
# ========================

@app.route('/api/super-admin/<int:admin_id>/toggle', methods=['POST'])
@login_required
def api_toggle_super_admin(admin_id):
    """Activer/d√©sactiver un super admin"""
    if current_user.role != 'super_admin':
        return jsonify({'error': 'Acc√®s non autoris√©'}), 403
    
    # On ne peut pas se d√©sactiver soi-m√™me
    if admin_id == current_user.id:
        return jsonify({'error': 'Vous ne pouvez pas vous d√©sactiver vous-m√™me'}), 400
    
    admin = User.query.get_or_404(admin_id)
    
    # V√©rifier que c'est bien un super admin
    if admin.role != 'super_admin':
        return jsonify({'error': 'Cet utilisateur n\'est pas un super admin'}), 400
    
    try:
        admin.is_active = not admin.is_active
        new_status = 'activ√©' if admin.is_active else 'd√©sactiv√©'
        
        db.session.commit()
        
        # Journaliser
        log_activity(current_user.id, 'toggle_super_admin',
                    f"Super admin {admin.username} {new_status}",
                    'user', admin.id)
        
        return jsonify({
            'success': True,
            'message': f'Super admin {admin.username} {new_status}',
            'is_active': admin.is_active
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/api/super-admin/<int:admin_id>/reset-password', methods=['POST'])
@login_required
def api_reset_super_admin_password(admin_id):
    """R√©initialiser le mot de passe d'un super admin"""
    if current_user.role != 'super_admin':
        return jsonify({'error': 'Acc√®s non autoris√©'}), 403
    
    admin = User.query.get_or_404(admin_id)
    
    # V√©rifier que c'est bien un super admin
    if admin.role != 'super_admin':
        return jsonify({'error': 'Cet utilisateur n\'est pas un super admin'}), 400
    
    try:
        data = request.get_json()
        new_password = data.get('password')
        
        if not new_password or len(new_password) < 8:
            return jsonify({'error': 'Le mot de passe doit avoir au moins 8 caract√®res'}), 400
        
        admin.set_password(new_password)
        db.session.commit()
        
        # Journaliser (sans le mot de passe)
        log_activity(current_user.id, 'reset_super_admin_password',
                    f"Mot de passe r√©initialis√© pour {admin.username}",
                    'user', admin.id)
        
        return jsonify({
            'success': True,
            'message': f'Mot de passe r√©initialis√© pour {admin.username}'
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/api/super-admin/<int:admin_id>', methods=['DELETE'])
@login_required
def api_delete_super_admin(admin_id):
    """Supprimer un super admin"""
    if current_user.role != 'super_admin':
        return jsonify({'error': 'Acc√®s non autoris√©'}), 403
    
    # On ne peut pas se supprimer soi-m√™me
    if admin_id == current_user.id:
        return jsonify({'error': 'Vous ne pouvez pas vous supprimer vous-m√™me'}), 400
    
    admin = User.query.get_or_404(admin_id)
    
    # V√©rifier que c'est bien un super admin
    if admin.role != 'super_admin':
        return jsonify({'error': 'Cet utilisateur n\'est pas un super admin'}), 400
    
    try:
        # Journaliser avant suppression
        log_activity(current_user.id, 'delete_super_admin',
                    f"Suppression super admin {admin.username}",
                    'user', admin.id)
        
        db.session.delete(admin)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Super admin {admin.username} supprim√©'
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/client-admin/utilisateur/<int:id>/editer', methods=['GET', 'POST'])
@login_required
def client_admin_editer_utilisateur(id):
    """√âditer un utilisateur - version admin client"""
    
    # V√©rifier que c'est un admin client
    if not current_user.is_client_admin:
        flash('Acc√®s r√©serv√© aux administrateurs client', 'error')
        return redirect(url_for('dashboard'))
    
    # R√©cup√©rer l'utilisateur
    user = User.query.get_or_404(id)
    client = current_user.client
    
    # V√©rifications sp√©cifiques admin client
    if not client:
        flash('Aucun client associ√© √† votre compte', 'error')
        return redirect(url_for('dashboard'))
    
    # V√©rifier que l'utilisateur appartient au m√™me client
    if user.client_id != client.id:
        flash('Acc√®s non autoris√© √† cet utilisateur', 'error')
        return redirect(url_for('client_admin_utilisateurs'))
    
    # Emp√™cher un admin client de modifier un autre admin client (sauf lui-m√™me)
    if user.is_client_admin and user.id != current_user.id:
        flash('Vous ne pouvez pas modifier un autre administrateur client', 'error')
        return redirect(url_for('client_admin_utilisateurs'))
    
    # Cr√©er le formulaire sp√©cifique pour admin client
    from flask_wtf import FlaskForm
    from wtforms import StringField, PasswordField, SelectField, BooleanField, SubmitField, TextAreaField
    from wtforms.validators import DataRequired, Email, Length, EqualTo, Optional
    
    class EditerUtilisateurClientForm(FlaskForm):
        username = StringField('Nom d\'utilisateur', validators=[
            DataRequired(message='Le nom d\'utilisateur est requis'),
            Length(min=3, max=50, message='Le nom d\'utilisateur doit contenir entre 3 et 50 caract√®res')
        ])
        email = StringField('Email', validators=[
            DataRequired(message='L\'email est requis'),
            Email(message='Format d\'email invalide'),
            Length(max=120, message='L\'email ne peut pas d√©passer 120 caract√®res')
        ])
        password = PasswordField('Nouveau mot de passe', validators=[
            Optional(),
            Length(min=6, message='Le mot de passe doit avoir au moins 6 caract√®res')
        ])
        confirm_password = PasswordField('Confirmer le mot de passe', validators=[
            Optional(),
            EqualTo('password', message='Les mots de passe doivent correspondre')
        ])
        role = SelectField('R√¥le', choices=[
            ('utilisateur', 'Utilisateur Standard'),
            ('auditeur', 'Auditeur'),
            ('compliance', 'Responsable Conformit√©'),
            ('manager', 'Manager'),
            ('consultant', 'Consultant')
        ], validators=[DataRequired(message='Le r√¥le est requis')])
        department = StringField('D√©partement/Service', validators=[
            Optional(),
            Length(max=100, message='Le d√©partement ne peut pas d√©passer 100 caract√®res')
        ])
        is_active = BooleanField('Activer le compte', default=True)
        
        # Template de permissions - limit√© aux templates du client
        template_permissions = SelectField('Template de permissions', 
            choices=[],  # Rempli dynamiquement
            coerce=int, 
            default=0,
            validators=[Optional()])
        
        submit = SubmitField('Mettre √† jour')
    
    # D√©terminer si c'est l'admin client qui modifie son propre compte
    is_self_edit = (user.id == current_user.id)
    
    # Cr√©er l'instance du formulaire avec les donn√©es actuelles
    form = EditerUtilisateurClientForm(
        username=user.username,
        email=user.email,
        role=user.role,
        department=user.department or '',
        is_active=user.is_active
    )
    
    # Remplir les templates de permissions disponibles pour ce client
    try:
        # R√©cup√©rer les templates du client ou globaux
        templates = PermissionTemplate.query.filter(
            db.or_(
                PermissionTemplate.client_id == client.id,
                PermissionTemplate.client_id == None,  # Templates globaux
                db.and_(
                    PermissionTemplate.client_id == None,
                    PermissionTemplate.role.in_(['utilisateur', 'auditeur', 'manager', 'compliance', 'consultant'])
                )
            )
        ).all()
        
        form.template_permissions.choices = [(0, 'Aucun template (garder permissions actuelles)')]
        for template in templates:
            form.template_permissions.choices.append((template.id, f"{template.name} ({template.role})"))
        
        # D√©finir la valeur actuelle si un template est appliqu√©
        if user.permissions:
            # Chercher si les permissions correspondent √† un template
            for template in templates:
                if template.permissions == user.permissions:
                    form.template_permissions.data = template.id
                    break
    
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur chargement templates: {e}")
        form.template_permissions.choices = [(0, 'Erreur chargement templates')]
    
    if form.validate_on_submit():
        try:
            # V√©rifier si c'est un self-edit
            if is_self_edit:
                # Pour un self-edit, ne permettre que certains changements
                # Emp√™cher la modification du r√¥le et des templates
                if form.role.data != user.role:
                    flash('Vous ne pouvez pas modifier votre propre r√¥le', 'error')
                    return redirect(url_for('client_admin_editer_utilisateur', id=user.id))
                
                if form.template_permissions.data != 0:
                    # Emp√™cher l'application d'un template √† soi-m√™me
                    flash('Vous ne pouvez pas modifier les templates de permissions sur votre propre compte', 'error')
                    return redirect(url_for('client_admin_editer_utilisateur', id=user.id))
            
            # Mettre √† jour les champs de base
            user.username = form.username.data
            user.email = form.email.data
            
            # Ne pas modifier le r√¥le pour un self-edit
            if not is_self_edit:
                user.role = form.role.data
            
            user.department = form.department.data
            user.is_active = form.is_active.data
            
            # Mettre √† jour le mot de passe si fourni
            if form.password.data and form.password.data.strip():
                user.set_password(form.password.data)
            
            # Appliquer template de permissions si s√©lectionn√© (uniquement si pas self-edit)
            if not is_self_edit and form.template_permissions.data and int(form.template_permissions.data) != 0:
                template = PermissionTemplate.query.get(form.template_permissions.data)
                if template:
                    user.permissions = template.permissions
            elif form.template_permissions.data == 0:
                # Si "Aucun template" est s√©lectionn√©, ne pas modifier les permissions
                pass
            
            user.updated_at = datetime.utcnow()
            
            db.session.commit()
            
            # Journaliser l'action
            journal = JournalActiviteClient(
                client_id=client.id,
                utilisateur_id=current_user.id,
                action='modification_utilisateur',
                details={
                    'user_id': user.id,
                    'username': user.username,
                    'role': user.role,
                    'modifie_par': current_user.username,
                    'is_self_edit': is_self_edit
                }
            )
            db.session.add(journal)
            db.session.commit()
            
            flash(f'‚úÖ Utilisateur {user.username} mis √† jour avec succ√®s', 'success')
            return redirect(url_for('client_admin_utilisateurs'))
            
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Erreur mise √† jour utilisateur: {str(e)}")
            import traceback
            traceback.print_exc()
            flash(f'‚ùå Erreur lors de la mise √† jour: {str(e)}', 'error')
    
    return render_template('client_admin/editer_utilisateur.html', 
                         form=form, 
                         user=user,
                         client=client,
                         current_user=current_user,
                         is_self_edit=is_self_edit)  # <-- Ajouter cette variable



@app.route('/client-admin/utilisateur/creer-gestionnaire', methods=['GET', 'POST'])
@login_required
def client_admin_creer_gestionnaire():
    """Cr√©er un gestionnaire d'utilisateurs - version admin client"""
    
    print(f"üîç DEBUG: Route appel√©e - client_admin_creer_gestionnaire")
    
    if not current_user.is_client_admin:
        flash('Acc√®s r√©serv√© aux administrateurs client', 'error')
        return redirect(url_for('dashboard'))
    
    client = current_user.client
    if not client:
        flash('Aucun client associ√© √† votre compte', 'error')
        return redirect(url_for('dashboard'))
    
    # V√©rifier la limite d'utilisateurs
    current_count = User.query.filter_by(client_id=client.id, is_active=True).count()
    max_users = client.formule.max_utilisateurs if client.formule else 10
    
    if current_count >= max_users:
        flash(f'Limite d\'utilisateurs atteinte ({max_users}). Veuillez mettre √† jour votre formule.', 'error')
        return redirect(url_for('client_admin_utilisateurs'))
    
    # Formulaire sp√©cifique pour les gestionnaires
    from flask_wtf import FlaskForm
    from wtforms import StringField, PasswordField, SelectField, BooleanField, SubmitField
    from wtforms.validators import DataRequired, Email, Length, EqualTo
    
    class CreerGestionnaireForm(FlaskForm):
        username = StringField('Nom d\'utilisateur', validators=[
            DataRequired(message='Le nom d\'utilisateur est requis')
        ])
        email = StringField('Email', validators=[
            DataRequired(message='L\'email est requis'),
            Email(message='Format d\'email invalide')
        ])
        password = PasswordField('Mot de passe', validators=[
            DataRequired(message='Le mot de passe est requis'),
            Length(min=6, message='Le mot de passe doit avoir au moins 6 caract√®res')
        ])
        confirm_password = PasswordField('Confirmer le mot de passe', validators=[
            DataRequired(message='Veuillez confirmer le mot de passe'),
            EqualTo('password', message='Les mots de passe doivent correspondre')
        ])
        
        # R√¥les possibles pour les gestionnaires (pas admin)
        role = SelectField('R√¥le', 
            choices=[
                ('manager', 'Manager'),
                ('auditeur', 'Auditeur'),
                ('compliance', 'Responsable Conformit√©'),
                ('consultant', 'Consultant'),
                ('utilisateur', 'Utilisateur Standard')
            ],
            default='manager',
            validators=[DataRequired()]
        )
        
        # Permissions de gestion d'utilisateurs (TOUTES activ√©es pour un gestionnaire)
        can_view_users_list = BooleanField('Peut voir la liste des utilisateurs', default=True)
        can_edit_users = BooleanField('Peut √©diter les utilisateurs (sauf admin)', default=True)
        can_create_users = BooleanField('Peut cr√©er de nouveaux utilisateurs', default=True)
        can_deactivate_users = BooleanField('Peut activer/d√©sactiver les comptes', default=True)
        can_delete_users = BooleanField('Peut supprimer (d√©sactiver) les utilisateurs', default=True)
        
        # Permissions m√©tier selon le r√¥le
        # CORRIG√â: Toujours cr√©er les champs, ils seront affich√©s ou non dans le template
        can_manage_risks = BooleanField('Peut g√©rer les risques', default=True)
        can_validate_risks = BooleanField('Peut valider les risques', default=True)
        can_confirm_evaluations = BooleanField('Peut confirmer les √©valuations', default=True)
        can_manage_kri = BooleanField('Peut g√©rer les KRI', default=True)
        can_manage_audit = BooleanField('Peut g√©rer les audits', default=True)
        can_manage_regulatory = BooleanField('Peut g√©rer la veille r√©glementaire', default=True)
        can_manage_logigram = BooleanField('Peut g√©rer les logigrammes', default=True)
        can_view_departments = BooleanField('Peut voir les directions/services', default=True)
        can_manage_departments = BooleanField('Peut g√©rer les directions/services', default=True)
        can_access_all_departments = BooleanField('Peut acc√©der √† tous les d√©partements', default=True)
        
        # Autres permissions
        can_export_data = BooleanField('Peut exporter des donn√©es', default=True)
        can_archive_data = BooleanField('Peut archiver des donn√©es', default=True)
        
        department = StringField('D√©partement')
        is_active = BooleanField('Activer le compte imm√©diatement', default=True)
        submit = SubmitField('Cr√©er le gestionnaire')
    
    form = CreerGestionnaireForm()
    
    if form.validate_on_submit():
        print("‚úÖ Formulaire de cr√©ation gestionnaire valid√© avec succ√®s!")
        
        try:
            # V√©rifier les limites
            if client.formule:
                current_count = User.query.filter_by(
                    client_id=client.id, 
                    is_active=True
                ).count()
                
                if current_count >= client.formule.max_utilisateurs:
                    flash(f'‚ùå Limite atteinte pendant la cr√©ation. Veuillez r√©essayer.', 'error')
                    return redirect(url_for('client_admin_creer_gestionnaire'))
            
            # V√©rifier si l'utilisateur existe d√©j√†
            existing_user = User.query.filter(
                db.or_(
                    User.username == form.username.data,
                    User.email == form.email.data
                ),
                User.client_id == client.id
            ).first()
            
            if existing_user:
                flash(f'Un utilisateur avec ce nom ou email existe d√©j√† dans votre client', 'error')
                return redirect(url_for('client_admin_creer_gestionnaire'))
            
            # Cr√©er l'utilisateur avec permissions de gestion COMPL√àTES
            user = User(
                username=form.username.data,
                email=form.email.data,
                role=form.role.data,
                department=form.department.data or '',
                is_active=form.is_active.data,
                client_id=client.id,
                is_client_admin=False,  # JAMAIS True pour un gestionnaire
                can_view_users_list=True,  # Toujours True pour les gestionnaires
                can_manage_users=True,    # True car c'est un gestionnaire
                created_at=datetime.utcnow()
            )
            
            # D√©finir le mot de passe
            user.set_password(form.password.data)
            
            # D√©finir les permissions COMPL√àTES pour les gestionnaires
            # CORRIG√â: Acc√©der correctement aux champs bool√©ens
            permissions = {
                # Permissions de base (toujours activ√©es pour les gestionnaires)
                'can_view_dashboard': True,
                'can_view_reports': True,
                'can_export_data': True,
                'can_view_departments': True,
                'can_view_users_list': True,
                
                # Permissions de gestion d'utilisateurs
                'can_edit_users': form.can_edit_users.data if hasattr(form, 'can_edit_users') else False,
                'can_create_users': form.can_create_users.data if hasattr(form, 'can_create_users') else False,
                'can_deactivate_users': form.can_deactivate_users.data if hasattr(form, 'can_deactivate_users') else False,
                'can_delete_users': form.can_delete_users.data if hasattr(form, 'can_delete_users') else False,
                'can_manage_users': True,  # Toujours True pour les gestionnaires
                
                # Permissions m√©tier selon le r√¥le
                'can_manage_risks': form.can_manage_risks.data if hasattr(form, 'can_manage_risks') else False,
                'can_validate_risks': form.can_validate_risks.data if hasattr(form, 'can_validate_risks') else False,
                'can_confirm_evaluations': form.can_confirm_evaluations.data if hasattr(form, 'can_confirm_evaluations') else False,
                'can_manage_kri': form.can_manage_kri.data if hasattr(form, 'can_manage_kri') else False,
                'can_manage_audit': form.can_manage_audit.data if hasattr(form, 'can_manage_audit') else False,
                'can_manage_regulatory': form.can_manage_regulatory.data if hasattr(form, 'can_manage_regulatory') else False,
                'can_manage_logigram': form.can_manage_logigram.data if hasattr(form, 'can_manage_logigram') else False,
                'can_manage_departments': form.can_manage_departments.data if hasattr(form, 'can_manage_departments') else False,
                'can_access_all_departments': form.can_access_all_departments.data if hasattr(form, 'can_access_all_departments') else False,
                
                # Autres permissions
                'can_archive_data': form.can_archive_data.data if hasattr(form, 'can_archive_data') else False,
                
                # Permissions D√âSACTIV√âES pour les gestionnaires
                'can_manage_settings': False,        # Pas de param√©trage syst√®me
                'can_manage_permissions': False,     # Pas de gestion permissions avanc√©es
                'can_delete_data': False,            # Pas de suppression d√©finitive
                'can_provision_servers': False,      # Pas d'administration syst√®me
                'can_manage_clients': False,         # Pas de gestion clients
                'is_super_admin': False,             # Jamais super admin
                'can_manage_system': False,          # Pas d'administration syst√®me
                
                # Permissions par d√©faut
                'can_access_all_departments': False,
                'can_manage_templates': False,
                'can_manage_lists': False,
                'can_manage_fields': False,
                'can_manage_files': False,
                'can_use_ia_analysis': False
            }
            
            # Ajuster les permissions selon le r√¥le choisi
            role_permissions = {
                'manager': {
                    'can_manage_risks': True,
                    'can_validate_risks': True,
                    'can_confirm_evaluations': True,
                    'can_manage_kri': True,
                    'can_manage_audit': True
                },
                'auditeur': {
                    'can_manage_audit': True
                },
                'compliance': {
                    'can_manage_regulatory': True
                },
                'consultant': {
                    # Permissions de consultation seulement
                },
                'utilisateur': {
                    # Pas de permissions sp√©ciales
                }
            }
            
            # Appliquer les permissions du r√¥le
            if form.role.data in role_permissions:
                for perm, value in role_permissions[form.role.data].items():
                    permissions[perm] = value
            
            # V√©rifier la coh√©rence avec la formule du client
            if client.formule:
                formule = client.formule
                
                # D√©sactiver les permissions non incluses dans la formule
                formule_permissions = formule.get_permissions_list()
                for perm in list(permissions.keys()):
                    if perm.startswith('can_') and perm not in formule_permissions:
                        # Si la permission n'est pas dans la formule, la d√©sactiver
                        permissions[perm] = False
            
            user.permissions = permissions
            
            print(f"üìä DEBUG: Permissions du gestionnaire cr√©√©:")
            for perm, value in permissions.items():
                if value:
                    print(f"  ‚úì {perm}")
            
            # Sauvegarder
            db.session.add(user)
            
            # Mettre √† jour les statistiques du client
            client.nb_utilisateurs = User.query.filter_by(
                client_id=client.id, 
                is_active=True
            ).count()
            
            # Journaliser
            journal = JournalActiviteClient(
                client_id=client.id,
                utilisateur_id=current_user.id,
                action='creation_gestionnaire',
                details={
                    'username': user.username,
                    'email': user.email,
                    'role': user.role,
                    'is_gestionnaire': True,
                    'permissions': {
                        'view_users': permissions.get('can_view_users_list', False),
                        'edit_users': permissions.get('can_edit_users', False),
                        'create_users': permissions.get('can_create_users', False),
                        'deactivate_users': permissions.get('can_deactivate_users', False),
                        'delete_users': permissions.get('can_delete_users', False),
                        'manage_users': True
                    },
                    'created_by': current_user.username
                }
            )
            db.session.add(journal)
            
            db.session.commit()
            
            flash(f'‚úÖ Gestionnaire {user.username} cr√©√© avec succ√®s', 'success')
            return redirect(url_for('client_admin_utilisateurs'))
            
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Erreur cr√©ation gestionnaire: {str(e)}")
            import traceback
            traceback.print_exc()
            flash(f'‚ùå Erreur lors de la cr√©ation: {str(e)}', 'error')
    else:
        # Afficher les erreurs de validation
        if form.errors:
            print("‚ùå Erreurs de validation du formulaire gestionnaire:")
            for field, errors in form.errors.items():
                print(f"  {field}: {errors}")
            
            # Afficher les messages d'erreur
            for field, errors in form.errors.items():
                if errors:
                    flash(f'Erreur {field}: {errors[0]}', 'error')
    
    # Calculer le pourcentage d'utilisation
    pourcentage = (current_count / max_users * 100) if max_users > 0 else 0
    
    return render_template('client_admin/creer_gestionnaire.html',
                         form=form,
                         client=client,
                         limite=max_users,
                         utilisateurs_actuels=current_count,
                         pourcentage=pourcentage)

@app.route('/gestionnaire/utilisateurs')
@login_required
def gestionnaire_utilisateurs():
    """Gestion des utilisateurs pour les gestionnaires"""
    
    # V√©rifier que l'utilisateur est un gestionnaire
    if not current_user.can_manage_users:
        flash('Acc√®s r√©serv√© aux gestionnaires', 'error')
        return redirect(url_for('dashboard'))
    
    # R√©cup√©rer les utilisateurs du m√™me client
    users = User.query.filter_by(
        client_id=current_user.client_id
    ).filter(
        User.role != 'super_admin'  # Exclure les super admins
    ).order_by(User.username).all()
    
    # Filtrer pour ne pas montrer les autres gestionnaires (sauf lui-m√™me)
    filtered_users = []
    for user in users:
        if not user.can_manage_users or user.id == current_user.id:
            filtered_users.append(user)
    
    # Calculer les statistiques
    stats = {
        'total': len(filtered_users),
        'actifs': len([u for u in filtered_users if u.is_active]),
        'admin_count': len([u for u in filtered_users if u.role == 'admin']),
        'limite': current_user.client.formule.max_utilisateurs if current_user.client and current_user.client.formule else 10,
        'pourcentage': 0
    }
    
    if stats['limite'] > 0:
        stats['pourcentage'] = (stats['total'] / stats['limite']) * 100
    
    return render_template('gestionnaire/utilisateurs.html',
                         users=filtered_users,
                         stats=stats,
                         now=datetime.utcnow())
@app.route('/fix-gestionnaire-permissions')
@login_required
def fix_gestionnaire_permissions():
    """Active toutes les permissions de gestionnaire pour l'utilisateur courant"""
    
    if current_user.role != 'manager':
        flash('Cette fonction est r√©serv√©e aux gestionnaires', 'error')
        return redirect(url_for('dashboard'))
    
    try:
        # Activer le flag can_manage_users
        current_user.can_manage_users = True
        
        # Ajouter les permissions manquantes
        if current_user.permissions is None:
            current_user.permissions = {}
        
        gestionnaire_permissions = {
            'can_create_users': True,
            'can_edit_users': True,
            'can_deactivate_users': True,
            'can_delete_users': True,
            'can_view_users_list': True,
            'can_manage_permissions': True,
            'can_manage_risks': True,
            'can_manage_kri': True,
            'can_manage_audit': True,
            'can_manage_action_plans': True,
            'can_view_action_plans': True
        }
        
        for perm, value in gestionnaire_permissions.items():
            current_user.permissions[perm] = value
        
        db.session.commit()
        
        flash('‚úÖ Permissions de gestionnaire activ√©es avec succ√®s! Vous pouvez maintenant :', 'success')
        flash('‚Ä¢ Cr√©er des utilisateurs', 'info')
        flash('‚Ä¢ Modifier des utilisateurs', 'info')
        flash('‚Ä¢ Bloquer/d√©bloquer des utilisateurs', 'info')
        flash('‚Ä¢ Supprimer des utilisateurs', 'info')
        flash('‚Ä¢ G√©rer les permissions', 'info')
        
        # Rediriger vers la page de gestion des utilisateurs
        return redirect(url_for('gestionnaire_utilisateurs'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
        return redirect(url_for('dashboard'))


@app.route('/activate-gestionnaire-full-permissions')
@login_required
def activate_gestionnaire_full_permissions():
    """Active TOUTES les permissions de gestionnaire pour l'utilisateur courant"""
    
    if current_user.role != 'manager':
        flash('Cette fonction est r√©serv√©e aux gestionnaires', 'error')
        return redirect(url_for('dashboard'))
    
    try:
        # Initialiser permissions si n√©cessaire
        if current_user.permissions is None:
            current_user.permissions = {}
        
        # Toutes les permissions n√©cessaires pour un gestionnaire COMPLET
        full_permissions = {
            # Gestion des utilisateurs
            'can_create_users': True,
            'can_edit_users': True,
            'can_deactivate_users': True,
            'can_delete_users': True,
            'can_view_users_list': True,
            'can_manage_users': True,
            'can_block_users': True,
            'can_manage_permissions': True,
            
            # Visualisation
            'can_view_dashboard': True,
            'can_view_reports': True,
            'can_view_departments': True,
            'can_view_notifications': True,
            'can_view_action_plans': True,
            
            # Gestion des risques
            'can_manage_risks': True,
            'can_validate_risks': True,
            'can_manage_kri': True,
            
            # Gestion des audits
            'can_manage_audit': True,
            'can_confirm_evaluations': True,
            'can_manage_action_plans': True,
            
            # Administration
            'can_export_data': True,
            'can_archive_data': True,
            
            # Param√©trage
            'can_manage_settings': False,  # Pas besoin pour gestionnaire
            'can_manage_departments': False,  # Pas besoin pour gestionnaire
            
            # Syst√®me
            'can_manage_clients': False,
            'can_provision_servers': False
        }
        
        # Appliquer toutes les permissions
        for perm, value in full_permissions.items():
            current_user.permissions[perm] = value
        
        # Activer aussi le flag can_manage_users
        current_user.can_manage_users = True
        
        db.session.commit()
        
        flash('üéâ TOUTES les permissions de gestionnaire ont √©t√© activ√©es !', 'success')
        flash('Vous pouvez maintenant :', 'info')
        flash('‚Ä¢ Cr√©er des utilisateurs', 'info')
        flash('‚Ä¢ Modifier des utilisateurs', 'info')
        flash('‚Ä¢ D√©sactiver des utilisateurs', 'info')
        flash('‚Ä¢ Supprimer des utilisateurs', 'info')
        flash('‚Ä¢ G√©rer les permissions', 'info')
        
        # Rediriger vers la gestion des utilisateurs
        return redirect(url_for('gestionnaire_utilisateurs'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
        return redirect(url_for('dashboard'))

@app.route('/gestionnaire/check-access')
@login_required
def gestionnaire_check_access():
    """V√©rifie l'acc√®s gestionnaire"""
    
    html = f"""
    <html>
    <head><title>Diagnostic Gestionnaire</title></head>
    <body style="padding: 20px; font-family: Arial;">
        <h1>üîç Diagnostic Acc√®s Gestionnaire</h1>
        
        <div style="background: #f5f5f5; padding: 20px; margin: 20px 0;">
            <h3>Informations Utilisateur</h3>
            <p><strong>Username:</strong> {current_user.username}</p>
            <p><strong>R√¥le:</strong> {current_user.role}</p>
            <p><strong>Client ID:</strong> {current_user.client_id}</p>
            <p><strong>is_client_admin:</strong> {current_user.is_client_admin}</p>
            <p><strong>can_manage_users:</strong> {current_user.can_manage_users}</p>
        </div>
        
        <div style="background: #e8f5e8; padding: 20px; margin: 20px 0;">
            <h3>Permissions dans la base</h3>
            <pre>{json.dumps(current_user.permissions or {}, indent=2)}</pre>
        </div>
        
        <div style="background: #e3f2fd; padding: 20px; margin: 20px 0;">
            <h3>V√©rification des permissions critiques</h3>
            <ul>
                <li>can_create_users: {current_user.has_permission('can_create_users')}</li>
                <li>can_edit_users: {current_user.has_permission('can_edit_users')}</li>
                <li>can_delete_users: {current_user.has_permission('can_delete_users')}</li>
                <li>can_deactivate_users: {current_user.has_permission('can_deactivate_users')}</li>
                <li>can_view_users_list: {current_user.has_permission('can_view_users_list')}</li>
            </ul>
        </div>
        
        <div style="background: #fff3cd; padding: 20px; margin: 20px 0;">
            <h3>Actions</h3>
            <a href="/admin/fix-gestionnaire-permissions" style="color: blue;">Corriger automatiquement les permissions</a><br>
            <a href="/gestionnaire/utilisateurs" style="color: blue;">Retour √† la gestion des utilisateurs</a>
        </div>
    </body>
    </html>
    """
    
    return html

@app.route('/gestionnaire/utilisateur/creer', methods=['GET', 'POST'])
@login_required
def gestionnaire_creer_utilisateur():
    """Cr√©er un nouvel utilisateur - version gestionnaire"""
    
    if not current_user.has_permission('can_create_users'):
        flash('Permission refus√©e pour cr√©er des utilisateurs', 'error')
        return redirect(url_for('dashboard'))
    
    client = current_user.client
    if not client:
        flash('Aucun client associ√© √† votre compte', 'error')
        return redirect(url_for('dashboard'))
    
    # V√©rifier la limite d'utilisateurs
    current_count = User.query.filter_by(client_id=client.id, is_active=True).count()
    max_users = client.formule.max_utilisateurs if client.formule else 10
    
    if current_count >= max_users:
        flash(f'Limite d\'utilisateurs atteinte ({max_users}). Veuillez mettre √† jour votre formule.', 'error')
        return redirect(url_for('gestionnaire_utilisateurs'))
    
    from flask_wtf import FlaskForm
    from wtforms import StringField, PasswordField, SelectField, BooleanField, SubmitField
    from wtforms.validators import DataRequired, Email, Length, EqualTo
    
    class GestionnaireNouvelUtilisateurForm(FlaskForm):
        username = StringField('Nom d\'utilisateur', validators=[
            DataRequired(message='Le nom d\'utilisateur est requis')
        ])
        email = StringField('Email', validators=[
            DataRequired(message='L\'email est requis'),
            Email(message='Format d\'email invalide')
        ])
        password = PasswordField('Mot de passe', validators=[
            DataRequired(message='Le mot de passe est requis'),
            Length(min=6, message='Le mot de passe doit avoir au moins 6 caract√®res')
        ])
        confirm_password = PasswordField('Confirmer le mot de passe', validators=[
            DataRequired(message='Veuillez confirmer le mot de passe'),
            EqualTo('password', message='Les mots de passe doivent correspondre')
        ])
        
        role = SelectField('R√¥le', 
            choices=[
                ('utilisateur', 'Utilisateur Standard'),
                ('auditeur', 'Auditeur'),
                ('compliance', 'Responsable Conformit√©'),
                ('manager', 'Manager'),
                ('consultant', 'Consultant')
            ],
            default='utilisateur',
            validators=[DataRequired()]
        )
        
        department = StringField('D√©partement')
        is_active = BooleanField('Activer le compte imm√©diatement', default=True)
        submit = SubmitField('Cr√©er l\'utilisateur')
    
    form = GestionnaireNouvelUtilisateurForm()
    
    # DEBUG: V√©rifier le formulaire
    print(f"DEBUG: Formulaire cr√©√©, type: {type(form)}")
    print(f"DEBUG: Champ is_active: {form.is_active}")
    print(f"DEBUG: Type du champ is_active: {type(form.is_active)}")
    
    if form.validate_on_submit():
        try:
            print(f"DEBUG: Formulaire valid√©, donn√©es re√ßues")
            print(f"DEBUG: is_active.data = {form.is_active.data}")
            print(f"DEBUG: username.data = {form.username.data}")
            
            # V√©rifier les limites
            if client.formule:
                current_count = User.query.filter_by(
                    client_id=client.id, 
                    is_active=True
                ).count()
                
                if current_count >= client.formule.max_utilisateurs:
                    flash(f'‚ùå Limite atteinte pendant la cr√©ation. Veuillez r√©essayer.', 'error')
                    return redirect(url_for('gestionnaire_creer_utilisateur'))
            
            # V√©rifier si l'utilisateur existe d√©j√†
            existing_user = User.query.filter(
                db.or_(
                    User.username == form.username.data,
                    User.email == form.email.data
                ),
                User.client_id == client.id
            ).first()
            
            if existing_user:
                flash(f'Un utilisateur avec ce nom ou email existe d√©j√† dans votre client', 'error')
                return redirect(url_for('gestionnaire_creer_utilisateur'))
            
            # Cr√©er l'utilisateur
            user = User(
                username=form.username.data,
                email=form.email.data,
                role=form.role.data,
                department=form.department.data or '',
                is_active=form.is_active.data,  # ICI: utiliser form.is_active.data
                client_id=client.id,
                is_client_admin=False,
                can_manage_users=(form.role.data == 'manager'),
                can_view_users_list=(form.role.data == 'manager'),
                created_at=datetime.utcnow()
            )
            
            user.set_password(form.password.data)
            
            # Permissions basiques selon le r√¥le
            role_permissions = {
                'utilisateur': {
                    'can_view_dashboard': True,
                    'can_view_reports': True,
                    'can_view_departments': True,
                    'can_view_users_list': False,
                    'can_edit_users': False,
                    'can_create_users': False,
                    'can_deactivate_users': False
                },
                'auditeur': {
                    'can_view_dashboard': True,
                    'can_view_reports': True,
                    'can_view_departments': True,
                    'can_view_users_list': False,
                    'can_edit_users': False,
                    'can_create_users': False,
                    'can_deactivate_users': False,
                    'can_manage_audit': True
                },
                'manager': {
                    'can_view_dashboard': True,
                    'can_view_reports': True,
                    'can_view_departments': True,
                    'can_view_users_list': True,
                    'can_edit_users': True,
                    'can_create_users': True,
                    'can_deactivate_users': True,
                    'can_manage_risks': True,
                    'can_manage_kri': True,
                    'can_manage_audit': True,
                    'can_manage_action_plans': True,
                    'can_manage_permissions': True
                },
                'compliance': {
                    'can_view_dashboard': True,
                    'can_view_reports': True,
                    'can_view_departments': True,
                    'can_view_users_list': False,
                    'can_edit_users': False,
                    'can_create_users': False,
                    'can_deactivate_users': False,
                    'can_manage_regulatory': True
                },
                'consultant': {
                    'can_view_dashboard': True,
                    'can_view_reports': True,
                    'can_view_departments': True,
                    'can_view_users_list': False,
                    'can_edit_users': False,
                    'can_create_users': False,
                    'can_deactivate_users': False
                }
            }
            
            user.permissions = role_permissions.get(form.role.data, role_permissions['utilisateur'])
            
            db.session.add(user)
            db.session.commit()
            
            flash(f'‚úÖ Utilisateur {user.username} cr√©√© avec succ√®s', 'success')
            return redirect(url_for('gestionnaire_utilisateurs'))
            
        except Exception as e:
            db.session.rollback()
            print(f"DEBUG: Erreur compl√®te: {str(e)}")
            import traceback
            traceback.print_exc()
            flash(f'‚ùå Erreur lors de la cr√©ation: {str(e)}', 'error')
    
    return render_template('gestionnaire/creer_utilisateur.html',
                         form=form,
                         client=client,
                         limite=max_users,
                         utilisateurs_actuels=current_count)

@app.route('/gestionnaire/utilisateur/<int:id>/editer', methods=['GET', 'POST'])
@login_required
def gestionnaire_editer_utilisateur(id):
    """√âditer un utilisateur - version gestionnaire"""
    
    # V√©rifier les permissions
    if not current_user.has_permission('can_edit_users'):
        flash('Permission refus√©e pour √©diter des utilisateurs', 'error')
        return redirect(url_for('dashboard'))
    
    # R√©cup√©rer l'utilisateur
    user = User.query.get_or_404(id)
    client = current_user.client
    
    # V√©rifications
    if not client:
        flash('Aucun client associ√© √† votre compte', 'error')
        return redirect(url_for('dashboard'))
    
    if user.client_id != client.id:
        flash('Acc√®s non autoris√© √† cet utilisateur', 'error')
        return redirect(url_for('gestionnaire_utilisateurs'))
    
    # EMP√äCHER la modification des client_admin
    if user.is_client_admin:
        flash('Vous ne pouvez pas modifier un administrateur client', 'error')
        return redirect(url_for('gestionnaire_utilisateurs'))
    
    # EMP√äCHER la modification des autres gestionnaires (sauf soi-m√™me)
    if user.can_manage_users and user.id != current_user.id:
        flash('Vous ne pouvez pas modifier un autre gestionnaire', 'error')
        return redirect(url_for('gestionnaire_utilisateurs'))
    
    # D√©terminer si c'est un self-edit
    is_self_edit = (user.id == current_user.id)
    
    # Formulaire simplifi√© (sans permissions)
    from flask_wtf import FlaskForm
    from wtforms import StringField, PasswordField, SelectField, BooleanField, SubmitField
    from wtforms.validators import DataRequired, Email, Length, EqualTo, Optional
    
    class GestionnaireEditerUtilisateurForm(FlaskForm):
        username = StringField('Nom d\'utilisateur', validators=[
            DataRequired(message='Le nom d\'utilisateur est requis')
        ])
        email = StringField('Email', validators=[
            DataRequired(message='L\'email est requis'),
            Email(message='Format d\'email invalide')
        ])
        password = PasswordField('Nouveau mot de passe', validators=[
            Optional(),
            Length(min=6, message='Le mot de passe doit avoir au moins 6 caract√®res')
        ])
        confirm_password = PasswordField('Confirmer le mot de passe', validators=[
            Optional(),
            EqualTo('password', message='Les mots de passe doivent correspondre')
        ])
        
        # R√¥le (non modifiable pour self-edit)
        role = SelectField('R√¥le', 
            choices=[
                ('utilisateur', 'Utilisateur Standard'),
                ('auditeur', 'Auditeur'),
                ('compliance', 'Responsable Conformit√©'),
                ('manager', 'Manager'),
                ('consultant', 'Consultant')
            ],
            validators=[DataRequired()]
        )
        
        department = StringField('D√©partement')
        
        # Statut (non modifiable pour self-edit)
        if not is_self_edit and current_user.has_permission('can_deactivate_users'):
            is_active = BooleanField('Activer le compte', default=True)
        else:
            # Champ cach√© pour maintenir la valeur
            is_active = BooleanField('Activer le compte', default=True)
        
        submit = SubmitField('Mettre √† jour')
    
    # Initialiser le formulaire
    form = GestionnaireEditerUtilisateurForm(
        username=user.username,
        email=user.email,
        role=user.role,
        department=user.department or '',
        is_active=user.is_active
    )
    
    if form.validate_on_submit():
        try:
            # Validation des restrictions
            if is_self_edit:
                # Pour self-edit, emp√™cher changement de r√¥le
                if form.role.data != user.role:
                    flash('Vous ne pouvez pas modifier votre propre r√¥le', 'error')
                    return redirect(url_for('gestionnaire_editer_utilisateur', id=user.id))
            
            # Mise √† jour
            user.username = form.username.data
            user.email = form.email.data
            
            if not is_self_edit:
                user.role = form.role.data
                if hasattr(form, 'is_active') and current_user.has_permission('can_deactivate_users'):
                    user.is_active = form.is_active.data
            
            user.department = form.department.data
            
            if form.password.data and form.password.data.strip():
                user.set_password(form.password.data)
            
            user.updated_at = datetime.utcnow()
            db.session.commit()
            
            # Journaliser
            journal = JournalActiviteClient(
                client_id=client.id,
                utilisateur_id=current_user.id,
                action='modification_utilisateur_gestionnaire',
                details={
                    'user_id': user.id,
                    'username': user.username,
                    'role': user.role,
                    'modified_by': current_user.username,
                    'is_self_edit': is_self_edit
                }
            )
            db.session.add(journal)
            db.session.commit()
            
            flash(f'‚úÖ Utilisateur {user.username} mis √† jour avec succ√®s', 'success')
            return redirect(url_for('gestionnaire_utilisateurs'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'‚ùå Erreur lors de la mise √† jour: {str(e)}', 'error')
    
    return render_template('gestionnaire/editer_utilisateur.html',
                         form=form,
                         user=user,
                         client=client,
                         is_self_edit=is_self_edit,
                         current_user=current_user)



@app.route('/gestionnaire/utilisateur/<int:id>/permissions', methods=['GET', 'POST'])
@login_required
def gestionnaire_gerer_permissions(id):
    """G√©rer les permissions d'un utilisateur - version gestionnaire"""
    
    # V√©rifier que c'est un gestionnaire
    if not current_user.can_manage_users:
        flash('Acc√®s r√©serv√© aux gestionnaires d\'utilisateurs', 'error')
        return redirect(url_for('dashboard'))
    
    # R√©cup√©rer l'utilisateur
    user = User.query.get_or_404(id)
    client = current_user.client
    
    # V√©rifications sp√©cifiques gestionnaire
    if not client:
        flash('Aucun client associ√© √† votre compte', 'error')
        return redirect(url_for('dashboard'))
    
    if user.client_id != client.id:
        flash('Acc√®s non autoris√© √† cet utilisateur', 'error')
        return redirect(url_for('gestionnaire_utilisateurs'))
    
    # EMP√äCHER la modification des permissions de :
    # 1. client_admin
    if user.is_client_admin:
        flash('Vous ne pouvez pas modifier les permissions d\'un administrateur client', 'error')
        return redirect(url_for('gestionnaire_utilisateurs'))
    
    # 2. autres gestionnaires (sauf soi-m√™me)
    if user.can_manage_users and user.id != current_user.id:
        flash('Vous ne pouvez pas modifier les permissions d\'un autre gestionnaire', 'error')
        return redirect(url_for('gestionnaire_utilisateurs'))
    
    # D√©terminer si c'est un self-edit
    is_self_edit = (user.id == current_user.id)
    
    # Permissions disponibles pour les gestionnaires (restreintes)
    from flask_wtf import FlaskForm
    from wtforms import BooleanField
    
    class GestionnairePermissionsForm(FlaskForm):
        pass
    
    # Liste des permissions que les gestionnaires peuvent modifier
    # (pas les permissions syst√®me)
    manageable_permissions = [
        # Dashboard
        ('can_view_dashboard', 'Voir le tableau de bord'),
        ('can_view_reports', 'Voir les rapports'),
        ('can_export_data', 'Exporter des donn√©es'),
        
        # Risques
        ('can_manage_risks', 'G√©rer les risques'),
        ('can_validate_risks', 'Valider les √©valuations de risque'),
        ('can_confirm_evaluations', 'Confirmer les √©valuations'),
        
        # KRI
        ('can_manage_kri', 'G√©rer les KRI'),
        
        # Audit
        ('can_manage_audit', 'G√©rer les audits'),
        
        # Plans d'action - AJOUT√â
        ('can_manage_action_plans', 'G√©rer les plans d\'action'),
        ('can_view_action_plans', 'Voir les plans d\'action'),
        
        # Conformit√©
        ('can_manage_regulatory', 'G√©rer la veille r√®glementaire'),
        
        # Processus
        ('can_manage_logigram', 'G√©rer les logigrammes'),
        
        # Directions & Services
        ('can_view_departments', 'Voir les d√©partements'),
        ('can_manage_departments', 'G√©rer les d√©partements'),
        ('can_access_all_departments', 'Acc√®s √† tous les d√©partements'),
        
        # Utilisateurs (limit√©)
        ('can_view_users_list', 'Voir la liste des utilisateurs'),
        
        # Autres
        ('can_archive_data', 'Archiver des donn√©es')
    ]
    
    # Cr√©er dynamiquement les champs du formulaire
    for perm_code, perm_label in manageable_permissions:
        # Sauter certaines permissions pour self-edit
        if is_self_edit and perm_code in ['can_manage_users', 'can_edit_users', 'can_delete_users']:
            continue
        
        # Cr√©er le champ avec le label appropri√©
        field = BooleanField(perm_label)
        setattr(GestionnairePermissionsForm, perm_code, field)
    
    # Initialiser le formulaire avec les valeurs actuelles
    form = GestionnairePermissionsForm()
    
    if request.method == 'GET':
        # Pr√©-remplir les valeurs actuelles
        for perm_code, _ in manageable_permissions:
            if hasattr(form, perm_code):
                # R√©cup√©rer la valeur actuelle de la permission
                current_value = user.permissions.get(perm_code, False)
                getattr(form, perm_code).data = current_value
    
    if form.validate_on_submit():
        try:
            # R√©cup√©rer ou initialiser les permissions
            new_permissions = user.permissions.copy() if user.permissions else {}
            
            # Mettre √† jour uniquement les permissions g√©rables
            for perm_code, _ in manageable_permissions:
                # Ne pas modifier certaines permissions pour self-edit
                if is_self_edit and perm_code in ['can_manage_users', 'can_edit_users', 'can_delete_users']:
                    continue
                
                # Mettre √† jour la valeur
                if hasattr(form, perm_code):
                    new_permissions[perm_code] = getattr(form, perm_code).data
            
            # FORCER certaines permissions √† False pour les gestionnaires
            forbidden_permissions = [
                'can_manage_settings', 'can_manage_permissions', 'can_delete_data',
                'can_manage_clients', 'can_provision_servers'
            ]
            
            for forbidden in forbidden_permissions:
                new_permissions[forbidden] = False
            
            # Mettre √† jour l'utilisateur
            user.permissions = new_permissions
            user.updated_at = datetime.utcnow()
            
            db.session.commit()
            
            # Journaliser
            journal = JournalActiviteClient(
                client_id=client.id,
                utilisateur_id=current_user.id,
                action='modification_permissions_gestionnaire',
                details={
                    'user_id': user.id,
                    'username': user.username,
                    'modified_by': current_user.username,
                    'is_self_edit': is_self_edit,
                    'permissions_changed': [p for p, v in new_permissions.items() if v]
                }
            )
            db.session.add(journal)
            db.session.commit()
            
            flash('‚úÖ Permissions mises √† jour avec succ√®s', 'success')
            return redirect(url_for('gestionnaire_utilisateurs'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'‚ùå Erreur lors de la mise √† jour: {str(e)}', 'error')
    
    # Calculer les statistiques pour le template
    stats = {
        'total_users': User.query.filter_by(
            client_id=client.id, 
            is_active=True
        ).count() if client else 0,
        'max_users': client.formule.max_utilisateurs if client and client.formule else 0
    }
    
    return render_template('gestionnaire/gerer_permissions.html', 
                         user=user, 
                         form=form,
                         manageable_permissions=manageable_permissions,
                         is_self_edit=is_self_edit,
                         stats=stats,
                         current_user=current_user)

@app.route('/gestionnaire/utilisateur/<int:id>/toggle-status', methods=['POST'])
@login_required
def gestionnaire_toggle_user_status(id):
    """Activer/d√©sactiver un utilisateur - version gestionnaire"""
    
    # V√©rifier les permissions
    if not current_user.has_permission('can_deactivate_users'):
        return jsonify({'success': False, 'error': 'Permission refus√©e'}), 403
    
    # R√©cup√©rer l'utilisateur
    user = User.query.get_or_404(id)
    client = current_user.client
    
    # V√©rifications de s√©curit√©
    if not client:
        return jsonify({'success': False, 'error': 'Client non trouv√©'}), 404
    
    # V√©rifier que l'utilisateur appartient au m√™me client
    if user.client_id != client.id:
        return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
    
    # Emp√™cher de modifier :
    # 1. Soi-m√™me
    if user.id == current_user.id:
        return jsonify({'success': False, 'error': 'Impossible de modifier votre propre statut'}), 403
    
    # 2. Les client_admin
    if user.is_client_admin:
        return jsonify({'success': False, 'error': 'Impossible de modifier un administrateur client'}), 403
    
    # 3. Les autres gestionnaires (sauf si c'est un admin client)
    if user.can_manage_users and not current_user.is_client_admin:
        return jsonify({'success': False, 'error': 'Impossible de modifier un autre gestionnaire'}), 403
    
    try:
        # Basculer le statut
        user.is_active = not user.is_active
        user.updated_at = datetime.utcnow()
        
        # Journaliser l'action
        journal = JournalActiviteClient(
            client_id=client.id,
            utilisateur_id=current_user.id,
            action='toggle_user_status',
            details={
                'user_id': user.id,
                'username': user.username,
                'new_status': user.is_active,
                'modified_by': current_user.username
            }
        )
        db.session.add(journal)
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Utilisateur {"activ√©" if user.is_active else "d√©sactiv√©"} avec succ√®s',
            'is_active': user.is_active,
            'username': user.username
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/gestionnaire/utilisateur/<int:id>/supprimer', methods=['POST'])
@login_required
def gestionnaire_supprimer_utilisateur(id):
    """Supprimer un utilisateur - version gestionnaire"""
    
    # V√©rifier les permissions
    if not current_user.has_permission('can_delete_users'):
        return jsonify({'success': False, 'error': 'Permission refus√©e'}), 403
    
    # R√©cup√©rer l'utilisateur
    user = User.query.get_or_404(id)
    client = current_user.client
    
    # V√©rifications de s√©curit√©
    if not client:
        return jsonify({'success': False, 'error': 'Client non trouv√©'}), 404
    
    # V√©rifier que l'utilisateur appartient au m√™me client
    if user.client_id != client.id:
        return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
    
    # Emp√™cher de supprimer :
    # 1. Soi-m√™me
    if user.id == current_user.id:
        return jsonify({'success': False, 'error': 'Impossible de supprimer votre propre compte'}), 403
    
    # 2. Les client_admin
    if user.is_client_admin:
        return jsonify({'success': False, 'error': 'Impossible de supprimer un administrateur client'}), 403
    
    # 3. Les autres gestionnaires (sauf si c'est un admin client)
    if user.can_manage_users and not current_user.is_client_admin:
        return jsonify({'success': False, 'error': 'Impossible de supprimer un autre gestionnaire'}), 403
    
    try:
        username = user.username
        
        # Suppression logique (d√©sactivation)
        user.is_active = False
        user.updated_at = datetime.utcnow()
        
        # Journaliser la suppression
        journal = JournalActiviteClient(
            client_id=client.id,
            utilisateur_id=current_user.id,
            action='suppression_utilisateur',
            details={
                'user_id': user.id,
                'username': username,
                'deleted_by': current_user.username,
                'method': 'desactivation'
            }
        )
        db.session.add(journal)
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Utilisateur {username} d√©sactiv√© avec succ√®s',
            'username': username
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/gestionnaire/debug-permissions')
@login_required
def debug_permissions():
    """Page de d√©bogage des permissions"""
    
    html = f"""
    <html>
    <head><title>Debug Permissions</title></head>
    <body style="padding: 20px; font-family: Arial;">
        <h1>üîç D√©bogage des Permissions Gestionnaire</h1>
        
        <h3>Utilisateur actuel: {current_user.username}</h3>
        
        <div style="background: #f0f0f0; padding: 15px; margin: 10px 0;">
            <h4>Permissions critiques:</h4>
            <ul>
                <li>can_create_users: {current_user.has_permission('can_create_users')}</li>
                <li>can_edit_users: {current_user.has_permission('can_edit_users')}</li>
                <li>can_delete_users: {current_user.has_permission('can_delete_users')}</li>
                <li>can_deactivate_users: {current_user.has_permission('can_deactivate_users')}</li>
                <li>can_view_users_list: {current_user.has_permission('can_view_users_list')}</li>
                <li>can_manage_users: {current_user.can_manage_users}</li>
                <li>is_client_admin: {current_user.is_client_admin}</li>
            </ul>
        </div>
        
        <div style="background: #e8f5e8; padding: 15px; margin: 10px 0;">
            <h4>Toutes les permissions:</h4>
            <pre>{json.dumps(current_user.permissions or {}, indent=2)}</pre>
        </div>
        
        <div style="background: #fff3cd; padding: 15px; margin: 10px 0;">
            <h4>Routes disponibles:</h4>
            <ul>
                <li><a href="/gestionnaire/utilisateurs">/gestionnaire/utilisateurs</a></li>
                <li><a href="/gestionnaire/utilisateur/1/toggle-status" onclick="alert('Route test')">/toggle-status (test)</a></li>
                <li><a href="/gestionnaire/utilisateur/1/supprimer" onclick="alert('Route test')">/supprimer (test)</a></li>
            </ul>
        </div>
    </body>
    </html>
    """
    
    return html

# Ajoutez cette fonction au d√©but de votre fichier app.py
def journaliser_action_client(client_id, utilisateur_id, action, details=None):
    """Journaliser une action client (version simplifi√©e)"""
    try:
        # Cr√©er directement l'objet sans import probl√©matique
        journal = JournalActiviteClient(
            client_id=client_id,
            utilisateur_id=utilisateur_id,
            action=action,
            details=details
        )
        db.session.add(journal)
        db.session.commit()
        return True
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur journalisation client (fallback): {e}")
        try:
            # Fallback : cr√©er une entr√©e dans le journal syst√®me
            from models import JournalActivite
            journal_systeme = JournalActivite(
                utilisateur_id=utilisateur_id,
                action=f'client_{action}',
                details=details,
                entite_type='client',
                entite_id=client_id
            )
            db.session.add(journal_systeme)
            db.session.commit()
            return True
        except:
            db.session.rollback()
            return False


@app.route('/client-admin/utilisateurs')
@login_required
def client_admin_utilisateurs():
    """G√©rer les utilisateurs du client (admin client uniquement)"""
    
    # V√©rifier que c'est un admin client
    if not (current_user.is_client_admin or current_user.role == 'admin'):
        flash('Acc√®s r√©serv√© aux administrateurs client', 'error')
        return redirect(url_for('dashboard'))
    
    # R√©cup√©rer le client de l'utilisateur courant
    client = current_user.client
    
    if not client:
        flash('Aucun client associ√© √† votre compte', 'error')
        return redirect(url_for('dashboard'))
    
    # ‚úÖ CORRECTION : R√©cup√©rer les utilisateurs sans ORDER BY sur la propri√©t√©
    users = User.query.filter_by(client_id=client.id)\
        .order_by(User.username.asc())\
        .all()
    
    # ‚úÖ Trier en Python par statut actif (les actifs d'abord)
    users.sort(key=lambda u: (not u.is_active, u.username))
    
    # R√©cup√©rer la formule du client
    formule = client.formule
    
    # Statistiques
    max_utilisateurs = formule.max_utilisateurs if formule else 10
    total_users = len(users)
    
    stats = {
        'total': total_users,
        'actifs': len([u for u in users if u.is_active]),
        'inactifs': len([u for u in users if not u.is_active]),
        'admin_count': len([u for u in users if u.is_client_admin or u.role == 'admin']),
        'user_count': len([u for u in users if not u.is_client_admin and u.role != 'admin']),
        'limite': max_utilisateurs,
        'pourcentage': (total_users / max_utilisateurs * 100) if max_utilisateurs > 0 else 0
    }
    
    # V√©rifier les limites
    if formule:
        if stats['total'] >= max_utilisateurs:
            flash(f'‚ö†Ô∏è Limite d\'utilisateurs atteinte ({max_utilisateurs}). Pensez √† mettre √† niveau votre formule.', 'warning')
        elif stats['total'] >= max_utilisateurs * 0.9:
            flash(f'‚ö†Ô∏è Vous approchez de la limite d\'utilisateurs ({stats["total"]}/{max_utilisateurs})', 'info')
    
    return render_template('client_admin/utilisateurs.html',
                         users=users,
                         client=client,
                         stats=stats,
                         current_user=current_user,
                         now=datetime.utcnow(),
                         can_edit_users=current_user.has_permission('can_edit_users'))


@app.route('/client-admin/utilisateur/nouveau', methods=['GET', 'POST'])
@login_required
def client_admin_nouvel_utilisateur():
    """Cr√©er un nouvel utilisateur dans le client"""
    if not current_user.is_client_admin:
        abort(403)
    
    # V√©rifier la limite d'utilisateurs
    client = Client.query.get(current_user.client_id)
    if client.nb_utilisateurs >= client.max_utilisateurs:
        flash('Limite d\'utilisateurs atteinte. Veuillez mettre √† jour votre plan.', 'error')
        return redirect(url_for('client_admin_utilisateurs'))
    
    form = NouvelUtilisateurForm()
    
    # Filtrer les templates de permissions accessibles
    templates = PermissionTemplate.query.filter(
        PermissionTemplate.role != 'super_admin'
    ).all()
    form.template_permissions.choices = [(0, 'Aucun template')] + [(t.id, t.name) for t in templates]
    
    if form.validate_on_submit():
        try:
            user = User(
                username=form.username.data,
                email=form.email.data,
                role=form.role.data,
                department=form.department.data,
                is_active=form.is_active.data,
                client_id=current_user.client_id,
                is_client_admin=False  # Seul le super admin peut cr√©er des admin client
            )
            user.set_password(form.password.data)
            
            # Appliquer template de permissions
            if form.template_permissions.data and int(form.template_permissions.data) != 0:
                template = PermissionTemplate.query.get(form.template_permissions.data)
                if template:
                    user.permissions = template.permissions
            
            db.session.add(user)
            
            # Mettre √† jour les m√©triques du client
            client.incrementer_metrique('utilisateurs')
            
            db.session.commit()
            
            # Journaliser
            journal = JournalActiviteClient(
                client_id=current_user.client_id,
                utilisateur_id=current_user.id,
                action='creation_utilisateur',
                details={'username': user.username, 'role': user.role}
            )
            db.session.add(journal)
            db.session.commit()
            
            flash(f'Utilisateur {user.username} cr√©√© avec succ√®s', 'success')
            return redirect(url_for('client_admin_utilisateurs'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur: {str(e)}', 'error')
    
    return render_template('client_admin/nouvel_utilisateur.html', form=form)

@app.route('/client-admin/dashboard')
@login_required
def client_admin_dashboard():
    """Tableau de bord admin client"""
    
    if not current_user.is_client_admin and current_user.role != 'admin':
        flash('Acc√®s r√©serv√© aux administrateurs client', 'error')
        return redirect(url_for('dashboard'))
    
    client = current_user.client
    if not client:
        flash('Aucun client associ√© √† votre compte', 'error')
        return redirect(url_for('dashboard'))
    
    # Statistiques
    stats = {
        'utilisateurs': User.query.filter_by(client_id=client.id, is_active=True).count(),
        'utilisateurs_actifs': User.query.filter_by(client_id=client.id, is_active=True).count(),
        'risques': 0,  # √Ä impl√©menter selon vos mod√®les
        'audits': 0,   # √Ä impl√©menter selon vos mod√®les
        'limite_utilisateurs': client.formule.max_utilisateurs if client.formule else 10,
        'limite_risques': client.formule.max_risques if client.formule else 1000,
        'limite_audits': client.formule.max_audits if client.formule else 100
    }
    
    # Activit√©s r√©centes
    activites = JournalActiviteClient.query.filter_by(
        client_id=client.id
    ).order_by(
        JournalActiviteClient.created_at.desc()
    ).limit(10).all()
    
    # Utilisateurs r√©cents
    utilisateurs_recents = User.query.filter_by(
        client_id=client.id
    ).order_by(
        User.created_at.desc()
    ).limit(5).all()
    
    return render_template('client_admin/dashboard.html',
                         client=client,
                         stats=stats,
                         activites=activites,
                         utilisateurs_recents=utilisateurs_recents)


@app.route('/super-admin/dashboard')
@login_required
@super_admin_required
def super_admin_dashboard():
    """Tableau de bord super admin"""
    # R√©cup√©rer les statistiques
    total_clients = Client.query.count()
    clients_actifs = Client.query.filter_by(is_active=True).count()
    
    # Calculer les totaux globaux
    total_utilisateurs = User.query.count()
    total_risques = Risque.query.filter_by(is_archived=False).count()
    total_audits = Audit.query.filter_by(is_archived=False).count()
    
    # Clients r√©cents
    clients_recents = Client.query.order_by(Client.created_at.desc()).limit(5).all()
    
    # Activit√©s r√©centes
    activites = JournalActiviteClient.query.order_by(
        JournalActiviteClient.created_at.desc()
    ).limit(10).all()
    
    return render_template('super_admin/dashboard.html',
                         total_clients=total_clients,
                         clients_actifs=clients_actifs,
                         total_utilisateurs=total_utilisateurs,
                         total_risques=total_risques,
                         total_audits=total_audits,
                         clients_recents=clients_recents,
                         activites=activites)


# ========================
# FONCTIONS DE D√âBOGAGE
# ========================

def debug_form_errors(form):
    """Affiche les erreurs de formulaire"""
    if form.errors:
        print("‚ùå ERREURS DE FORMULAIRE:")
        for field, errors in form.errors.items():
            print(f"  Champ '{field}': {errors}")



# ========================
# MIDDLEWARE DE FILTRAGE CLIENT
# ========================

@app.before_request
def filter_client_data():
    """Filtre automatiquement les donn√©es par client"""
    if current_user.is_authenticated and not current_user.role == 'super_admin':
        # Ne pas filtrer les routes publiques ou d'administration
        if request.endpoint and not request.endpoint.startswith(('login', 'logout', 'static', 
                                                                'super_admin', 'client_admin')):
            # Ajouter le filtre client_id aux requ√™tes
            g.client_id = current_user.client_id

# Dans chaque route qui manipule des donn√©es, ajoutez ce filtre :
def check_client_access(entite):
    """V√©rifie que l'utilisateur a acc√®s √† l'entit√©"""
    
    # SUPER ADMIN : ACC√àS UNIVERSEL (sauf aux autres super admin)
    if current_user.role == 'super_admin':
        # Un super admin ne peut pas acc√©der √† un autre super admin
        if isinstance(entite, User) and entite.role == 'super_admin':
            return current_user.id == entite.id  # Seulement son propre compte
        return True
    
    # Si l'entit√© n'existe pas
    if not entite:
        return False
    
    # V√©rifier client_id direct
    if hasattr(entite, 'client_id') and entite.client_id:
        return entite.client_id == current_user.client_id
    
    # V√©rifier par created_by
    if hasattr(entite, 'created_by') and entite.created_by:
        createur = User.query.get(entite.created_by)
        if createur:
            # Un utilisateur normal ne peut pas acc√©der aux donn√©es cr√©√©es par un super admin
            if createur.role == 'super_admin':
                return False
            if hasattr(createur, 'client_id'):
                return createur.client_id == current_user.client_id
    
    # Pour les User, v√©rifier directement
    if isinstance(entite, User):
        # Ne pas permettre l'acc√®s aux super admin
        if entite.role == 'super_admin':
            return False
        return entite.client_id == current_user.client_id
    
    # Par d√©faut, refuser
    return False

def check_client_access(entite):
    """V√©rifie que l'utilisateur a acc√®s √† l'entit√©"""
    
    # SUPER ADMIN : ACC√àS UNIVERSEL (sauf aux autres super admin)
    if current_user.role == 'super_admin':
        # Un super admin ne peut pas acc√©der √† un autre super admin
        if isinstance(entite, User) and entite.role == 'super_admin':
            return current_user.id == entite.id  # Seulement son propre compte
        return True
    
    # Si l'entit√© n'existe pas
    if not entite:
        return False
    
    # V√©rifier client_id direct
    if hasattr(entite, 'client_id') and entite.client_id:
        return entite.client_id == current_user.client_id
    
    # V√©rifier par created_by
    if hasattr(entite, 'created_by') and entite.created_by:
        createur = User.query.get(entite.created_by)
        if createur:
            # Un utilisateur normal ne peut pas acc√©der aux donn√©es cr√©√©es par un super admin
            if createur.role == 'super_admin':
                return False
            if hasattr(createur, 'client_id'):
                return createur.client_id == current_user.client_id
    
    # Pour les User, v√©rifier directement
    if isinstance(entite, User):
        # Ne pas permettre l'acc√®s aux super admin
        if entite.role == 'super_admin':
            return False
        return entite.client_id == current_user.client_id
    
    # Par d√©faut, refuser
    return False

# ========================
# ROUTES PRINCIPALES
# ========================
@app.route('/')
def dashboard():
    """Route racine - affiche home si non connect√©, sinon dashboard"""
    
    # Si l'utilisateur n'est PAS connect√©, rediriger vers home
    if not current_user.is_authenticated:
        return redirect(url_for('home'))
    
    # Si l'utilisateur est connect√©, afficher le dashboard
    """Tableau de bord principal avec isolation multi-tenant compl√®te"""
    from sqlalchemy import func, and_
    
    # ========================
    # 1. FILTRES DE BASE PAR CLIENT
    # ========================
    
    # Risques avec filtre client
    total_risques = get_client_filter(Risque).filter_by(is_archived=False).count()
    
    # KRI avec filtre client
    total_kri = get_client_filter(KRI).filter_by(est_actif=True).count()
    
    # ========================
    # 2. LOGIGRAMMES & PROCESSUS
    # ========================
    
    # Logigrammes - seulement ceux de l'utilisateur
    total_logigrammes = get_client_filter(ProcessusActivite).count()
    logigrammes_actifs = get_client_filter(ProcessusActivite).filter_by(is_archived=False).count()
    
    # Processus pour compatibilit√©
    total_processus = get_client_filter(Processus).count()
    processus_actifs = get_client_filter(Processus).filter_by(statut='actif').count()
    
    # ========================
    # 3. VEILLE R√âGLEMENTAIRE
    # ========================
    
    # Veilles actives et non archiv√©es
    veilles_actives = get_client_filter(VeilleReglementaire).filter_by(
        is_active=True, 
        is_archived=False
    ).count()
    
    # Actions retard√©es
    actions_retardees = get_client_filter(ActionConformite).filter(
        ActionConformite.date_echeance < datetime.now().date(),
        ActionConformite.statut.in_(['a_faire', 'en_cours']),
        ActionConformite.is_archived == False
    ).count()
    
    # ========================
    # 4. ANALYSE DES RISQUES
    # ========================
    
    # Sous-requ√™te pour les derni√®res √©valuations
    derniere_eval_subq = db.session.query(
        EvaluationRisque.risque_id,
        func.max(EvaluationRisque.created_at).label('max_date')
    ).join(Risque, EvaluationRisque.risque_id == Risque.id)
    
    # Ajouter le filtre client pour les super admin uniquement
    if current_user.role != 'super_admin':
        derniere_eval_subq = derniere_eval_subq.filter(Risque.client_id == current_user.client_id)
    
    derniere_eval_subq = derniere_eval_subq.group_by(EvaluationRisque.risque_id).subquery()
    
    # Niveaux de risques
    niveaux_query = db.session.query(
        EvaluationRisque.niveau_risque, func.count(EvaluationRisque.id)
    ).select_from(EvaluationRisque).join(
        derniere_eval_subq,
        and_(
            EvaluationRisque.risque_id == derniere_eval_subq.c.risque_id,
            EvaluationRisque.created_at == derniere_eval_subq.c.max_date
        )
    ).join(Risque, EvaluationRisque.risque_id == Risque.id)
    
    # Filtrer par client
    if current_user.role != 'super_admin':
        niveaux_query = niveaux_query.filter(Risque.client_id == current_user.client_id)
    
    niveaux_risques = niveaux_query.filter(
        Risque.is_archived == False, 
        EvaluationRisque.niveau_risque.isnot(None)
    ).group_by(EvaluationRisque.niveau_risque).all()
    
    # Compter les risques par niveau
    risques_faibles = risques_moyens = risques_eleves = risques_critiques_count = 0
    for niveau, count in niveaux_risques:
        if niveau == 'Faible': 
            risques_faibles = count
        elif niveau == 'Moyen': 
            risques_moyens = count
        elif niveau == '√âlev√©': 
            risques_eleves = count
        elif niveau == 'Critique': 
            risques_critiques_count = count
    
    # ========================
    # 5. RISQUES CRITIQUES
    # ========================
    
    # Risques critiques avec √©valuations
    risques_critiques_query = db.session.query(Risque, EvaluationRisque
    ).select_from(EvaluationRisque).join(
        derniere_eval_subq,
        and_(
            EvaluationRisque.risque_id == derniere_eval_subq.c.risque_id,
            EvaluationRisque.created_at == derniere_eval_subq.c.max_date
        )
    ).join(Risque, EvaluationRisque.risque_id == Risque.id)
    
    # Filtrer par client
    if current_user.role != 'super_admin':
        risques_critiques_query = risques_critiques_query.filter(Risque.client_id == current_user.client_id)
    
    risques_critiques_list = risques_critiques_query.filter(
        Risque.is_archived == False, 
        EvaluationRisque.niveau_risque == 'Critique'
    ).order_by(EvaluationRisque.score_risque.desc()
    ).limit(10).all()
    
    risques_critiques_formatted = [{'risque': r, 'evaluation': e} for r, e in risques_critiques_list]
    
    # ========================
    # 6. CARTOS R√âCENTES
    # ========================
    
    # Cartographies r√©centes
    cartographies_query = get_client_filter(Cartographie).outerjoin(
        Risque, and_(
            Risque.cartographie_id == Cartographie.id, 
            Risque.is_archived == False
        )
    ).group_by(Cartographie.id).having(func.count(Risque.id) > 0
    ).order_by(Cartographie.created_at.desc()
    ).limit(5)
    
    cartographies = cartographies_query.all()
    
    # ========================
    # 7. ALERTES KRI
    # ========================
    
    # Derni√®res mesures KRI
    derniere_mesure_subq = db.session.query(
        MesureKRI.kri_id, func.max(MesureKRI.date_mesure).label('max_date')
    ).join(KRI, MesureKRI.kri_id == KRI.id)
    
    # Filtrer par client
    if current_user.role != 'super_admin':
        derniere_mesure_subq = derniere_mesure_subq.filter(KRI.client_id == current_user.client_id)
    
    derniere_mesure_subq = derniere_mesure_subq.group_by(MesureKRI.kri_id).subquery()
    
    # Alertes KRI
    kri_alertes_query = db.session.query(KRI).join(
        derniere_mesure_subq, KRI.id == derniere_mesure_subq.c.kri_id
    ).join(MesureKRI, and_(
        MesureKRI.kri_id == KRI.id, 
        MesureKRI.date_mesure == derniere_mesure_subq.c.max_date
    )).join(Risque, KRI.risque_id == Risque.id)
    
    # Filtrer par client
    if current_user.role != 'super_admin':
        kri_alertes_query = kri_alertes_query.filter(
            KRI.client_id == current_user.client_id,
            Risque.client_id == current_user.client_id
        )
    
    kri_alertes = kri_alertes_query.filter(
        Risque.is_archived == False, 
        KRI.est_actif == True,
        KRI.seuil_alerte.isnot(None), 
        MesureKRI.valeur >= KRI.seuil_alerte
    ).count()
    
    # ========================
    # 8. TENDANCE GLOBALE
    # ========================
    
    # Score de risque moyen
    score_query = db.session.query(func.avg(EvaluationRisque.score_risque)
    ).select_from(EvaluationRisque).join(
        derniere_eval_subq,
        and_(
            EvaluationRisque.risque_id == derniere_eval_subq.c.risque_id,
            EvaluationRisque.created_at == derniere_eval_subq.c.max_date
        )
    ).join(Risque, EvaluationRisque.risque_id == Risque.id
    ).filter(Risque.is_archived == False)
    
    # Filtrer par client
    if current_user.role != 'super_admin':
        score_query = score_query.filter(Risque.client_id == current_user.client_id)
    
    score_risque_moyen = score_query.scalar()
    score_risque_moyen = round(score_risque_moyen, 2) if score_risque_moyen else 0
    
    # D√©terminer la tendance
    if score_risque_moyen < 8:
        tendance_globale, couleur_tendance = 'positive', 'success'
    elif score_risque_moyen < 16:
        tendance_globale, couleur_tendance = 'neutre', 'warning'
    else:
        tendance_globale, couleur_tendance = 'negative', 'danger'
    
    # ========================
    # 9. CALCULS FINAUX
    # ========================
    
    # Pourcentage de risques critiques
    pourcentage_critiques = 0
    if total_risques > 0:
        pourcentage_critiques = round((risques_critiques_count / total_risques) * 100, 1)
    
    # ========================
    # 10. NOTIFICATIONS (optionnel)
    # ========================
    
    # R√©cup√©rer les notifications non lues
    notifications_non_lues = 0
    try:
        notifications_non_lues = get_client_filter(Notification).filter_by(
            destinataire_id=current_user.id,
            est_lue=False
        ).count()
    except:
        pass  # Si le mod√®le Notification n'existe pas encore
    
    # ========================
    # 11. RENDU
    # ========================
    
    return render_template('dashboard.html',
        # Totaux
        total_risques=total_risques,
        total_kri=total_kri,
        total_logigrammes=total_logigrammes,
        total_processus=total_processus,
        
        # Veille
        veilles_actives=veilles_actives,
        actions_retardees=actions_retardees,
        
        # Risques
        risques_critiques=risques_critiques_formatted,
        risques_faibles=risques_faibles,
        risques_moyens=risques_moyens,
        risques_eleves=risques_eleves,
        risques_critiques_count=risques_critiques_count,
        pourcentage_critiques=pourcentage_critiques,
        
        # KRI
        kri_alertes=kri_alertes,
        
        # Logigrammes & Processus
        logigrammes_actifs=logigrammes_actifs,
        processus_actifs=processus_actifs,
        
        # Cartographies
        cartographies=cartographies,
        
        # Tendances
        score_risque_moyen=score_risque_moyen,
        tendance_globale=tendance_globale,
        couleur_tendance=couleur_tendance,
        
        # Utilisateur & Notifications
        current_user=current_user,
        notifications_count=notifications_non_lues,
        
        # Utilitaires
        datetime=datetime,
        
        # Debug info (optionnel - √† retirer en production)
        debug_info={
            'user_role': current_user.role,
            'user_client_id': current_user.client_id,
            'is_super_admin': current_user.role == 'super_admin'
        }
    )

@app.route('/export/dashboard')
@login_required
def export_dashboard():
    """Export des donn√©es du dashboard en PDF avec graphiques enrichis"""
    try:
        from weasyprint import HTML
        import tempfile
        import os
        from sqlalchemy import func, and_, extract, case
        from datetime import datetime, timedelta
        from dateutil.relativedelta import relativedelta
        
        # --- R√âCUP√âRATION DES DONN√âES COMPL√àTES ---
        
        # 1. Statistiques principales
        total_risques = Risque.query.filter_by(is_archived=False).count()
        
        # KRI actifs
        total_kri = db.session.query(KRI).join(
            Risque, KRI.risque_id == Risque.id
        ).filter(
            Risque.is_archived == False,
            KRI.est_actif == True
        ).count()
        
        # Processus et logigrammes
        total_processus = Processus.query.count()
        total_logigrammes = ProcessusActivite.query.count()
        logigrammes_actifs = ProcessusActivite.query.filter_by(
            is_archived=False
        ).count()
        
        # Veilles actives
        veilles_actives = VeilleReglementaire.query.filter_by(
            is_active=True, 
            is_archived=False
        ).count()
        
        # 2. Calcul des risques par niveau
        derniere_eval_subq = db.session.query(
            EvaluationRisque.risque_id,
            func.max(EvaluationRisque.created_at).label('max_date')
        ).group_by(EvaluationRisque.risque_id).subquery()
        
        niveaux_risques = db.session.query(
            EvaluationRisque.niveau_risque, 
            func.count(EvaluationRisque.id)
        ).select_from(EvaluationRisque).join(
            derniere_eval_subq,
            and_(
                EvaluationRisque.risque_id == derniere_eval_subq.c.risque_id,
                EvaluationRisque.created_at == derniere_eval_subq.c.max_date
            )
        ).join(Risque, EvaluationRisque.risque_id == Risque.id
        ).filter(
            Risque.is_archived == False, 
            EvaluationRisque.niveau_risque.isnot(None)
        ).group_by(EvaluationRisque.niveau_risque).all()
        
        # Initialisation des compteurs
        risques_faibles = risques_moyens = risques_eleves = risques_critiques_count = 0
        for niveau, count in niveaux_risques:
            if niveau == 'Faible': 
                risques_faibles = count
            elif niveau == 'Moyen': 
                risques_moyens = count
            elif niveau == '√âlev√©': 
                risques_eleves = count
            elif niveau == 'Critique': 
                risques_critiques_count = count
        
        # 3. √âvolution des risques sur 6 mois - CORRECTION POUR SQLITE
        six_mois = datetime.now() - timedelta(days=180)
        
        # Pour SQLite, utiliser strftime pour grouper par mois
        evolution_data = db.session.query(
            func.strftime('%Y-%m', EvaluationRisque.created_at).label('mois'),
            EvaluationRisque.niveau_risque,
            func.count().label('count')
        ).join(Risque, EvaluationRisque.risque_id == Risque.id
        ).filter(
            Risque.is_archived == False,
            EvaluationRisque.created_at >= six_mois
        ).group_by(
            func.strftime('%Y-%m', EvaluationRisque.created_at),
            EvaluationRisque.niveau_risque
        ).order_by('mois').all()
        
        # 4. Top 5 des cartographies √† risque
        cartographies_risque = db.session.query(
            Cartographie.nom,
            func.count(Risque.id).label('nb_risques'),
            func.avg(EvaluationRisque.score_risque).label('score_moyen')
        ).join(Risque, Risque.cartographie_id == Cartographie.id
        ).join(EvaluationRisque, EvaluationRisque.risque_id == Risque.id
        ).join(derniere_eval_subq,
            and_(
                EvaluationRisque.risque_id == derniere_eval_subq.c.risque_id,
                EvaluationRisque.created_at == derniere_eval_subq.c.max_date
            )
        ).filter(
            Risque.is_archived == False
        ).group_by(Cartographie.id
        ).order_by(func.avg(EvaluationRisque.score_risque).desc()
        ).limit(5).all()
        
        # 5. KRI en alerte
        derniere_mesure_subq = db.session.query(
            MesureKRI.kri_id,
            func.max(MesureKRI.date_mesure).label('max_date')
        ).group_by(MesureKRI.kri_id).subquery()
        
        kri_alertes = db.session.query(KRI).join(
            derniere_mesure_subq, KRI.id == derniere_mesure_subq.c.kri_id
        ).join(MesureKRI, and_(
            MesureKRI.kri_id == KRI.id,
            MesureKRI.date_mesure == derniere_mesure_subq.c.max_date
        )).join(Risque, KRI.risque_id == Risque.id
        ).filter(
            Risque.is_archived == False,
            KRI.est_actif == True,
            KRI.seuil_alerte.isnot(None),
            MesureKRI.valeur >= KRI.seuil_alerte
        ).count()
        
        # 6. Actions en retard
        actions_retardees = ActionConformite.query.filter(
            ActionConformite.date_echeance < datetime.now().date(),
            ActionConformite.statut.in_(['a_faire', 'en_cours']),
            ActionConformite.is_archived == False
        ).join(VeilleReglementaire).filter(
            VeilleReglementaire.is_active == True,
            VeilleReglementaire.is_archived == False
        ).count()
        
        # 7. Score de risque moyen
        score_risque_moyen = db.session.query(
            func.avg(EvaluationRisque.score_risque)
        ).select_from(EvaluationRisque).join(
            derniere_eval_subq,
            and_(
                EvaluationRisque.risque_id == derniere_eval_subq.c.risque_id,
                EvaluationRisque.created_at == derniere_eval_subq.c.max_date
            )
        ).join(Risque
        ).filter(Risque.is_archived == False
        ).scalar()
        
        score_risque_moyen = round(score_risque_moyen, 2) if score_risque_moyen else 0
        
        # 8. Taux de couverture des risques (risques avec KRI)
        risques_avec_kri = db.session.query(Risque).join(KRI).filter(
            Risque.is_archived == False,
            KRI.est_actif == True
        ).distinct().count()
        
        taux_couverture = 0
        if total_risques > 0:
            taux_couverture = round((risques_avec_kri / total_risques) * 100, 1)
        
        # 9. Pourcentage des risques critiques
        pourcentage_critiques = 0
        if total_risques > 0:
            pourcentage_critiques = round((risques_critiques_count / total_risques) * 100, 1)
        
        # 10. Calcul des moyennes par niveau
        scores_par_niveau = {}
        niveaux = ['Faible', 'Moyen', '√âlev√©', 'Critique']
        for niveau in niveaux:
            score = db.session.query(
                func.avg(EvaluationRisque.score_risque)
            ).select_from(EvaluationRisque).join(
                derniere_eval_subq,
                and_(
                    EvaluationRisque.risque_id == derniere_eval_subq.c.risque_id,
                    EvaluationRisque.created_at == derniere_eval_subq.c.max_date
                )
            ).join(Risque).filter(
                Risque.is_archived == False,
                EvaluationRisque.niveau_risque == niveau
            ).scalar()
            scores_par_niveau[niveau] = round(score, 2) if score else 0
        
        # 11. Nouvelles donn√©es pour l'√©volution
        nouveaux_risques_6_mois = Risque.query.filter(
            Risque.is_archived == False,
            Risque.created_at >= six_mois
        ).count()
        
        # Risques avec faible score (consid√©r√©s comme "cl√¥tur√©s")
        risques_clotures_6_mois = db.session.query(Risque).join(EvaluationRisque).filter(
            Risque.is_archived == False,
            EvaluationRisque.created_at >= six_mois,
            EvaluationRisque.score_risque <= 5
        ).distinct().count()
        
        taux_rotation = 0
        if total_risques > 0:
            taux_rotation = round((nouveaux_risques_6_mois / total_risques) * 100, 1)
        
        # --- G√âN√âRATION DU HTML ENRICHIE ---
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Tableau de Bord Analytique - Export</title>
            <style>
                body {{
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    margin: 25px;
                    color: #333;
                    background: #f8fafc;
                }}
                .header {{
                    text-align: center;
                    background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
                    color: white;
                    padding: 30px 20px;
                    border-radius: 12px;
                    margin-bottom: 30px;
                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                }}
                .company-info {{
                    font-size: 14px;
                    opacity: 0.9;
                    margin-top: 10px;
                }}
                .stats-grid {{
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
                    gap: 20px;
                    margin-bottom: 30px;
                }}
                .stat-card {{
                    background: white;
                    border-radius: 10px;
                    padding: 20px;
                    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
                    border-left: 4px solid;
                    transition: transform 0.2s;
                }}
                .stat-card:hover {{
                    transform: translateY(-2px);
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                }}
                .stat-card h3 {{
                    margin-top: 0;
                    color: #475569;
                    font-size: 14px;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                }}
                .stat-card .value {{
                    font-size: 28px;
                    font-weight: bold;
                    margin: 10px 0;
                }}
                .stat-card .trend {{
                    font-size: 12px;
                    color: #64748b;
                }}
                .stat-card.risque {{ border-left-color: #ef4444; }}
                .stat-card.kri {{ border-left-color: #10b981; }}
                .stat-card.processus {{ border-left-color: #3b82f6; }}
                .stat-card.veille {{ border-left-color: #f59e0b; }}
                .stat-card.couverture {{ border-left-color: #8b5cf6; }}
                .stat-card.score {{ border-left-color: #ec4899; }}
                
                .section-title {{
                    color: #1e293b;
                    border-bottom: 2px solid #e2e8f0;
                    padding-bottom: 10px;
                    margin: 30px 0 20px 0;
                    font-size: 18px;
                }}
                
                .two-columns {{
                    display: grid;
                    grid-template-columns: 1fr 1fr;
                    gap: 25px;
                    margin-bottom: 30px;
                }}
                
                .chart-container {{
                    background: white;
                    border-radius: 10px;
                    padding: 20px;
                    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
                }}
                
                .risk-levels {{
                    display: grid;
                    grid-template-columns: repeat(4, 1fr);
                    gap: 10px;
                    margin-top: 15px;
                }}
                .risk-level {{
                    text-align: center;
                    padding: 15px;
                    border-radius: 8px;
                    color: white;
                    font-weight: bold;
                }}
                .risk-level.faible {{ background: linear-gradient(135deg, #10b981 0%, #059669 100%); }}
                .risk-level.moyen {{ background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); }}
                .risk-level.eleve {{ background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); }}
                .risk-level.critique {{ background: linear-gradient(135deg, #7f1d1d 0%, #450a0a 100%); }}
                
                .table-container {{
                    margin-top: 20px;
                    overflow: hidden;
                    border-radius: 8px;
                    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
                }}
                table {{
                    width: 100%;
                    border-collapse: collapse;
                    background: white;
                }}
                th {{
                    background: #f1f5f9;
                    color: #475569;
                    font-weight: 600;
                    text-align: left;
                    padding: 12px 15px;
                    border-bottom: 2px solid #e2e8f0;
                }}
                td {{
                    padding: 12px 15px;
                    border-bottom: 1px solid #e2e8f0;
                }}
                tr:hover {{
                    background: #f8fafc;
                }}
                
                .alert-badge {{
                    display: inline-block;
                    padding: 4px 12px;
                    border-radius: 20px;
                    font-size: 12px;
                    font-weight: bold;
                    margin: 2px;
                }}
                .alert-danger {{ background: #fee2e2; color: #dc2626; }}
                .alert-warning {{ background: #fef3c7; color: #d97706; }}
                .alert-info {{ background: #dbeafe; color: #1d4ed8; }}
                
                .summary-box {{
                    background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
                    border: 1px solid #bae6fd;
                    border-radius: 10px;
                    padding: 20px;
                    margin: 20px 0;
                }}
                
                .footer {{
                    margin-top: 40px;
                    padding-top: 20px;
                    border-top: 1px solid #e2e8f0;
                    text-align: center;
                    color: #64748b;
                    font-size: 12px;
                }}
                
                @media print {{
                    .stat-card, .chart-container {{ break-inside: avoid; }}
                    .header {{ background: #1e3a8a !important; -webkit-print-color-adjust: exact; }}
                    .risk-level {{ -webkit-print-color-adjust: exact; }}
                }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1 style="margin: 0; font-size: 28px;">TABLEAU DE BORD ANALYTIQUE</h1>
                <p style="margin: 10px 0 0 0; opacity: 0.9;">Syst√®me de Management des Risques & Contr√¥le Interne</p>
                <div class="company-info">
                    Export g√©n√©r√© le {datetime.now().strftime('%d/%m/%Y √† %H:%M')} |
                    Utilisateur: {current_user.username}
                </div>
            </div>
            
            <!-- SECTION 1: STATISTIQUES GLOBALES -->
            <div class="stats-grid">
                <div class="stat-card risque">
                    <h3>RISQUES ACTIFS</h3>
                    <div class="value" style="color: #ef4444;">{total_risques}</div>
                    <div class="trend">
                        <span style="color: #dc2626;">‚ñ≤ {risques_critiques_count} critiques</span> ‚Ä¢ 
                        {pourcentage_critiques}% de criticit√©
                    </div>
                </div>
                
                <div class="stat-card kri">
                    <h3>KRI SURVEILL√âS</h3>
                    <div class="value" style="color: #10b981;">{total_kri}</div>
                    <div class="trend">
                        <span style="color: #d97706;">‚ö† {kri_alertes} en alerte</span> ‚Ä¢ 
                        Taux de couverture: {taux_couverture}%
                    </div>
                </div>
                
                <div class="stat-card processus">
                    <h3>PROCESSUS & LOGIGRAMMES</h3>
                    <div class="value" style="color: #3b82f6;">{total_processus} / {total_logigrammes}</div>
                    <div class="trend">
                        {logigrammes_actifs} logigrammes actifs ‚Ä¢ 
                        {round(logigrammes_actifs/max(total_logigrammes,1)*100,0)}% d'activit√©
                    </div>
                </div>
                
                <div class="stat-card veille">
                    <h3>VEILLES R√âGLEMENTAIRES</h3>
                    <div class="value" style="color: #f59e0b;">{veilles_actives}</div>
                    <div class="trend">
                        <span style="color: #dc2626;">‚è∞ {actions_retardees} retards</span> ‚Ä¢ 
                        Conformit√© en surveillance
                    </div>
                </div>
                
                <div class="stat-card couverture">
                    <h3>COUVERTURE DES RISQUES</h3>
                    <div class="value" style="color: #8b5cf6;">{taux_couverture}%</div>
                    <div class="trend">
                        {risques_avec_kri} risques avec KRI ‚Ä¢ 
                        {total_risques - risques_avec_kri} sans surveillance
                    </div>
                </div>
                
                <div class="stat-card score">
                    <h3>SCORE DE RISQUE MOYEN</h3>
                    <div class="value" style="color: #ec4899;">{score_risque_moyen}/25</div>
                    <div class="trend">
                        {get_niveau_from_score(score_risque_moyen)} ‚Ä¢ 
                        Bas√© sur {total_risques} √©valuations
                    </div>
                </div>
            </div>
            
            <!-- SECTION 2: R√âPARTITION DES RISQUES -->
            <h2 class="section-title">üìä R√âPARTITION DES RISQUES PAR NIVEAU</h2>
            <div class="two-columns">
                <div class="chart-container">
                    <h3 style="margin-top: 0; color: #475569;">Distribution des Niveaux de Risque</h3>
                    <div class="risk-levels">
                        <div class="risk-level faible">
                            <div style="font-size: 22px;">{risques_faibles}</div>
                            <div>FAIBLE</div>
                            <div style="font-size: 11px; opacity: 0.9;">
                                {round(risques_faibles/max(total_risques,1)*100,1)}%
                            </div>
                        </div>
                        <div class="risk-level moyen">
                            <div style="font-size: 22px;">{risques_moyens}</div>
                            <div>MOYEN</div>
                            <div style="font-size: 11px; opacity: 0.9;">
                                {round(risques_moyens/max(total_risques,1)*100,1)}%
                            </div>
                        </div>
                        <div class="risk-level eleve">
                            <div style="font-size: 22px;">{risques_eleves}</div>
                            <div>√âLEV√â</div>
                            <div style="font-size: 11px; opacity: 0.9;">
                                {round(risques_eleves/max(total_risques,1)*100,1)}%
                            </div>
                        </div>
                        <div class="risk-level critique">
                            <div style="font-size: 22px;">{risques_critiques_count}</div>
                            <div>CRITIQUE</div>
                            <div style="font-size: 11px; opacity: 0.9;">
                                {round(risques_critiques_count/max(total_risques,1)*100,1)}%
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px; padding: 15px; background: #f8fafc; border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span>Total risques analys√©s:</span>
                            <strong>{total_risques}</strong>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span>Score moyen:</span>
                            <strong>{score_risque_moyen}/25 ({get_niveau_from_score(score_risque_moyen)})</strong>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span>Tendance globale:</span>
                            <strong style="color: {get_tendance_color(score_risque_moyen)};">
                                {get_tendance_text(score_risque_moyen)}
                            </strong>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h3 style="margin-top: 0; color: #475569;">üö® ALERTES ACTIVES</h3>
                    
                    <div style="margin: 15px 0;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <span>KRI en √©tat d'alerte:</span>
                            <span class="alert-badge alert-danger">{kri_alertes} / {total_kri}</span>
                        </div>
                        <div style="height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
                            <div style="height: 100%; width: {min(kri_alertes/max(total_kri,1)*100, 100)}%; 
                                     background: linear-gradient(90deg, #ef4444, #dc2626);"></div>
                        </div>
                    </div>
                    
                    <div style="margin: 20px 0;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <span>Actions en retard:</span>
                            <span class="alert-badge alert-warning">{actions_retardees}</span>
                        </div>
                        <div style="height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
                            <div style="height: 100%; width: {min(actions_retardees/max(veilles_actives,1)*100, 100)}%; 
                                     background: linear-gradient(90deg, #f59e0b, #d97706);"></div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 25px; padding: 15px; background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); 
                              border-radius: 8px; border-left: 4px solid #f59e0b;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="font-size: 24px;">‚ö†Ô∏è</div>
                            <div>
                                <strong>Recommandations:</strong>
                                <div style="font-size: 13px; margin-top: 5px;">
                                    ‚Ä¢ Prioriser les {risques_critiques_count} risques critiques<br>
                                    ‚Ä¢ Traiter les {actions_retardees} actions en retard<br>
                                    ‚Ä¢ Surveiller les {kri_alertes} KRI en alerte
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- SECTION 3: TOP DES CARTOCRAPHIES √Ä RISQUE -->
            <h2 class="section-title">üó∫Ô∏è TOP 5 DES CARTOCRAPHIES √Ä RISQUE</h2>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>Cartographie</th>
                            <th>Nombre de Risques</th>
                            <th>Score Moyen</th>
                            <th>Niveau</th>
                            <th>Priorit√©</th>
                        </tr>
                    </thead>
                    <tbody>
                        {generate_cartographie_rows(cartographies_risque)}
                    </tbody>
                </table>
            </div>
            
            <!-- SECTION 4: SYNTH√àSE ET RECOMMANDATIONS -->
            <div class="summary-box">
                <h3 style="margin-top: 0; color: #0369a1;">üìã SYNTH√àSE DU TABLEAU DE BORD</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-top: 15px;">
                    <div>
                        <strong>üîç Points Forts:</strong>
                        <ul style="margin: 8px 0 0 20px; font-size: 13px;">
                            <li>{total_kri} indicateurs KRI actifs</li>
                            <li>Taux de couverture: {taux_couverture}%</li>
                            <li>{veilles_actives} veilles r√©glementaires actives</li>
                        </ul>
                    </div>
                    <div>
                        <strong>‚ö†Ô∏è Points de Vigilance:</strong>
                        <ul style="margin: 8px 0 0 20px; font-size: 13px;">
                            <li>{risques_critiques_count} risques critiques √† traiter</li>
                            <li>{kri_alertes} KRI d√©passent leurs seuils</li>
                            <li>{actions_retardees} actions en retard</li>
                        </ul>
                    </div>
                    <div>
                        <strong>üéØ Recommandations:</strong>
                        <ul style="margin: 8px 0 0 20px; font-size: 13px;">
                            <li>R√©viser les risques critiques prioritaires</li>
                            <li>Mettre √† jour les actions en retard</li>
                            <li>Analyser les KRI en alerte</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <!-- SECTION 5: DONN√âES D'√âVOLUTION -->
            <h2 class="section-title">üìà √âVOLUTION SUR 6 MOIS</h2>
            <div style="background: white; border-radius: 10px; padding: 20px; margin-bottom: 20px;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                    <div style="text-align: center; padding: 15px; background: #f0f9ff; border-radius: 8px;">
                        <div style="font-size: 12px; color: #64748b;">Moyenne Mensuelle</div>
                        <div style="font-size: 24px; font-weight: bold; color: #0369a1;">
                            {round(total_risques/6, 1) if total_risques else 0}
                        </div>
                        <div style="font-size: 11px; color: #475569;">risques √©valu√©s/mois</div>
                    </div>
                    
                    <div style="text-align: center; padding: 15px; background: #f0fdf4; border-radius: 8px;">
                        <div style="font-size: 12px; color: #64748b;">Nouveaux Risques</div>
                        <div style="font-size: 24px; font-weight: bold; color: #059669;">
                            {nouveaux_risques_6_mois}
                        </div>
                        <div style="font-size: 11px; color: #475569;">derniers 6 mois</div>
                    </div>
                    
                    <div style="text-align: center; padding: 15px; background: #fef3c7; border-radius: 8px;">
                        <div style="font-size: 12px; color: #64748b;">Risques Cl√¥tur√©s</div>
                        <div style="font-size: 24px; font-weight: bold; color: #d97706;">
                            {risques_clotures_6_mois}
                        </div>
                        <div style="font-size: 11px; color: #475569;">derniers 6 mois</div>
                    </div>
                    
                    <div style="text-align: center; padding: 15px; background: #fef2f2; border-radius: 8px;">
                        <div style="font-size: 12px; color: #64748b;">Taux de Rotation</div>
                        <div style="font-size: 24px; font-weight: bold; color: #dc2626;">
                            {taux_rotation}%
                        </div>
                        <div style="font-size: 11px; color: #475569;">√©volution du portefeuille</div>
                    </div>
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: #f8fafc; border-radius: 8px;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                        <div style="width: 12px; height: 12px; background: #10b981; border-radius: 2px;"></div>
                        <span style="font-size: 13px;">Faible: √âvaluation stable, bonne ma√Ætrise</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                        <div style="width: 12px; height: 12px; background: #f59e0b; border-radius: 2px;"></div>
                        <span style="font-size: 13px;">Moyen: Surveillance renforc√©e recommand√©e</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div style="width: 12px; height: 12px; background: #ef4444; border-radius: 2px;"></div>
                        <span style="font-size: 13px;">√âlev√©/Critique: Actions correctives n√©cessaires</span>
                    </div>
                </div>
            </div>
            
            <!-- SECTION 6: SCORES PAR NIVEAU -->
            <h2 class="section-title">üìä SCORES MOYENS PAR NIVEAU DE RISQUE</h2>
            <div style="background: white; border-radius: 10px; padding: 20px; margin-bottom: 20px;">
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;">
                    <div style="text-align: center; padding: 20px; border-radius: 8px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white;">
                        <div style="font-size: 14px; opacity: 0.9;">FAIBLE</div>
                        <div style="font-size: 28px; font-weight: bold; margin: 10px 0;">{scores_par_niveau.get('Faible', 0)}</div>
                        <div style="font-size: 12px;">/25 points</div>
                    </div>
                    
                    <div style="text-align: center; padding: 20px; border-radius: 8px; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white;">
                        <div style="font-size: 14px; opacity: 0.9;">MOYEN</div>
                        <div style="font-size: 28px; font-weight: bold; margin: 10px 0;">{scores_par_niveau.get('Moyen', 0)}</div>
                        <div style="font-size: 12px;">/25 points</div>
                    </div>
                    
                    <div style="text-align: center; padding: 20px; border-radius: 8px; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white;">
                        <div style="font-size: 14px; opacity: 0.9;">√âLEV√â</div>
                        <div style="font-size: 28px; font-weight: bold; margin: 10px 0;">{scores_par_niveau.get('√âlev√©', 0)}</div>
                        <div style="font-size: 12px;">/25 points</div>
                    </div>
                    
                    <div style="text-align: center; padding: 20px; border-radius: 8px; background: linear-gradient(135deg, #7f1d1d 0%, #450a0a 100%); color: white;">
                        <div style="font-size: 14px; opacity: 0.9;">CRITIQUE</div>
                        <div style="font-size: 28px; font-weight: bold; margin: 10px 0;">{scores_par_niveau.get('Critique', 0)}</div>
                        <div style="font-size: 12px;">/25 points</div>
                    </div>
                </div>
            </div>
            
            <!-- FOOTER -->
            <div class="footer">
                <p>
                    <strong>Document g√©n√©r√© automatiquement</strong><br>
                    Syst√®me de Management Int√©gr√© ‚Ä¢ Version 1.0<br>
                    Les donn√©es excluent les √©l√©ments archiv√©s ‚Ä¢ Confidentialit√©: Interne
                </p>
                <p style="margin-top: 10px; font-size: 11px; color: #94a3b8;">
                    ¬© {datetime.now().year} FabriceKonan Corporate ‚Ä¢ Toute reproduction interdite
                </p>
            </div>
        </body>
        </html>
        """
        
        # --- G√âN√âRATION DU PDF ---
        with tempfile.NamedTemporaryFile(suffix='.pdf', delete=False, mode='wb') as f:
            HTML(string=html_content).write_pdf(f.name)
            
            # Lire le fichier PDF
            with open(f.name, 'rb') as pdf_file:
                pdf_data = pdf_file.read()
            
            # Supprimer le fichier temporaire
            os.unlink(f.name)
        
        # Retourner le PDF
        response = Response(pdf_data, mimetype='application/pdf')
        response.headers['Content-Disposition'] = f'attachment; filename=dashboard_analytique_{datetime.now().strftime("%Y%m%d_%H%M")}.pdf'
        return response
        
    except ImportError:
        flash("WeasyPrint n'est pas install√©, export CSV enrichi √† la place", 'warning')
        return export_dashboard_csv()
    except Exception as e:
        flash(f'Erreur lors de l\'export: {str(e)}', 'error')
        return redirect(url_for('dashboard'))

def generate_cartographie_rows(cartographies_risque):
    """G√©n√®re les lignes du tableau des cartographies"""
    rows = ""
    
    if cartographies_risque:
        for idx, (nom, nb_risques, score_moyen) in enumerate(cartographies_risque, 1):
            niveau = get_niveau_from_score(score_moyen or 0)
            priorite = "Haute" if niveau in ["√âlev√©", "Critique"] else "Moyenne"
            
            rows += f"""
            <tr>
                <td><strong>{nom or 'Non nomm√©'}</strong></td>
                <td><span class="alert-badge alert-info">{nb_risques or 0}</span></td>
                <td><strong>{round(score_moyen or 0, 2)}</strong>/25</td>
                <td>
                    <span class="alert-badge {'alert-danger' if niveau == 'Critique' else 'alert-warning' if niveau == '√âlev√©' else 'alert-info'}">
                        {niveau}
                    </span>
                </td>
                <td>
                    <span class="alert-badge {'alert-danger' if priorite == 'Haute' else 'alert-warning'}">
                        {priorite}
                    </span>
                </td>
            </tr>
            """
    else:
        rows = """
        <tr>
            <td colspan="5" style="text-align: center; padding: 30px; color: #64748b;">
                Aucune donn√©e de cartographie disponible
            </td>
        </tr>
        """
    
    return rows

def export_dashboard_csv():
    """Export de secours en CSV enrichi (compatible SQLite)"""
    try:
        import csv
        from io import StringIO
        from flask import Response
        from sqlalchemy import func, and_
        from datetime import datetime, timedelta
        
        # --- R√âCUP√âRATION DES DONN√âES (compatible SQLite) ---
        total_risques = Risque.query.filter_by(is_archived=False).count()
        total_kri = db.session.query(KRI).join(
            Risque, KRI.risque_id == Risque.id
        ).filter(
            Risque.is_archived == False,
            KRI.est_actif == True
        ).count()
        total_processus = Processus.query.count()
        total_logigrammes = ProcessusActivite.query.count()
        logigrammes_actifs = ProcessusActivite.query.filter_by(is_archived=False).count()
        veilles_actives = VeilleReglementaire.query.filter_by(is_active=True, is_archived=False).count()
        
        # Donn√©es risques avec sous-requ√™te
        derniere_eval_subq = db.session.query(
            EvaluationRisque.risque_id,
            func.max(EvaluationRisque.created_at).label('max_date')
        ).group_by(EvaluationRisque.risque_id).subquery()
        
        niveaux_risques = db.session.query(
            EvaluationRisque.niveau_risque, 
            func.count(EvaluationRisque.id)
        ).select_from(EvaluationRisque).join(
            derniere_eval_subq,
            and_(
                EvaluationRisque.risque_id == derniere_eval_subq.c.risque_id,
                EvaluationRisque.created_at == derniere_eval_subq.c.max_date
            )
        ).join(Risque, EvaluationRisque.risque_id == Risque.id
        ).filter(
            Risque.is_archived == False, 
            EvaluationRisque.niveau_risque.isnot(None)
        ).group_by(EvaluationRisque.niveau_risque).all()
        
        risques_faibles = risques_moyens = risques_eleves = risques_critiques_count = 0
        for niveau, count in niveaux_risques:
            if niveau == 'Faible': risques_faibles = count
            elif niveau == 'Moyen': risques_moyens = count
            elif niveau == '√âlev√©': risques_eleves = count
            elif niveau == 'Critique': risques_critiques_count = count
        
        # KRI alertes
        derniere_mesure_subq = db.session.query(
            MesureKRI.kri_id,
            func.max(MesureKRI.date_mesure).label('max_date')
        ).group_by(MesureKRI.kri_id).subquery()
        
        kri_alertes = db.session.query(KRI).join(
            derniere_mesure_subq, KRI.id == derniere_mesure_subq.c.kri_id
        ).join(MesureKRI, and_(
            MesureKRI.kri_id == KRI.id,
            MesureKRI.date_mesure == derniere_mesure_subq.c.max_date
        )).join(Risque, KRI.risque_id == Risque.id
        ).filter(
            Risque.is_archived == False,
            KRI.est_actif == True,
            KRI.seuil_alerte.isnot(None),
            MesureKRI.valeur >= KRI.seuil_alerte
        ).count()
        
        # Actions retard√©es
        actions_retardees = ActionConformite.query.filter(
            ActionConformite.date_echeance < datetime.now().date(),
            ActionConformite.statut.in_(['a_faire', 'en_cours']),
            ActionConformite.is_archived == False
        ).join(VeilleReglementaire).filter(
            VeilleReglementaire.is_active == True,
            VeilleReglementaire.is_archived == False
        ).count()
        
        # Score moyen
        score_risque_moyen = db.session.query(
            func.avg(EvaluationRisque.score_risque)
        ).select_from(EvaluationRisque).join(
            derniere_eval_subq,
            and_(
                EvaluationRisque.risque_id == derniere_eval_subq.c.risque_id,
                EvaluationRisque.created_at == derniere_eval_subq.c.max_date
            )
        ).join(Risque).filter(Risque.is_archived == False).scalar()
        score_risque_moyen = round(score_risque_moyen, 2) if score_risque_moyen else 0
        
        # Taux couverture
        risques_avec_kri = db.session.query(Risque).join(KRI).filter(
            Risque.is_archived == False,
            KRI.est_actif == True
        ).distinct().count()
        taux_couverture = round((risques_avec_kri / max(total_risques, 1)) * 100, 1) if total_risques > 0 else 0
        
        # Donn√©es √©volutives
        six_mois = datetime.now() - timedelta(days=180)
        nouveaux_risques_6_mois = Risque.query.filter(
            Risque.is_archived == False,
            Risque.created_at >= six_mois
        ).count()
        
        risques_clotures_6_mois = db.session.query(Risque).join(EvaluationRisque).filter(
            Risque.is_archived == False,
            EvaluationRisque.created_at >= six_mois,
            EvaluationRisque.score_risque <= 5
        ).distinct().count()
        
        taux_rotation = 0
        if total_risques > 0:
            taux_rotation = round((nouveaux_risques_6_mois / total_risques) * 100, 1)
        
        # Pourcentage critiques
        pourcentage_critiques = round((risques_critiques_count / max(total_risques, 1)) * 100, 1) if total_risques > 0 else 0
        
        # --- CR√âATION DU CSV ENRICHIE ---
        output = StringIO()
        writer = csv.writer(output, delimiter=';', quoting=csv.QUOTE_ALL)
        
        # En-t√™te compl√®te
        writer.writerow(['TABLEAU DE BORD ANALYTIQUE - SYST√àME DE MANAGEMENT DES RISQUES'])
        writer.writerow(['Export g√©n√©r√© le', datetime.now().strftime('%d/%m/%Y √† %H:%M')])
        writer.writerow(['Utilisateur', current_user.username])
        writer.writerow(['Base de donn√©es', 'SQLite'])
        writer.writerow([])
        
        # Section 1: Statistiques principales
        writer.writerow(['SECTION 1: STATISTIQUES PRINCIPALES'])
        writer.writerow(['Indicateur', 'Valeur', 'D√©tail', 'Pourcentage'])
        writer.writerow(['Risques Actifs', total_risques, f'{risques_critiques_count} critiques', 
                        f'{pourcentage_critiques}%'])
        writer.writerow(['KRI Surveill√©s', total_kri, f'{kri_alertes} en alerte', 
                        f'{round(kri_alertes/max(total_kri,1)*100,1)}%' if total_kri > 0 else '0%'])
        writer.writerow(['Taux Couverture', f'{taux_couverture}%', f'{risques_avec_kri} risques couverts', '-'])
        writer.writerow(['Score Moyen', f'{score_risque_moyen}/25', get_niveau_from_score(score_risque_moyen), '-'])
        writer.writerow(['Veilles Actives', veilles_actives, f'{actions_retardees} retards', 
                        f'{round(actions_retardees/max(veilles_actives,1)*100,1)}%' if veilles_actives > 0 else '0%'])
        writer.writerow(['Processus/Logigrammes', f'{total_processus}/{total_logigrammes}', 
                        f'{logigrammes_actifs} actifs', 
                        f'{round(logigrammes_actifs/max(total_logigrammes,1)*100,1)}%' if total_logigrammes > 0 else '0%'])
        writer.writerow([])
        
        # Section 2: R√©partition des risques
        writer.writerow(['SECTION 2: R√âPARTITION DES RISQUES'])
        writer.writerow(['Niveau', 'Nombre', 'Pourcentage'])
        
        total_risques_niveles = max(risques_faibles + risques_moyens + risques_eleves + risques_critiques_count, 1)
        
        writer.writerow(['Faible', risques_faibles, f'{risques_faibles/total_risques_niveles*100:.1f}%'])
        writer.writerow(['Moyen', risques_moyens, f'{risques_moyens/total_risques_niveles*100:.1f}%'])
        writer.writerow(['√âlev√©', risques_eleves, f'{risques_eleves/total_risques_niveles*100:.1f}%'])
        writer.writerow(['Critique', risques_critiques_count, f'{risques_critiques_count/total_risques_niveles*100:.1f}%'])
        writer.writerow(['TOTAL', total_risques_niveles, '100%'])
        writer.writerow([])
        
        # Section 3: Alertes et recommandations
        writer.writerow(['SECTION 3: ALERTES ET RECOMMANDATIONS'])
        writer.writerow(['Type Alerte', 'Nombre', 'Priorit√©', 'Recommandation'])
        writer.writerow(['Risques Critiques', risques_critiques_count, 'Haute', 
                        'R√©viser et mettre en place des actions correctives imm√©diates'])
        writer.writerow(['KRI en Alerte', kri_alertes, 'Moyenne', 
                        'Analyser les causes et ajuster les seuils si n√©cessaire'])
        writer.writerow(['Actions en Retard', actions_retardees, 'Haute', 
                        'Mettre √† jour les √©ch√©ances et statuts'])
        writer.writerow(['Risques non Couverts', total_risques - risques_avec_kri, 'Moyenne', 
                        'D√©finir des KRI pour les risques sans surveillance'])
        writer.writerow([])
        
        # Section 4: √âvolution
        writer.writerow(['SECTION 4: √âVOLUTION SUR 6 MOIS'])
        writer.writerow(['M√©trique', 'Valeur', 'P√©riode'])
        writer.writerow(['Nouveaux Risques', nouveaux_risques_6_mois, '6 derniers mois'])
        writer.writerow(['Risques Cl√¥tur√©s', risques_clotures_6_mois, '6 derniers mois'])
        writer.writerow(['Taux de Rotation', f'{taux_rotation}%', '6 derniers mois'])
        writer.writerow(['Moyenne Mensuelle', f'{round(total_risques/6, 1)}', 'risques √©valu√©s/mois'])
        writer.writerow([])
        
        # Section 5: Synth√®se
        writer.writerow(['SECTION 5: SYNTH√àSE'])
        writer.writerow(['Aspect', '√âvaluation', 'Commentaire'])
        writer.writerow(['Maturit√© du Syst√®me', 
                        '√âlev√©e' if taux_couverture > 70 else 'Moyenne' if taux_couverture > 40 else 'Faible',
                        f'Couverture KRI: {taux_couverture}%'])
        writer.writerow(['Niveau de Risque Global', 
                        get_niveau_from_score(score_risque_moyen),
                        f'Score moyen: {score_risque_moyen}/25'])
        writer.writerow(['Vigilance Requise', 
                        '√âlev√©e' if risques_critiques_count > 0 or actions_retardees > 5 else 'Moyenne',
                        f'{risques_critiques_count} critiques, {actions_retardees} retards'])
        writer.writerow(['Tendance', 
                        get_tendance_text(score_risque_moyen),
                        get_tendance_text(score_risque_moyen).upper()])
        writer.writerow([])
        
        # Notes
        writer.writerow(['NOTES IMPORTANTES:'])
        writer.writerow(['1. Les donn√©es excluent les √©l√©ments archiv√©s'])
        writer.writerow(['2. Les scores de risque sont sur une √©chelle de 0 √† 25'])
        writer.writerow(['3. La criticit√© est d√©termin√©e par le score: Faible(0-5), Moyen(6-10), √âlev√©(11-15), Critique(16-25)'])
        writer.writerow(['4. Document g√©n√©r√© automatiquement - Syst√®me de Management Int√©gr√©'])
        writer.writerow(['5. Compatible SQLite - Utilisation de strftime pour les dates'])
        
        # Pr√©parer la r√©ponse
        output.seek(0)
        response = Response(
            output.getvalue(),
            mimetype='text/csv; charset=utf-8',
            headers={
                'Content-Disposition': f'attachment; filename=dashboard_analytique_{datetime.now().strftime("%Y%m%d_%H%M")}.csv',
                'Content-Type': 'application/csv'
            }
        )
        
        return response
        
    except Exception as e:
        flash(f'Erreur lors de l\'export CSV: {str(e)}', 'error')
        return redirect(url_for('dashboard'))

# ------------------------------------------------------------
# FONCTIONS UTILITAIRES POUR LE PARAMETRAGE
# ------------------------------------------------------------

def get_parametres_evaluation():
    """R√©cup√®re tous les param√®tres d'√©valuation depuis la base"""
    parametres = {}
    
    try:
        # R√©cup√©rer les param√®tres par cat√©gorie
        categories = ['impact', 'probabilite', 'maitrise']
        
        for categorie in categories:
            params = ParametreEvaluation.query.filter_by(
                categorie=categorie, 
                est_actif=True
            ).order_by('niveau').all()
            
            parametres[categorie] = {
                str(param.niveau): {
                    'nom_court': param.nom_court,
                    'description': param.description_longue or '',
                    'couleur': param.couleur_hex or get_couleur_par_defaut(categorie, param.niveau)
                }
                for param in params
            }
            
        # R√©cup√©rer les sections du guide
        guide_sections = GuideEvaluation.query.filter_by(
            est_actif=True
        ).order_by('ordre').all()
        
        parametres['guide'] = {
            section.section: {
                'titre': section.titre,
                'contenu': section.contenu or ''
            }
            for section in guide_sections
        }
        
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur chargement param√®tres: {e}")
        parametres = get_parametres_par_defaut()
    
    return parametres


def get_parametres_par_defaut():
    """Retourne les param√®tres par d√©faut si la base n'est pas configur√©e"""
    return {
        'impact': {
            '1': {'nom_court': 'N√©gligeable', 'description': 'Impact minime sur les objectifs - Pertes < 1% du CA', 'couleur': '#28a745'},
            '2': {'nom_court': 'Mineur', 'description': 'Impact limit√© - Pertes 1-5% CA - D√©r√®glement op√©rationnel mineur', 'couleur': '#7ebf45'},
            '3': {'nom_court': 'Mod√©r√©', 'description': 'Impact significatif - Pertes 5-10% CA - Atteinte √† la r√©putation', 'couleur': '#ffc107'},
            '4': {'nom_court': 'Important', 'description': 'Impact majeur - Pertes 10-20% CA - Non-conformit√© r√©glementaire', 'couleur': '#fd7e14'},
            '5': {'nom_court': 'Critique', 'description': 'Impact catastrophique - Pertes > 20% CA - Arr√™t d\'activit√© - Sanctions majeures', 'couleur': '#dc3545'}
        },
        'probabilite': {
            '1': {'nom_court': 'Tr√®s rare', 'description': 'Moins d\'une fois tous les 5 ans - Probabilit√© < 5%', 'couleur': '#28a745'},
            '2': {'nom_court': 'Rare', 'description': 'Une fois tous les 1-2 ans - Probabilit√© 5-20%', 'couleur': '#7ebf45'},
            '3': {'nom_court': 'Possible', 'description': 'Plusieurs fois par an - Probabilit√© 20-50%', 'couleur': '#ffc107'},
            '4': {'nom_court': 'Probable', 'description': 'Une fois par mois - Probabilit√© 50-80%', 'couleur': '#fd7e14'},
            '5': {'nom_court': 'Tr√®s probable', 'description': 'Une fois par semaine ou plus - Probabilit√© > 80%', 'couleur': '#dc3545'}
        },
        'maitrise': {
            '1': {'nom_court': 'Insuffisant', 'description': 'Contr√¥les inexistants ou inefficaces - Aucune documentation', 'couleur': '#dc3545'},
            '2': {'nom_court': 'Partiel', 'description': 'Contr√¥les basiques - Couverture limit√©e - Documentation incompl√®te', 'couleur': '#fd7e14'},
            '3': {'nom_court': 'Ad√©quat', 'description': 'Contr√¥les standard - Couverture acceptable - Documentation de base', 'couleur': '#ffc107'},
            '4': {'nom_court': 'Bon', 'description': 'Contr√¥les robustes - Couverture √©tendue - Documentation compl√®te', 'couleur': '#7ebf45'},
            '5': {'nom_court': 'Excellent', 'description': 'Contr√¥les optimis√©s - Couverture compl√®te - Documentation exemplaire', 'couleur': '#28a745'}
        }
    }


def get_couleur_par_defaut(categorie, niveau):
    """Retourne la couleur par d√©faut selon la cat√©gorie et le niveau"""
    couleurs = {
        'impact': ['#28a745', '#7ebf45', '#ffc107', '#fd7e14', '#dc3545'],
        'probabilite': ['#28a745', '#7ebf45', '#ffc107', '#fd7e14', '#dc3545'],
        'maitrise': ['#dc3545', '#fd7e14', '#ffc107', '#7ebf45', '#28a745']  # Invers√©
    }
    
    if categorie in couleurs and 1 <= niveau <= 5:
        return couleurs[categorie][niveau - 1]
    
    return '#28a745'


def init_parametres_par_defaut():
    """Initialise les param√®tres par d√©faut dans la base"""
    try:
        # V√©rifier si des param√®tres existent d√©j√†
        if ParametreEvaluation.query.count() == 0:
            print("üîÑ Initialisation des param√®tres d'√©valuation par d√©faut...")
            
            parametres_defaut = get_parametres_par_defaut()
            
            for categorie, niveaux in parametres_defaut.items():
                for niveau_str, valeurs in niveaux.items():
                    niveau = int(niveau_str)
                    
                    param = ParametreEvaluation(
                        categorie=categorie,
                        niveau=niveau,
                        nom_court=valeurs['nom_court'],
                        description_longue=valeurs['description'],
                        couleur_hex=valeurs['couleur'],
                        ordre=niveau,
                        est_actif=True
                    )
                    db.session.add(param)
            
            # Initialiser le guide
            sections_guide = [
                {
                    'section': 'phase1',
                    'titre': 'Phase 1 - Pr√©-√©valuation',
                    'contenu': '<p><strong>Objectif:</strong> Identification initiale du risque</p><p><strong>Acteur:</strong> R√©f√©rent m√©tier</p><p><strong>Livrable:</strong> Score pr√©liminaire</p>',
                    'ordre': 1
                },
                {
                    'section': 'phase2',
                    'titre': 'Phase 2 - Validation',
                    'contenu': '<p><strong>Objectif:</strong> Validation et ajustement</p><p><strong>Acteur:</strong> Comit√© de validation</p><p><strong>Livrable:</strong> Score valid√©</p>',
                    'ordre': 2
                },
                {
                    'section': 'phase3',
                    'titre': 'Phase 3 - Confirmation',
                    'contenu': '<p><strong>Objectif:</strong> Finalisation et reporting</p><p><strong>Acteur:</strong> √âvaluateur final</p><p><strong>Livrable:</strong> Score d√©finitif</p>',
                    'ordre': 3
                },
                {
                    'section': 'matrice',
                    'titre': 'Matrice des Risques',
                    'contenu': '<table class="table table-sm"><thead><tr><th>Score</th><th>Niveau</th><th>Interpr√©tation</th></tr></thead><tbody><tr><td>1-4</td><td>Faible</td><td>Risque acceptable</td></tr><tr><td>5-10</td><td>Moyen</td><td>Surveillance n√©cessaire</td></tr><tr><td>11-16</td><td>√âlev√©</td><td>Action corrective requise</td></tr><tr><td>17-25</td><td>Critique</td><td>Traitement urgent</td></tr></tbody></table>',
                    'ordre': 4
                }
            ]
            
            for section in sections_guide:
                guide = GuideEvaluation(
                    section=section['section'],
                    titre=section['titre'],
                    contenu=section['contenu'],
                    ordre=section['ordre'],
                    est_actif=True
                )
                db.session.add(guide)
            
            db.session.commit()
            print("‚úÖ Param√®tres d'√©valuation initialis√©s avec succ√®s")
        
        return True
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur initialisation param√®tres: {e}")
        return False

@app.context_processor
def utility_processor():
    def get_file_size(filepath):
        # La m√™me fonction que ci-dessus
        try:
            if os.path.exists(filepath):
                size = os.path.getsize(filepath)
                if size < 1024:
                    return f"{size} B"
                elif size < 1024 * 1024:
                    return f"{size/1024:.1f} KB"
                else:
                    return f"{size/(1024*1024):.1f} MB"
            return "N/A"
        except:
            return "N/A"
    
    return dict(get_file_size=get_file_size)


# ========================
# OPTIMISATIONS PERFORMANCE
# ========================

# Middleware pour les performances
@app.after_request
def add_header(response):
    """Ajouter des headers pour le cache et la s√©curit√©"""
    response.headers['X-Content-Type-Options'] = 'nosniff'
    response.headers['X-Frame-Options'] = 'SAMEORIGIN'
    response.headers['X-XSS-Protection'] = '1; mode=block'
    
    # Cache pour les assets statiques
    if 'Cache-Control' not in response.headers:
        if response.mimetype in ['text/css', 'application/javascript', 'image/', 'font/']:
            response.headers['Cache-Control'] = 'public, max-age=31536000'  # 1 an
        else:
            response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, max-age=0'
    
    return response

# Compression Gzip (si possible)
try:
    from flask_compress import Compress
    compress = Compress(app)
    print("‚úÖ Compression Gzip activ√©e")
except ImportError:
    print("‚ö†Ô∏è Flask-Compress non disponible")


# Endpoint de sant√© pour Render
@app.route('/health')
def health_check():
    """Health check endpoint pour Render"""
    try:
        # V√©rifier la base de donn√©es
        db.session.execute(text('SELECT 1'))
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.utcnow().isoformat(),
            'database': 'connected',
            'version': '1.0.0'
        }), 200
    except Exception as e:
        return jsonify({
            'status': 'unhealthy',
            'error': str(e),
            'timestamp': datetime.utcnow().isoformat()
        }), 500

# ========================
# GESTION DES SESSIONS POUR 1000+ UTILISATEURS
# ========================

# Utiliser Redis pour les sessions si disponible
if os.environ.get('REDIS_URL'):
    try:
        from flask_session import Session
        import redis
        
        app.config['SESSION_TYPE'] = 'redis'
        app.config['SESSION_REDIS'] = redis.from_url(os.environ.get('REDIS_URL'))
        app.config['SESSION_PERMANENT'] = False
        app.config['SESSION_USE_SIGNER'] = True
        app.config['SESSION_KEY_PREFIX'] = 'sess:'
        
        Session(app)
        print("‚úÖ Sessions Redis activ√©es")
    except ImportError:
        print("‚ö†Ô∏è Flask-Session/Redis non disponible, sessions en m√©moire")
else:
    # Sessions en m√©moire avec limite
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = '/tmp/flask_session'
    app.config['SESSION_FILE_THRESHOLD'] = 500  # Nettoyer au-del√† de 500 sessions

# ========================
# OPTIMISATION DES REQU√äTES DATABASE
# ========================

@app.before_request
def before_request():
    """Hook avant chaque requ√™te"""
    g.request_start_time = time.time()

@app.teardown_request
def teardown_request(exception=None):
    """Hook apr√®s chaque requ√™te"""
    if hasattr(g, 'request_start_time'):
        duration = time.time() - g.request_start_time
        if duration > 2:  # Log les requ√™tes lentes (> 2 secondes)
            app.logger.warning(f"Requ√™te lente: {request.path} - {duration:.2f}s")

# ========================
# CLEANUP POUR LONG-RUNNING PROCESS
# ========================

def cleanup_old_sessions():
    """Nettoyer les sessions expir√©es"""
    try:
        # Logique de nettoyage
        pass
    except Exception as e:
        app.logger.error(f"Erreur cleanup sessions: {e}")

def cleanup_temp_files():
    """Nettoyer les fichiers temporaires"""
    try:
        import os
        import glob
        from datetime import datetime, timedelta
        
        temp_dir = '/tmp/flask_uploads'
        if os.path.exists(temp_dir):
            for file in glob.glob(f"{temp_dir}/*"):
                if os.path.getmtime(file) < (time.time() - 3600):  # 1 heure
                    os.remove(file)
    except Exception as e:
        app.logger.error(f"Erreur cleanup fichiers: {e}")

# Schedule cleanup tasks
scheduler = BackgroundScheduler()
scheduler.add_job(cleanup_old_sessions, 'interval', hours=1)
scheduler.add_job(cleanup_temp_files, 'interval', hours=6)
scheduler.start()

# ------------------------------------------------------------
# ROUTES D'ADMINISTRATION
# ------------------------------------------------------------

@app.route('/admin/parametres-evaluation')
@login_required
@admin_required
def admin_parametres_evaluation():
    """Page d'administration des param√®tres d'√©valuation"""
    
    # Initialiser les param√®tres si n√©cessaire
    init_parametres_par_defaut()
    
    # R√©cup√©rer les param√®tres
    parametres_impact = ParametreEvaluation.query.filter_by(categorie='impact').order_by('niveau').all()
    parametres_probabilite = ParametreEvaluation.query.filter_by(categorie='probabilite').order_by('niveau').all()
    parametres_maitrise = ParametreEvaluation.query.filter_by(categorie='maitrise').order_by('ordre').all()
    
    # R√©cup√©rer le guide
    guide_sections = GuideEvaluation.query.order_by('ordre').all()
    
    # Pour l'instant, on utilise des couleurs par d√©faut
    couleurs_matrise = {
        'faible': '#28a745',
        'moyen': '#ffc107',
        'eleve': '#fd7e14',
        'critique': '#dc3545'
    }
    
    couleurs_phases = {
        'phase1': '#007bff',
        'phase2': '#ffc107',
        'phase3': '#28a745'
    }
    
    return render_template('admin/parametres_evaluation.html',
                         parametres_impact=parametres_impact,
                         parametres_probabilite=parametres_probabilite,
                         parametres_maitrise=parametres_maitrise,
                         guide_sections=guide_sections,
                         couleurs_matrise=couleurs_matrise,
                         couleurs_phases=couleurs_phases)


@app.route('/admin/save-parametres', methods=['POST'])
@csrf.exempt
@login_required
@admin_required
def admin_save_parametres():
    """Sauvegarde les param√®tres d'√©valuation"""
    
    categorie = request.form.get('categorie')
    
    try:
        # R√©cup√©rer tous les param√®tres de cette cat√©gorie
        parametres = ParametreEvaluation.query.filter_by(categorie=categorie).all()
        
        for param in parametres:
            param_id = str(param.id)
            
            # Mettre √† jour les champs
            param.nom_court = request.form.get(f'nom_court_{param_id}', param.nom_court)
            param.description_longue = request.form.get(f'description_{param_id}', '')
            param.couleur_hex = request.form.get(f'couleur_{param_id}', param.couleur_hex)
            param.est_actif = bool(request.form.get(f'actif_{param_id}'))
            
            if categorie == 'maitrise':
                param.ordre = int(request.form.get(f'ordre_{param_id}', param.ordre))
            
            param.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        # Invalider le cache des param√®tres
        app.config['PARAMETRES_CACHE'] = None
        
        flash(f'‚úÖ Param√®tres {categorie} mis √† jour avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur lors de la sauvegarde: {str(e)}', 'error')
    
    return redirect(url_for('admin_parametres_evaluation', _anchor=f'{categorie}-tab'))


@app.route('/admin/save-guide', methods=['POST'])
@csrf.exempt
@login_required
@admin_required
def admin_save_guide():
    """Sauvegarde le guide d'√©valuation"""
    
    try:
        # R√©cup√©rer toutes les sections du guide
        sections = GuideEvaluation.query.all()
        
        for section in sections:
            section_id = str(section.id)
            
            # Mettre √† jour les champs
            section.titre = request.form.get(f'titre_{section_id}', section.titre)
            section.contenu = request.form.get(f'contenu_{section_id}', '')
            section.est_actif = bool(request.form.get(f'actif_{section_id}'))
            section.ordre = int(request.form.get(f'ordre_{section_id}', section.ordre))
            section.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        # Invalider le cache
        app.config['PARAMETRES_CACHE'] = None
        
        flash('‚úÖ Guide d\'√©valuation mis √† jour avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur lors de la sauvegarde: {str(e)}', 'error')
    
    return redirect(url_for('admin_parametres_evaluation', _anchor='guide-tab'))



@app.route('/admin/save-couleurs', methods=['POST'])
@csrf.exempt
@login_required
@admin_required
def admin_save_couleurs():
    """Sauvegarde les couleurs personnalis√©es"""
    
    try:
        # Pour l'instant, on pourrait stocker dans une table d√©di√©e ou en configuration
        # Ici, on montre le concept, √† adapter selon vos besoins
        
        couleurs = {
            'matrice_faible': request.form.get('couleur_faible'),
            'matrice_moyen': request.form.get('couleur_moyen'),
            'matrice_eleve': request.form.get('couleur_eleve'),
            'matrice_critique': request.form.get('couleur_critique'),
            'phase1': request.form.get('couleur_phase1'),
            'phase2': request.form.get('couleur_phase2'),
            'phase3': request.form.get('couleur_phase3'),
        }
        
        # Vous pourriez stocker dans une table Configuration
        # Pour l'exemple, on utilise un cache en session
        session['couleurs_personnalisees'] = couleurs
        
        flash('‚úÖ Couleurs personnalis√©es sauvegard√©es avec succ√®s', 'success')
        
    except Exception as e:
        flash(f'‚ùå Erreur lors de la sauvegarde: {str(e)}', 'error')
    
    return redirect(url_for('admin_parametres_evaluation', _anchor='couleurs-tab'))


# ------------------------------------------------------------
# FONCTIONS POUR LE TEMPLATE D'√âVALUATION
# ------------------------------------------------------------
# Routes pour la gestion des templates de permissions
# ========================
# ROUTES POUR TEMPLATES DE PERMISSIONS
# ========================

# Ajouter apr√®s les imports
@app.template_filter('split')
def split_filter(s, delimiter=' '):
    """Filtre pour splitter une cha√Æne de caract√®res"""
    return s.split(delimiter)

@app.template_filter('last')
def last_filter(lst):
    """Retourne le dernier √©l√©ment d'une liste"""
    if lst and hasattr(lst, '__len__'):
        return lst[-1] if len(lst) > 0 else ''
    return ''# Ajouter apr√®s les imports
@app.template_filter('split')
def split_filter(s, delimiter=' '):
    """Filtre pour splitter une cha√Æne de caract√®res"""
    return s.split(delimiter)

@app.template_filter('last')
def last_filter(lst):
    """Retourne le dernier √©l√©ment d'une liste"""
    if lst and hasattr(lst, '__len__'):
        return lst[-1] if len(lst) > 0 else ''
    return ''

@app.route('/admin/templates-permissions')
@login_required
@csrf.exempt
@admin_required
def admin_templates_permissions():
    """Page de gestion des templates de permissions"""
    templates = PermissionTemplate.query.order_by(PermissionTemplate.name).all()
    return render_template('admin/templates_permissions.html', templates=templates)

@app.route('/admin/template/nouveau', methods=['GET', 'POST'])
@login_required
@admin_required
def admin_nouveau_template():
    """Cr√©er un nouveau template de permissions"""
    form = PermissionTemplateForm()
    
    # D√©finir les choices pour le champ role AVANT la validation
    form.role.choices = [
        ('admin', 'Administrateur'),
        ('manager', 'Manager'),
        ('utilisateur', 'Utilisateur standard'),
        ('auditeur', 'Auditeur'),
        ('compliance', 'Responsable Conformit√©'),
        ('risk_manager', 'Risk Manager'),
        ('referent', 'R√©f√©rent m√©tier'),
        ('viewer', 'Consultant (lecture seule)'),
        ('super_admin', 'Super Administrateur')
    ]
    
    if form.validate_on_submit():
        try:
            # Cr√©er le template AVEC TOUTES LES PERMISSIONS en structure plate
            template = PermissionTemplate(
                name=form.name.data,
                description=form.description.data,
                role=form.role.data,
                client_id=current_user.client_id if current_user.role != 'super_admin' else None,
                permissions={
                    # Permissions de base
                    'can_view_dashboard': form.can_view_dashboard.data,
                    'can_view_reports': form.can_view_reports.data,
                    'can_export_data': form.can_export_data.data,
                    
                    # Gestion des donn√©es
                    'can_manage_risks': form.can_manage_risks.data,
                    'can_manage_kri': form.can_manage_kri.data,
                    'can_manage_audit': form.can_manage_audit.data,
                    'can_manage_regulatory': form.can_manage_regulatory.data,
                    'can_manage_logigram': form.can_manage_logigram.data,
                    
                    # Administration
                    'can_manage_users': form.can_manage_users.data,
                    'can_manage_settings': form.can_manage_settings.data,
                    'can_manage_permissions': form.can_manage_permissions.data,
                    
                    # Permissions avanc√©es
                    'can_delete_data': form.can_delete_data.data,
                    'can_archive_data': form.can_archive_data.data,
                    'can_validate_risks': form.can_validate_risks.data,
                    'can_confirm_evaluations': form.can_confirm_evaluations.data,
                    
                    # Nouvelles permissions
                    'can_view_departments': form.can_view_departments.data,
                    'can_manage_departments': form.can_manage_departments.data,
                    'can_view_users_list': form.can_view_users_list.data,
                    'can_edit_users': form.can_edit_users.data,
                    'can_access_all_departments': form.can_access_all_departments.data,
                    'can_manage_clients': form.can_manage_clients.data,
                    'can_provision_servers': form.can_provision_servers.data
                }
            )
            
            db.session.add(template)
            db.session.commit()
            
            # Journaliser l'action
            log_activity(current_user.id, 'creation', 
                        f"Cr√©ation template permissions {template.name}",
                        'template_permissions', template.id)
            
            flash(f'‚úÖ Template {template.name} cr√©√© avec succ√®s', 'success')
            return redirect(url_for('admin_templates_permissions'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'‚ùå Erreur lors de la cr√©ation: {str(e)}', 'error')
    
    return render_template('admin/nouveau_template.html', form=form)


@app.route('/admin/template/<int:id>/editer', methods=['GET', 'POST'])
@login_required
@admin_required
def admin_editer_template(id):
    """√âditer un template de permissions"""
    template = PermissionTemplate.query.get_or_404(id)
    
    # V√©rifier l'acc√®s au client (sauf super admin)
    if current_user.role != 'super_admin' and template.client_id != current_user.client_id:
        flash('Acc√®s non autoris√© √† ce template', 'error')
        return redirect(url_for('admin_dashboard'))
    
    from forms_admin import PermissionTemplateForm
    form = PermissionTemplateForm(obj=template)
    
    if form.validate_on_submit():
        try:
            # Mettre √† jour les champs
            template.name = form.name.data
            template.description = form.description.data
            template.role = form.role.data
            
            # Collecter toutes les permissions
            template.permissions = {
                # Permissions de base
                'can_view_dashboard': form.can_view_dashboard.data,
                'can_view_reports': form.can_view_reports.data,
                'can_export_data': form.can_export_data.data,
                
                # Gestion des donn√©es
                'can_manage_risks': form.can_manage_risks.data,
                'can_manage_kri': form.can_manage_kri.data,
                'can_manage_audit': form.can_manage_audit.data,
                'can_manage_regulatory': form.can_manage_regulatory.data,
                'can_manage_logigram': form.can_manage_logigram.data,
                
                # Administration
                'can_manage_users': form.can_manage_users.data,
                'can_manage_settings': form.can_manage_settings.data,
                'can_manage_permissions': form.can_manage_permissions.data,
                
                # Permissions avanc√©es
                'can_delete_data': form.can_delete_data.data,
                'can_archive_data': form.can_archive_data.data,
                'can_validate_risks': form.can_validate_risks.data,
                'can_confirm_evaluations': form.can_confirm_evaluations.data,
                
                # Nouvelles permissions
                'can_view_departments': form.can_view_departments.data,
                'can_manage_departments': form.can_manage_departments.data,
                'can_view_users_list': form.can_view_users_list.data,
                'can_edit_users': form.can_edit_users.data,
                'can_access_all_departments': form.can_access_all_departments.data,
                'can_manage_clients': form.can_manage_clients.data,
                'can_provision_servers': form.can_provision_servers.data
            }
            
            template.updated_at = datetime.utcnow()
            db.session.commit()
            
            flash('Template mis √† jour avec succ√®s', 'success')
            return redirect(url_for('admin_template_permissions'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur: {str(e)}', 'error')
    
    return render_template('admin/editer_template.html', form=form, template=template)


@app.route('/export/dashboard/<format>')
@login_required
def export_dashboard_format(format):
    """Export avec choix de format"""
    if format.lower() == 'csv':
        return export_dashboard_csv()
    else:
        return export_dashboard()  # PDF par d√©faut

@app.route('/admin/template/<int:id>/supprimer')
@login_required
@admin_required
def admin_supprimer_template(id):
    """Supprimer un template de permissions"""
    template = PermissionTemplate.query.get_or_404(id)
    
    try:
        log_activity(current_user.id, 'suppression',
                    f"Suppression template permissions {template.name}",
                    'template_permissions', template.id)
        
        db.session.delete(template)
        db.session.commit()
        
        flash('Template supprim√© avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la suppression: {str(e)}', 'error')
    
    return redirect(url_for('admin_templates_permissions'))





# ========================
# ROUTES POUR NOTIFICATIONS (√Ä IMPL√âMENTER)
# ========================

@app.route('/admin/notifications')
@login_required
@admin_required
def admin_notifications():
    """Page des notifications syst√®me"""
    notifications = Notification.query.filter_by(user_id=current_user.id).order_by(
        Notification.created_at.desc()
    ).limit(50).all()
    
    # Marquer comme lues
    for notification in notifications:
        if not notification.is_read:
            notification.is_read = True
    db.session.commit()
    
    return render_template('admin/notifications.html', notifications=notifications)


@app.route('/admin/logs-systeme')
@login_required
@admin_required
def admin_logs_systeme():
    """Page des logs syst√®me"""
    logs = SystemLog.query.order_by(SystemLog.created_at.desc()).limit(100).all()
    return render_template('admin/logs_systeme.html', logs=logs)


@app.route('/admin/sessions-utilisateurs')
@login_required
@admin_required
def admin_sessions_utilisateurs():
    """Page des sessions utilisateurs"""
    sessions = UserSession.query.order_by(UserSession.login_time.desc()).limit(50).all()
    return render_template('admin/sessions_utilisateurs.html', sessions=sessions)
# ------------------------------------------------------------
# FONCTIONS POUR LE PARAM√âTRAGE (AJOUTEZ √Ä VOTRE app.py)
# ------------------------------------------------------------

def get_niveau_description(categorie, niveau):
    """Retourne la description d'un niveau sp√©cifique"""
    try:
        param = ParametreEvaluation.query.filter_by(
            categorie=categorie, 
            niveau=niveau,
            est_actif=True
        ).first()
        
        if param and param.description_longue:
            return param.description_longue
    except:
        pass
    
    # Valeurs par d√©faut
    defaults = {
        'impact': {
            1: "Impact minime sur les objectifs - Pertes < 1% du CA",
            2: "Impact limit√© sur les objectifs - Pertes 1-5% CA",
            3: "Impact significatif sur les objectifs - Pertes 5-10% CA",
            4: "Impact majeur sur les objectifs - Pertes 10-20% CA",
            5: "Impact catastrophique sur les objectifs - Pertes > 20% CA"
        },
        'probabilite': {
            1: "Moins d'une fois tous les 5 ans - Probabilit√© < 5%",
            2: "Une fois tous les 1-2 ans - Probabilit√© 5-20%",
            3: "Plusieurs fois par an - Probabilit√© 20-50%",
            4: "Une fois par mois - Probabilit√© 50-80%",
            5: "Une fois par semaine ou plus - Probabilit√© > 80%"
        },
        'maitrise': {
            1: "Contr√¥les inexistants ou inefficaces - Aucune documentation",
            2: "Contr√¥les basiques - Couverture limit√©e - Documentation incompl√®te",
            3: "Contr√¥les standard - Couverture acceptable - Documentation de base",
            4: "Contr√¥les robustes - Couverture √©tendue - Documentation compl√®te",
            5: "Contr√¥les optimis√©s - Couverture compl√®te - Documentation exemplaire"
        }
    }
    
    return defaults.get(categorie, {}).get(niveau, "Description non disponible")


def get_niveau_nom_court(categorie, niveau):
    """Retourne le nom court d'un niveau"""
    try:
        param = ParametreEvaluation.query.filter_by(
            categorie=categorie, 
            niveau=niveau,
            est_actif=True
        ).first()
        
        if param:
            return param.nom_court
    except:
        pass
    
    # Valeurs par d√©faut
    defaults = {
        'impact': {1: 'N√©gligeable', 2: 'Mineur', 3: 'Mod√©r√©', 4: 'Important', 5: 'Critique'},
        'probabilite': {1: 'Tr√®s rare', 2: 'Rare', 3: 'Possible', 4: 'Probable', 5: 'Tr√®s probable'},
        'maitrise': {1: 'Insuffisant', 2: 'Partiel', 3: 'Ad√©quat', 4: 'Bon', 5: 'Excellent'}
    }
    
    return defaults.get(categorie, {}).get(niveau, f"Niveau {niveau}")


def get_niveau_couleur(categorie, niveau):
    """Retourne la couleur d'un niveau"""
    try:
        param = ParametreEvaluation.query.filter_by(
            categorie=categorie, 
            niveau=niveau,
            est_actif=True
        ).first()
        
        if param and param.couleur_hex:
            return param.couleur_hex
    except:
        pass
    
    # Couleurs par d√©faut (vert au rouge)
    couleurs = {
        'impact': ['#28a745', '#7ebf45', '#ffc107', '#fd7e14', '#dc3545'],
        'probabilite': ['#28a745', '#7ebf45', '#ffc107', '#fd7e14', '#dc3545'],
        'maitrise': ['#dc3545', '#fd7e14', '#ffc107', '#7ebf45', '#28a745'],  # Invers√©
        'phase': {
            'phase1': '#007bff',
            'phase2': '#ffc107', 
            'phase3': '#28a745'
        }
    }
    
    if categorie == 'phase' and niveau in couleurs['phase']:
        return couleurs['phase'][niveau]
    
    if categorie in couleurs and 1 <= niveau <= 5:
        return couleurs[categorie][niveau - 1]
    
    return '#28a745'


def get_parametres_evaluation():
    """Retourne tous les param√®tres d'√©valuation"""
    return {
        'maitrise_inverse': True  # Pour l'inversion des couleurs de ma√Ætrise
    }


# ------------------------------------------------------------
# AJOUTEZ CES LIGNES √Ä LA FIN DE VOTRE app.py
# ------------------------------------------------------------

app.jinja_env.globals['get_niveau_description'] = get_niveau_description
app.jinja_env.globals['get_niveau_nom_court'] = get_niveau_nom_court
app.jinja_env.globals['get_niveau_couleur'] = get_niveau_couleur
app.jinja_env.globals['get_parametres_evaluation'] = get_parametres_evaluation

# Route archivage risque
@app.route('/risque/<int:id>/archiver', methods=['POST'])
@login_required
def archiver_risque(id):
    """Archiver un risque"""
    risque = Risque.query.get_or_404(id)
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_risks') or 
            risque.created_by == current_user.id):
        flash('Vous n\'√™tes pas autoris√© √† archiver ce risque', 'error')
        return redirect(url_for('detail_cartographie', id=risque.cartographie_id))
    
    # Formulaire d'archivage
    form = ArchiveRisqueForm()
    
    if request.method == 'POST':
        # Si un formulaire est soumis avec une raison
        if form.reason.data:
            raison = form.reason.data
        else:
            raison = 'Archivage manuel'
        
        # Archiver le risque
        risque.is_archived = True
        risque.archived_at = datetime.utcnow()
        risque.archived_by = current_user.id
        risque.archive_reason = raison
        
        db.session.commit()
        
        # üî• SYNCHRONISATION AUTOMATIQUE
        synchroniser_cartographie_apres_action(risque.cartographie_id, 'archivage_risque', current_user.id)
        declencher_mise_a_jour_risque(id, 'archivage', current_user.id, raison)
        
        flash('Risque archiv√© avec succ√®s', 'success')
        return redirect(url_for('detail_cartographie', id=risque.cartographie_id))
    
    # Si GET, afficher le formulaire
    return render_template('cartographie/archiver_risque.html', form=form, risque=risque)



@app.route('/export/risques-excel/<int:cartographie_id>')
@login_required
def export_risques_excel(cartographie_id):
    """Export Excel complet des risques d'une cartographie - Version sans pandas"""
    try:
        from openpyxl import Workbook
        from openpyxl.styles import PatternFill, Font, Alignment, Border, Side
        import io
        from datetime import datetime
        
        # R√©cup√©rer la cartographie
        cartographie = Cartographie.query.get_or_404(cartographie_id)
        
        # R√©cup√©rer tous les risques NON ARCHIV√âS
        risques = Risque.query.filter_by(
            cartographie_id=cartographie_id,
            is_archived=False
        ).all()
        
        # Cr√©er un workbook
        wb = Workbook()
        
        # Supprimer la feuille par d√©faut
        wb.remove(wb.active)
        
        # ============================================================================
        # FEUILLE 1 : D√âTAIL COMPLET DES RISQUES
        # ============================================================================
        ws_detail = wb.create_sheet("D√©tail Risques")
        
        # Titre principal
        ws_detail.merge_cells('A1:X1')
        ws_detail['A1'] = f"CARTOGRAPHIE DES RISQUES - {cartographie.nom.upper()}"
        ws_detail['A1'].font = Font(size=14, bold=True, color="FFFFFF")
        ws_detail['A1'].fill = PatternFill(start_color="2C3E50", end_color="2C3E50", fill_type="solid")
        ws_detail['A1'].alignment = Alignment(horizontal='center', vertical='center')
        
        # Informations de la cartographie
        ws_detail['A2'] = f"Direction : {cartographie.direction.nom if cartographie.direction else 'Non sp√©cifi√©e'}"
        ws_detail['A3'] = f"Service : {cartographie.service.nom if cartographie.service else 'Non sp√©cifi√©'}"
        ws_detail['A4'] = f"Date d'export : {datetime.now().strftime('%d/%m/%Y √† %H:%M')}"
        ws_detail['A5'] = f"Nombre de risques : {len(risques)}"
        
        # En-t√™tes d√©taill√©s (commencer √† la ligne 7)
        headers = [
            'R√©f√©rence', 'Intitul√©', 'Description', 'Cat√©gorie', 'Type de risque',
            'Processus concern√©', 'Cause racine', 'Cons√©quences',
            'Date cr√©ation', 'Cr√©√© par',
            # √âvaluation
            'Impact', 'Probabilit√©', 'Niveau de ma√Ætrise', 'Score', 'Niveau de risque',
            'Date derni√®re √©valuation', '√âvaluateur', 'Commentaire √©valuation',
            # Informations compl√©mentaires
            'KRI associ√©', 'Derni√®re mesure KRI', 'Statut KRI',
            'Priorit√©', 'Co√ªt estim√©', 'Date √©ch√©ance'
        ]
        
        # Ajouter les en-t√™tes
        for col, header in enumerate(headers, 1):
            cell = ws_detail.cell(row=7, column=col)
            cell.value = header
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="34495E", end_color="34495E", fill_type="solid")
            cell.alignment = Alignment(horizontal='center')
            cell.border = Border(bottom=Side(style='thin'))
        
        # Couleurs pour les niveaux de risque
        couleur_faible = PatternFill(start_color="27AE60", end_color="27AE60", fill_type="solid")  # Vert
        couleur_moyen = PatternFill(start_color="F39C12", end_color="F39C12", fill_type="solid")   # Orange
        couleur_eleve = PatternFill(start_color="E74C3C", end_color="E74C3C", fill_type="solid")   # Rouge
        couleur_critique = PatternFill(start_color="8B0000", end_color="8B0000", fill_type="solid") # Rouge fonc√©
        couleur_non_evalue = PatternFill(start_color="95A5A6", end_color="95A5A6", fill_type="solid") # Gris
        
        # Remplir les donn√©es (commencer √† la ligne 8)
        for row_idx, risque in enumerate(risques, 8):
            # ========== INFORMATIONS DE BASE ==========
            data_row = [
                risque.reference,
                risque.intitule,
                risque.description or '',
                risque.categorie or '',
                risque.type_risque or '',
                risque.processus_concerne or '',
                risque.cause_racine or '',
                risque.consequences or '',
                risque.created_at.strftime('%d/%m/%Y') if risque.created_at else '',
                risque.createur.username if risque.createur else ''
            ]
            
            # ========== √âVALUATION ==========
            # R√©cup√©rer la derni√®re √©valuation
            derniere_eval = EvaluationRisque.query.filter_by(
                risque_id=risque.id
            ).order_by(EvaluationRisque.created_at.desc()).first()
            
            if derniere_eval:
                # Calcul des valeurs finales selon la hi√©rarchie triphas√©e
                impact_final = (
                    derniere_eval.impact_conf 
                    if derniere_eval.impact_conf and derniere_eval.impact_conf > 0 
                    else derniere_eval.impact_val 
                    if derniere_eval.impact_val and derniere_eval.impact_val > 0 
                    else derniere_eval.impact_pre
                )
                
                probabilite_final = (
                    derniere_eval.probabilite_conf 
                    if derniere_eval.probabilite_conf and derniere_eval.probabilite_conf > 0 
                    else derniere_eval.probabilite_val 
                    if derniere_eval.probabilite_val and derniere_eval.probabilite_val > 0 
                    else derniere_eval.probabilite_pre
                )
                
                niveau_maitrise_final = (
                    derniere_eval.niveau_maitrise_conf 
                    if derniere_eval.niveau_maitrise_conf and derniere_eval.niveau_maitrise_conf > 0 
                    else derniere_eval.niveau_maitrise_val 
                    if derniere_eval.niveau_maitrise_val and derniere_eval.niveau_maitrise_val > 0 
                    else derniere_eval.niveau_maitrise_pre
                )
                
                # Calculer le score et niveau de risque
                if impact_final and probabilite_final:
                    score_final = impact_final * probabilite_final
                    niveau_final = calculer_niveau_risque(impact_final, probabilite_final)[0]
                else:
                    score_final = None
                    niveau_final = "√Ä √©valuer"
                
                # Compl√©ter les donn√©es d'√©valuation
                data_row.extend([
                    impact_final or "√Ä √©valuer",
                    probabilite_final or "√Ä √©valuer",
                    niveau_maitrise_final or "√Ä √©valuer",
                    score_final or "√Ä √©valuer",
                    niveau_final,
                    derniere_eval.created_at.strftime('%d/%m/%Y') if derniere_eval.created_at else '',
                    derniere_eval.evaluateur_final.username if derniere_eval.evaluateur_final else 
                        (derniere_eval.validateur.username if derniere_eval.validateur else 
                        (derniere_eval.referent_pre_evaluation.username if derniere_eval.referent_pre_evaluation else '')),
                    derniere_eval.commentaire_confirmation or 
                        derniere_eval.commentaire_validation or 
                        derniere_eval.commentaire_pre_evaluation or ''
                ])
            else:
                # Pas d'√©valuation
                data_row.extend([
                    "√Ä √©valuer", "√Ä √©valuer", "√Ä √©valuer", "√Ä √©valuer", "√Ä √©valuer",
                    "", "", ""
                ])
            
            # ========== KRI ASSOCI√â ==========
            kri = KRI.query.filter_by(risque_id=risque.id, est_actif=True).first()
            if kri:
                derniere_mesure = MesureKRI.query.filter_by(
                    kri_id=kri.id
                ).order_by(MesureKRI.date_mesure.desc()).first()
                
                data_row.extend([
                    kri.nom,
                    f"{derniere_mesure.valeur} {kri.unite_mesure}" if derniere_mesure else "Pas de mesure",
                    "Actif"
                ])
            else:
                data_row.extend(["", "", ""])
            
            # ========== CHAMPS PERSONNALIS√âS ==========
            # R√©cup√©rer les champs personnalis√©s
            champs_personnalises = {}
            for champ in risque.champs_personnalises:
                champs_personnalises[champ.nom_technique] = champ.get_valeur()
            
            # Ajouter les champs personnalis√©s sp√©cifiques
            data_row.extend([
                champs_personnalises.get('priorite', ''),
                champs_personnalises.get('cout_estime', ''),
                champs_personnalises.get('date_echeance', '') 
                if champs_personnalises.get('date_echeance') 
                else ''
            ])
            
            # ========== AJOUTER LA LIGNE AU WORKSHEET ==========
            for col, value in enumerate(data_row, 1):
                cell = ws_detail.cell(row=row_idx, column=col)
                cell.value = value
                
                # Mise en forme conditionnelle pour le niveau de risque (colonne O)
                if col == 15:  # Colonne "Niveau de risque"
                    if value == 'Faible':
                        cell.fill = couleur_faible
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif value == 'Moyen':
                        cell.fill = couleur_moyen
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif value == '√âlev√©':
                        cell.fill = couleur_eleve
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif value == 'Critique':
                        cell.fill = couleur_critique
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif value == '√Ä √©valuer' or value == 'Non √©valu√©':
                        cell.fill = couleur_non_evalue
                        cell.font = Font(color="FFFFFF", bold=True)
                        cell.value = "√Ä √âVALUER"
                    cell.alignment = Alignment(horizontal='center')
                
                # Centrer les scores et valeurs num√©riques
                if col in [11, 12, 13, 14]:  # Impact, Probabilit√©, Ma√Ætrise, Score
                    if isinstance(value, (int, float)):
                        cell.alignment = Alignment(horizontal='center')
                    elif value == "√Ä √©valuer":
                        cell.font = Font(color="FF0000", italic=True)
                        cell.alignment = Alignment(horizontal='center')
                
                # Mise en forme pour les champs manquants
                if value == "√Ä √©valuer":
                    cell.fill = PatternFill(start_color="FFEAA7", end_color="FFEAA7", fill_type="solid")
        
        # Ajuster les largeurs de colonnes
        column_widths = [15, 40, 50, 15, 15, 20, 30, 30, 12, 15, 
                        10, 12, 12, 10, 15, 12, 15, 30, 20, 15, 12, 12, 15, 12]
        for col, width in enumerate(column_widths, 1):
            ws_detail.column_dimensions[chr(64 + col)].width = width
        
        # ============================================================================
        # FEUILLE 2 : RISQUES √Ä √âVALUER
        # ============================================================================
        ws_a_evaluer = wb.create_sheet("Risques √† √©valuer")
        
        ws_a_evaluer.merge_cells('A1:F1')
        ws_a_evaluer['A1'] = "RISQUES √Ä √âVALUER"
        ws_a_evaluer['A1'].font = Font(size=14, bold=True, color="FFFFFF")
        ws_a_evaluer['A1'].fill = PatternFill(start_color="FF6B6B", end_color="FF6B6B", fill_type="solid")
        ws_a_evaluer['A1'].alignment = Alignment(horizontal='center')
        
        # Informations de la cartographie
        ws_a_evaluer['A2'] = f"Cartographie : {cartographie.nom}"
        ws_a_evaluer['A3'] = f"Nombre total de risques : {len(risques)}"
        
        # En-t√™tes (ligne 5)
        headers_a_evaluer = ['R√©f√©rence', 'Intitul√©', 'Cat√©gorie', 'Date cr√©ation', 'Cr√©√© par', 'Derni√®re √©valuation']
        for col, header in enumerate(headers_a_evaluer, 1):
            cell = ws_a_evaluer.cell(row=5, column=col)
            cell.value = header
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="E74C3C", end_color="E74C3C", fill_type="solid")
            cell.alignment = Alignment(horizontal='center')
        
        # R√©cup√©rer les risques sans √©valuation ou avec √©valuation incompl√®te
        risques_a_evaluer = []
        for risque in risques:
            derniere_eval = EvaluationRisque.query.filter_by(
                risque_id=risque.id
            ).order_by(EvaluationRisque.created_at.desc()).first()
            
            doit_etre_evalue = False
            
            if not derniere_eval:
                doit_etre_evalue = True
            else:
                # V√©rifier si l'√©valuation est incompl√®te
                impact_final = (
                    derniere_eval.impact_conf or 
                    derniere_eval.impact_val or 
                    derniere_eval.impact_pre
                )
                probabilite_final = (
                    derniere_eval.probabilite_conf or 
                    derniere_eval.probabilite_val or 
                    derniere_eval.probabilite_pre
                )
                
                if not impact_final or not probabilite_final:
                    doit_etre_evalue = True
            
            if doit_etre_evalue:
                risques_a_evaluer.append({
                    'risque': risque,
                    'derniere_eval': derniere_eval,
                    'motif': "Pas d'√©valuation" if not derniere_eval else "√âvaluation incompl√®te"
                })
        
        # Ajouter les risques √† √©valuer (ligne 6)
        for row_idx, item in enumerate(risques_a_evaluer, 6):
            data = [
                item['risque'].reference,
                item['risque'].intitule,
                item['risque'].categorie or '',
                item['risque'].created_at.strftime('%d/%m/%Y') if item['risque'].created_at else '',
                item['risque'].createur.username if item['risque'].createur else '',
                item['derniere_eval'].created_at.strftime('%d/%m/%Y') if item['derniere_eval'] else 'Jamais'
            ]
            
            for col, value in enumerate(data, 1):
                cell = ws_a_evaluer.cell(row=row_idx, column=col)
                cell.value = value
                
                # Mettre en √©vidence
                cell.fill = PatternFill(start_color="FFEAA7", end_color="FFEAA7", fill_type="solid")
                if col == 6 and value == 'Jamais':
                    cell.font = Font(color="E74C3C", bold=True)
        
        if not risques_a_evaluer:
            cell = ws_a_evaluer.cell(row=6, column=1)
            cell.value = "‚úÖ Tous les risques sont √† jour !"
            cell.font = Font(color="27AE60", bold=True)
            ws_a_evaluer.merge_cells('A6:F6')
            cell.alignment = Alignment(horizontal='center')
        
        # Ajuster les largeurs
        for col in range(1, 7):
            ws_a_evaluer.column_dimensions[chr(64 + col)].width = 20
        
        # ============================================================================
        # FEUILLE 3 : TABLEAU DE BORDEAUX
        # ============================================================================
        ws_bordeaux = wb.create_sheet("Tableau de Bordeaux")
        
        ws_bordeaux.merge_cells('A1:D1')
        ws_bordeaux['A1'] = "TABLEAU DE BORDEAUX - CLASSEMENT DES RISQUES"
        ws_bordeaux['A1'].font = Font(size=14, bold=True, color="FFFFFF")
        ws_bordeaux['A1'].fill = PatternFill(start_color="2C3E50", end_color="2C3E50", fill_type="solid")
        ws_bordeaux['A1'].alignment = Alignment(horizontal='center')
        
        # Informations de la cartographie
        ws_bordeaux['A2'] = f"Cartographie : {cartographie.nom}"
        
        # Cat√©gories du tableau de Bordeaux (ligne 4)
        categories = [
            ('ACTIONS PRIORITAIRES (Critiques)', couleur_critique),
            ('SURVEILLANCE RENFORC√âE (√âlev√©s)', couleur_eleve),
            ('SURVEILLANCE COURANTE (Moyens)', couleur_moyen),
            ('ACTIONS LIMIT√âES (Faibles)', couleur_faible)
        ]
        
        row_start = 4
        for cat_index, (categorie, couleur) in enumerate(categories):
            # En-t√™te de cat√©gorie
            ws_bordeaux.merge_cells(f'A{row_start}:D{row_start}')
            cell = ws_bordeaux.cell(row=row_start, column=1)
            cell.value = categorie
            cell.fill = couleur
            cell.font = Font(color="FFFFFF", bold=True)
            cell.alignment = Alignment(horizontal='center')
            
            # Sous-en-t√™tes (ligne suivante)
            headers_bordeaux = ['R√©f√©rence', 'Intitul√©', 'Score', 'Niveau']
            for col, header in enumerate(headers_bordeaux, 1):
                cell = ws_bordeaux.cell(row=row_start + 1, column=col)
                cell.value = header
                cell.font = Font(bold=True)
                cell.fill = PatternFill(start_color="ECF0F1", end_color="ECF0F1", fill_type="solid")
            
            # R√©cup√©rer les risques par niveau
            niveau = categorie.split('(')[1].replace(')', '').strip()
            risques_niveau = []
            
            for risque in risques:
                derniere_eval = EvaluationRisque.query.filter_by(
                    risque_id=risque.id
                ).order_by(EvaluationRisque.created_at.desc()).first()
                
                if derniere_eval and derniere_eval.niveau_risque == niveau:
                    risques_niveau.append({
                        'risque': risque,
                        'evaluation': derniere_eval
                    })
            
            # Trier par score d√©croissant
            risques_niveau.sort(key=lambda x: x['evaluation'].score_risque or 0, reverse=True)
            
            # Ajouter les risques (ligne suivante)
            for risk_idx, item in enumerate(risques_niveau, row_start + 2):
                data_risk = [
                    item['risque'].reference,
                    item['risque'].intitule[:50] + "..." if len(item['risque'].intitule) > 50 else item['risque'].intitule,
                    item['evaluation'].score_risque or 0,
                    item['evaluation'].niveau_risque or 'Non √©valu√©'
                ]
                
                for col, value in enumerate(data_risk, 1):
                    cell = ws_bordeaux.cell(row=risk_idx, column=col)
                    cell.value = value
                    
                    # Appliquer la couleur pour la colonne niveau
                    if col == 4:
                        if value == 'Faible':
                            cell.fill = couleur_faible
                            cell.font = Font(color="FFFFFF", bold=True)
                        elif value == 'Moyen':
                            cell.fill = couleur_moyen
                            cell.font = Font(color="FFFFFF", bold=True)
                        elif value == '√âlev√©':
                            cell.fill = couleur_eleve
                            cell.font = Font(color="FFFFFF", bold=True)
                        elif value == 'Critique':
                            cell.fill = couleur_critique
                            cell.font = Font(color="FFFFFF", bold=True)
            
            if not risques_niveau:
                # Aucun risque dans cette cat√©gorie
                cell = ws_bordeaux.cell(row=row_start + 2, column=1)
                cell.value = "Aucun risque"
                cell.font = Font(italic=True, color="95A5A6")
                risk_idx = row_start + 2
            
            row_start = risk_idx + 3
        
        # Ajuster les largeurs
        ws_bordeaux.column_dimensions['A'].width = 15
        ws_bordeaux.column_dimensions['B'].width = 40
        ws_bordeaux.column_dimensions['C'].width = 10
        ws_bordeaux.column_dimensions['D'].width = 12
        
        # ============================================================================
        # FEUILLE 4 : STATISTIQUES
        # ============================================================================
        ws_stats = wb.create_sheet("Statistiques")
        
        ws_stats.merge_cells('A1:C1')
        ws_stats['A1'] = "STATISTIQUES DE LA CARTOGRAPHIE"
        ws_stats['A1'].font = Font(size=14, bold=True, color="FFFFFF")
        ws_stats['A1'].fill = PatternFill(start_color="2C3E50", end_color="2C3E50", fill_type="solid")
        ws_stats['A1'].alignment = Alignment(horizontal='center')
        
        # Informations de base (ligne 3)
        ws_stats['A3'] = f"Cartographie : {cartographie.nom}"
        ws_stats['A4'] = f"Direction : {cartographie.direction.nom if cartographie.direction else 'Non sp√©cifi√©e'}"
        ws_stats['A5'] = f"Service : {cartographie.service.nom if cartographie.service else 'Non sp√©cifi√©'}"
        ws_stats['A6'] = f"Nombre total de risques : {len(risques)}"
        ws_stats['A7'] = f"Date d'export : {datetime.now().strftime('%d/%m/%Y %H:%M')}"
        
        # Calcul des statistiques (ligne 9)
        row_start = 9
        
        # Distribution par niveau de risque
        ws_stats.cell(row=row_start, column=1, value="NIVEAU DE RISQUE")
        ws_stats.cell(row=row_start, column=2, value="NOMBRE")
        ws_stats.cell(row=row_start, column=3, value="POURCENTAGE")
        
        # Mise en forme de l'en-t√™te
        for col in [1, 2, 3]:
            cell = ws_stats.cell(row=row_start, column=col)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="34495E", end_color="34495E", fill_type="solid")
        
        niveaux = {'Critique': 0, '√âlev√©': 0, 'Moyen': 0, 'Faible': 0, '√Ä √©valuer': 0}
        for risque in risques:
            derniere_eval = EvaluationRisque.query.filter_by(
                risque_id=risque.id
            ).order_by(EvaluationRisque.created_at.desc()).first()
            
            if derniere_eval and derniere_eval.niveau_risque:
                niveau = derniere_eval.niveau_risque
                if niveau in niveaux:
                    niveaux[niveau] += 1
            else:
                niveaux['√Ä √©valuer'] += 1
        
        # Ajouter les statistiques de niveau (ligne 10+)
        for idx, (niveau, count) in enumerate(niveaux.items(), row_start + 1):
            ws_stats.cell(row=idx, column=1, value=niveau)
            ws_stats.cell(row=idx, column=2, value=count)
            
            # Calculer le pourcentage
            total = len(risques)
            pourcentage = (count / total * 100) if total > 0 else 0
            ws_stats.cell(row=idx, column=3, value=f"{pourcentage:.1f}%")
            
            # Mise en forme conditionnelle
            cell_niveau = ws_stats.cell(row=idx, column=1)
            if niveau == 'Critique':
                cell_niveau.fill = couleur_critique
                cell_niveau.font = Font(color="FFFFFF", bold=True)
            elif niveau == '√âlev√©':
                cell_niveau.fill = couleur_eleve
                cell_niveau.font = Font(color="FFFFFF", bold=True)
            elif niveau == 'Moyen':
                cell_niveau.fill = couleur_moyen
                cell_niveau.font = Font(color="FFFFFF", bold=True)
            elif niveau == 'Faible':
                cell_niveau.fill = couleur_faible
                cell_niveau.font = Font(color="FFFFFF", bold=True)
            elif niveau == '√Ä √©valuer':
                cell_niveau.fill = couleur_non_evalue
                cell_niveau.font = Font(color="FFFFFF", bold=True)
        
        # √âtat des √©valuations (apr√®s un saut de ligne)
        row_start = idx + 3
        ws_stats.cell(row=row_start, column=1, value="√âTAT √âVALUATION")
        ws_stats.cell(row=row_start, column=2, value="NOMBRE")
        ws_stats.cell(row=row_start, column=3, value="POURCENTAGE")
        
        # Mise en forme de l'en-t√™te
        for col in [1, 2, 3]:
            cell = ws_stats.cell(row=row_start, column=col)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="34495E", end_color="34495E", fill_type="solid")
        
        # Calculer les √©tats d'√©valuation
        eval_completes = 0
        eval_incompletes = 0
        sans_eval = 0
        
        for risque in risques:
            derniere_eval = EvaluationRisque.query.filter_by(
                risque_id=risque.id
            ).order_by(EvaluationRisque.created_at.desc()).first()
            
            if not derniere_eval:
                sans_eval += 1
            else:
                impact_final = (
                    derniere_eval.impact_conf or 
                    derniere_eval.impact_val or 
                    derniere_eval.impact_pre
                )
                probabilite_final = (
                    derniere_eval.probabilite_conf or 
                    derniere_eval.probabilite_val or 
                    derniere_eval.probabilite_pre
                )
                
                if impact_final and probabilite_final:
                    eval_completes += 1
                else:
                    eval_incompletes += 1
        
        # Ajouter les √©tats d'√©valuation
        stats_eval = [
            ('√âvaluations compl√®tes', eval_completes),
            ('√âvaluations incompl√®tes', eval_incompletes),
            ('Sans √©valuation', sans_eval)
        ]
        
        for idx, (label, count) in enumerate(stats_eval, row_start + 1):
            ws_stats.cell(row=idx, column=1, value=label)
            ws_stats.cell(row=idx, column=2, value=count)
            
            # Calculer le pourcentage
            total = len(risques)
            pourcentage = (count / total * 100) if total > 0 else 0
            ws_stats.cell(row=idx, column=3, value=f"{pourcentage:.1f}%")
        
        # Ajuster les largeurs
        ws_stats.column_dimensions['A'].width = 25
        ws_stats.column_dimensions['B'].width = 15
        ws_stats.column_dimensions['C'].width = 15
        
        # ============================================================================
        # SAUVEGARDE ET RETOUR DU FICHIER
        # ============================================================================
        # Sauvegarder dans un buffer
        buffer = io.BytesIO()
        wb.save(buffer)
        buffer.seek(0)
        
        # Retourner le fichier Excel
        from flask import Response
        return Response(
            buffer.getvalue(),
            mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={
                "Content-Disposition": f"attachment; filename=risques_{cartographie.nom.replace(' ', '_')}_{datetime.now().strftime('%Y%m%d_%H%M')}.xlsx"
            }
        )
        
    except Exception as e:
        print(f"Erreur d√©taill√©e export Excel: {str(e)}")
        import traceback
        traceback.print_exc()
        flash(f'Erreur lors de l\'export Excel: {str(e)}', 'error')
        return redirect(url_for('detail_cartographie', id=cartographie_id))
# Route restauration risque
# Modifiez votre route restaurer_risque pour d√©sactiver CSRF
@app.route('/risque/<int:id>/restaurer', methods=['POST'])
@csrf.exempt  # <-- AJOUTEZ CETTE LIGNE
@login_required
def restaurer_risque(id):
    risque = Risque.query.get_or_404(id)
    
    if current_user.role != 'admin' and current_user.id != risque.archived_by:
        flash('Vous n\'√™tes pas autoris√© √† restaurer ce risque', 'error')
        return redirect(url_for('risques_archives'))
    
    risque.is_archived = False
    risque.archived_at = None
    risque.archived_by = None
    risque.archive_reason = None
    
    db.session.commit()
    
    # üî• SYNCHRONISATION AUTOMATIQUE
    synchroniser_cartographie_apres_action(risque.cartographie_id, 'restauration_risque', current_user.id)
    declencher_mise_a_jour_risque(id, 'restauration', current_user.id)
    
    flash('Risque restaur√© avec succ√®s', 'success')
    return redirect(url_for('risques_archives'))

# Faites de m√™me pour la route de suppression
@app.route('/risque/<int:id>/supprimer-definitivement', methods=['POST'])
@csrf.exempt  # <-- AJOUTEZ CETTE LIGNE
@login_required
def supprimer_definitivement_risque(id):
    """Supprimer d√©finitivement un risque archiv√© (admin seulement)"""
    if current_user.role != 'admin':
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('risques_archives'))
    
    risque = Risque.query.get_or_404(id)
    
    # V√©rifier que le risque est bien archiv√©
    if not risque.is_archived:
        flash('Seuls les risques archiv√©s peuvent √™tre supprim√©s d√©finitivement', 'error')
        return redirect(url_for('risques_archives'))
    
    cartographie_id = risque.cartographie_id
    
    # Supprimer les √©valuations associ√©es
    EvaluationRisque.query.filter_by(risque_id=id).delete()
    
    # Supprimer les KRI associ√©s
    kri = KRI.query.filter_by(risque_id=id).first()
    if kri:
        MesureKRI.query.filter_by(kri_id=kri.id).delete()
        db.session.delete(kri)
    
    db.session.delete(risque)
    db.session.commit()
    flash('Risque supprim√© d√©finitivement avec succ√®s', 'success')
    return redirect(url_for('risques_archives'))

@app.route('/risques/archives')
@csrf.exempt
@login_required
def risques_archives():
    """Page listant tous les risques archiv√©s"""
    risques_archives = Risque.query.filter_by(is_archived=True).all()
    return render_template('cartographie/risques_archives.html', risques=risques_archives)


# ------------------------------------------------------------
# ROUTES DE PARAM√âTRAGE (Nouvelles routes)
# ------------------------------------------------------------
@app.route('/parametrage/risque', methods=['GET'])
@login_required
def parametrage_risque():
    """Page principale de param√©trage des fiches de risque"""
    
    # V√©rifier la permission de g√©rer les param√®tres
    if not current_user.has_permission('can_manage_settings'):
        flash('Acc√®s non autoris√© : permission de g√©rer les param√®tres requise', 'error')
        return redirect(url_for('dashboard'))
    
    # V√âRIFICATION FORMULE : v√©rifier si le client a acc√®s au param√©trage avanc√©
    mode_limite = False
    if current_user.client and hasattr(current_user.client, 'formule') and current_user.client.formule:
        formule = current_user.client.formule
        
        # V√©rifier si la formule donne acc√®s au param√©trage avanc√©
        if hasattr(formule, 'can_use_feature'):
            if not formule.can_use_feature('advanced_configuration'):
                mode_limite = True
                flash('Vous utilisez une version limit√©e du param√©trage (votre formule ne comprend pas le param√©trage avanc√©)', 'info')
    
    # R√©cup√©rer les configurations existantes avec filtrage tenant
    if current_user.role == 'super_admin':
        # Super admin : d√©terminer le client visualis√©
        if session.get('viewing_client_id'):
            client_id = session.get('viewing_client_id')
            # Voir les configurations globales ET celles du client sp√©cifique
            champs = ConfigurationChampRisque.query.filter(
                db.or_(
                    ConfigurationChampRisque.client_id == None,  # Global
                    ConfigurationChampRisque.client_id == client_id  # Client sp√©cifique
                )
            ).order_by('section', 'ordre_affichage').all()
            
            listes = ConfigurationListeDeroulante.query.filter(
                db.or_(
                    ConfigurationListeDeroulante.client_id == None,
                    ConfigurationListeDeroulante.client_id == client_id
                )
            ).order_by('nom_affichage').all()
        else:
            # Mode global : voir tout
            champs = ConfigurationChampRisque.query.order_by('section', 'ordre_affichage').all()
            listes = ConfigurationListeDeroulante.query.order_by('nom_affichage').all()
    else:
        # Client normal : filtrer par client_id (configurations sp√©cifiques + globales)
        client_id = current_user.client_id
        champs = ConfigurationChampRisque.query.filter(
            db.or_(
                ConfigurationChampRisque.client_id == None,  # Configurations globales
                ConfigurationChampRisque.client_id == client_id  # Configurations du client
            )
        ).order_by('section', 'ordre_affichage').all()
        
        listes = ConfigurationListeDeroulante.query.filter(
            db.or_(
                ConfigurationListeDeroulante.client_id == None,
                ConfigurationListeDeroulante.client_id == client_id
            )
        ).order_by('nom_affichage').all()
    
    # Formulaires
    champ_form = ConfigurationChampForm()
    liste_form = ConfigurationListeForm()
    
    # Si mode limit√©, restreindre les options
    if mode_limite:
        champ_form.type_champ.choices = [
            ('text', 'Texte'),
            ('textarea', 'Zone de texte'),
            ('select', 'Liste d√©roulante'),
            ('checkbox', 'Case √† cocher')
        ]
        champ_form.section.choices = [
            ('general', 'G√©n√©ral'),
            ('identification', 'Identification')
        ]
    
    # Configuration fichiers
    config_fichiers = get_fichier_configuration()
    
    # Calculer les statistiques
    stats = {
        'total_champs': len(champs),
        'champs_obligatoires': len([c for c in champs if c.est_obligatoire]),
        'champs_actifs': len([c for c in champs if c.est_actif]),
        'total_listes': len(listes),
        'listes_avec_valeurs': len([l for l in listes if l.valeurs and len(l.valeurs) > 0]),
        'champs_globaux': len([c for c in champs if c.client_id is None]),
        'champs_clients': len([c for c in champs if c.client_id is not None])
    }
    
    # Grouper les champs par section pour l'affichage
    champs_par_section = {}
    for champ in champs:
        # Si mode limit√©, filtrer uniquement certaines sections
        if mode_limite and champ.section not in ['general', 'identification']:
            continue
            
        if champ.section not in champs_par_section:
            champs_par_section[champ.section] = []
        champs_par_section[champ.section].append(champ)
    
    # Trier les sections par ordre logique
    if mode_limite:
        sections_ordre = ['general', 'identification']
    else:
        sections_ordre = ['general', 'identification', 'evaluation', 'traitement', 'suivi', 'documents', 'autre']
    
    sections_triees = []
    for section in sections_ordre:
        if section in champs_par_section:
            sections_triees.append({
                'nom': section,
                'nom_affichage': section.replace('_', ' ').title(),
                'champs': sorted(champs_par_section[section], key=lambda x: x.ordre_affichage)
            })
    
    # Ajouter les sections non standardis√©es (uniquement si pas en mode limit√©)
    if not mode_limite:
        for section in champs_par_section:
            if section not in sections_ordre:
                sections_triees.append({
                    'nom': section,
                    'nom_affichage': section.replace('_', ' ').title(),
                    'champs': sorted(champs_par_section[section], key=lambda x: x.ordre_affichage)
                })
    
    return render_template('admin/parametrage/parametrage_risque.html',
                         champs=champs,
                         listes=listes,
                         champ_form=champ_form,
                         liste_form=liste_form,
                         config_fichiers=config_fichiers,
                         stats=stats,
                         sections=sections_triees,
                         mode_limite=mode_limite,
                         current_user=current_user,
                         viewing_client_id=session.get('viewing_client_id'))

@app.route('/parametrage/champ/ajouter', methods=['POST'])
@login_required
@csrf.exempt
def ajouter_champ_risque():
    """Ajouter un champ de risque avec filtrage tenant"""
    
    # V√©rifier la permission
    if not current_user.has_permission('can_manage_settings'):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    form = ConfigurationChampForm()
    
    if form.validate_on_submit():
        try:
            # V√©rifier l'unicit√© du nom technique POUR CE CLIENT
            if current_user.role == 'super_admin':
                existing = ConfigurationChampRisque.query.filter_by(
                    nom_technique=form.nom_technique.data
                ).first()
            else:
                existing = ConfigurationChampRisque.query.filter_by(
                    nom_technique=form.nom_technique.data,
                    client_id=current_user.client_id
                ).first()
            
            if existing:
                flash('Ce nom technique existe d√©j√†', 'error')
                return redirect(url_for('parametrage_risque', _anchor='champs'))
            
            # Parser les valeurs possibles
            valeurs_possibles = None
            if form.valeurs_possibles.data:
                valeurs_possibles = [v.strip() for v in form.valeurs_possibles.data.split('\n') if v.strip()]
            
            # Cr√©er le champ avec client_id (SANS created_by qui n'existe pas)
            champ = ConfigurationChampRisque(
                nom_technique=form.nom_technique.data,
                nom_affichage=form.nom_affichage.data,
                type_champ=form.type_champ.data,
                est_obligatoire=form.est_obligatoire.data,
                est_actif=form.est_actif.data,
                ordre_affichage=form.ordre_affichage.data,
                section=form.section.data,
                aide_texte=form.aide_texte.data,
                valeurs_possibles=valeurs_possibles,
                regex_validation=form.regex_validation.data,
                client_id=current_user.client_id if current_user.role != 'super_admin' else None
            )
            
            db.session.add(champ)
            db.session.commit()
            
            # Synchroniser le champ avec les risques existants si n√©cessaire
            if champ.est_obligatoire and champ.est_actif:
                synchroniser_configuration_champ(champ)
            
            # Journaliser l'action
            log_activity(current_user.id, 'ajout_champ_risque',
                        f"Ajout champ risque: {champ.nom_affichage} ({champ.nom_technique})",
                        'parametrage', champ.id)
            
            flash(f'‚úÖ Champ "{champ.nom_affichage}" ajout√© avec succ√®s', 'success')
            
        except Exception as e:
            db.session.rollback()
            flash(f'‚ùå Erreur lors de l\'ajout du champ: {str(e)}', 'error')
            print(f"‚ùå Erreur ajout champ: {e}")
    
    else:
        # Afficher les erreurs de validation
        if form.errors:
            for field, errors in form.errors.items():
                for error in errors:
                    flash(f'Erreur {field}: {error}', 'error')
    
    return redirect(url_for('parametrage_risque', _anchor='champs'))

@app.route('/logigramme/<int:activite_id>/export-diagramme')
@login_required
def export_diagramme_complet(activite_id):
    """Export PDF fid√®le √† l'affichage de l'√©diteur visuel"""
    if not REPORTLAB_AVAILABLE:
        return "ReportLab n'est pas install√©. Installez-le avec: pip install reportlab", 500
    
    try:
        activite = ProcessusActivite.query.filter_by(
            id=activite_id, 
            created_by=current_user.id
        ).first_or_404()
        
        elements = ElementLogigramme.query.filter_by(activite_id=activite_id).all()
        liens = LienLogigramme.query.filter_by(activite_id=activite_id).all()
        
        buffer = BytesIO()
        # A4 paysage
        doc = SimpleDocTemplate(buffer, pagesize=landscape(A4), 
                               leftMargin=10, rightMargin=10,
                               topMargin=15, bottomMargin=15)
        story = []
        
        styles = getSampleStyleSheet()
        
        # En-t√™te simple
        header_style = ParagraphStyle(
            'HeaderStyle',
            parent=styles['Heading1'],
            fontSize=12,
            alignment=1,
            spaceAfter=3,
            textColor=HexColor('#1e293b')
        )
        story.append(Paragraph(f"{activite.nom}", header_style))
        
        if activite.description:
            desc_style = ParagraphStyle(
                'DescStyle',
                parent=styles['Normal'],
                fontSize=7,
                alignment=1,
                textColor=HexColor('#64748b'),
                spaceAfter=10
            )
            story.append(Paragraph(f"<i>{activite.description}</i>", desc_style))
        
        # === REPRODUCTION SIMPLIFI√âE MAIS R√âALISTE ===
        
        if elements:
            # Trouver les limites du diagramme
            min_x = min(e.position_x for e in elements)
            max_x = max(e.position_x + (e.style.get('width', 160) if e.style else 160) for e in elements)
            min_y = min(e.position_y for e in elements)
            max_y = max(e.position_y + (e.style.get('height', 80) if e.style else 80) for e in elements)
            
            # Ajouter des marges
            padding = 50
            width_needed = max_x - min_x + 2 * padding
            height_needed = max_y - min_y + 2 * padding
            
            # Dimensions du dessin
            drawing_width = 750
            drawing_height = 400
            
            # Calcul de l'√©chelle
            scale_x = drawing_width / max(width_needed, 1)
            scale_y = drawing_height / max(height_needed, 1)
            scale = min(scale_x, scale_y) * 0.9
            
            # Cr√©er le dessin
            d = Drawing(drawing_width, drawing_height)
            
            # Arri√®re-plan avec grille l√©g√®re
            bg_color = HexColor('#f8fafc')
            bg_rect = Rect(0, 0, drawing_width, drawing_height)
            bg_rect.fillColor = bg_color
            bg_rect.strokeColor = None
            d.add(bg_rect)
            
            # Grille subtile
            grid_color = HexColor('#e2e8f0')
            grid_size = 20 * scale
            
            # Lignes verticales
            for x in range(0, int(drawing_width) + 1, int(grid_size)):
                if x <= drawing_width:
                    line = Line(x, 0, x, drawing_height)
                    line.strokeColor = grid_color
                    line.strokeWidth = 0.2
                    d.add(line)
            
            # Lignes horizontales
            for y in range(0, int(drawing_height) + 1, int(grid_size)):
                if y <= drawing_height:
                    line = Line(0, y, drawing_width, y)
                    line.strokeColor = grid_color
                    line.strokeWidth = 0.2
                    d.add(line)
            
            # Fonction de conversion
            def convert_coords(x, y):
                # Normaliser et inverser Y
                norm_x = (x - min_x + padding) * scale
                norm_y = drawing_height - ((y - min_y + padding) * scale)
                return norm_x, norm_y
            
            # Dessiner les liens d'abord
            for lien in liens:
                source = next((e for e in elements if e.id == lien.element_source_id), None)
                cible = next((e for e in elements if e.id == lien.element_cible_id), None)
                
                if source and cible:
                    # Points de d√©part et d'arriv√©e au centre
                    s_width = source.style.get('width', 160) if source.style else 160
                    s_height = source.style.get('height', 80) if source.style else 80
                    c_width = cible.style.get('width', 160) if cible.style else 160
                    c_height = cible.style.get('height', 80) if cible.style else 80
                    
                    sx = source.position_x + s_width / 2
                    sy = source.position_y + s_height / 2
                    cx = cible.position_x + c_width / 2
                    cy = cible.position_y + c_height / 2
                    
                    x1, y1 = convert_coords(sx, sy)
                    x2, y2 = convert_coords(cx, cy)
                    
                    # Type de lien
                    lien_type = lien.style.get('type', 'normal') if lien.style else 'normal'
                    
                    if lien_type == 'oui':
                        line_color = HexColor('#10b981')
                        stroke_width = 2.5
                        dash = None
                    elif lien_type == 'non':
                        line_color = HexColor('#ef4444')
                        stroke_width = 2.5
                        dash = [4, 4]
                    else:
                        line_color = HexColor('#475569')
                        stroke_width = 2
                        dash = None
                    
                    # Ligne
                    line = Line(x1, y1, x2, y2)
                    line.strokeColor = line_color
                    line.strokeWidth = stroke_width
                    if dash:
                        line.strokeDashArray = dash
                    d.add(line)
                    
                    # Fl√®che
                    arrow_size = 8
                    dx = x2 - x1
                    dy = y2 - y1
                    angle = math.atan2(dy, dx)
                    
                    arrow_x1 = x2 - arrow_size * math.cos(angle - math.pi/6)
                    arrow_y1 = y2 - arrow_size * math.sin(angle - math.pi/6)
                    arrow_x2 = x2 - arrow_size * math.cos(angle + math.pi/6)
                    arrow_y2 = y2 - arrow_size * math.sin(angle + math.pi/6)
                    
                    arrow = Polygon([x2, y2, arrow_x1, arrow_y1, arrow_x2, arrow_y2])
                    arrow.fillColor = line_color
                    arrow.strokeColor = line_color
                    d.add(arrow)
            
            # Dessiner les √©l√©ments
            for element in elements:
                # Dimensions
                width = (element.style.get('width', 160) if element.style else 160) * scale
                height = (element.style.get('height', 80) if element.style else 80) * scale
                
                # Position (centre)
                center_x = element.position_x + (element.style.get('width', 160) if element.style else 160) / 2
                center_y = element.position_y + (element.style.get('height', 80) if element.style else 80) / 2
                
                x, y = convert_coords(center_x, center_y)
                rect_x = x - width / 2
                rect_y = y - height / 2
                
                # Couleurs selon le type
                colors_map = {
                    'debut': {'fill': HexColor('#10b981'), 'stroke': HexColor('#047857'), 'text': colors.white},
                    'fin': {'fill': HexColor('#6b7280'), 'stroke': HexColor('#374151'), 'text': colors.white},
                    'action': {'fill': HexColor('#3b82f6'), 'stroke': HexColor('#1e40af'), 'text': colors.white},
                    'controle': {'fill': HexColor('#f59e0b'), 'stroke': HexColor('#b45309'), 'text': colors.white},
                    'risque': {'fill': HexColor('#ef4444'), 'stroke': HexColor('#b91c1c'), 'text': colors.white},
                    'organisation': {'fill': HexColor('#8b5cf6'), 'stroke': HexColor('#6d28d9'), 'text': colors.white},
                    'titre': {'fill': colors.white, 'stroke': HexColor('#e2e8f0'), 'text': HexColor('#1e293b')}
                }
                
                config = colors_map.get(element.type_element, colors_map['action'])
                
                # Cr√©er la forme
                if element.type_element in ['debut', 'fin']:
                    # Ovale
                    shape = Rect(rect_x, rect_y, width, height, rx=height/2, ry=height/2)
                    shape.fillColor = config['fill']
                    shape.strokeColor = config['stroke']
                    shape.strokeWidth = 2
                    d.add(shape)
                    
                elif element.type_element == 'organisation':
                    # Rectangle vertical √©troit
                    org_width = 15 * scale
                    org_height = height * 1.5
                    org_x = x - org_width / 2
                    org_y = y - org_height / 2
                    
                    shape = Rect(org_x, org_y, org_width, org_height)
                    shape.fillColor = config['fill']
                    shape.strokeColor = config['stroke']
                    shape.strokeWidth = 1.5
                    shape.strokeDashArray = [4, 2]
                    d.add(shape)
                    
                    # Texte vertical
                    # Simuler la rotation avec plusieurs lignes verticales
                    libelle = element.libelle
                    if len(libelle) > 15:
                        libelle = libelle[:12] + '...'
                    
                    # Cr√©er chaque caract√®re sur une ligne diff√©rente
                    char_height = 7 * scale
                    start_y = org_y + org_height - char_height
                    
                    for i, char in enumerate(libelle):
                        char_y = start_y - (i * char_height)
                        if char_y > org_y:
                            char_text = String(org_x + org_width/2, char_y, char)
                            char_text.fontName = 'Helvetica'
                            char_text.fontSize = 6 * scale
                            char_text.fillColor = config['text']
                            char_text.textAnchor = 'middle'
                            d.add(char_text)
                    
                else:
                    # Rectangle standard
                    shape = Rect(rect_x, rect_y, width, height, rx=6, ry=6)
                    shape.fillColor = config['fill']
                    shape.strokeColor = config['stroke']
                    shape.strokeWidth = 2
                    d.add(shape)
                
                # Texte pour tous sauf organisation (d√©j√† trait√©)
                if element.type_element != 'organisation':
                    # Libell√© principal
                    libelle = element.libelle
                    if len(libelle) > 20:
                        libelle = libelle[:17] + '...'
                    
                    main_text = String(x, y + 3, libelle)
                    main_text.fontName = 'Helvetica-Bold'
                    main_text.fontSize = 8 * scale
                    main_text.fillColor = config['text']
                    main_text.textAnchor = 'middle'
                    d.add(main_text)
                    
                    # Description si disponible et espace suffisant
                    if element.description and height > 30 * scale:
                        desc = element.description
                        if len(desc) > 25:
                            desc = desc[:22] + '...'
                        
                        desc_text = String(x, y - 8, desc)
                        desc_text.fontName = 'Helvetica'
                        desc_text.fontSize = 6 * scale
                        desc_text.fillColor = config['text']
                        desc_text.textAnchor = 'middle'
                        d.add(desc_text)
            
            # Ajouter le dessin au PDF
            story.append(Spacer(1, 5))
            story.append(d)
            
            # L√©gende simple
            story.append(Spacer(1, 10))
            
            legend_text = """
            <b>L√©gende:</b> 
            <font color="#10b981">‚óè D√©but/Fin</font> | 
            <font color="#3b82f6">‚ñ† Action</font> | 
            <font color="#f59e0b">‚ñ† Contr√¥le</font> | 
            <font color="#ef4444">‚ñ† Risque</font> | 
            <font color="#8b5cf6">‚èê Organisation</font> | 
            <font color="#10b981">‚îÅ‚îÅ‚îÅ‚ñ∂ OUI</font> | 
            <font color="#ef4444">‚∏∫‚∏∫‚ñ∂ NON</font>
            """
            
            legend_style = ParagraphStyle(
                'LegendStyle',
                parent=styles['Normal'],
                fontSize=7,
                alignment=1,
                textColor=HexColor('#475569'),
                backColor=HexColor('#f1f5f9'),
                borderPadding=5,
                borderColor=HexColor('#cbd5e1'),
                borderWidth=1
            )
            
            legend_box = Table([[Paragraph(legend_text, legend_style)]], colWidths=[drawing_width*0.95])
            legend_box.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, -1), HexColor('#f8fafc')),
                ('BOX', (0, 0), (-1, -1), 0.5, HexColor('#cbd5e1')),
                ('PADDING', (0, 0), (-1, -1), 8),
                ('ROUNDEDCORNERS', [4, 4]),
            ]))
            
            story.append(legend_box)
        
        # === PAGE 2 : INFORMATIONS ===
        story.append(PageBreak())
        
        # Titre page 2
        page2_title = Paragraph("<b>D√©tails du Logigramme</b>", 
                              ParagraphStyle('Page2Title', fontSize=14, alignment=1, spaceAfter=15))
        story.append(page2_title)
        
        # Informations de base
        info_data = [
            ['Propri√©t√©', 'Valeur'],
            ['Nom', activite.nom],
            ['ID', str(activite.id)],
            ['Cr√©√© le', activite.created_at.strftime('%d/%m/%Y %H:%M') if activite.created_at else 'N/A'],
            ['Modifi√© le', activite.updated_at.strftime('%d/%m/%Y %H:%M') if activite.updated_at else 'N/A'],
            ['Export√© le', datetime.now().strftime('%d/%m/%Y %H:%M:%S')],
            ['Par', current_user.email],
            ['Format', 'PDF haute fid√©lit√©']
        ]
        
        info_table = Table(info_data, colWidths=[5*cm, 8*cm])
        info_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), HexColor('#3b82f6')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ('PADDING', (0, 0), (-1, -1), 6),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, HexColor('#f8fafc')]),
        ]))
        
        story.append(info_table)
        
        # Statistiques
        story.append(Spacer(1, 20))
        
        if elements:
            # Compter par type
            type_counts = {}
            for element in elements:
                type_counts[element.type_element] = type_counts.get(element.type_element, 0) + 1
            
            stats_data = [['Type d\'√©l√©ment', 'Quantit√©', 'Pourcentage']]
            total = len(elements)
            
            for type_elem, count in sorted(type_counts.items()):
                percentage = (count / total) * 100 if total > 0 else 0
                stats_data.append([
                    type_elem.upper(),
                    str(count),
                    f"{percentage:.1f}%"
                ])
            
            stats_table = Table(stats_data, colWidths=[5*cm, 3*cm, 3*cm])
            stats_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), HexColor('#10b981')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
                ('PADDING', (0, 0), (-1, -1), 6),
                ('ALIGN', (1, 0), (2, -1), 'CENTER'),
                ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, HexColor('#f8fafc')]),
            ]))
            
            story.append(Paragraph("<b>R√©partition des √âl√©ments</b>", styles['Heading3']))
            story.append(Spacer(1, 5))
            story.append(stats_table)
        
        # Liste des √©l√©ments
        story.append(Spacer(1, 20))
        story.append(Paragraph("<b>Liste des √âl√©ments</b>", styles['Heading3']))
        story.append(Spacer(1, 5))
        
        if elements:
            for i, element in enumerate(elements, 1):
                element_info = f"""
                <b>{i}. {element.libelle}</b> ({element.type_element.upper()})<br/>
                <font size="7" color="#64748b">
                Position: ({element.position_x}, {element.position_y}) | 
                {element.description[:50] if element.description else 'Pas de description'}
                </font>
                """
                story.append(Paragraph(element_info, styles['Normal']))
                story.append(Spacer(1, 3))
        
        # Connexions
        story.append(Spacer(1, 20))
        story.append(Paragraph("<b>Connexions</b>", styles['Heading3']))
        story.append(Spacer(1, 5))
        
        if liens:
            connections_count = len(liens)
            oui_count = len([l for l in liens if (l.style or {}).get('type') == 'oui'])
            non_count = len([l for l in liens if (l.style or {}).get('type') == 'non'])
            normal_count = connections_count - oui_count - non_count
            
            conn_info = f"""
            Total: <b>{connections_count}</b> connexions<br/>
            <font color="#10b981">OUI: {oui_count}</font> | 
            <font color="#ef4444">NON: {non_count}</font> | 
            <font color="#475569">Normales: {normal_count}</font>
            """
            story.append(Paragraph(conn_info, styles['Normal']))
        else:
            story.append(Paragraph("<i>Aucune connexion d√©finie</i>", styles['Italic']))
        
        # Pied de page
        story.append(Spacer(1, 30))
        footer = Paragraph(
            f"<font size='6' color='#94a3b8'>Document g√©n√©r√© automatiquement ‚Ä¢ "
            f"R√©f√©rence: LG-{activite.id}-EX-{datetime.now().strftime('%Y%m%d%H%M%S')} ‚Ä¢ "
            f"Syst√®me de Gestion des Processus</font>",
            ParagraphStyle('Footer', alignment=1, fontSize=6)
        )
        story.append(footer)
        
        # === G√âN√âRATION ===
        doc.build(story)
        buffer.seek(0)
        
        # Nom de fichier
        safe_name = ''.join(c if c.isalnum() or c in ' -_' else '_' for c in activite.nom)
        filename = f"logigramme_{safe_name}.pdf"
        
        return send_file(
            buffer,
            as_attachment=True,
            download_name=filename,
            mimetype='application/pdf'
        )
        
    except Exception as e:
        print(f"‚ùå Erreur export diagramme complet: {str(e)}")
        import traceback
        traceback.print_exc()
        return f"Erreur lors de l'export: {str(e)}", 500


@app.route('/parametrage/champ/<int:champ_id>/editer', methods=['GET', 'POST'])
@login_required
@csrf.exempt
@admin_required
def editer_champ_risque(champ_id):
    """√âditer un champ personnalis√© avec isolation multi-tenant"""
    
    # R√©cup√©rer le champ avec filtrage multi-tenant
    champ = get_client_object_or_404(ConfigurationChampRisque, champ_id)
    
    # V√©rification d'acc√®s suppl√©mentaire (double s√©curit√©)
    if not check_client_access(champ):
        flash('Acc√®s non autoris√© √† ce champ', 'error')
        return redirect(url_for('parametrage_champs'))
    
    # V√©rifier les permissions sp√©cifiques
    if not current_user.has_permission('can_manage_settings'):
        flash('Permission insuffisante pour modifier les param√®tres', 'error')
        return redirect(url_for('dashboard'))
    
    form = ConfigurationChampForm(obj=champ)
    
    # Pr√©parer les valeurs possibles pour l'affichage
    if request.method == 'GET':
        if champ.valeurs_possibles:
            if isinstance(champ.valeurs_possibles, list):
                form.valeurs_possibles.data = '\n'.join(champ.valeurs_possibles)
            elif isinstance(champ.valeurs_possibles, dict):
                # Convertir dict en format cl√©: valeur
                dict_lines = []
                for key, value in champ.valeurs_possibles.items():
                    dict_lines.append(f"{key}: {value}")
                form.valeurs_possibles.data = '\n'.join(dict_lines)
            else:
                form.valeurs_possibles.data = str(champ.valeurs_possibles)
        
        # Remplir les sections disponibles
        try:
            from utils import GestionnaireParametrage
            sections_disponibles = GestionnaireParametrage.get_sections_disponibles()
            form.section.choices = [(s, s) for s in sections_disponibles]
        except:
            # Sections par d√©faut si le gestionnaire n'est pas disponible
            form.section.choices = [
                ('general', 'G√©n√©ral'),
                ('identification', 'Identification'),
                ('evaluation', '√âvaluation'),
                ('traitement', 'Traitement'),
                ('suivi', 'Suivi'),
                ('documentation', 'Documentation')
            ]
        
        # Remplir les types de champs disponibles
        form.type_champ.choices = [
            ('text', 'Texte'),
            ('textarea', 'Zone de texte'),
            ('number', 'Nombre'),
            ('date', 'Date'),
            ('select', 'Liste d√©roulante'),
            ('multiselect', 'Liste multiple'),
            ('checkbox', 'Case √† cocher'),
            ('radio', 'Boutons radio'),
            ('file', 'Fichier'),
            ('email', 'Email'),
            ('url', 'URL'),
            ('tel', 'T√©l√©phone')
        ]
    
    if form.validate_on_submit():
        try:
            # V√©rifier si le nom technique est modifi√©
            old_nom_technique = champ.nom_technique
            new_nom_technique = form.nom_technique.data
            
            # Si le nom technique change, v√©rifier qu'il n'existe pas d√©j√†
            if old_nom_technique != new_nom_technique:
                existing = get_client_filter(ConfigurationChampRisque)\
                    .filter_by(nom_technique=new_nom_technique)\
                    .filter(ConfigurationChampRisque.id != champ_id)\
                    .first()
                
                if existing:
                    flash(f'Le nom technique "{new_nom_technique}" existe d√©j√†', 'error')
                    return render_template('admin/parametrage/editer_champ.html', 
                                         form=form, 
                                         champ=champ,
                                         current_user=current_user)
            
            # Mettre √† jour les champs de base
            champ.nom_technique = new_nom_technique
            champ.nom_affichage = form.nom_affichage.data
            champ.type_champ = form.type_champ.data
            champ.est_obligatoire = form.est_obligatoire.data
            champ.est_actif = form.est_actif.data
            champ.ordre_affichage = form.ordre_affichage.data
            champ.section = form.section.data
            champ.aide_texte = form.aide_texte.data
            champ.regex_validation = form.regex_validation.data
            
            # Traitement des valeurs possibles
            valeurs_text = form.valeurs_possibles.data
            
            if valeurs_text and valeurs_text.strip():
                valeurs_list = [v.strip() for v in valeurs_text.split('\n') if v.strip()]
                
                if form.type_champ.data in ['select', 'multiselect', 'radio']:
                    # Pour les listes, stocker comme dict cl√©: label
                    valeurs_dict = {}
                    for v in valeurs_list:
                        if ':' in v:
                            key, label = v.split(':', 1)
                            valeurs_dict[key.strip()] = label.strip()
                        else:
                            valeurs_dict[v] = v
                    champ.valeurs_possibles = valeurs_dict
                elif form.type_champ.data in ['checkbox']:
                    # Pour les cases √† cocher, liste simple
                    champ.valeurs_possibles = valeurs_list
                else:
                    # Pour les autres types, liste simple ou None
                    champ.valeurs_possibles = valeurs_list if valeurs_list else None
            else:
                champ.valeurs_possibles = None
            
            # Mettre √† jour la date et assurer le client_id
            champ.updated_at = datetime.utcnow()
            
            # Pour les super admin, garder le client_id tel quel
            # Pour les admin clients, s'assurer que le champ appartient √† leur client
            if current_user.role != 'super_admin':
                if champ.client_id != current_user.client_id:
                    flash('Vous ne pouvez pas modifier un champ qui ne vous appartient pas', 'error')
                    return redirect(url_for('parametrage_champs'))
            
            db.session.commit()
            
            # Journaliser l'action avec plus de d√©tails
            log_activity(current_user.id, 'modification_champ_parametrage', 
                        f'Modification du champ {old_nom_technique} -> {new_nom_technique}', 
                        'configuration_champ', champ.id,
                        details={
                            'old_nom': old_nom_technique,
                            'new_nom': new_nom_technique,
                            'type': champ.type_champ,
                            'est_obligatoire': champ.est_obligatoire,
                            'est_actif': champ.est_actif,
                            'client_id': champ.client_id
                        })
            
            # Synchroniser les champs existants si n√©cessaire
            try:
                # Si le nom technique a chang√©, mettre √† jour les champs personnalis√©s existants
                if old_nom_technique != new_nom_technique:
                    # Mettre √† jour tous les ChampPersonnaliseRisque qui utilisent l'ancien nom
                    champs_perso = get_client_filter(ChampPersonnaliseRisque)\
                        .filter_by(nom_technique=old_nom_technique)\
                        .all()
                    
                    for cp in champs_perso:
                        cp.nom_technique = new_nom_technique
                    
                    if champs_perso:
                        db.session.commit()
                        print(f"‚úÖ {len(champs_perso)} champs personnalis√©s mis √† jour avec le nouveau nom technique")
                
                # Synchroniser la configuration si la fonction existe
                if 'synchroniser_modification_champ' in globals() and callable(synchroniser_modification_champ):
                    synchroniser_modification_champ(champ)
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur synchronisation champ: {e}")
                # Ne pas bloquer l'op√©ration principale pour une erreur de synchronisation
            
            flash(f'‚úÖ Champ "{champ.nom_affichage}" mis √† jour avec succ√®s.', 'success')
            
            # Rediriger selon l'origine
            next_page = request.args.get('next')
            if next_page:
                return redirect(next_page)
            return redirect(url_for('parametrage_champs'))
            
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Erreur modification champ: {str(e)}")
            import traceback
            traceback.print_exc()
            flash(f'‚ùå Erreur lors de la modification: {str(e)}', 'error')
    
    # Si GET ou erreur de validation
    return render_template('admin/parametrage/editer_champ.html', 
                         form=form, 
                         champ=champ,
                         current_user=current_user)

@app.route('/parametrage/champ/<int:id>/supprimer', methods=['POST'])
@login_required
@admin_required
@csrf.exempt 
def supprimer_champ_risque(id):
    """Supprimer un champ de risque avec isolation multi-tenant"""
    if not current_user.has_permission('can_manage_settings'):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    # R√©cup√©rer le champ avec v√©rification d'acc√®s
    champ = get_client_object_or_404(ConfigurationChampRisque, id)
    
    # V√©rification d'acc√®s suppl√©mentaire
    if not check_client_access(champ):
        flash('Acc√®s non autoris√© √† ce champ', 'error')
        return redirect(url_for('parametrage_risque'))
    
    # V√©rifier si le champ est utilis√©
    if current_user.role == 'super_admin':
        champs_utilises = ChampPersonnaliseRisque.query\
            .filter_by(nom_technique=champ.nom_technique)\
            .count()
    else:
        # Filtrer par client pour les champs utilis√©s
        champs_utilises = get_client_filter(ChampPersonnaliseRisque)\
            .filter_by(nom_technique=champ.nom_technique)\
            .count()
    
    if champs_utilises > 0:
        flash('Ce champ est utilis√© dans des fiches de risque et ne peut pas √™tre supprim√©', 'error')
        return redirect(url_for('parametrage_risque'))
    
    db.session.delete(champ)
    db.session.commit()
    
    # Journaliser l'action
    log_activity(current_user.id, 'suppression', 
                f'Suppression du champ {champ.nom_technique}', 
                'configuration_champ', champ.id)
    
    flash('Champ supprim√© avec succ√®s', 'success')
    return redirect(url_for('parametrage_risque'))

@app.route('/parametrage/liste/<int:id>/dupliquer', methods=['GET', 'POST'])
@login_required
@csrf.exempt
def dupliquer_liste_deroulante(id):
    """Dupliquer une liste d√©roulante"""
    if not current_user.has_permission('can_manage_settings'):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    # R√©cup√©rer la liste originale avec v√©rification d'acc√®s
    liste_originale = get_client_object_or_404(ConfigurationListeDeroulante, id)
    
    if request.method == 'POST':
        try:
            # Cr√©er une copie de la liste
            nouvelle_liste = ConfigurationListeDeroulante(
                nom_technique=f"{liste_originale.nom_technique}_copie_{datetime.now().strftime('%Y%m%d%H%M%S')}",
                nom_affichage=f"{liste_originale.nom_affichage} (copie)",
                est_multiple=liste_originale.est_multiple,
                valeurs=liste_originale.valeurs.copy() if liste_originale.valeurs else [],
                valeurs_par_defaut=liste_originale.valeurs_par_defaut.copy() if liste_originale.valeurs_par_defaut else None,
                est_actif=liste_originale.est_actif,
                client_id=liste_originale.client_id,
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow()
            )
            
            db.session.add(nouvelle_liste)
            db.session.commit()
            
            # Journaliser l'action
            log_activity(current_user.id, 'duplication', 
                       f'Duplication liste d√©roulante {liste_originale.nom_technique} -> {nouvelle_liste.nom_technique}', 
                       'configuration_liste', nouvelle_liste.id)
            
            flash(f'Liste "{liste_originale.nom_affichage}" dupliqu√©e avec succ√®s', 'success')
            return redirect(url_for('parametrage_listes'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur duplication: {e}', 'error')
            return redirect(url_for('parametrage_listes'))
    
    # GET: Afficher la confirmation
    return render_template('admin/parametrage/dupliquer_liste.html',
                         liste=liste_originale,
                         current_user=current_user)


@app.route('/parametrage/liste/ajouter', methods=['POST'])
@login_required
def ajouter_liste_deroulante():
    """Ajouter une liste d√©roulante avec isolation multi-tenant"""
    if not current_user.has_permission('can_manage_settings'):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    form = ConfigurationListeForm()
    
    if form.validate_on_submit():
        # Parser les valeurs
        valeurs = []
        for ligne in form.valeurs.data.split('\n'):
            ligne = ligne.strip()
            if ligne:
                if '|' in ligne:
                    valeur, label = ligne.split('|', 1)
                    valeurs.append({'valeur': valeur.strip(), 'label': label.strip()})
                else:
                    valeurs.append({'valeur': ligne, 'label': ligne})
        
        # Parser les valeurs par d√©faut
        valeurs_par_defaut = None
        if form.valeurs_par_defaut.data:
            valeurs_par_defaut = [v.strip() for v in form.valeurs_par_defaut.data.split('\n') if v.strip()]
        
        # D√©terminer le client_id
        client_id = None
        if current_user.role == 'super_admin' and session.get('viewing_client_id'):
            client_id = session.get('viewing_client_id')
        elif hasattr(current_user, 'client_id') and current_user.client_id:
            client_id = current_user.client_id
        
        # Cr√©er la liste avec client_id
        liste = ConfigurationListeDeroulante(
            nom_technique=form.nom_technique.data,
            nom_affichage=form.nom_affichage.data,
            est_multiple=form.est_multiple.data,
            valeurs=valeurs,
            valeurs_par_defaut=valeurs_par_defaut,
            est_actif=form.est_actif.data,
            client_id=client_id,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )
        
        db.session.add(liste)
        db.session.commit()
        
        # Journaliser
        log_activity(current_user.id, 'creation', 
                    f'Cr√©ation liste d√©roulante {liste.nom_technique}', 
                    'configuration_liste', liste.id)
        
        flash('Liste d√©roulante ajout√©e avec succ√®s', 'success')
    else:
        # Afficher les erreurs de validation
        for field, errors in form.errors.items():
            for error in errors:
                flash(f'Erreur {field}: {error}', 'error')
    
    return redirect(url_for('parametrage_listes'))


@app.route('/parametrage/champs/reorganiser', methods=['POST'])
@login_required
def reorganiser_champs():
    """R√©organiser les champs par glisser-d√©poser avec isolation multi-tenant"""
    if not current_user.has_permission('can_manage_settings'):
        return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
    
    try:
        data = request.get_json()
        order = data.get('order', [])
        section = data.get('section', 'general')
        
        for index, champ_id in enumerate(order):
            # R√©cup√©rer le champ avec v√©rification d'acc√®s
            champ = get_client_filter(ConfigurationChampRisque)\
                .filter_by(id=int(champ_id))\
                .first()
            
            if champ and champ.section == section and check_client_access(champ):
                champ.ordre_affichage = index
                champ.updated_at = datetime.utcnow()
                db.session.add(champ)
            else:
                print(f"‚ö†Ô∏è Champ {champ_id} inaccessible pour r√©organisation")
        
        db.session.commit()
        
        # Journaliser
        log_activity(current_user.id, 'reorganisation', 
                    f'R√©organisation des champs section {section}', 
                    'configuration_champ', None)
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/parametrage/categorie/supprimer', methods=['POST'])
@login_required
def supprimer_categorie_fichier():
    """Supprimer une cat√©gorie de fichier avec isolation multi-tenant"""
    if not current_user.has_permission('can_manage_settings'):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    categorie = request.form.get('categorie', '').strip()
    
    if not categorie:
        flash('Cat√©gorie non sp√©cifi√©e', 'error')
        return redirect(url_for('parametrage_fichiers'))
    
    # D√©terminer le client_id pour la recherche
    client_id = None
    if current_user.role == 'super_admin' and session.get('viewing_client_id'):
        client_id = session.get('viewing_client_id')
    elif hasattr(current_user, 'client_id') and current_user.client_id:
        client_id = current_user.client_id
    
    try:
        # Rechercher la configuration
        if client_id is not None:
            config = ConfigurationFichier.query.filter_by(
                categorie=categorie,
                client_id=client_id
            ).first()
        else:
            # Pour super admin en mode global, ne peut pas supprimer
            flash('Vous devez s√©lectionner un client sp√©cifique pour supprimer des cat√©gories', 'error')
            return redirect(url_for('parametrage_fichiers'))
        
        if config:
            # V√©rifier si la cat√©gorie est utilis√©e dans des fichiers
            fichiers_count = FichierRisque.query.filter_by(categorie=categorie).count()
            if fichiers_count > 0:
                flash(f'La cat√©gorie "{categorie}" est utilis√©e dans {fichiers_count} fichier(s) et ne peut pas √™tre supprim√©e', 'error')
                return redirect(url_for('parametrage_fichiers'))
            
            db.session.delete(config)
            db.session.commit()
            
            # Journaliser
            log_activity(current_user.id, 'suppression', 
                       f'Suppression cat√©gorie fichiers {categorie}', 
                       'configuration_fichier', config.id)
            
            flash(f'Cat√©gorie "{categorie}" supprim√©e avec succ√®s', 'success')
        else:
            flash('Cat√©gorie non trouv√©e', 'error')
            
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur suppression cat√©gorie: {e}', 'error')
    
    return redirect(url_for('parametrage_fichiers'))


@app.route('/parametrage/categorie/ajouter', methods=['POST'])
@login_required
@csrf.exempt
def ajouter_categorie_fichier():
    """Ajouter une cat√©gorie de fichier avec isolation multi-tenant"""
    if not current_user.has_permission('can_manage_settings'):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    categorie = request.form.get('categorie', '').strip()
    
    if not categorie:
        flash('Cat√©gorie non sp√©cifi√©e', 'error')
        return redirect(url_for('parametrage_fichiers'))
    
    # D√©terminer le client_id
    client_id = None
    if current_user.role == 'super_admin' and session.get('viewing_client_id'):
        client_id = session.get('viewing_client_id')
    elif hasattr(current_user, 'client_id') and current_user.client_id:
        client_id = current_user.client_id
    
    if client_id is None and current_user.role != 'super_admin':
        flash('Client non identifi√©', 'error')
        return redirect(url_for('parametrage_fichiers'))
    
    try:
        # V√©rifier si la cat√©gorie existe d√©j√†
        if client_id is not None:
            existing = ConfigurationFichier.query.filter_by(
                categorie=categorie,
                client_id=client_id
            ).first()
        else:
            # Pour super admin en mode global
            existing = None
        
        if existing:
            flash(f'La cat√©gorie "{categorie}" existe d√©j√† pour ce client', 'warning')
        else:
            config = ConfigurationFichier(
                categorie=categorie,
                client_id=client_id,
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow()
            )
            db.session.add(config)
            db.session.commit()
            
            # Journaliser
            log_activity(current_user.id, 'creation', 
                       f'Ajout cat√©gorie fichiers {categorie}', 
                       'configuration_fichier', config.id)
            
            flash(f'Cat√©gorie "{categorie}" ajout√©e avec succ√®s', 'success')
            
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur ajout cat√©gorie: {e}', 'error')
    
    return redirect(url_for('parametrage_fichiers'))


@app.route('/parametrage/liste/<int:id>/supprimer', methods=['POST'])
@login_required
@csrf.exempt
def supprimer_liste_deroulante(id):
    """Supprimer une liste d√©roulante avec isolation multi-tenant"""
    if not current_user.has_permission('can_manage_settings'):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    # R√©cup√©rer la liste avec v√©rification d'acc√®s
    liste = get_client_object_or_404(ConfigurationListeDeroulante, id)
    
    # V√©rifier si la liste est utilis√©e dans des champs
    champs_utilisant_liste = ConfigurationChampRisque.query.filter(
        ConfigurationChampRisque.type_champ == 'select',
        ConfigurationChampRisque.valeurs_possibles.like(f'%{liste.nom_technique}%')
    ).count()
    
    if champs_utilisant_liste > 0:
        flash(f'Cette liste est utilis√©e dans {champs_utilisant_liste} champ(s) et ne peut pas √™tre supprim√©e', 'error')
        return redirect(url_for('parametrage_listes'))
    
    try:
        db.session.delete(liste)
        db.session.commit()
        
        # Journaliser
        log_activity(current_user.id, 'suppression', 
                   f'Suppression liste d√©roulante {liste.nom_technique}', 
                   'configuration_liste', liste.id)
        
        flash('Liste d√©roulante supprim√©e avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur suppression: {e}', 'error')
    
    return redirect(url_for('parametrage_listes'))

def get_client_parametrage_filtre(model_class, **filters):
    """
    Filtre sp√©cial pour les param√©trages qui peuvent √™tre globaux ou sp√©cifiques
    """
    query = model_class.query
    
    # Super admin en mode global
    if current_user.role == 'super_admin' and not session.get('viewing_client_id'):
        # Voir les configurations globales (client_id=None) ET celles de tous les clients
        return query.filter(
            db.or_(
                model_class.client_id == None,
                model_class.client_id.isnot(None)
            )
        ).filter_by(**filters)
    
    # Super admin visualisant un client sp√©cifique
    if current_user.role == 'super_admin' and session.get('viewing_client_id'):
        client_id = session.get('viewing_client_id')
        return query.filter(
            db.or_(
                model_class.client_id == None,  # Configurations globales
                model_class.client_id == client_id  # Configurations du client
            )
        ).filter_by(**filters)
    
    # Utilisateurs normaux
    if hasattr(current_user, 'client_id') and current_user.client_id:
        client_id = current_user.client_id
        return query.filter(
            db.or_(
                model_class.client_id == None,  # Configurations globales
                model_class.client_id == client_id  # Configurations de leur client
            )
        ).filter_by(**filters)
    
    # Par d√©faut (ne devrait jamais arriver)
    return query.filter_by(**filters)

def get_fichier_configuration():
    """R√©cup√®re la configuration des fichiers pour le client actuel"""
    # Configuration de base
    base_config = {
        'extensions': list(app.config.get('ALLOWED_EXTENSIONS', [])),
        'taille_max_mo': app.config.get('MAX_CONTENT_LENGTH', 10 * 1024 * 1024) // (1024 * 1024)
    }
    
    if current_user.role == 'super_admin' and not session.get('viewing_client_id'):
        # Super admin en mode global : configuration par d√©faut + toutes les cat√©gories clients
        try:
            all_categories = db.session.query(ConfigurationFichier.categorie).distinct().all()
            categories = [cat[0] for cat in all_categories] if all_categories else []
            
            if not categories:
                categories = ['document', 'image', 'analyse', 'autre', 'rapport', 'contrat']
            
            return {**base_config, 'categories': sorted(categories)}
        except:
            return {**base_config, 'categories': ['document', 'image', 'analyse', 'autre', 'rapport', 'contrat']}
    
    # Pour tous les autres cas (client sp√©cifique)
    client_id = None
    
    if current_user.role == 'super_admin' and session.get('viewing_client_id'):
        # Super admin visualisant un client sp√©cifique
        client_id = session.get('viewing_client_id')
    elif hasattr(current_user, 'client_id') and current_user.client_id:
        # Utilisateur normal
        client_id = current_user.client_id
    
    if client_id:
        try:
            configs = ConfigurationFichier.query.filter_by(client_id=client_id).all()
            categories = [config.categorie for config in configs]
            
            if not categories:
                # Cat√©gories par d√©faut si aucune configur√©e
                categories = ['document', 'image', 'analyse', 'autre']
            
            return {**base_config, 'categories': sorted(categories)}
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur r√©cup√©ration config fichiers: {e}")
            return {**base_config, 'categories': ['document', 'image', 'analyse', 'autre']}
    
    # Fallback
    return {**base_config, 'categories': ['document', 'image', 'analyse', 'autre']}

@app.route('/parametrage/liste/<int:id>/editer', methods=['GET', 'POST'])
@login_required
@csrf.exempt
def editer_liste_deroulante(id):
    """√âditer une liste d√©roulante avec isolation multi-tenant"""
    if not current_user.has_permission('can_manage_settings'):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    # R√©cup√©rer la liste avec v√©rification d'acc√®s
    liste = get_client_object_or_404(ConfigurationListeDeroulante, id)
    
    form = ConfigurationListeForm(obj=liste)  # Pr√©-remplir avec les donn√©es existantes
    
    if request.method == 'GET':
        # Pr√©parer les donn√©es pour l'affichage
        if liste.valeurs:
            # Convertir les valeurs dict en format texte
            valeurs_text = []
            for item in liste.valeurs:
                if isinstance(item, dict) and 'valeur' in item and 'label' in item:
                    if item['valeur'] != item['label']:
                        valeurs_text.append(f"{item['valeur']}|{item['label']}")
                    else:
                        valeurs_text.append(item['valeur'])
                else:
                    valeurs_text.append(str(item))
            form.valeurs.data = '\n'.join(valeurs_text)
        
        if liste.valeurs_par_defaut:
            form.valeurs_par_defaut.data = '\n'.join(liste.valeurs_par_defaut)
        
        return render_template('admin/parametrage/editer_liste.html',
                             form=form,
                             liste=liste,
                             current_user=current_user)
    
    # POST: Traitement du formulaire
    if form.validate_on_submit():
        try:
            # Parser les valeurs
            valeurs = []
            for ligne in form.valeurs.data.split('\n'):
                ligne = ligne.strip()
                if ligne:
                    if '|' in ligne:
                        valeur, label = ligne.split('|', 1)
                        valeurs.append({'valeur': valeur.strip(), 'label': label.strip()})
                    else:
                        valeurs.append({'valeur': ligne, 'label': ligne})
            
            # Parser les valeurs par d√©faut
            valeurs_par_defaut = None
            if form.valeurs_par_defaut.data:
                valeurs_par_defaut = [v.strip() for v in form.valeurs_par_defaut.data.split('\n') if v.strip()]
            
            # Mettre √† jour la liste
            liste.nom_technique = form.nom_technique.data
            liste.nom_affichage = form.nom_affichage.data
            liste.est_multiple = form.est_multiple.data
            liste.valeurs = valeurs
            liste.valeurs_par_defaut = valeurs_par_defaut
            liste.est_actif = form.est_actif.data
            liste.updated_at = datetime.utcnow()
            
            db.session.commit()
            
            # Journaliser
            log_activity(current_user.id, 'modification', 
                       f'Modification liste d√©roulante {liste.nom_technique}', 
                       'configuration_liste', liste.id)
            
            flash('Liste d√©roulante mise √† jour avec succ√®s', 'success')
            return redirect(url_for('parametrage_listes'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur mise √† jour: {e}', 'error')
    else:
        # Afficher les erreurs de validation
        for field, errors in form.errors.items():
            for error in errors:
                flash(f'Erreur {field}: {error}', 'error')
    
    return render_template('admin/parametrage/editer_liste.html',
                         form=form,
                         liste=liste,
                         current_user=current_user)

@app.route('/parametrage/liste/<int:id>/options')
@login_required
def get_options_liste(id):
    """R√©cup√©rer les options d'une liste d√©roulante (API)"""
    liste = ConfigurationListeDeroulante.query.get_or_404(id)
    
    options = []
    for item in liste.valeurs:
        options.append([item.get('valeur'), item.get('label', item.get('valeur'))])
    
    return jsonify(options)

@app.route('/parametrage/champ/<int:id>/configuration')
@login_required
def get_configuration_champ(id):
    """API pour r√©cup√©rer la configuration d'un champ (AJAX)"""
    config = ConfigurationChampRisque.query.get_or_404(id)
    
    return jsonify({
        'type_champ': config.type_champ,
        'aide_texte': config.aide_texte,
        'valeurs_possibles': config.valeurs_possibles,
        'est_obligatoire': config.est_obligatoire,
        'section': config.section
    })



# ------------------------------------------------------------
# ROUTES POUR LES CHAMPS PERSONNALIS√âS
# ------------------------------------------------------------

@app.route('/risque/<int:risque_id>/champ/ajouter', methods=['POST'])
@login_required
def ajouter_champ_personnalise(risque_id):
    """Ajouter un champ personnalis√© √† un risque"""
    risque = Risque.query.get_or_404(risque_id)
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_risks') or 
            risque.created_by == current_user.id):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_risque', id=risque_id))
    
    champ_config_id = request.form.get('champ_config_id')
    valeur = request.form.get('valeur')
    
    if not champ_config_id:
        flash('Veuillez s√©lectionner un champ', 'error')
        return redirect(url_for('detail_risque', id=risque_id))
    
    # R√©cup√©rer la configuration
    config = ConfigurationChampRisque.query.get(champ_config_id)
    if not config:
        flash('Configuration de champ non trouv√©e', 'error')
        return redirect(url_for('detail_risque', id=risque_id))
    
    # V√©rifier si le champ existe d√©j√†
    existing = ChampPersonnaliseRisque.query.filter_by(
        risque_id=risque_id,
        nom_technique=config.nom_technique
    ).first()
    
    if existing:
        # Mettre √† jour la valeur existante
        existing.set_valeur(valeur)
        action = 'modification'
        message = 'Champ mis √† jour'
    else:
        # Cr√©er un nouveau champ
        champ = ChampPersonnaliseRisque(
            risque_id=risque_id,
            nom_technique=config.nom_technique
        )
        champ.set_valeur(valeur)
        db.session.add(champ)
        action = 'creation'
        message = 'Champ ajout√©'
    
    db.session.commit()
    
    # üî• SYNCHRONISATION AUTOMATIQUE
    declencher_mise_a_jour_risque(risque_id, f'champ_personnalise_{action}', current_user.id, {
        'champ': config.nom_technique,
        'valeur': valeur
    })
    
    # Journaliser l'action
    log_activity(current_user.id, action, 
                f'{message} du champ {config.nom_technique} pour risque {risque.reference}', 
                'risque', risque_id)
    
    flash(message, 'success')
    return redirect(url_for('detail_risque', id=risque_id))

@app.route('/risque/champ/<int:id>/editer', methods=['GET'])
@login_required
def get_form_edition_champ(id):
    """R√©cup√©rer le formulaire d'√©dition d'un champ (pour modal AJAX)"""
    champ = ChampPersonnaliseRisque.query.get_or_404(id)
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_risks') or 
            champ.risque.created_by == current_user.id):
        return jsonify({'error': 'Acc√®s non autoris√©'}), 403
    
    # R√©cup√©rer la configuration
    config = ConfigurationChampRisque.query.filter_by(
        nom_technique=champ.nom_technique
    ).first()
    
    valeur = champ.get_valeur()
    
    # G√©n√©rer le formulaire selon le type
    html = f'''
    <form method="POST" action="/risque/champ/{id}/modifier">
        <input type="hidden" name="csrf_token" value="{{{{ csrf_token() }}}}">
        
        <div class="mb-3">
            <label class="form-label fw-bold">{config.nom_affichage if config else champ.nom_technique}</label>
    '''
    
    if config:
        if config.type_champ == 'texte':
            valeur_str = valeur or ''
            html += f'<input type="text" class="form-control" name="valeur" value="{valeur_str}">'
        elif config.type_champ == 'textarea':
            valeur_str = valeur or ''
            html += f'<textarea class="form-control" name="valeur" rows="4">{valeur_str}</textarea>'
        elif config.type_champ == 'select':
            html += f'<select class="form-select" name="valeur">'
            if config.valeurs_possibles:
                for option in config.valeurs_possibles:
                    selected = 'selected' if valeur == option else ''
                    html += f'<option value="{option}" {selected}>{option}</option>'
            html += '</select>'
        elif config.type_champ == 'checkbox':
            checked = 'checked' if valeur else ''
            html += f'<div class="form-check"><input type="checkbox" class="form-check-input" name="valeur" value="true" {checked}></div>'
        elif config.type_champ == 'date':
            date_str = valeur.strftime('%Y-%m-%d') if valeur else ''
            html += f'<input type="date" class="form-control" name="valeur" value="{date_str}">'
        elif config.type_champ == 'multiselect':
            html += f'<select class="form-select" name="valeur" multiple size="4">'
            if config.valeurs_possibles:
                for option in config.valeurs_possibles:
                    selected = 'selected' if valeur and option in valeur else ''
                    html += f'<option value="{option}" {selected}>{option}</option>'
            html += '</select>'
            html += '<small class="form-text text-muted">Maintenez Ctrl (Cmd sur Mac) pour s√©lectionner plusieurs valeurs</small>'
    else:
        # Configuration par d√©faut pour les champs non configur√©s
        valeur_str = valeur or ''
        html += f'<input type="text" class="form-control" name="valeur" value="{valeur_str}">'
    
    html += '''
        </div>
        <div class="d-flex justify-content-between">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
            <button type="submit" class="btn btn-primary">Enregistrer</button>
        </div>
    </form>
    '''
    
    return html

@app.route('/risque/champ/<int:id>/modifier', methods=['POST'])
@csrf.exempt
@login_required
def modifier_champ_personnalise(id):
    """Modifier un champ personnalis√©"""
    champ = ChampPersonnaliseRisque.query.get_or_404(id)
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_risks') or 
            champ.risque.created_by == current_user.id):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_risque', id=champ.risque_id))
    
    valeur = request.form.get('valeur')
    
    # Gestion sp√©ciale pour les checkbox
    if valeur == 'true':
        valeur = True
    elif valeur == 'false':
        valeur = False
    # Gestion sp√©ciale pour les multiselect
    elif isinstance(valeur, str) and valeur.startswith('[') and valeur.endswith(']'):
        try:
            import json
            valeur = json.loads(valeur)
        except:
            valeur = [valeur]
    
    ancienne_valeur = champ.get_valeur()
    champ.set_valeur(valeur)
    db.session.commit()
    
    # üî• SYNCHRONISATION AUTOMATIQUE
    declencher_mise_a_jour_risque(champ.risque_id, 'champ_personnalise_modifie', current_user.id, {
        'champ': champ.nom_technique,
        'ancienne_valeur': ancienne_valeur,
        'nouvelle_valeur': valeur
    })
    
    # Journaliser l'action
    log_activity(current_user.id, 'modification', 
                f'Modification du champ {champ.nom_technique} pour risque {champ.risque.reference}', 
                'risque', champ.risque_id)
    
    flash('Champ modifi√© avec succ√®s', 'success')
    return redirect(url_for('detail_risque', id=champ.risque_id))


# ------------------------------------------------------------
# ROUTES POUR LES FICHIERS
# ------------------------------------------------------------

@app.route('/risque/<int:risque_id>/fichier/ajouter', methods=['POST'])
@login_required
def ajouter_fichier_risque(risque_id):
    """Ajouter un fichier √† un risque"""
    risque = Risque.query.get_or_404(risque_id)
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_risks') or 
            risque.created_by == current_user.id):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_risque', id=risque_id))
    
    if 'fichier' not in request.files:
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(url_for('detail_risque', id=risque_id))
    
    fichier = request.files['fichier']
    
    if fichier.filename == '':
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(url_for('detail_risque', id=risque_id))
    
    # V√©rifier l'extension
    allowed_extensions = app.config['ALLOWED_EXTENSIONS']
    if '.' in fichier.filename:
        extension = fichier.filename.rsplit('.', 1)[1].lower()
        if extension not in allowed_extensions:
            flash(f'Extension non autoris√©e: {extension}. Formats autoris√©s: {", ".join(allowed_extensions)}', 'error')
            return redirect(url_for('detail_risque', id=risque_id))
    
    # V√©rifier la taille (max 10Mo par d√©faut)
    max_size = 10 * 1024 * 1024  # 10Mo en octets
    fichier.seek(0, 2)  # Aller √† la fin du fichier
    size = fichier.tell()
    fichier.seek(0)  # Retourner au d√©but
    
    if size > max_size:
        flash(f'Fichier trop volumineux ({size/1024/1024:.2f} Mo). Maximum: 10 Mo', 'error')
        return redirect(url_for('detail_risque', id=risque_id))
    
    # Sauvegarder le fichier
    nom_fichier = secure_filename(fichier.filename)
    timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
    nom_unique = f"{timestamp}_{nom_fichier}"
    
    dossier = os.path.join(app.config['UPLOAD_FOLDER_RISQUES'], str(risque_id))
    os.makedirs(dossier, exist_ok=True)
    chemin = os.path.join(dossier, nom_unique)
    
    fichier.save(chemin)
    
    # Enregistrer en base
    fichier_db = FichierRisque(
        risque_id=risque_id,
        nom_fichier=nom_fichier,
        chemin_fichier=chemin,
        type_fichier=fichier.content_type,
        taille=size,
        categorie=request.form.get('categorie', 'document'),
        description=request.form.get('description', ''),
        uploaded_by=current_user.id
    )
    
    db.session.add(fichier_db)
    db.session.commit()
    
    # üî• SYNCHRONISATION AUTOMATIQUE
    declencher_mise_a_jour_risque(risque_id, 'fichier_ajoute', current_user.id, {
        'fichier': nom_fichier,
        'categorie': request.form.get('categorie', 'document')
    })
    
    # Journaliser l'action
    log_activity(current_user.id, 'creation', 
                f'Ajout du fichier {nom_fichier} au risque {risque.reference}', 
                'risque', risque_id)
    
    flash('Fichier ajout√© avec succ√®s', 'success')
    return redirect(url_for('detail_risque', id=risque_id))

@app.route('/risque/fichier/<int:id>/telecharger')
@login_required
def telecharger_fichier_risque(id):
    """T√©l√©charger un fichier attach√© √† un risque"""
    fichier = FichierRisque.query.get_or_404(id)
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_risks') or 
            fichier.risque.created_by == current_user.id or
            current_user.id == fichier.uploaded_by):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    # Journaliser le t√©l√©chargement
    log_activity(current_user.id, 'consultation', 
                f'T√©l√©chargement du fichier {fichier.nom_fichier} du risque {fichier.risque.reference}', 
                'risque', fichier.risque_id)
    
    return send_file(fichier.chemin_fichier, 
                    as_attachment=True, 
                    download_name=fichier.nom_fichier)
@app.route('/risque/fichier/<int:id>/supprimer', methods=['POST'])
@login_required
@csrf.exempt
def supprimer_fichier_risque(id):
    """Supprimer un fichier attach√© √† un risque"""
    print(f"üîç DEBUG: Route supprimer_fichier_risque appel√©e avec id={id}")
    
    fichier = FichierRisque.query.get_or_404(id)
    risque_id = fichier.risque_id
    
    print(f"üîç DEBUG: Fichier {fichier.nom_fichier} trouv√© pour risque {risque_id}")
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_risks') or 
            fichier.risque.created_by == current_user.id or
            current_user.id == fichier.uploaded_by):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_risque', id=risque_id))
    
    try:
        # Supprimer le fichier physique
        if os.path.exists(fichier.chemin_fichier):
            os.remove(fichier.chemin_fichier)
            print(f"üîç DEBUG: Fichier physique supprim√©: {fichier.chemin_fichier}")
        
        # Journaliser l'action avant suppression
        log_activity(current_user.id, 'suppression_fichier', 
                    f'Suppression du fichier {fichier.nom_fichier} du risque {fichier.risque.reference}', 
                    'fichier_risque', id)
        
        # Supprimer l'enregistrement en base
        db.session.delete(fichier)
        db.session.commit()
        
        print(f"üîç DEBUG: Enregistrement base supprim√© avec succ√®s")
        
        # Synchronisation automatique
        try:
            declencher_mise_a_jour_risque(risque_id, 'fichier_supprime', current_user.id, {
                'fichier': fichier.nom_fichier
            })
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur synchronisation: {e}")
        
        flash('Fichier supprim√© avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur suppression: {e}")
        flash(f'Erreur lors de la suppression: {str(e)}', 'error')
    
    return redirect(url_for('detail_risque', id=risque_id))


# ========================
# ROUTES D'EXPORT/IMPORT
# ========================

@app.route('/parametrage/export', methods=['POST'])
@login_required
def exporter_configuration():
    """Exporter la configuration au format JSON"""
    if not current_user.has_permission('can_manage_settings'):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    data = {
        'export_date': datetime.utcnow().isoformat(),
        'version': '1.0',
        'configuration': {}
    }
    
    if request.form.get('export_champs'):
        champs = ConfigurationChampRisque.query.all()
        data['configuration']['champs'] = [
            {
                'nom_technique': c.nom_technique,
                'nom_affichage': c.nom_affichage,
                'type_champ': c.type_champ,
                'est_obligatoire': c.est_obligatoire,
                'est_actif': c.est_actif,
                'ordre_affichage': c.ordre_affichage,
                'section': c.section,
                'aide_texte': c.aide_texte,
                'valeurs_possibles': c.valeurs_possibles,
                'regex_validation': c.regex_validation
            }
            for c in champs
        ]
    
    if request.form.get('export_listes'):
        listes = ConfigurationListeDeroulante.query.all()
        data['configuration']['listes'] = [
            {
                'nom_technique': l.nom_technique,
                'nom_affichage': l.nom_affichage,
                'est_multiple': l.est_multiple,
                'valeurs': l.valeurs,
                'valeurs_par_defaut': l.valeurs_par_defaut,
                'est_actif': l.est_actif
            }
            for l in listes
        ]
    
    # Cr√©er un fichier JSON temporaire
    import tempfile
    import json as json_module
    
    with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
        json_module.dump(data, f, indent=2, ensure_ascii=False)
        temp_path = f.name
    
    # Envoyer le fichier
    return send_file(temp_path, 
                    as_attachment=True, 
                    download_name=f'configuration_risque_{datetime.utcnow().strftime("%Y%m%d_%H%M%S")}.json')
@app.route('/risque/<int:id>/exporter')
@login_required
def exporter_risque(id):
    """Exporter un risque sp√©cifique au format PDF ou Excel"""
    risque = Risque.query.get_or_404(id)
    
    if not current_user.has_permission('can_export_data'):
        flash('Vous n\'avez pas la permission d\'exporter des donn√©es', 'error')
        return redirect(url_for('detail_risque', id=id))
    
    # Logique d'export ici
    # Pour l'instant, rediriger vers la page d'export g√©n√©rale
    flash('Fonction d\'export sp√©cifique en d√©veloppement', 'info')
    return redirect(url_for('detail_risque', id=id))

@app.route('/parametrage/import', methods=['POST'])
@login_required
def importer_configuration():
    """Importer une configuration depuis un fichier JSON"""
    if not current_user.has_permission('can_manage_settings'):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    if 'fichier_config' not in request.files:
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(url_for('parametrage_risque'))
    
    fichier = request.files['fichier_config']
    mode_import = request.form.get('mode_import', 'fusion')
    
    if fichier.filename == '':
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(url_for('parametrage_risque'))
    
    try:
        import json as json_module
        data = json_module.load(fichier)
        
        if mode_import == 'remplacer':
            # Supprimer les configurations existantes
            ConfigurationChampRisque.query.delete()
            ConfigurationListeDeroulante.query.delete()
        
        # Importer les champs
        if 'champs' in data.get('configuration', {}):
            for champ_data in data['configuration']['champs']:
                existing = ConfigurationChampRisque.query.filter_by(
                    nom_technique=champ_data['nom_technique']
                ).first()
                
                if existing and mode_import == 'fusion':
                    # Mettre √† jour l'existant
                    existing.nom_affichage = champ_data['nom_affichage']
                    existing.type_champ = champ_data['type_champ']
                    existing.est_obligatoire = champ_data['est_obligatoire']
                    existing.est_actif = champ_data['est_actif']
                    existing.ordre_affichage = champ_data['ordre_affichage']
                    existing.section = champ_data['section']
                    existing.aide_texte = champ_data['aide_texte']
                    existing.valeurs_possibles = champ_data['valeurs_possibles']
                    existing.regex_validation = champ_data['regex_validation']
                else:
                    # Cr√©er un nouveau champ
                    champ = ConfigurationChampRisque(**champ_data)
                    db.session.add(champ)
        
        # Importer les listes
        if 'listes' in data.get('configuration', {}):
            for liste_data in data['configuration']['listes']:
                existing = ConfigurationListeDeroulante.query.filter_by(
                    nom_technique=liste_data['nom_technique']
                ).first()
                
                if existing and mode_import == 'fusion':
                    # Mettre √† jour l'existant
                    existing.nom_affichage = liste_data['nom_affichage']
                    existing.est_multiple = liste_data['est_multiple']
                    existing.valeurs = liste_data['valeurs']
                    existing.valeurs_par_defaut = liste_data['valeurs_par_defaut']
                    existing.est_actif = liste_data['est_actif']
                else:
                    # Cr√©er une nouvelle liste
                    liste = ConfigurationListeDeroulante(**liste_data)
                    db.session.add(liste)
        
        db.session.commit()
        flash('Configuration import√©e avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de l\'import: {str(e)}', 'error')
    
    return redirect(url_for('parametrage_risque'))


# ========================
# FONCTIONS DE SYNCHRONISATION
# ========================

def synchroniser_configuration_champ(champ):
    """Synchroniser l'ajout d'un champ avec toutes les fiches de risque"""
    print(f"üîÑ Synchronisation champ ajout√©: {champ.nom_technique}")
    
    # Pour les champs obligatoires, cr√©er des entr√©es vides pour tous les risques existants
    if champ.est_obligatoire and champ.est_actif:
        risques = Risque.query.filter_by(is_archived=False).all()
        
        for risque in risques:
            # V√©rifier si le champ existe d√©j√†
            existing = ChampPersonnaliseRisque.query.filter_by(
                risque_id=risque.id,
                nom_technique=champ.nom_technique
            ).first()
            
            if not existing:
                # Cr√©er une entr√©e vide
                champ_perso = ChampPersonnaliseRisque(
                    risque_id=risque.id,
                    nom_technique=champ.nom_technique
                )
                champ_perso.set_valeur(champ.valeurs_possibles[0] if champ.valeurs_possibles else '')
                db.session.add(champ_perso)
        
        db.session.commit()
        print(f"‚úÖ Champ ajout√© √† {len(risques)} risques existants")


def synchroniser_modification_champ(champ):
    """Synchroniser la modification d'un champ"""
    print(f"üîÑ Synchronisation modification champ: {champ.nom_technique}")
    
    # Mettre √† jour le nom d'affichage dans les logs d'activit√© si n√©cessaire
    # (impl√©mentation sp√©cifique selon vos besoins)


def declencher_mise_a_jour_risque(risque_id, action, utilisateur_id, donnees_supplementaires=None):
    """D√©clencher une mise √† jour automatique pour un risque"""
    risque = Risque.query.get(risque_id)
    if not risque:
        print(f"‚ùå Risque {risque_id} non trouv√© pour mise √† jour")
        return
    
    from flask import request
    import json  # Ajoutez cet import
    
    ip_address = None
    user_agent = None
    
    try:
        if request:
            ip_address = request.remote_addr
            user_agent = request.user_agent.string
    except RuntimeError:
        pass
    
    # CORRECTION : Convertir le dictionnaire en JSON string
    details_json = None
    if donnees_supplementaires:
        if isinstance(donnees_supplementaires, dict):
            details_json = json.dumps(donnees_supplementaires, ensure_ascii=False)
        elif isinstance(donnees_supplementaires, list):
            details_json = json.dumps(donnees_supplementaires, ensure_ascii=False)
        else:
            details_json = str(donnees_supplementaires)
    
    # Journaliser l'action
    journal = JournalActivite(
        utilisateur_id=utilisateur_id,
        action=action,
        details=details_json,  # CORRECTION : Utiliser JSON string au lieu de dict
        entite_type='risque',
        entite_id=risque_id,
        ip_address=ip_address,
        user_agent=user_agent
    )
    
    db.session.add(journal)
    
    try:
        db.session.commit()
        print(f"üìù Activit√© journalis√©e: {action} pour risque {risque_id}")
    except Exception as e:
        db.session.rollback()  # IMPORTANT : Rollback en cas d'erreur
        print(f"‚ùå Erreur journalisation: {e}")
        # Continuer sans bloquer
    
    # Synchroniser les matrices si n√©cessaire
    actions_sync = [
        'champ_personnalise_ajoute', 'champ_personnalise_modifie',
        'fichier_ajoute', 'fichier_supprime', 'evaluation_modifiee',
        'kri_associe', 'kri_modifie', 'risque_modifie'
    ]
    
    if action in actions_sync:
        try:
            synchroniser_matrices_apres_modification(risque.cartographie_id)
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur synchronisation matrices: {e}")


def synchroniser_matrices_apres_modification(cartographie_id):
    """Synchroniser les matrices apr√®s modification d'un risque"""
    try:
        # Import local pour √©viter les d√©pendances circulaires
        from utils import synchroniser_matrices_apres_evaluation_triphase  # CORRECTION : changer le nom
        synchroniser_matrices_apres_evaluation_triphase(cartographie_id)  # CORRECTION : changer le nom
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur synchronisation matrices: {e}")

# ============================================================================
# ROUTES API POUR L'ORGANIGRAMME FLUIDE - CORRIG√âES
# ============================================================================
@app.route('/api/processus/<int:processus_id>/etapes', methods=['POST'])
@login_required
def api_creer_etape_simple(processus_id):
    """Cr√©er une √©tape - VERSION CORRIG√âE ET TEST√âE"""
    try:
        print(f"üÜï Cr√©ation √©tape pour processus {processus_id}")
        
        # V√©rifier que le processus existe
        processus = Processus.query.get_or_404(processus_id)
        
        # R√©cup√©rer les donn√©es JSON
        data = request.get_json()
        print(f"üì® Donn√©es re√ßues:", data)
        
        if not data:
            return jsonify({'success': False, 'error': 'Donn√©es JSON manquantes'}), 400
        
        # Validation des champs requis
        nom = data.get('nom', 'Nouvelle √©tape').strip()
        if not nom:
            return jsonify({'success': False, 'error': 'Le nom est requis'}), 400
        
        type_etape = data.get('type_etape', 'action')
        
        # Calculer l'ordre automatique
        derniere_etape = EtapeProcessus.query.filter_by(
            processus_id=processus_id
        ).order_by(EtapeProcessus.ordre.desc()).first()
        
        ordre = (derniere_etape.ordre + 1) if derniere_etape else 1
        
        # Positions par d√©faut selon le type
        positions_par_defaut = {
            'debut': (100, 100),
            'action': (300, 200),
            'decision': (500, 200),
            'risque': (300, 400),
            'controle': (500, 400),
            'fin': (700, 100)
        }
        
        position_x = data.get('position_x')
        position_y = data.get('position_y')
        
        if position_x is None or position_y is None:
            pos_defaut = positions_par_defaut.get(type_etape, (ordre * 200, 100))
            position_x = pos_defaut[0]
            position_y = pos_defaut[1]
        
        # Couleurs par d√©faut selon le type
        couleurs_par_defaut = {
            'debut': '#28a745',
            'action': '#007bff', 
            'decision': '#ffc107',
            'risque': '#dc3545',
            'controle': '#6f42c1',
            'fin': '#6c757d'
        }
        
        couleur = data.get('couleur', couleurs_par_defaut.get(type_etape, '#007bff'))
        
        # Cr√©er l'√©tape
        etape = EtapeProcessus(
            processus_id=processus_id,
            ordre=ordre,
            nom=nom,
            description=data.get('description', ''),
            type_etape=type_etape,
            position_x=position_x,
            position_y=position_y,
            couleur=couleur,
            responsable_id=data.get('responsable_id')
        )
        
        db.session.add(etape)
        db.session.commit()
        
        print(f"‚úÖ √âtape cr√©√©e: {etape.id} - {etape.nom} √† ({etape.position_x}, {etape.position_y})")
        
        # Synchronisation
        synchroniser_organigramme_complet(processus_id)
        
        return jsonify({
            'success': True,
            'etape': {
                'id': etape.id,
                'nom': etape.nom,
                'type_etape': etape.type_etape,
                'description': etape.description,
                'position_x': etape.position_x,
                'position_y': etape.position_y,
                'couleur': etape.couleur,
                'ordre': etape.ordre
            }
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur cr√©ation √©tape: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/processus/<int:processus_id>/liens', methods=['POST'])
@login_required
def api_creer_lien_simple(processus_id):
    """Cr√©er un lien - VERSION SIMPLIFI√âE"""
    try:
        print(f"üîó Cr√©ation lien pour processus {processus_id}")
        
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'error': 'Donn√©es manquantes'}), 400
        
        # Validation des champs requis
        source = data.get('source')
        cible = data.get('cible')
        
        if not source or not cible:
            return jsonify({'success': False, 'error': 'Source et cible requis'}), 400
        
        # V√©rifier que les √©tapes existent
        etape_source = EtapeProcessus.query.get(int(source))
        etape_cible = EtapeProcessus.query.get(int(cible))
        
        if not etape_source or not etape_cible:
            return jsonify({'success': False, 'error': '√âtape source ou cible non trouv√©e'}), 404
        
        # V√©rifier si le lien existe d√©j√†
        lien_existant = LienProcessus.query.filter_by(
            processus_id=processus_id,
            etape_source_id=source,
            etape_cible_id=cible
        ).first()
        
        if lien_existant:
            return jsonify({
                'success': False, 
                'error': 'Ce lien existe d√©j√†',
                'lien_id': lien_existant.id
            }), 400
        
        # Cr√©er le lien
        lien = LienProcessus(
            processus_id=processus_id,
            etape_source_id=int(source),
            etape_cible_id=int(cible),
            type_lien=data.get('type', 'sequence'),
            label=data.get('label', '')
        )
        
        db.session.add(lien)
        db.session.commit()
        
        print(f"‚úÖ Lien cr√©√©: {lien.id} ({source} ‚Üí {cible})")
        
        # Synchronisation
        synchroniser_organigramme_complet(processus_id)
        
        return jsonify({
            'success': True,
            'lien': {
                'id': lien.id,
                'source': lien.etape_source_id,
                'cible': lien.etape_cible_id,
                'type': lien.type_lien,
                'label': lien.label
            }
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur cr√©ation lien: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/processus/<int:processus_id>/lignes', methods=['POST'])
@login_required
def api_creer_ligne(processus_id):
    """Cr√©er une ligne d'organisation - CORRIG√âE"""
    try:
        data = request.get_json()
        
        ligne = LigneOrganisation(
            processus_id=processus_id,
            type_ligne=data.get('type', 'verticale'),
            position_x=data.get('x', 0),
            position_y=data.get('y', 100),
            couleur=data.get('couleur', '#6c757d'),
            epaisseur=data.get('epaisseur', 2),
            style=data.get('style', 'solid')
        )
        
        db.session.add(ligne)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'ligne': {
                'id': ligne.id,
                'type': ligne.type_ligne,
                'x': ligne.position_x,
                'y': ligne.position_y,
                'couleur': ligne.couleur,
                'epaisseur': ligne.epaisseur,
                'style': ligne.style
            }
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/processus/<int:processus_id>/titres', methods=['POST'])
@login_required
def api_creer_titre(processus_id):
    """Cr√©er un titre d'organisation - CORRIG√âE"""
    try:
        data = request.get_json()
        
        titre = TitreOrganisation(
            processus_id=processus_id,
            texte=data.get('texte', 'Nouveau titre'),
            position_x=data.get('x', 100),
            position_y=data.get('y', 100),
            couleur=data.get('couleur', '#000000'),
            taille_police=data.get('taille', 20),
            gras=data.get('gras', False),
            italique=data.get('italique', False)
        )
        
        db.session.add(titre)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'titre': {
                'id': titre.id,
                'texte': titre.texte,
                'x': titre.position_x,
                'y': titre.position_y,
                'couleur': titre.couleur,
                'taille': titre.taille_police,
                'gras': titre.gras,
                'italique': titre.italique
            }
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500
# ============================================================================
# ROUTES CORRIG√âES POUR LES CONNEXIONS ET ORGANIGRAMME
# ============================================================================

@app.route('/api/processus/<int:processus_id>/lien/existe', methods=['POST'])
@login_required
def api_verifier_lien_existe(processus_id):
    """V√©rifier si un lien existe d√©j√† entre deux √©tapes - CORRIG√âE"""
    try:
        data = request.get_json()
        source_id = data.get('source')
        cible_id = data.get('cible')
        
        print(f"üîç V√©rification lien: {source_id} -> {cible_id}")
        
        if not source_id or not cible_id:
            return jsonify({'success': False, 'error': 'Source et cible requis'}), 400
        
        # Convertir en entiers
        source_id = int(source_id)
        cible_id = int(cible_id)
        
        lien_existant = LienProcessus.query.filter_by(
            processus_id=processus_id,
            etape_source_id=source_id,
            etape_cible_id=cible_id
        ).first()
        
        existe = lien_existant is not None
        print(f"‚úÖ Lien existe: {existe}")
        
        return jsonify({
            'success': True,
            'existe': existe,
            'lien_id': lien_existant.id if lien_existant else None
        })
        
    except Exception as e:
        print(f"‚ùå Erreur v√©rification lien: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/processus/<int:processus_id>/lignes', methods=['GET', 'POST'])
@login_required
def api_lignes_processus(processus_id):
    """API pour g√©rer les lignes d'organisation - CORRIG√âE"""
    try:
        if request.method == 'GET':
            # R√©cup√©rer les lignes existantes
            lignes = LigneOrganisation.query.filter_by(processus_id=processus_id).all()
            return jsonify({
                'success': True,
                'lignes': [{
                    'id': l.id,
                    'type': l.type_ligne,
                    'x': l.position_x,
                    'y': l.position_y,
                    'couleur': l.couleur,
                    'epaisseur': l.epaisseur,
                    'style': l.style
                } for l in lignes]
            })
        
        elif request.method == 'POST':
            data = request.get_json()
            
            # Cr√©er une nouvelle ligne
            ligne = LigneOrganisation(
                processus_id=processus_id,
                type_ligne=data.get('type', 'horizontale'),
                position_x=data.get('x', 0),
                position_y=data.get('y', 100),
                couleur=data.get('couleur', '#6c757d'),
                epaisseur=data.get('epaisseur', 2),
                style=data.get('style', 'solid')
            )
            
            db.session.add(ligne)
            db.session.commit()
            
            return jsonify({
                'success': True,
                'ligne': {
                    'id': ligne.id,
                    'type': ligne.type_ligne,
                    'x': ligne.position_x,
                    'y': ligne.position_y,
                    'couleur': ligne.couleur,
                    'epaisseur': ligne.epaisseur,
                    'style': ligne.style
                }
            })
            
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur API lignes: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/processus/<int:processus_id>/titres', methods=['GET', 'POST'])
@login_required
def api_titres_processus(processus_id):
    """API pour g√©rer les titres d'organisation - CORRIG√âE"""
    try:
        if request.method == 'GET':
            # R√©cup√©rer les titres existants
            titres = TitreOrganisation.query.filter_by(processus_id=processus_id).all()
            return jsonify({
                'success': True,
                'titres': [{
                    'id': t.id,
                    'texte': t.texte,
                    'x': t.position_x,
                    'y': t.position_y,
                    'couleur': t.couleur,
                    'taille': t.taille_police,
                    'gras': t.gras,
                    'italique': t.italique
                } for t in titres]
            })
        
        elif request.method == 'POST':
            data = request.get_json()
            
            # Cr√©er un nouveau titre
            titre = TitreOrganisation(
                processus_id=processus_id,
                texte=data.get('texte', 'Nouveau titre'),
                position_x=data.get('x', 100),
                position_y=data.get('y', 100),
                couleur=data.get('couleur', '#000000'),
                taille_police=data.get('taille', 20),
                gras=data.get('gras', False),
                italique=data.get('italique', False)
            )
            
            db.session.add(titre)
            db.session.commit()
            
            return jsonify({
                'success': True,
                'titre': {
                    'id': titre.id,
                    'texte': titre.texte,
                    'x': titre.position_x,
                    'y': titre.position_y,
                    'couleur': titre.couleur,
                    'taille': titre.taille_police,
                    'gras': titre.gras,
                    'italique': titre.italique
                }
            })
            
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur API titres: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

# Route pour cr√©er un label de lien
@app.route('/api/lien/<int:lien_id>/label', methods=['PUT'])
@login_required
def api_mettre_a_jour_label_lien(lien_id):
    """Mettre √† jour le label d'un lien - CORRIG√âE"""
    try:
        data = request.get_json()
        lien = LienProcessus.query.get_or_404(lien_id)
        
        lien.label = data.get('label', '')
        db.session.commit()
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

# Route pour supprimer un lien
@app.route('/api/etape/<int:etape_id>', methods=['DELETE'])
@login_required
def api_supprimer_etape(etape_id):
    """Supprimer une √©tape - VERSION UNIQUE"""
    try:
        etape = EtapeProcessus.query.get_or_404(etape_id)
        processus_id = etape.processus_id
        
        print(f"üóëÔ∏è Suppression √©tape {etape_id}")
        
        # Supprimer les liens associ√©s
        LienProcessus.query.filter(
            (LienProcessus.etape_source_id == etape_id) | 
            (LienProcessus.etape_cible_id == etape_id)
        ).delete()
        
        db.session.delete(etape)
        db.session.commit()
        
        # Synchronisation
        synchroniser_organigramme_complet(processus_id)
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur suppression √©tape: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

    

@app.route('/risque/<int:id>/supprimer', methods=['POST'])
@login_required
def supprimer_risque(id):
    """Supprimer un risque (uniquement s'il n'a pas d'√©valuations)"""
    risque = Risque.query.get_or_404(id)
    
    # V√©rifier les permissions
    if current_user.id != risque.created_by and current_user.role != 'admin':
        flash('Vous n\'√™tes pas autoris√© √† supprimer ce risque', 'error')
        return redirect(url_for('detail_risque', id=id))
    
    # V√©rifier s'il y a des √©valuations associ√©es
    if risque.evaluations:
        flash('Impossible de supprimer ce risque car il a des √©valuations associ√©es. Archivez-le √† la place.', 'error')
        return redirect(url_for('detail_risque', id=id))
    
    cartographie_id = risque.cartographie_id
    
    # Supprimer les KRI associ√©s s'ils existent
    kri = KRI.query.filter_by(risque_id=id).first()
    if kri:
        MesureKRI.query.filter_by(kri_id=kri.id).delete()
        db.session.delete(kri)
    
    db.session.delete(risque)
    db.session.commit()
    flash('Risque supprim√© avec succ√®s', 'success')
    return redirect(url_for('detail_cartographie', id=cartographie_id))


@app.route('/api/processus/<int:processus_id>/organisation', methods=['GET', 'POST'])
@login_required
def api_organisation_processus(processus_id):
    """API pour g√©rer les √©l√©ments d'organisation (lignes, titres) - CORRIG√â"""
    if request.method == 'GET':
        try:
            # Pour l'instant, retourner des donn√©es vides
            # Vous pouvez impl√©menter la logique pour r√©cup√©rer les lignes et titres
            return jsonify({
                'lignes': [],
                'titres': [],
                'zones_risque': []
            })
        except Exception as e:
            return jsonify({'error': str(e)}), 500
    
    elif request.method == 'POST':
        try:
            data = request.get_json()
            
            # Sauvegarder les √©l√©ments d'organisation
            # √Ä impl√©menter selon votre mod√®le de donn√©es
            
            return jsonify({'success': True, 'message': 'Organisation sauvegard√©e'})
        except Exception as e:
            return jsonify({'success': False, 'error': str(e)}), 500

# ============================================================================
# FONCTIONS DE SYNCHRONISATION - CORRIG√âES
# ============================================================================

def synchroniser_etape_organigramme(etape_id, action_type, user_id):
    """Synchronise une √©tape avec l'organigramme fluide - CORRIG√âE"""
    try:
        etape = EtapeProcessus.query.get(etape_id)
        if not etape:
            print(f"‚ùå √âtape {etape_id} non trouv√©e pour synchronisation")
            return False
        
        print(f"üîÑ Synchronisation √©tape {etape_id} ({action_type})")
        
        # Forcer la synchronisation du processus parent
        synchroniser_organigramme_complet(etape.processus_id)
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur synchronisation √©tape {etape_id}: {str(e)}")
        return False


@app.route('/admin/synchroniser-donnees')
@login_required
def synchroniser_donnees():
    """Route admin pour forcer la synchronisation des donn√©es"""
    if current_user.role != 'admin':
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    try:
        from utils import synchroniser_donnees_globales
        resultat = synchroniser_donnees_globales()
        
        if resultat:
            flash('Synchronisation des donn√©es r√©ussie', 'success')
        else:
            flash('Erreur lors de la synchronisation', 'error')
            
    except Exception as e:
        flash(f'Erreur synchronisation: {str(e)}', 'error')
    
    return redirect(url_for('dashboard'))

@app.route('/debug/synchronisation')
@login_required
def debug_synchronisation():
    """Route pour debuguer la synchronisation des donn√©es"""
    if current_user.role != 'admin':
        flash('Acc√®s r√©serv√© aux administrateurs', 'error')
        return redirect(url_for('dashboard'))
    
    from utils import debug_synchronisation as debug_sync
    resultat = debug_sync()
    
    # Afficher les r√©sultats dans la page
    return f"""
    <h1>Debug Synchronisation</h1>
    <pre>
    Total risques: {resultat['total_risques']}
    Risques actifs: {resultat['risques_actifs']} 
    Risques archiv√©s: {resultat['risques_archives']}
    </pre>
    <a href="{{ url_for('dashboard') }}">Retour au dashboard</a>
    """


# Routes pour l'administration
# Routes pour l'administration
@app.route('/risques')
@login_required
def liste_risques():
    """Liste des risques avec isolation multi-tenant et filtres par cartographie/campagne"""
    from sqlalchemy.orm import joinedload
    from sqlalchemy import func
    
    # ========================
    # 1. R√âCUP√âRATION DES FILTRES
    # ========================
    cartographie_id = request.args.get('cartographie_id', type=int)
    campagne_id = request.args.get('campagne_id', type=int)
    filtre_niveau = request.args.get('niveau')
    filtre_statut = request.args.get('statut')
    
    # ========================
    # 2. FILTRE PRINCIPAL
    # ========================
    base_query = get_client_filter(Risque).filter_by(is_archived=False)
    
    # Filtre par cartographie
    if cartographie_id:
        base_query = base_query.filter_by(cartographie_id=cartographie_id)
    
    # ========================
    # 3. SOUS-REQU√äTE POUR LES √âVALUATIONS PAR CAMPAGNE
    # ========================
    if campagne_id:
        # Si on filtre par campagne, on ne veut que les risques √©valu√©s dans cette campagne
        # OU les risques non √©valu√©s (selon le besoin)
        risques_avec_eval_campagne = db.session.query(EvaluationRisque.risque_id)\
            .filter(EvaluationRisque.campagne_id == campagne_id)\
            .subquery()
        
        # Option 1: Uniquement les risques √©valu√©s dans cette campagne
        base_query = base_query.filter(Risque.id.in_(risques_avec_eval_campagne))
        
        # Option 2 (alternative): Tous les risques, avec indication de l'√©valuation
        # Pour cette option, on garde la requ√™te sans filtre mais on ajoute des infos plus tard
    
    # ========================
    # 4. OPTIMISATION DES JOINTURES
    # ========================
    risques_query = base_query\
        .options(
            joinedload(Risque.cartographie),
            joinedload(Risque.createur),
            joinedload(Risque.kri),
            joinedload(Risque.evaluations)
        )\
        .order_by(Risque.reference)
    
    # ========================
    # 5. PAGINATION
    # ========================
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    
    risques = risques_query.paginate(
        page=page,
        per_page=per_page,
        error_out=False
    )
    
    # ========================
    # 6. STATISTIQUES
    # ========================
    # Sous-requ√™te pour les derni√®res √©valuations
    derniere_eval_subq = db.session.query(
        EvaluationRisque.risque_id,
        func.max(EvaluationRisque.created_at).label('max_date')
    ).group_by(EvaluationRisque.risque_id).subquery()
    
    # Compter les risques critiques
    risques_critiques_query = db.session.query(Risque.id).join(
        EvaluationRisque, Risque.id == EvaluationRisque.risque_id
    ).join(
        derniere_eval_subq,
        (EvaluationRisque.risque_id == derniere_eval_subq.c.risque_id) &
        (EvaluationRisque.created_at == derniere_eval_subq.c.max_date)
    ).filter(
        Risque.is_archived == False,
        EvaluationRisque.niveau_risque == 'Critique'
    )
    
    # Appliquer les m√™mes filtres aux stats
    stats_query = get_client_filter(Risque).filter_by(is_archived=False)
    if cartographie_id:
        stats_query = stats_query.filter_by(cartographie_id=cartographie_id)
    
    stats = {
        'total': stats_query.count(),
        'critiques': risques_critiques_query.distinct().count(),
        'avec_evaluations': stats_query.filter(Risque.evaluations.any()).count(),
        'sans_evaluations': stats_query.filter(~Risque.evaluations.any()).count(),
        'avec_kri': stats_query.filter(Risque.kri.has()).count(),
        'sans_kri': stats_query.filter(~Risque.kri.has()).count(),
        'archives': get_client_filter(Risque).filter_by(is_archived=True).count()
    }
    
    # ========================
    # 7. R√âCUP√âRER LES LISTES POUR LES FILTRES
    # ========================
    cartographies = get_client_filter(Cartographie).filter_by(is_archived=False).all()
    
    # R√©cup√©rer les campagnes disponibles (si une cartographie est s√©lectionn√©e)
    campagnes = []
    if cartographie_id:
        campagnes = CampagneEvaluation.query\
            .filter_by(cartographie_id=cartographie_id)\
            .filter(CampagneEvaluation.statut != 'archivee')\
            .order_by(CampagneEvaluation.date_debut.desc())\
            .all()
    
    # ========================
    # 8. AJOUTER LA DERNI√àRE √âVALUATION ET INFOS DE CAMPAGNE
    # ========================
    for risque in risques.items:
        # Derni√®re √©valuation globale
        if risque.evaluations:
            risque.derniere_evaluation = max(risque.evaluations, key=lambda x: x.created_at)
        else:
            risque.derniere_evaluation = None
        
        # Si une campagne sp√©cifique est s√©lectionn√©e, trouver l'√©valuation pour cette campagne
        risque.evaluation_campagne = None
        if campagne_id and risque.evaluations:
            for eval in risque.evaluations:
                if eval.campagne_id == campagne_id:
                    risque.evaluation_campagne = eval
                    break
        
        risque.nb_kri_actifs = 1 if risque.kri and getattr(risque.kri, 'est_actif', True) else 0
    
    # ========================
    # 9. RENDU
    # ========================
    return render_template('risque/liste.html',
                         risques=risques,
                         stats=stats,
                         cartographies=cartographies,
                         campagnes=campagnes,
                         cartographie_id=cartographie_id,
                         campagne_id=campagne_id,
                         filtre_niveau=filtre_niveau,
                         filtre_statut=filtre_statut,
                         page=page,
                         per_page=per_page,
                         current_user=current_user)



@app.route('/risque/nouveau', methods=['GET'])
@login_required
def nouveau_risque_sans_carto():
    """Rediriger vers le formulaire de cr√©ation avec la premi√®re cartographie disponible"""
    # R√©cup√©rer les cartographies accessibles
    cartographies = get_client_filter(Cartographie).filter_by(is_archived=False).all()
    
    if not cartographies:
        flash('Aucune cartographie disponible. Veuillez d\'abord cr√©er une cartographie.', 'error')
        return redirect(url_for('liste_cartographies'))
    
    # Utiliser la premi√®re cartographie
    return redirect(url_for('nouveau_risque', cartographie_id=cartographies[0].id))

@app.route('/cartographie')
@login_required
def liste_cartographies():
    """Liste des cartographies avec isolation multi-tenant"""
    from sqlalchemy.orm import joinedload
    
    # V√âRIFICATION FORMULE : v√©rifier si le client a acc√®s au module "cartographie"
    if current_user.client and current_user.client.formule:
        formule = current_user.client.formule
        
        # V√©rifier si la formule donne acc√®s au module "cartographie"
        if not formule.can_access_module('cartographie'):
            # Afficher une page d'upgrade
            try:
                # R√©cup√©rer toutes les formules actives
                all_formules = FormuleAbonnement.query.filter(
                    FormuleAbonnement.is_active == True
                ).all()
                
                # Filtrer celles qui ont le module cartographie
                upgrade_suggestions = []
                for f in all_formules:
                    if f.modules.get('cartographie', False):
                        upgrade_suggestions.append(f)
                
                # Trier par prix
                upgrade_suggestions.sort(key=lambda x: x.prix_mensuel or 0)
                
                return render_template('errors/formule_restricted.html', 
                                     module_name='Cartographie des Risques',
                                     current_formule=formule,
                                     upgrade_suggestions=upgrade_suggestions[:3])
                
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur recherche formules upgrade: {e}")
                flash('Ce module n\'est pas inclus dans votre formule actuelle', 'error')
                return redirect(url_for('dashboard'))
    
    # V√©rifier la permission de g√©rer les risques
    if not current_user.has_permission('can_manage_risks'):
        flash('Acc√®s refus√© : permission de g√©rer les risques requise', 'error')
        return redirect(url_for('dashboard'))
    
    # CORRECTION : Utiliser get_client_filter pour l'isolation
    cartographies_query = get_client_filter(Cartographie)\
        .filter_by(is_archived=False)\
        .options(joinedload(Cartographie.direction))\
        .options(joinedload(Cartographie.service))\
        .options(joinedload(Cartographie.risques))
    
    # Debug : voir la requ√™te SQL g√©n√©r√©e
    print(f"üîç REQU√äTE SQL: {str(cartographies_query)}")
    
    # Ex√©cuter la requ√™te
    cartographies = cartographies_query.all()
    
    print(f"üîç UTILISATEUR: {current_user.username} (r√¥le: {current_user.role}, client_id: {current_user.client_id})")
    print(f"üîç LISTE CARTOS - {len(cartographies)} cartographies NON archiv√©es trouv√©es")
    
    # V√©rifier l'isolation pour chaque cartographie
    for cartographie in cartographies:
        print(f"üîç Cartographie '{cartographie.nom}' - Client ID: {cartographie.client_id}")
        
        # V√©rifier l'acc√®s (s√©curit√© suppl√©mentaire)
        if not check_client_access(cartographie):
            print(f"‚ö†Ô∏è ALERTE: L'utilisateur n'a pas acc√®s √† la cartographie {cartographie.id}")
    
    # Pr√©calcul des risques actifs
    for cartographie in cartographies:
        # Filtrer uniquement les risques non archiv√©s
        risques_actifs = []
        for risque in cartographie.risques:
            # V√©rification d'acc√®s suppl√©mentaire
            if not check_client_access(risque):
                print(f"‚ö†Ô∏è Risque {risque.reference} inaccessible pour l'utilisateur")
                continue
                
            # V√©rifier l'archivage
            est_archive = getattr(risque, 'is_archived', False)
            if not est_archive:
                risques_actifs.append(risque)
        
        cartographie.risques_actifs = risques_actifs
        cartographie.nb_risques_actifs = len(risques_actifs)
        
        # Calcul des niveaux de risque
        niveaux = {'Critique': 0, '√âlev√©': 0, 'Moyen': 0, 'Faible': 0}
        
        for risque in risques_actifs:
            if risque.evaluations:
                # Prendre la DERNI√àRE √©valuation
                evaluations_triees = sorted(risque.evaluations, key=lambda x: x.created_at, reverse=True)
                derniere_eval = evaluations_triees[0] if evaluations_triees else None
                
                if derniere_eval and derniere_eval.niveau_risque in niveaux:
                    niveaux[derniere_eval.niveau_risque] += 1
        
        cartographie.niveaux_risques = niveaux
    
    # Calcul des totaux
    total_risques_actifs_global = sum(cartographie.nb_risques_actifs for cartographie in cartographies)
    print(f"üåç TOTAL GLOBAL risques actifs pour l'utilisateur: {total_risques_actifs_global}")
    
    # Statistiques pour le template
    stats = {
        'total_cartographies': len(cartographies),
        'total_risques_actifs': total_risques_actifs_global,
        'niveau_max': 'Faible'  # Par d√©faut
    }
    
    # D√©terminer le niveau maximum
    total_niveaux = {'Critique': 0, '√âlev√©': 0, 'Moyen': 0, 'Faible': 0}
    for cartographie in cartographies:
        for niveau, count in cartographie.niveaux_risques.items():
            total_niveaux[niveau] += count
    
    # Trouver le niveau avec le plus de risques
    for niveau in ['Critique', '√âlev√©', 'Moyen', 'Faible']:
        if total_niveaux[niveau] > 0:
            stats['niveau_max'] = niveau
            break
    
    return render_template('cartographie/liste.html', 
                         cartographies=cartographies,
                         stats=stats,
                         current_user=current_user)


@app.route('/cartographie/<int:id>/dupliquer', methods=['POST'])
@csrf.exempt  
@login_required
def dupliquer_cartographie(id):
    """Dupliquer une cartographie avec tous ses risques et √©valuations"""
    try:
        # CORRECTION : V√©rifier l'acc√®s √† la cartographie source
        cartographie_source = Cartographie.query.get_or_404(id)
        if not check_client_access(cartographie_source):
            flash('Acc√®s non autoris√© √† cette cartographie', 'error')
            return redirect(url_for('liste_cartographies'))
        
        from utils import dupliquer_cartographie_complete
        
        # Utiliser la fonction am√©lior√©e de duplication
        nouvelle_cartographie_id = dupliquer_cartographie_complete(id, current_user.id)
        
        if nouvelle_cartographie_id:
            # CORRECTION : V√©rifier que la nouvelle cartographie a bien le client_id
            nouvelle_carto = Cartographie.query.get(nouvelle_cartographie_id)
            if nouvelle_carto:
                if current_user.role != 'super_admin':
                    nouvelle_carto.client_id = current_user.client_id
                db.session.commit()
            
            flash('Cartographie dupliqu√©e avec succ√®s avec tous ses risques et √©valuations', 'success')
            return redirect(url_for('liste_cartographies'))
        else:
            flash('Erreur lors de la duplication de la cartographie', 'error')
            return redirect(url_for('liste_cartographies'))
            
    except Exception as e:
        flash(f'Erreur lors de la duplication : {str(e)}', 'error')
        return redirect(url_for('liste_cartographies'))



@app.route('/cartographie/<int:id>/archiver', methods=['POST'])
@csrf.exempt  
@login_required
def archiver_cartographie(id):
    """Archiver une cartographie et tous ses risques"""
    cartographie = Cartographie.query.get_or_404(id)
    
    # CORRECTION : V√©rifier l'acc√®s multi-tenant
    if not check_client_access(cartographie):
        flash('Acc√®s non autoris√© √† cette cartographie', 'error')
        return redirect(url_for('liste_cartographies'))
    
    # V√©rifier les permissions
    if current_user.role != 'admin' and current_user.id != cartographie.created_by:
        flash('Vous n\'√™tes pas autoris√© √† archiver cette cartographie', 'error')
        return redirect(url_for('liste_cartographies'))
    
    # V√©rifier si d√©j√† archiv√©e
    if getattr(cartographie, 'is_archived', False):
        flash('Cette cartographie est d√©j√† archiv√©e', 'warning')
        return redirect(url_for('liste_cartographies'))
    
    try:
        print(f"üîÑ Archivage de la cartographie {id}: {cartographie.nom}")
        
        # 1. Compter et archiver tous les risques NON archiv√©s de la cartographie
        risques_archives = 0
        for risque in cartographie.risques:
            # CORRECTION : V√©rifier l'acc√®s au risque
            if not check_client_access(risque):
                print(f"   ‚ö†Ô∏è Risque {risque.reference} inaccessible, ignor√©")
                continue
                
            if not getattr(risque, 'is_archived', False):  # Seulement si pas d√©j√† archiv√©
                print(f"   üìù Archivage du risque {risque.id}: {risque.reference}")
                
                # Mettre √† jour les champs d'archivage
                risque.is_archived = True
                risque.archived_at = datetime.utcnow()
                risque.archived_by = current_user.id
                risque.archive_reason = f"Cartographie '{cartographie.nom}' archiv√©e"
                
                risques_archives += 1
            else:
                print(f"   ‚ö†Ô∏è Risque {risque.reference} d√©j√† archiv√©, ignor√©")
        
        # 2. Archiver la cartographie elle-m√™me
        cartographie.is_archived = True
        cartographie.archived_at = datetime.utcnow()
        cartographie.archived_by = current_user.id
        cartographie.archive_reason = f"Archiv√©e par {current_user.username}"
        
        db.session.commit()
        print(f"‚úÖ Cartographie {id} archiv√©e avec {risques_archives} risques")
        
        flash(f'Cartographie archiv√©e avec succ√®s ({risques_archives} risques archiv√©s)', 'success')
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur lors de l\'archivage : {str(e)}")
        import traceback
        traceback.print_exc()
        flash(f'Erreur lors de l\'archivage : {str(e)}', 'error')
    
    return redirect(url_for('liste_cartographies'))


@app.route('/cartographie/<int:id>/restaurer', methods=['POST'])
@csrf.exempt  
@login_required
def restaurer_cartographie(id):
    """Restaurer une cartographie archiv√©e et ses risques"""
    cartographie = Cartographie.query.get_or_404(id)
    
    # CORRECTION : V√©rifier l'acc√®s multi-tenant
    if not check_client_access(cartographie):
        flash('Acc√®s non autoris√© √† cette cartographie', 'error')
        return redirect(url_for('cartographies_archives'))
    
    # V√©rifier les permissions
    if current_user.role != 'admin' and current_user.id != cartographie.created_by:
        flash('Vous n\'√™tes pas autoris√© √† restaurer cette cartographie', 'error')
        return redirect(url_for('cartographies_archives'))
    
    if not getattr(cartographie, 'is_archived', False):
        flash('Cette cartographie n\'est pas archiv√©e', 'warning')
        return redirect(url_for('liste_cartographies'))
    
    try:
        print(f"üîÑ Restauration de la cartographie {id}: {cartographie.nom}")
        
        # 1. Restaurer la cartographie
        cartographie.is_archived = False
        cartographie.archived_at = None
        cartographie.archived_by = None
        cartographie.archive_reason = None
        
        # 2. Restaurer tous les risques associ√©s
        risques_restaures = 0
        for risque in cartographie.risques:
            # CORRECTION : V√©rifier l'acc√®s au risque
            if not check_client_access(risque):
                continue
                
            if getattr(risque, 'is_archived', False):
                risque.is_archived = False
                risque.archived_at = None
                risque.archived_by = None
                risque.archive_reason = None
                risques_restaures += 1
        
        db.session.commit()
        
        print(f"‚úÖ Cartographie {id} restaur√©e avec {risques_restaures} risques")
        flash(f'Cartographie restaur√©e avec succ√®s ({risques_restaures} risques restaur√©s)', 'success')
        
        # Rediriger vers la liste principale
        return redirect(url_for('liste_cartographies'))
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur lors de la restauration : {str(e)}")
        flash(f'Erreur lors de la restauration : {str(e)}', 'error')
        return redirect(url_for('cartographies_archives'))


@app.route('/cartographies/archives')
@login_required
def cartographies_archives():
    """Afficher les cartographies archiv√©es"""
    # CORRECTION : Utiliser get_client_filter
    cartographies_archivees = get_client_filter(Cartographie)\
        .filter_by(is_archived=True)\
        .order_by(Cartographie.archived_at.desc())\
        .all()
    
    # Pour chaque cartographie archiv√©e, r√©cup√©rer ses risques archiv√©s
    archives_data = []
    for cartographie in cartographies_archivees:
        # Compter les risques archiv√©s
        risques_archives = [r for r in cartographie.risques 
                           if getattr(r, 'is_archived', False) and check_client_access(r)]
        
        # R√©cup√©rer l'utilisateur qui a archiv√©
        archive_user = None
        if cartographie.archived_by:
            archive_user = User.query.get(cartographie.archived_by)
        
        archives_data.append({
            'cartographie': cartographie,
            'risques_archives': risques_archives,
            'nb_risques_archives': len(risques_archives),
            'archive_user': archive_user,
            'date_archivage': cartographie.archived_at
        })
    
    return render_template('cartographie/archives.html',
                         archives_data=archives_data,
                         current_user=current_user)


@app.route('/cartographie/archive/<int:cartographie_id>/supprimer-definitivement', methods=['POST'])
@csrf.exempt  
@login_required
def supprimer_definitivement_cartographie_archive(cartographie_id):
    """Supprimer d√©finitivement une cartographie archiv√©e"""
    if current_user.role != 'admin' and not current_user.is_client_admin:
        flash('Acc√®s non autoris√©. Admin uniquement.', 'error')
        return redirect(url_for('cartographies_archives'))
    
    cartographie = Cartographie.query.get_or_404(cartographie_id)
    
    # CORRECTION : V√©rifier l'acc√®s multi-tenant
    if not check_client_access(cartographie):
        flash('Acc√®s non autoris√© √† cette cartographie', 'error')
        return redirect(url_for('cartographies_archives'))
    
    # V√©rifier que la cartographie est bien archiv√©e
    if not getattr(cartographie, 'is_archived', False):
        flash('Cette cartographie n\'est pas archiv√©e', 'error')
        return redirect(url_for('liste_cartographies'))
    
    try:
        # R√©cup√©rer le nom avant suppression pour le message
        nom_cartographie = cartographie.nom
        
        # R√©cup√©rer tous les risques archiv√©s de cette cartographie
        risques_archives = [r for r in cartographie.risques 
                           if getattr(r, 'is_archived', False) and check_client_access(r)]
        nb_risques = len(risques_archives)
        
        # Supprimer les donn√©es associ√©es
        for risque in risques_archives:
            # Supprimer les √©valuations
            EvaluationRisque.query.filter_by(risque_id=risque.id).delete()
            
            # Supprimer les KRI et mesures
            kri = KRI.query.filter_by(risque_id=risque.id).first()
            if kri:
                MesureKRI.query.filter_by(kri_id=kri.id).delete()
                db.session.delete(kri)
            
            # Supprimer les champs personnalis√©s (g√©rer les contraintes NOT NULL)
            try:
                from models import ChampPersonnaliseRisque
                ChampPersonnaliseRisque.query.filter_by(risque_id=risque.id).delete()
            except:
                pass  # Ignorer si la table n'existe pas
            
            # Supprimer le risque
            db.session.delete(risque)
        
        # Supprimer les campagnes d'√©valuation associ√©es
        CampagneEvaluation.query.filter_by(cartographie_id=cartographie_id).delete()
        
        # Supprimer la cartographie
        db.session.delete(cartographie)
        
        db.session.commit()
        
        flash(f'Cartographie "{nom_cartographie}" supprim√©e d√©finitivement ({nb_risques} risques)', 'success')
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur lors de la suppression : {str(e)}")
        flash(f'Erreur lors de la suppression : {str(e)}', 'error')
    
    return redirect(url_for('cartographies_archives'))

@app.route('/cartographie/archive/tout-supprimer', methods=['POST'])
@login_required
def supprimer_toutes_archives_cartographies():
    """Supprimer toutes les cartographies archiv√©es"""
    if current_user.role != 'admin' and not current_user.is_client_admin:
        flash('Acc√®s non autoris√©. Admin uniquement.', 'error')
        return redirect(url_for('cartographies_archives'))
    
    try:
        # CORRECTION : Utiliser get_client_filter
        cartographies_archivees = get_client_filter(Cartographie)\
            .filter_by(is_archived=True)\
            .all()
        
        total_cartos = len(cartographies_archivees)
        total_risques = 0
        
        for cartographie in cartographies_archivees:
            # Compter les risques accessibles
            risques_archives = [r for r in cartographie.risques 
                               if getattr(r, 'is_archived', False) and check_client_access(r)]
            total_risques += len(risques_archives)
            
            # Supprimer les donn√©es
            for risque in risques_archives:
                EvaluationRisque.query.filter_by(risque_id=risque.id).delete()
                
                kri = KRI.query.filter_by(risque_id=risque.id).first()
                if kri:
                    MesureKRI.query.filter_by(kri_id=kri.id).delete()
                    db.session.delete(kri)
                
                try:
                    from models import ChampPersonnaliseRisque
                    ChampPersonnaliseRisque.query.filter_by(risque_id=risque.id).delete()
                except:
                    pass
                
                db.session.delete(risque)
            
            # Supprimer les campagnes
            CampagneEvaluation.query.filter_by(cartographie_id=cartographie.id).delete()
            
            # Supprimer la cartographie
            db.session.delete(cartographie)
        
        db.session.commit()
        
        flash(f'Toutes les archives ont √©t√© supprim√©es ({total_cartos} cartographies, {total_risques} risques)', 'success')
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur lors de la suppression globale : {str(e)}")
        flash(f'Erreur lors de la suppression globale : {str(e)}', 'error')
    
    return redirect(url_for('cartographies_archives'))

@app.route('/risque/choisir-cartographie')
@login_required
def choisir_cartographie_risque():
    """Page pour choisir une cartographie avant de cr√©er un risque"""
    # CORRECTION : Utiliser get_client_filter
    cartographies = get_client_filter(Cartographie).all()
    
    if not cartographies:
        flash('Aucune cartographie disponible. Veuillez d\'abord cr√©er une cartographie.', 'warning')
        return redirect(url_for('nouvelle_cartographie'))
    
    if len(cartographies) == 1:
        # Si une seule cartographie, rediriger directement
        return redirect(url_for('nouveau_risque', cartographie_id=cartographies[0].id))
    
    return render_template('cartographie/choisir_cartographie.html', 
                         cartographies=cartographies,
                         current_user=current_user)

@app.route('/risque/nouveau-sans-cartographie', methods=['GET', 'POST'])
@login_required
def nouveau_risque_sans_cartographie():
    """Cr√©er un risque sans cartographie sp√©cifique (utilise la premi√®re disponible)"""
    # CORRECTION : Utiliser get_client_filter
    cartographies = get_client_filter(Cartographie).all()
    
    if not cartographies:
        flash('Aucune cartographie disponible. Veuillez d\'abord cr√©er une cartographie.', 'error')
        return redirect(url_for('nouvelle_cartographie'))
    
    # Utiliser la premi√®re cartographie disponible
    cartographie_id = cartographies[0].id
    
    # CORRECTION : Rediriger avec v√©rification d'acc√®s
    cartographie = Cartographie.query.get(cartographie_id)
    if cartographie and check_client_access(cartographie):
        return redirect(url_for('nouveau_risque', cartographie_id=cartographie_id))
    else:
        flash('Aucune cartographie accessible', 'error')
        return redirect(url_for('liste_cartographies'))



@app.route('/risque/<int:risque_id>/dispositifs')
@login_required
def liste_dispositifs_risque(risque_id):
    """Liste des dispositifs de ma√Ætrise pour un risque"""
    risque = Risque.query.get_or_404(risque_id)
    
    if not check_client_access(risque):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_risque', id=risque_id))
    
    dispositifs = get_client_filter(DispositifMaitrise)\
        .filter_by(risque_id=risque_id, is_archived=False)\
        .order_by(DispositifMaitrise.reference.asc())\
        .all()
    
    # Statistiques
    stats = {
        'total': len(dispositifs),
        'par_type': {},
        'par_statut': {},
        'efficaces': sum(1 for d in dispositifs if d.efficacite_reelle and d.efficacite_reelle >= 4)
    }
    
    for dispositif in dispositifs:
        stats['par_type'][dispositif.type_dispositif] = stats['par_type'].get(dispositif.type_dispositif, 0) + 1
        stats['par_statut'][dispositif.statut] = stats['par_statut'].get(dispositif.statut, 0) + 1
    
    return render_template('dispositifs/liste.html',
                         risque=risque,
                         dispositifs=dispositifs,
                         stats=stats)

@app.route('/cartographie/<int:cartographie_id>/campagnes')
@login_required
def liste_campagnes_cartographie(cartographie_id):
    """Afficher toutes les campagnes d'une cartographie"""
    cartographie = Cartographie.query.get_or_404(cartographie_id)
    
    if not check_client_access(cartographie):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_cartographies'))
    
    # V√©rifier si on veut voir les archives
    voir_archives = request.args.get('archives', 'non') == 'oui'
    
    # Construire la requ√™te
    query = CampagneEvaluation.query.filter_by(cartographie_id=cartographie_id)
    
    # Filtrer selon si on veut voir les archives ou non
    if voir_archives:
        # Si on veut voir les archives, on ne filtre QUE les archives
        campagnes = query.filter(CampagneEvaluation.statut == 'archivee')\
                         .order_by(CampagneEvaluation.date_debut.desc()).all()
    else:
        # Si on veut voir les actives, on exclut les archives
        campagnes = query.filter(CampagneEvaluation.statut != 'archivee')\
                         .order_by(CampagneEvaluation.date_debut.desc()).all()
    
    # Calculer les statistiques - CORRECTION ICI
    total_risques = Risque.query\
        .filter_by(cartographie_id=cartographie_id, is_archived=False)\
        .count()
    
    campagnes_data = []
    for campagne in campagnes:
        risques_evalues = EvaluationRisque.query\
            .join(Risque)\
            .filter(
                Risque.cartographie_id == cartographie_id,
                Risque.is_archived == False,
                EvaluationRisque.campagne_id == campagne.id
            )\
            .count()
        
        progression = (risques_evalues / total_risques * 100) if total_risques > 0 else 0
        
        campagnes_data.append({
            'campagne': campagne,
            'total_risques': total_risques,
            'risques_evalues': risques_evalues,
            'progression': progression,
            'est_active': (campagne.id == cartographie.campagne_active_id) if hasattr(cartographie, 'campagne_active_id') else False
        })
    
    # Statistiques globales - CALCUL CORRECT
    # Pour calculer correctement, il faut toutes les campagnes
    toutes_campagnes = CampagneEvaluation.query\
        .filter_by(cartographie_id=cartographie_id)\
        .all()
    
    stats = {
        'total': len([c for c in toutes_campagnes if c.statut != 'archivee']),
        'archives': len([c for c in toutes_campagnes if c.statut == 'archivee']),
        'en_cours': len([c for c in toutes_campagnes if c.statut == 'en_cours']),
        'terminees': len([c for c in toutes_campagnes if c.statut == 'terminee'])
    }
    
    return render_template('campagnes/liste.html',
                         cartographie=cartographie,
                         campagnes_data=campagnes_data,
                         stats=stats,
                         voir_archives=voir_archives,
                         current_user=current_user)


@app.route('/cartographie/<int:cartographie_id>/campagnes/supprimer-toutes-archives', methods=['POST'])
@csrf.exempt
@login_required
def supprimer_toutes_campagnes_archivees(cartographie_id):
    """Supprimer toutes les campagnes archiv√©es"""
    if current_user.role != 'admin' and not current_user.is_client_admin:
        flash('Acc√®s non autoris√©. Admin uniquement.', 'error')
        return redirect(url_for('liste_campagnes_cartographie', cartographie_id=cartographie_id))
    
    try:
        # R√©cup√©rer toutes les campagnes archiv√©es
        campagnes_archivees = CampagneEvaluation.query\
            .filter_by(cartographie_id=cartographie_id, is_archived=True)\
            .all()
        
        count = 0
        for campagne in campagnes_archivees:
            # V√©rifier s'il y a des √©valuations
            evaluations_count = EvaluationRisque.query.filter_by(campagne_id=campagne.id).count()
            if evaluations_count == 0:  # Ne supprimer que si pas d'√©valuations
                db.session.delete(campagne)
                count += 1
        
        db.session.commit()
        flash(f'{count} campagne(s) archiv√©e(s) supprim√©e(s)', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur: {str(e)}', 'error')
    
    return redirect(url_for('liste_campagnes_cartographie', cartographie_id=cartographie_id, archives='oui'))


@app.route('/cartographie/<int:cartographie_id>/cloturer-campagne/<int:campagne_id>')
@login_required
def cloturer_campagne_specifique(cartographie_id, campagne_id):
    """Cl√¥turer une campagne sp√©cifique"""
    campagne = CampagneEvaluation.query.get_or_404(campagne_id)
    
    if not check_client_access(campagne.cartographie):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_cartographies'))
    
    if campagne.statut != 'en_cours':
        flash('Seules les campagnes en cours peuvent √™tre cl√¥tur√©es', 'error')
        return redirect(url_for('liste_campagnes_cartographie', cartographie_id=cartographie_id))
    
    campagne.statut = 'terminee'
    campagne.date_fin = datetime.utcnow().date()
    campagne.updated_at = datetime.utcnow()
    
    db.session.commit()
    flash(f'Campagne "{campagne.nom}" cl√¥tur√©e avec succ√®s', 'success')
    return redirect(url_for('liste_campagnes_cartographie', cartographie_id=cartographie_id))

@app.route('/campagne/<int:campagne_id>/modifier', methods=['GET', 'POST'])
@login_required
def modifier_campagne(campagne_id):
    """Modifier une campagne d'√©valuation"""
    campagne = CampagneEvaluation.query.get_or_404(campagne_id)
    cartographie = campagne.cartographie
    
    if not check_client_access(cartographie):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_cartographies'))
    
    # V√©rifier les permissions
    if not current_user.has_permission('can_manage_risks'):
        flash('Vous n\'avez pas la permission de modifier les campagnes', 'error')
        return redirect(url_for('liste_campagnes_cartographie', cartographie_id=cartographie.id))
    
    form = CampagneForm(obj=campagne)
    
    if form.validate_on_submit():
        campagne.nom = form.nom.data
        campagne.description = form.description.data
        campagne.date_debut = form.date_debut.data
        campagne.date_fin = form.date_fin.data
        
        # Ne pas permettre de modifier le statut si la campagne est termin√©e
        if campagne.statut != 'terminee':
            campagne.statut = form.statut.data
        
        campagne.updated_at = datetime.utcnow()
        
        db.session.commit()
        flash('Campagne modifi√©e avec succ√®s', 'success')
        return redirect(url_for('liste_campagnes_cartographie', cartographie_id=cartographie.id))
    
    return render_template('campagnes/form_modifier.html',
                         form=form,
                         campagne=campagne,
                         cartographie=cartographie)

@app.route('/campagne/<int:campagne_id>/archiver', methods=['POST'])
@csrf.exempt
@login_required
def archiver_campagne(campagne_id):
    """Archiver une campagne d'√©valuation - VERSION CORRIG√âE"""
    campagne = CampagneEvaluation.query.get_or_404(campagne_id)
    cartographie = campagne.cartographie
    
    if not check_client_access(cartographie):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_cartographies'))
    
    # V√©rifier les permissions
    if not current_user.has_permission('can_archive_data'):
        flash('Vous n\'avez pas la permission d\'archiver', 'error')
        return redirect(url_for('liste_campagnes_cartographie', cartographie_id=cartographie.id))
    
    print(f"üîç DEBUG - Archivage campagne {campagne_id}: {campagne.nom}")
    print(f"üîç DEBUG - Statut AVANT: '{campagne.statut}'")
    
    try:
        # CORRECTION ICI : Il faut changer le statut en 'archivee'
        campagne.statut = 'archivee'  # <-- CE CHANGEMENT EST CRUCIAL !
        campagne.archived_at = datetime.utcnow()
        campagne.archived_by = current_user.id
        campagne.updated_at = datetime.utcnow()
        
        print(f"üîç DEBUG - Statut APR√àS: '{campagne.statut}'")
        
        db.session.commit()
        
        # V√©rifier
        campagne_refresh = CampagneEvaluation.query.get(campagne_id)
        print(f"üîç DEBUG - V√©rification apr√®s commit: statut='{campagne_refresh.statut}'")
        
        flash(f'Campagne "{campagne.nom}" archiv√©e avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur lors de l'archivage: {str(e)}")
        flash(f'Erreur lors de l\'archivage: {str(e)}', 'error')
    
    return redirect(url_for('liste_campagnes_cartographie', cartographie_id=cartographie.id))


@app.route('/campagne/<int:campagne_id>/desarchiver', methods=['POST'])
@csrf.exempt
@login_required
def desarchiver_campagne(campagne_id):
    """D√©sarchiver une campagne d'√©valuation - VERSION CORRIG√âE"""
    campagne = CampagneEvaluation.query.get_or_404(campagne_id)
    cartographie = campagne.cartographie
    
    if not check_client_access(cartographie):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_cartographies'))
    
    # V√©rifier les permissions
    if not current_user.has_permission('can_archive_data'):
        flash('Vous n\'avez pas la permission de d√©sarchiver', 'error')
        return redirect(url_for('liste_campagnes_cartographie', cartographie_id=cartographie.id))
    
    print(f"üîç DEBUG - D√©sarchivage campagne {campagne_id}: {campagne.nom}")
    print(f"üîç DEBUG - Statut AVANT: '{campagne.statut}'")
    
    try:
        # CORRECTION ICI : Remettre un statut actif
        campagne.statut = 'en_cours'  # ou 'terminee' selon ce qu'elle √©tait avant
        campagne.archived_at = None
        campagne.archived_by = None
        campagne.updated_at = datetime.utcnow()
        
        print(f"üîç DEBUG - Statut APR√àS: '{campagne.statut}'")
        
        db.session.commit()
        
        flash(f'Campagne "{campagne.nom}" d√©sarchiv√©e avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur lors du d√©sarchivage: {str(e)}")
        flash(f'Erreur lors du d√©sarchivage: {str(e)}', 'error')
    
    return redirect(url_for('liste_campagnes_cartographie', cartographie_id=cartographie.id, archives='oui'))



@app.route('/campagne/<int:campagne_id>/supprimer', methods=['POST'])
@csrf.exempt
@login_required
def supprimer_campagne(campagne_id):
    """Supprimer une campagne d'√©valuation"""
    campagne = CampagneEvaluation.query.get_or_404(campagne_id)
    cartographie = campagne.cartographie
    
    if not check_client_access(cartographie):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_cartographies'))
    
    # V√©rifier les permissions
    if current_user.role != 'admin' and not current_user.is_client_admin:
        flash('Seuls les administrateurs peuvent supprimer des campagnes', 'error')
        return redirect(url_for('liste_campagnes_cartographie', cartographie_id=cartographie.id))
    
    # V√©rifier si la campagne est active
    if hasattr(cartographie, 'campagne_active_id') and cartographie.campagne_active_id == campagne_id:
        flash('Impossible de supprimer la campagne active. Changez d\'abord de campagne active.', 'error')
        return redirect(url_for('liste_campagnes_cartographie', cartographie_id=cartographie.id))
    
    # V√©rifier s'il y a des √©valuations associ√©es
    evaluations_count = EvaluationRisque.query.filter_by(campagne_id=campagne_id).count()
    
    try:
        nom_campagne = campagne.nom
        
        if evaluations_count > 0:
            # Option 1 : Supprimer aussi les √©valuations
            # Supprimer les √©valuations associ√©es
            EvaluationRisque.query.filter_by(campagne_id=campagne_id).delete()
            
            # Supprimer la campagne
            db.session.delete(campagne)
            
            flash(f'Campagne "{nom_campagne}" supprim√©e avec succ√®s ({evaluations_count} √©valuation(s) supprim√©e(s))', 'success')
        else:
            # Option 2 : Si pas d'√©valuations, suppression simple
            db.session.delete(campagne)
            flash(f'Campagne "{nom_campagne}" supprim√©e avec succ√®s', 'success')
        
        db.session.commit()
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur lors de la suppression: {str(e)}")
        flash(f'Erreur lors de la suppression: {str(e)}', 'error')
    
    # Rediriger vers la bonne page (archives ou actives)
    if campagne.statut == 'archivee':
        return redirect(url_for('liste_campagnes_cartographie', cartographie_id=cartographie.id, archives='oui'))
    else:
        return redirect(url_for('liste_campagnes_cartographie', cartographie_id=cartographie.id))


@app.route('/cartographie/<int:cartographie_id>/rapport-pdf')
@login_required
def telecharger_rapport_cartographie_pdf(cartographie_id):
    """G√©n√©rer un rapport PDF d√©taill√© de la cartographie pour la campagne active"""
    
    # R√©cup√©rer la cartographie avec v√©rification d'acc√®s
    cartographie = get_client_filter(Cartographie).filter_by(id=cartographie_id).first_or_404()
    
    if not check_client_access(cartographie):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_cartographies'))
    
    # Trouver la campagne active (non archiv√©e)
    campagne_active = CampagneEvaluation.query.filter_by(
        cartographie_id=cartographie_id
    ).filter(
        CampagneEvaluation.statut != 'archivee'
    ).order_by(CampagneEvaluation.date_debut.desc()).first()
    
    if not campagne_active:
        # Si pas de campagne active, prendre la plus r√©cente
        campagne_active = CampagneEvaluation.query.filter_by(
            cartographie_id=cartographie_id
        ).order_by(CampagneEvaluation.date_debut.desc()).first()
    
    if not campagne_active:
        flash('Aucune campagne trouv√©e pour cette cartographie', 'error')
        return redirect(url_for('detail_cartographie', id=cartographie_id))
    
    # R√©cup√©rer tous les risques non archiv√©s de la cartographie avec leurs relations
    from sqlalchemy.orm import joinedload
    from datetime import datetime, date
    
    risques = get_client_filter(Risque).filter_by(
        cartographie_id=cartographie_id,
        is_archived=False
    ).options(
        joinedload(Risque.dispositifs_maitrise),
        joinedload(Risque.plans_action).joinedload(PlanAction.responsable)  # Charger aussi le responsable
    ).all()
    
    # R√©cup√©rer les √©valuations pour cette campagne
    evaluations = EvaluationRisque.query.filter(
        EvaluationRisque.risque_id.in_([r.id for r in risques]),
        EvaluationRisque.campagne_id == campagne_active.id
    ).all()
    
    # Cr√©er un dictionnaire des √©valuations par risque
    evaluations_par_risque = {e.risque_id: e for e in evaluations}
    
    # Pr√©parer les donn√©es pour le tableau de Bordeaux
    tableau_bordeaux = {
        'actions_prioritaires': [],
        'surveillance_renforcee': [],
        'surveillance_courante': [],
        'actions_limitees': []
    }
    
    risques_avec_evaluation = []
    total_plans = 0
    total_plans_par_statut = {
        'en_cours': 0,
        'termine': 0,
        'en_attente': 0,
        'suspendu': 0,
        'annule': 0,
        'en_retard': 0
    }
    
    aujourdhui = date.today()  # Utiliser date.today() au lieu de datetime.now().date()
    
    for risque in risques:
        evaluation = evaluations_par_risque.get(risque.id)
        
        # R√©cup√©rer les plans d'action pour ce risque
        plans_actifs = []
        if hasattr(risque, 'plans_action') and risque.plans_action:
            for plan in risque.plans_action:
                # V√©rifier si le plan est actif (non archiv√©)
                est_actif = True
                if hasattr(plan, 'statut_archive'):
                    est_actif = (plan.statut_archive == 'actif')
                
                if est_actif:
                    plans_actifs.append(plan)
                    total_plans += 1
                    
                    # Compter par statut
                    if plan.statut in total_plans_par_statut:
                        total_plans_par_statut[plan.statut] += 1
                    
                    # V√©rifier si le plan est en retard - CORRECTION ICI
                    if hasattr(plan, 'est_en_retard') and plan.est_en_retard:
                        total_plans_par_statut['en_retard'] += 1
                    elif hasattr(plan, 'date_fin_prevue') and plan.date_fin_prevue:
                        # plan.date_fin_prevue est d√©j√† un objet date, pas besoin de .date()
                        if plan.date_fin_prevue < aujourdhui and plan.statut != 'termine':
                            total_plans_par_statut['en_retard'] += 1
        
        if evaluation and evaluation.niveau_risque:
            risque_data = {
                'risque': risque,
                'evaluation': evaluation,
                'est_evalue': True,
                'score': evaluation.score_risque or 0,
                'nb_plans': len(plans_actifs),
                'plans_actifs': plans_actifs
            }
            risques_avec_evaluation.append(risque_data)
            
            # Classer selon le niveau
            if evaluation.niveau_risque == 'Critique':
                tableau_bordeaux['actions_prioritaires'].append(risque_data)
            elif evaluation.niveau_risque == '√âlev√©':
                tableau_bordeaux['surveillance_renforcee'].append(risque_data)
            elif evaluation.niveau_risque == 'Moyen':
                tableau_bordeaux['surveillance_courante'].append(risque_data)
            elif evaluation.niveau_risque == 'Faible':
                tableau_bordeaux['actions_limitees'].append(risque_data)
        else:
            risque_data = {
                'risque': risque,
                'evaluation': None,
                'est_evalue': False,
                'score': 0,
                'nb_plans': len(plans_actifs),
                'plans_actifs': plans_actifs
            }
            risques_avec_evaluation.append(risque_data)
    
    nb_risques_evalues = len([r for r in risques_avec_evaluation if r['est_evalue']])
    nb_risques_total = len(risques)
    progression_campagne = round((nb_risques_evalues / nb_risques_total * 100) if nb_risques_total > 0 else 0)
    
    # Statistiques des plans d'action
    stats_plans = {
        'total': total_plans,
        'en_cours': total_plans_par_statut['en_cours'],
        'termines': total_plans_par_statut['termine'],
        'en_attente': total_plans_par_statut['en_attente'],
        'suspendus': total_plans_par_statut['suspendu'],
        'annules': total_plans_par_statut['annule'],
        'en_retard': total_plans_par_statut['en_retard']
    }
    
    # R√©cup√©rer les dispositifs de ma√Ætrise
    dispositifs_par_risque = {}
    total_dispositifs = 0
    for risque in risques:
        dispositifs_actifs = []
        if hasattr(risque, 'dispositifs_maitrise') and risque.dispositifs_maitrise:
            for dispositif in risque.dispositifs_maitrise:
                if not getattr(dispositif, 'is_archived', False):
                    dispositifs_actifs.append(dispositif)
        
        if dispositifs_actifs:
            dispositifs_par_risque[risque.id] = dispositifs_actifs
            total_dispositifs += len(dispositifs_actifs)
    
    # Statistiques des dispositifs
    stats_dispositifs = {
        'total': total_dispositifs,
        'preventif': 0,
        'detectif': 0,
        'correctif': 0,
        'efficaces': 0
    }
    
    for dispositifs in dispositifs_par_risque.values():
        for d in dispositifs:
            if d.type_dispositif == 'Pr√©ventif':
                stats_dispositifs['preventif'] += 1
            elif d.type_dispositif == 'D√©tectif':
                stats_dispositifs['detectif'] += 1
            elif d.type_dispositif == 'Correctif':
                stats_dispositifs['correctif'] += 1
            
            if d.efficacite_reelle and d.efficacite_reelle >= 4:
                stats_dispositifs['efficaces'] += 1
    
    # Debug - Afficher ce qui est pass√© au template
    print(f"üìä RAPPORT PDF - R√©capitulatif:")
    print(f"   Cartographie: {cartographie.nom}")
    print(f"   Campagne: {campagne_active.nom}")
    print(f"   Risques: {nb_risques_total} total, {nb_risques_evalues} √©valu√©s")
    print(f"   Plans d'action: {total_plans} total")
    print(f"   Dispositifs: {total_dispositifs} total")
    print(f"   Stats plans: {stats_plans}")
    
    # G√©n√©rer le HTML du rapport avec TOUTES les variables n√©cessaires
    html_content = render_template('rapports/cartographie_pdf.html',
                                  cartographie=cartographie,
                                  campagne=campagne_active,
                                  risques_avec_evaluation=risques_avec_evaluation,
                                  tableau_bordeaux=tableau_bordeaux,
                                  nb_risques_evalues=nb_risques_evalues,
                                  nb_risques_total=nb_risques_total,
                                  progression_campagne=progression_campagne,
                                  dispositifs_par_risque=dispositifs_par_risque,
                                  stats_dispositifs=stats_dispositifs,
                                  total_dispositifs=total_dispositifs,
                                  stats_plans=stats_plans,
                                  total_plans=total_plans,  # Important!
                                  current_user=current_user,
                                  date_generation=datetime.now())
    
    # G√©n√©rer le PDF
    try:
        from weasyprint import HTML
        import tempfile
        
        pdf = HTML(string=html_content).write_pdf()
        
        # Cr√©er la r√©ponse
        from flask import make_response
        response = make_response(pdf)
        response.headers['Content-Type'] = 'application/pdf'
        
        # Nom du fichier s√©curis√©
        nom_fichier = f"rapport_{cartographie.nom}_{campagne_active.nom}_{datetime.now().strftime('%Y%m%d')}.pdf"
        nom_fichier = nom_fichier.replace(' ', '_').replace('/', '-')
        
        response.headers['Content-Disposition'] = f'attachment; filename="{nom_fichier}"'
        
        return response
        
    except Exception as e:
        print(f"‚ùå Erreur g√©n√©ration PDF: {e}")
        import traceback
        traceback.print_exc()
        flash(f'Erreur lors de la g√©n√©ration du PDF: {str(e)}', 'error')
        return redirect(url_for('detail_cartographie', id=cartographie_id))

@app.route('/telecharger_rapport_cartographie_pdf_campagne/<int:cartographie_id>/<int:campagne_id>')
@login_required
def telecharger_rapport_cartographie_pdf_campagne(cartographie_id, campagne_id):
    """G√©n√©rer un rapport PDF pour une cartographie et une campagne sp√©cifique"""
    
    # R√©cup√©rer la cartographie avec v√©rification d'acc√®s
    cartographie = get_client_filter(Cartographie)\
        .filter_by(id=cartographie_id)\
        .first_or_404()
    
    if not check_client_access(cartographie):
        flash('Acc√®s non autoris√© √† cette cartographie', 'error')
        return redirect(url_for('liste_cartographies'))
    
    # Utiliser CampagneEvaluation au lieu de Campagne
    campagne = get_client_filter(CampagneEvaluation)\
        .filter_by(id=campagne_id, cartographie_id=cartographie_id)\
        .first_or_404()
    
    if not check_client_access(campagne):
        flash('Acc√®s non autoris√© √† cette campagne', 'error')
        return redirect(url_for('detail_cartographie', id=cartographie_id))
    
    print(f"üìä G√©n√©ration rapport PDF - Cartographie: {cartographie.nom}, Campagne: {campagne.nom}")
    
    # ===== R√âCUP√âRER LES RISQUES AVEC LEURS √âVALUATIONS =====
    risques_avec_evaluation = []
    dispositifs_par_risque = {}
    total_dispositifs = 0
    
    risques = get_client_filter(Risque)\
        .filter_by(cartographie_id=cartographie_id, is_archived=False)\
        .all()
    
    for risque in risques:
        if not check_client_access(risque):
            continue
            
        # R√©cup√©rer l'√©valuation pour cette campagne
        evaluation = get_client_filter(EvaluationRisque)\
            .filter_by(risque_id=risque.id, campagne_id=campagne_id)\
            .first()
        
        # Initialiser les variables
        score = 0
        niveau = "Non √©valu√©"
        niveau_classe = "secondary"
        impact_final = None
        probabilite_final = None
        
        if evaluation:
            impact_final = evaluation.impact_conf or evaluation.impact_val or evaluation.impact_pre
            probabilite_final = evaluation.probabilite_conf or evaluation.probabilite_val or evaluation.probabilite_pre
            
            if impact_final and probabilite_final:
                score = impact_final * probabilite_final
                # CORRECTION ICI : Appeler avec impact et probabilite, pas seulement score
                niveau, niveau_classe = calculer_niveau_risque(impact_final, probabilite_final)
        
        # Compter les dispositifs pour ce risque
        dispositifs = get_client_filter(DispositifMaitrise)\
            .filter_by(risque_id=risque.id)\
            .all()
        
        if dispositifs:
            dispositifs_par_risque[risque.id] = dispositifs
            total_dispositifs += len(dispositifs)
        
        risques_avec_evaluation.append({
            'risque': risque,
            'evaluation': evaluation,
            'est_evalue': evaluation is not None,
            'score': score,
            'niveau': niveau,
            'niveau_classe': niveau_classe,  # Ajout pour le template
            'impact': impact_final,
            'probabilite': probabilite_final,
            'dispositifs': dispositifs,
            'nb_dispositifs': len(dispositifs)
        })
    
    # ===== G√âN√âRER LA MATRICE =====
    print("üéØ G√©n√©ration de la matrice...")
    
    # R√©cup√©rer toutes les √©valuations valides pour la campagne
    evaluations_valides = []
    for item in risques_avec_evaluation:
        if item['est_evalue'] and item['impact'] and item['probabilite']:
            evaluations_valides.append(item['evaluation'])
    
    print(f"üìä {len(evaluations_valides)} √©valuations valides trouv√©es")
    
    # G√©n√©rer la matrice
    matrice_classique = None
    try:
        if evaluations_valides:
            # Appeler votre fonction de g√©n√©ration de matrice
            matrice_classique = generer_matrice_risques(cartographie, campagne)
            print("‚úÖ Matrice classique g√©n√©r√©e")
    except Exception as e:
        print(f"‚ùå Erreur g√©n√©ration matrice: {e}")
        import traceback
        traceback.print_exc()
    
    # ===== CALCULER LE TABLEAU DE BORDEAUX =====
    tableau_bordeaux = {
        'actions_prioritaires': [],
        'surveillance_renforcee': [],
        'surveillance_courante': [],
        'actions_limitees': []
    }
    
    for item in risques_avec_evaluation:
        if item['est_evalue'] and item['score'] > 0:
            niveau = item['niveau']
            if niveau == 'Critique':
                tableau_bordeaux['actions_prioritaires'].append(item)
            elif niveau == '√âlev√©':
                tableau_bordeaux['surveillance_renforcee'].append(item)
            elif niveau == 'Moyen':
                tableau_bordeaux['surveillance_courante'].append(item)
            elif niveau == 'Faible':
                tableau_bordeaux['actions_limitees'].append(item)
    
    # ===== STATISTIQUES DES PLANS D'ACTION =====
    total_plans = 0
    stats_plans = {
        'total': 0,
        'en_cours': 0,
        'termines': 0,
        'en_retard': 0
    }
    
    for item in risques_avec_evaluation:
        plans = get_client_filter(PlanAction)\
            .filter_by(risque_id=item['risque'].id)\
            .all()
        
        if plans:
            item['plans_actifs'] = plans
            total_plans += len(plans)
            stats_plans['total'] += len(plans)
            
            for plan in plans:
                if plan.statut == 'en_cours':
                    stats_plans['en_cours'] += 1
                elif plan.statut == 'termine':
                    stats_plans['termines'] += 1
                
                # V√©rifier les retards
                if plan.date_fin_prevue and plan.date_fin_prevue < datetime.now().date() and plan.statut != 'termine':
                    stats_plans['en_retard'] += 1
        else:
            item['plans_actifs'] = []
    
    # ===== PR√âPARER LE CONTEXTE POUR LE TEMPLATE =====
    nb_risques_total = len(risques_avec_evaluation)
    nb_risques_evalues = sum(1 for r in risques_avec_evaluation if r['est_evalue'])
    progression = (nb_risques_evalues / nb_risques_total * 100) if nb_risques_total > 0 else 0
    
    context = {
        'cartographie': cartographie,
        'campagne': campagne,
        'date_generation': datetime.now(),
        'current_user': current_user,
        
        # Statistiques de base
        'nb_risques_total': nb_risques_total,
        'nb_risques_evalues': nb_risques_evalues,
        'progression_campagne': round(progression, 1),
        
        # Donn√©es d√©taill√©es
        'risques_avec_evaluation': risques_avec_evaluation,
        'tableau_bordeaux': tableau_bordeaux,
        'total_dispositifs': total_dispositifs,
        'dispositifs_par_risque': dispositifs_par_risque,
        
        # Plans d'action
        'total_plans': total_plans,
        'stats_plans': stats_plans,
        
        # Matrice
        'matrice_classique': matrice_classique,
        
        # M√©tadonn√©es
        'has_evaluations': nb_risques_evalues > 0,
        'has_matrices': matrice_classique is not None
    }
    
    print(f"üìä Contexte pr√©par√©: {nb_risques_evalues}/{nb_risques_total} risques √©valu√©s")
    print(f"üìä Matrice disponible: {matrice_classique is not None}")
    
    # ===== RENDER LE TEMPLATE PDF =====
    try:
        from weasyprint import HTML
        from flask import make_response
        
        rendered = render_template('rapports/cartographie_pdf.html', **context)
        
        # G√©n√©rer le PDF avec WeasyPrint
        pdf = HTML(string=rendered).write_pdf()
        
        # Nom du fichier
        filename = f"rapport_{cartographie.nom}_{campagne.nom}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
        filename = filename.replace(' ', '_').replace('/', '-')
        
        response = make_response(pdf)
        response.headers['Content-Type'] = 'application/pdf'
        response.headers['Content-Disposition'] = f'attachment; filename={filename}'
        
        print(f"‚úÖ PDF g√©n√©r√© avec succ√®s: {filename}")
        return response
        
    except Exception as e:
        print(f"‚ùå Erreur g√©n√©ration PDF: {e}")
        import traceback
        traceback.print_exc()
        flash('Erreur lors de la g√©n√©ration du PDF', 'error')
        return redirect(url_for('detail_cartographie', id=cartographie_id))

    
@app.route('/risque/<int:risque_id>/dispositif/nouveau', methods=['GET', 'POST'])
@login_required
def nouveau_dispositif(risque_id):
    """Cr√©er un nouveau dispositif de ma√Ætrise"""
    risque = Risque.query.get_or_404(risque_id)
    
    if not check_client_access(risque):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_risque', id=risque_id))
    
    form = DispositifMaitriseForm()
    
    # Pr√©-remplir les choix
    utilisateurs = get_client_filter(User).filter_by(is_active=True).all()
    form.responsable_id.choices = [(0, 'Non assign√©')] + \
        [(u.id, f"{u.username} - {u.role}") for u in utilisateurs]
    
    directions = get_client_filter(Direction).all()
    form.direction_id.choices = [(0, 'Non sp√©cifi√©')] + \
        [(d.id, d.nom) for d in directions]
    
    services = get_client_filter(Service).all()
    form.service_id.choices = [(0, 'Non sp√©cifi√©')] + \
        [(s.id, s.nom) for s in services]
    
    if form.validate_on_submit():
        # G√©n√©rer une r√©f√©rence automatique
        try:
            dernier_dispositif = DispositifMaitrise.query\
                .filter(DispositifMaitrise.reference.like(f'DM-{risque.reference}-%'))\
                .order_by(DispositifMaitrise.reference.desc())\
                .first()
            
            if dernier_dispositif:
                try:
                    num = int(dernier_dispositif.reference.split('-')[-1]) + 1
                except:
                    num = 1
            else:
                num = 1
        except:
            # Si la table n'existe pas encore
            num = 1
        
        reference = f"DM-{risque.reference}-{num:03d}"
        
        # Cr√©er le dispositif
        dispositif = DispositifMaitrise(
            risque_id=risque_id,
            reference=reference,
            nom=form.nom.data,
            description=form.description.data,
            type_dispositif=form.type_dispositif.data,
            nature=form.nature.data,
            frequence=form.frequence.data,
            responsable_id=form.responsable_id.data if form.responsable_id.data != 0 else None,
            direction_id=form.direction_id.data if form.direction_id.data != 0 else None,
            service_id=form.service_id.data if form.service_id.data != 0 else None,
            efficacite_attendue=form.efficacite_attendue.data if form.efficacite_attendue.data != 0 else None,
            date_mise_en_place=form.date_mise_en_place.data,
            statut='actif',
            created_by=current_user.id,
            client_id=current_user.client_id
        )
        
        db.session.add(dispositif)
        db.session.commit()
        
        # Notification
        try:
            from models import Notification
            notif = Notification(
                type_notification='success',
                titre=f"Nouveau dispositif de ma√Ætrise",
                message=f"Dispositif '{dispositif.nom}' cr√©√© pour le risque {risque.reference}",
                destinataire_id=current_user.id,
                entite_type='dispositif',
                entite_id=dispositif.id
            )
            db.session.add(notif)
            db.session.commit()
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur cr√©ation notification: {e}")
        
        flash('Dispositif de ma√Ætrise cr√©√© avec succ√®s', 'success')
        return redirect(url_for('liste_dispositifs_risque', risque_id=risque_id))
    
    return render_template('dispositifs/form.html',
                         form=form,
                         risque=risque,
                         action='creer')

@app.route('/dispositif/<int:dispositif_id>/archiver', methods=['POST'])
@login_required
def archiver_dispositif(dispositif_id):
    """Archiver un dispositif de ma√Ætrise"""
    dispositif = DispositifMaitrise.query.get_or_404(dispositif_id)
    
    if not check_client_access(dispositif):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))
    
    # V√©rifier les permissions
    if not current_user.has_permission('can_archive_data'):
        flash('Vous n\'avez pas la permission d\'archiver', 'error')
        return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))
    
    # Archiver le dispositif
    dispositif.is_archived = True
    dispositif.archived_at = datetime.utcnow()
    dispositif.archived_by = current_user.id
    dispositif.statut = 'inactif'
    dispositif.updated_at = datetime.utcnow()
    
    db.session.commit()
    
    flash('Dispositif archiv√© avec succ√®s', 'success')
    return redirect(url_for('liste_dispositifs_risque', risque_id=dispositif.risque_id))

@app.route('/dispositif/<int:dispositif_id>/desarchiver', methods=['POST'])
@login_required
def desarchiver_dispositif(dispositif_id):
    """D√©sarchiver un dispositif de ma√Ætrise"""
    dispositif = DispositifMaitrise.query.get_or_404(dispositif_id)
    
    if not check_client_access(dispositif):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_dispositifs_risque', risque_id=dispositif.risque_id))
    
    # V√©rifier les permissions
    if not current_user.has_permission('can_archive_data'):
        flash('Vous n\'avez pas la permission de d√©sarchiver', 'error')
        return redirect(url_for('liste_dispositifs_risque', risque_id=dispositif.risque_id))
    
    # D√©sarchiver le dispositif
    dispositif.is_archived = False
    dispositif.archived_at = None
    dispositif.archived_by = None
    dispositif.updated_at = datetime.utcnow()
    
    db.session.commit()
    
    flash('Dispositif d√©sarchiv√© avec succ√®s', 'success')
    return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))


@app.route('/dispositif/document/<int:doc_id>/telecharger')
@login_required
def telecharger_document_dispositif(doc_id):
    """T√©l√©charger un document attach√© √† un dispositif"""
    document = DocumentDispositif.query.get_or_404(doc_id)
    dispositif = document.dispositif
    
    if not check_client_access(dispositif):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_dispositif', dispositif_id=dispositif.id))
    
    # V√©rifier que le fichier existe
    if not document.chemin_fichier or not os.path.exists(document.chemin_fichier):
        flash('Fichier introuvable', 'error')
        return redirect(url_for('detail_dispositif', dispositif_id=dispositif.id))
    
    return send_file(
        document.chemin_fichier,
        as_attachment=True,
        download_name=document.nom_fichier
    )

@app.route('/dispositif/<int:dispositif_id>/document/upload', methods=['POST'])
@login_required
def uploader_document_dispositif(dispositif_id):
    """Uploader un document pour un dispositif"""
    dispositif = DispositifMaitrise.query.get_or_404(dispositif_id)
    
    if not check_client_access(dispositif):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))
    
    if 'fichier' not in request.files:
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))
    
    fichier = request.files['fichier']
    if fichier.filename == '':
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))
    
    # V√©rifier l'extension
    allowed_extensions = app.config.get('ALLOWED_EXTENSIONS', 
                                       ['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'txt', 'jpg', 'jpeg', 'png'])
    if not '.' in fichier.filename or \
       fichier.filename.rsplit('.', 1)[1].lower() not in allowed_extensions:
        flash('Type de fichier non autoris√©', 'error')
        return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))
    
    # Cr√©er le dossier de stockage s'il n'existe pas
    upload_folder = app.config.get('UPLOAD_FOLDER_DISPOSITIFS', 'uploads/dispositifs')
    if not os.path.exists(upload_folder):
        os.makedirs(upload_folder)
    
    # G√©n√©rer un nom de fichier unique
    filename = secure_filename(f"{dispositif_id}_{datetime.now().timestamp()}_{fichier.filename}")
    filepath = os.path.join(upload_folder, filename)
    
    try:
        fichier.save(filepath)
        
        # Cr√©er l'entr√©e dans la base de donn√©es
        document = DocumentDispositif(
            dispositif_id=dispositif_id,
            nom_fichier=fichier.filename,
            type_document=request.form.get('type_document'),
            description=request.form.get('description'),
            chemin_fichier=filepath,
            taille=os.path.getsize(filepath),
            uploaded_by=current_user.id,
            client_id=current_user.client_id
        )
        
        db.session.add(document)
        db.session.commit()
        
        flash('Document t√©l√©vers√© avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors du t√©l√©versement: {str(e)}', 'error')
    
    return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))

@app.route('/risque/<int:risque_id>/plan-action/nouveau', methods=['GET', 'POST'])
@login_required
def nouveau_plan_action_pour_risque(risque_id):
    """Cr√©er un nouveau plan d'action pour un risque - VERSION CORRIG√âE"""
    
    print(f"\nüìù CR√âATION PLAN D'ACTION POUR RISQUE {risque_id}")
    print(f"   Utilisateur: {current_user.username}")
    print(f"   R√¥le: {current_user.role}")
    print(f"   Client ID: {current_user.client_id}")
    
    # 1. V√©rifier l'acc√®s au risque
    risque = Risque.query.get_or_404(risque_id)
    
    if not check_client_access(risque):
        print(f"   ‚ùå Acc√®s non autoris√© au risque {risque_id}")
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_risque', id=risque_id))
    
    print(f"   ‚úÖ Risque acc√©d√©: {risque.reference}")
    
    # 2. V√©rifier les permissions utilisateur
    if not current_user.has_permission('can_manage_action_plans'):
        print(f"   ‚ùå Permission 'can_manage_action_plans' manquante")
        
        # Autoriser les admins et managers automatiquement
        if current_user.role in ['admin', 'super_admin', 'manager']:
            print(f"   üîß For√ßage de la permission pour {current_user.role}")
            if current_user.permissions is None:
                current_user.permissions = {}
            current_user.permissions['can_manage_action_plans'] = True
            current_user.permissions['can_view_action_plans'] = True
            try:
                db.session.commit()
                flash('üîß Permissions ajust√©es automatiquement', 'info')
            except:
                db.session.rollback()
        else:
            flash('Permission "G√©rer les plans d\'action" requise', 'error')
            return redirect(url_for('detail_risque', id=risque_id))
    
    # 3. V√©rifier l'acc√®s au module plans d'action
    if current_user.role != 'super_admin' and current_user.client and current_user.client.formule:
        formule = current_user.client.formule
        
        # V√©rifier l'acc√®s au module plans d'action
        module_names_to_check = ['plans_action', 'audit_interne', 'audit']
        has_access = False
        
        for module_name in module_names_to_check:
            if module_name in formule.modules:
                if formule.modules[module_name]:
                    has_access = True
                    print(f"   ‚úÖ Module trouv√©: '{module_name}'")
                    break
        
        if not has_access:
            print(f"   ‚ùå Aucun module plans d'action activ√©")
            flash('Le module "Plans d\'action" n\'est pas inclus dans votre formule', 'error')
            return redirect(url_for('detail_risque', id=risque_id))
    
    # 4. Initialiser le formulaire
    form = SimplePlanActionForm()
    
    # 5. Pr√©-remplir les choix des utilisateurs
    utilisateurs = get_client_filter(User).filter_by(is_active=True).all()
    form.responsable_id.choices = [(0, 'Non assign√©')] + \
        [(u.id, f"{u.username} - {u.role}") for u in utilisateurs]
    
    # 6. Pr√©-remplir les valeurs par d√©faut (GET request)
    if request.method == 'GET':
        dispositif_id = request.args.get('dispositif_id')
        
        if dispositif_id:
            form.dispositif_id.data = dispositif_id
            dispositif = DispositifMaitrise.query.get(dispositif_id)
            
            if dispositif and check_client_access(dispositif):
                form.nom.data = f"Am√©lioration dispositif {dispositif.reference}"
                form.description.data = f"Plan d'action pour am√©liorer le dispositif de ma√Ætrise {dispositif.reference}: {dispositif.nom}\n\nObjectif: Augmenter l'efficacit√© du dispositif."
        
        # Pr√©-remplir l'ID du risque
        form.risque_id.data = risque_id
        
        # D√©finir les dates par d√©faut
        aujourdhui = datetime.now().date()
        form.date_debut.data = aujourdhui
        form.date_echeance.data = aujourdhui + timedelta(days=30)  # 30 jours par d√©faut
    
    # 7. Traiter la soumission du formulaire (POST request)
    if form.validate_on_submit():
        print(f"\n‚úÖ FORMULAIRE VALID√â")
        print(f"   Nom: {form.nom.data}")
        print(f"   Risque ID: {form.risque_id.data}")
        print(f"   Responsable ID: {form.responsable_id.data}")
        print(f"   Date d√©but: {form.date_debut.data}")
        print(f"   Date √©ch√©ance: {form.date_echeance.data}")
        
        # 7.1 G√©n√©rer une r√©f√©rence automatique
        try:
            dernier_plan = get_client_filter(PlanAction)\
                .filter(PlanAction.reference.like(f'PA-{risque.reference}-%'))\
                .order_by(PlanAction.reference.desc())\
                .first()
            
            if dernier_plan:
                try:
                    num = int(dernier_plan.reference.split('-')[-1]) + 1
                except:
                    num = 1
            else:
                num = 1
        except Exception as e:
            print(f"   ‚ö†Ô∏è Erreur g√©n√©ration r√©f√©rence: {e}")
            num = 1
        
        reference = f"PA-{risque.reference}-{num:03d}"
        print(f"   üìù R√©f√©rence g√©n√©r√©e: {reference}")
        
        # 7.2 Cr√©er le plan d'action - IMPORTANT: audit_id = NULL
        plan_action = PlanAction(
            reference=reference,
            nom=form.nom.data,
            description=form.description.data,
            risque_id=risque_id,  # ‚úÖ Directement li√© au risque
            dispositif_id=form.dispositif_id.data if form.dispositif_id.data else None,
            responsable_id=form.responsable_id.data if form.responsable_id.data != 0 else None,
            date_debut=form.date_debut.data,
            date_fin_prevue=form.date_echeance.data,
            date_fin_reelle=None,
            statut='en_cours',
            priorite=form.priorite.data if hasattr(form, 'priorite') else 'moyenne',
            pourcentage_realisation=0,
            created_by=current_user.id,
            client_id=current_user.client_id
            # ‚úÖ audit_id reste NULL - c'est autoris√© par votre mod√®le
        )
        
        print(f"   üèóÔ∏è Plan d'action cr√©√© (sans audit)")
        
        try:
            # 7.3 Sauvegarder le plan d'action
            db.session.add(plan_action)
            db.session.commit()
            print(f"   üíæ Plan d'action sauvegard√©: ID {plan_action.id}")
            
            # 7.4 Lier le dispositif au plan cr√©√© (si sp√©cifi√©)
            dispositif_id = form.dispositif_id.data
            if dispositif_id:
                dispositif = DispositifMaitrise.query.get(dispositif_id)
                if dispositif and check_client_access(dispositif):
                    dispositif.plan_action_id = plan_action.id
                    db.session.commit()
                    print(f"   üîó Dispositif li√©: {dispositif.reference}")
            
            # 7.5 Cr√©er une notification pour le responsable
            try:
                if plan_action.responsable_id and plan_action.responsable_id != current_user.id:
                    notification = Notification(
                        type_notification=Notification.TYPE_PLAN,
                        titre=f"Nouveau plan d'action: {plan_action.nom}",
                        message=f"Vous avez √©t√© assign√© comme responsable du plan d'action '{plan_action.nom}' pour le risque {risque.reference}",
                        destinataire_id=plan_action.responsable_id,
                        entite_type='plan_action',
                        entite_id=plan_action.id,
                        urgence=Notification.URGENCE_NORMAL,
                        client_id=current_user.client_id
                    )
                    db.session.add(notification)
                    db.session.commit()
                    print(f"   üîî Notification cr√©√©e pour responsable")
            except Exception as e:
                print(f"   ‚ö†Ô∏è Erreur cr√©ation notification: {e}")
                db.session.rollback()  # Rollback seulement la notification, pas le plan
            
            # 7.6 Journaliser l'action - CORRECTION IMPORTANTE: convertir dict en JSON string
            try:
                # Cr√©er les d√©tails comme une cha√Æne JSON
                details_json = {
                    'plan_id': plan_action.id,
                    'plan_nom': plan_action.nom,
                    'risque_id': risque.id,
                    'risque_reference': risque.reference,
                    'dispositif_id': dispositif_id if dispositif_id else None
                }
                
                # Si votre mod√®le JournalActivite a un champ JSON, utilisez-le directement
                # Sinon, convertissez en string JSON
                journal = JournalActivite(
                    utilisateur_id=current_user.id,
                    action=f"Cr√©ation plan d'action risque: {plan_action.reference}",
                    details=details_json,  # PostgreSQL avec JSONB acceptera le dict
                    entite_type='plan_action',
                    entite_id=plan_action.id,
                    ip_address=request.remote_addr,
                    user_agent=request.user_agent.string,
                    client_id=current_user.client_id
                )
                
                # ALTERNATIVE: Si votre base ne supporte pas JSON, convertissez en string
                # from json import dumps
                # journal = JournalActivite(
                #     utilisateur_id=current_user.id,
                #     action=f"Cr√©ation plan d'action risque: {plan_action.reference}",
                #     details=dumps(details_json),  # Convertir en string JSON
                #     entite_type='plan_action',
                #     entite_id=plan_action.id,
                #     ip_address=request.remote_addr,
                #     user_agent=request.user_agent.string,
                #     client_id=current_user.client_id
                # )
                
                db.session.add(journal)
                db.session.commit()
                print(f"   üìù Journal d'activit√© cr√©√©")
            except Exception as e:
                print(f"   ‚ö†Ô∏è Erreur journal: {e}")
                # IMPORTANT: Ne pas rollback ici, le plan est d√©j√† cr√©√©
                # Juste logger l'erreur et continuer
                try:
                    db.session.rollback()  # Rollback seulement le journal
                    # R√©essayer avec une version simplifi√©e
                    simple_journal = JournalActivite(
                        utilisateur_id=current_user.id,
                        action=f"Cr√©ation plan d'action risque: {plan_action.reference}",
                        details=None,  # Ou une cha√Æne simple
                        entite_type='plan_action',
                        entite_id=plan_action.id,
                        ip_address=request.remote_addr,
                        user_agent=request.user_agent.string,
                        client_id=current_user.client_id
                    )
                    db.session.add(simple_journal)
                    db.session.commit()
                    print(f"   üìù Journal simplifi√© cr√©√©")
                except:
                    print(f"   ‚ùå √âchec cr√©ation journal, mais plan sauvegard√©")
            
            flash(f'‚úÖ Plan d\'action "{plan_action.nom}" cr√©√© avec succ√®s', 'success')
            print(f"   üéâ REDIRECTION vers d√©tails du plan")
            
            # 7.7 Rediriger vers le d√©tail du nouveau plan
            return redirect(url_for('detail_plan_action_risque', plan_id=plan_action.id))
            
        except Exception as e:
            db.session.rollback()
            print(f"   ‚ùå ERREUR CRITIQUE lors de la cr√©ation: {str(e)}")
            import traceback
            print(f"   Traceback: {traceback.format_exc()}")
            flash(f'‚ùå Erreur lors de la cr√©ation du plan d\'action: {str(e)}', 'error')
    
    # 8. Afficher le formulaire (GET ou formulaire invalide)
    print(f"\nüìã AFFICHAGE FORMULAIRE")
    
    return render_template('plans_action/form_simple.html',
                         form=form,
                         risque=risque,
                         action='creer',
                         current_user=current_user)

@app.route('/plan-action-risque/<int:plan_id>')
@login_required
def detail_plan_action_risque(plan_id):
    """D√©tail d'un plan d'action li√© √† un risque"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan_action):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    # R√©cup√©rer les sous-actions tri√©es par date de cr√©ation
    sous_actions = SousAction.query\
        .filter_by(plan_action_id=plan_id)\
        .order_by(SousAction.created_at.asc())\
        .all()
    
    # R√©cup√©rer les √©tapes tri√©es par ordre
    etapes = EtapePlanAction.query\
        .filter_by(plan_action_id=plan_id)\
        .order_by(EtapePlanAction.ordre.asc())\
        .all()
    
    # Calculer l'avancement bas√© sur les sous-actions
    total_sous_actions = len(sous_actions)
    sous_actions_terminees = sum(1 for s in sous_actions if s.statut == 'termine')
    pourcentage_avancement = (sous_actions_terminees / total_sous_actions * 100) if total_sous_actions > 0 else 0
    
    return render_template('plans_action/detail_risque.html',
                         plan=plan_action,
                         sous_actions=sous_actions,
                         etapes=etapes,
                         pourcentage_avancement=pourcentage_avancement,
                         sous_actions_terminees=sous_actions_terminees,
                         total_sous_actions=total_sous_actions,
                         is_risque_plan=True,
                         datetime=datetime)

@app.route('/plan-action-risque/<int:plan_id>/modifier', methods=['GET', 'POST'])
@login_required
def modifier_plan_action_risque(plan_id):
    """Modifier un plan d'action li√© √† un risque"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan_action):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_id))
    
    # V√©rifier les permissions
    if (current_user.id != plan_action.created_by and 
        not current_user.has_permission('can_manage_plans')):
        flash('Vous n\'√™tes pas autoris√© √† modifier ce plan d\'action', 'error')
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_id))
    
    form = SimplePlanActionForm(obj=plan_action)
    
    # Pr√©-remplir les choix
    utilisateurs = get_client_filter(User).filter_by(is_active=True).all()
    form.responsable_id.choices = [(0, 'Non assign√©')] + \
        [(u.id, f"{u.username} - {u.role}") for u in utilisateurs]
    
    # Pr√©-remplir la date d'√©ch√©ance et l'ID du risque
    if request.method == 'GET':
        form.date_echeance.data = plan_action.date_fin_prevue
        form.priorite.data = getattr(plan_action, 'priorite', 'moyenne')
        form.risque_id.data = plan_action.risque_id
    
    if form.validate_on_submit():
        plan_action.nom = form.nom.data
        plan_action.description = form.description.data
        plan_action.responsable_id = form.responsable_id.data if form.responsable_id.data != 0 else None
        plan_action.date_debut = form.date_debut.data
        plan_action.date_fin_prevue = form.date_echeance.data
        
        # Mettre √† jour la priorit√© si le champ existe
        if hasattr(plan_action, 'priorite'):
            plan_action.priorite = form.priorite.data
        
        plan_action.updated_at = datetime.utcnow()
        
        db.session.commit()
        flash('Plan d\'action modifi√© avec succ√®s', 'success')
        # REDIRECTION VERS LE D√âTAIL DU PLAN
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_id))
    
    return render_template('plans_action/form_simple.html',
                         form=form,
                         risque=plan_action.risque,
                         action='modifier',
                         plan=plan_action)

@app.route('/plan-action-risque/<int:plan_id>/sous-action/nouveau', methods=['GET', 'POST'])
@login_required
def nouveau_sous_action_risque(plan_id):
    """Ajouter une sous-action √† un plan d'action risque"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan_action):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_id))
    
    # V√©rifier les permissions
    if (current_user.id != plan_action.created_by and 
        not current_user.has_permission('can_manage_plans')):
        flash('Vous n\'√™tes pas autoris√© √† ajouter des sous-actions', 'error')
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_id))
    
    # Utilisez le formulaire AVEC commentaire
    form = SousActionForm()
    
    # Pr√©-remplir les choix
    utilisateurs = get_client_filter(User).filter_by(is_active=True).all()
    form.responsable_id.choices = [(0, 'Non assign√©')] + \
        [(u.id, f"{u.username} - {u.role}") for u in utilisateurs]
    
    if request.method == 'GET':
        # D√©finir les dates par d√©faut
        form.date_debut.data = datetime.now().date()
        form.date_fin_prevue.data = (datetime.now() + timedelta(days=14)).date()
    
    if form.validate_on_submit():
        # Trouver le prochain ordre
        dernier_sous_action = SousAction.query\
            .filter_by(plan_action_id=plan_id)\
            .order_by(SousAction.created_at.desc())\
            .first()
        
        # G√©n√©rer une r√©f√©rence
        reference = f"SA-{plan_action.reference}-{(dernier_sous_action.id + 1) if dernier_sous_action else 1:03d}"
        
        # Cr√©er la sous-action - UTILISEZ SEULEMENT LES CHAMPS DISPONIBLES
        sous_action = SousAction(
            plan_action_id=plan_id,
            reference=reference,
            description=form.description.data,
            # Ne pas utiliser form.commentaire.data si le champ n'existe pas
            # commentaire=form.commentaire.data if hasattr(form, 'commentaire') else None,
            date_debut=form.date_debut.data,
            date_fin_prevue=form.date_fin_prevue.data,
            responsable_id=form.responsable_id.data if form.responsable_id.data != 0 else None,
            statut='a_faire',
            pourcentage_realisation=0,
            client_id=current_user.client_id
        )
        
        db.session.add(sous_action)
        db.session.commit()
        
        flash('Sous-action ajout√©e avec succ√®s', 'success')
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_id))
    
    return render_template('plans_action/form_sous_action.html',
                         form=form,
                         plan=plan_action,
                         action='creer')


# ============================================================================
# ROUTES POUR LES PLANS D'ACTION RISQUE
# ============================================================================
@app.route('/plan-action-risque/<int:plan_id>/archiver', methods=['POST'])
@csrf.exempt  # Important si vous utilisez AJAX
@login_required
def archiver_plan_risque(plan_id):
    """Archiver un plan d'action risque - VERSION CORRIG√âE"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan_action):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_id))
    
    # V√©rifier les permissions
    if (current_user.id != plan_action.created_by and 
        not current_user.has_permission('can_manage_plans')):
        flash('Vous n\'√™tes pas autoris√© √† archiver ce plan', 'error')
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_id))
    
    try:
        # V√©rifier si d√©j√† archiv√©
        if plan_action.is_archived:
            flash('Ce plan est d√©j√† archiv√©', 'warning')
            return redirect(url_for('voir_plans_action_risque', 
                                  risque_id=plan_action.risque_id,
                                  archives='oui'))
        
        print(f"üîç DEBUG - Archivage plan {plan_id}")
        print(f"üîç DEBUG - AVANT: is_archived={plan_action.is_archived}, statut_archive={plan_action.statut_archive}")
        
        # Archiver le plan
        plan_action.archiver(current_user.id, "Archiv√© manuellement")
        
        print(f"üîç DEBUG - APR√àS: is_archived={plan_action.is_archived}, statut_archive={plan_action.statut_archive}")
        
        # Journalisation (facultatif)
        try:
            from models import JournalActivite
            journal = JournalActivite(
                utilisateur_id=current_user.id,
                action='archivage_plan',
                details=json.dumps({
                    'plan_id': plan_id,
                    'plan_reference': plan_action.reference
                }),
                entite_type='plan_action',
                entite_id=plan_id,
                client_id=current_user.client_id
            )
            db.session.add(journal)
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur journalisation: {e}")
        
        db.session.commit()
        print(f"‚úÖ Plan {plan_id} archiv√© avec succ√®s")
        
        flash(f'Plan "{plan_action.reference}" archiv√© avec succ√®s', 'success')
        
        # V√©rifier la requ√™te AJAX
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({
                'success': True,
                'message': 'Plan archiv√© avec succ√®s',
                'redirect': url_for('voir_plans_action_risque', 
                                  risque_id=plan_action.risque_id)
            })
        
        # Redirection normale
        return redirect(url_for('voir_plans_action_risque', 
                              risque_id=plan_action.risque_id))
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur archivage: {e}")
        import traceback
        traceback.print_exc()
        flash(f'Erreur lors de l\'archivage: {str(e)}', 'error')
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_id))

@app.route('/plan-action-risque/<int:plan_id>/desarchiver', methods=['POST'])
@csrf.exempt
@login_required
def desarchiver_plan_risque(plan_id):
    """D√©sarchiver un plan d'action risque - VERSION CORRIG√âE"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan_action):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_id))
    
    # V√©rifier les permissions
    if (current_user.id != plan_action.created_by and 
        not current_user.has_permission('can_manage_plans')):
        flash('Vous n\'√™tes pas autoris√© √† d√©sarchiver ce plan', 'error')
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_id))
    
    try:
        # V√©rifier si d√©j√† d√©sarchiv√©
        if not plan_action.is_archived:
            flash('Ce plan n\'est pas archiv√©', 'warning')
            return redirect(url_for('voir_plans_action_risque', 
                                  risque_id=plan_action.risque_id))
        
        print(f"üîç DEBUG - D√©sarchivage plan {plan_id}")
        print(f"üîç DEBUG - AVANT: is_archived={plan_action.is_archived}, statut_archive={plan_action.statut_archive}")
        
        # D√©sarchiver le plan
        plan_action.desarchiver()
        
        print(f"üîç DEBUG - APR√àS: is_archived={plan_action.is_archived}, statut_archive={plan_action.statut_archive}")
        
        # Journalisation (facultatif)
        try:
            from models import JournalActivite
            journal = JournalActivite(
                utilisateur_id=current_user.id,
                action='desarchivage_plan',
                details=json.dumps({
                    'plan_id': plan_id,
                    'plan_reference': plan_action.reference
                }),
                entite_type='plan_action',
                entite_id=plan_id,
                client_id=current_user.client_id
            )
            db.session.add(journal)
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur journalisation: {e}")
        
        db.session.commit()
        print(f"‚úÖ Plan {plan_id} d√©sarchiv√© avec succ√®s")
        
        flash(f'Plan "{plan_action.reference}" d√©sarchiv√© avec succ√®s', 'success')
        
        # V√©rifier la requ√™te AJAX
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({
                'success': True,
                'message': 'Plan d√©sarchiv√© avec succ√®s',
                'redirect': url_for('voir_plans_action_risque', 
                                  risque_id=plan_action.risque_id)
            })
        
        # Redirection normale - retourner aux archives pour voir le changement
        return redirect(url_for('voir_plans_action_risque', 
                              risque_id=plan_action.risque_id,
                              archives='oui'))
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur d√©sarchivage: {e}")
        import traceback
        traceback.print_exc()
        flash(f'Erreur lors du d√©sarchivage: {str(e)}', 'error')
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_id))



@app.route('/plan-action-risque/<int:plan_id>/supprimer', methods=['DELETE'])
@login_required
def supprimer_plan_risque(plan_id):
    """Supprimer d√©finitivement un plan d'action risque"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan_action):
        return jsonify({'error': 'Acc√®s non autoris√©'}), 403
    
    # V√©rifier les permissions
    if current_user.role != 'admin' and current_user.id != plan_action.created_by:
        return jsonify({'error': 'Vous n\'√™tes pas autoris√© √† supprimer ce plan'}), 403
    
    try:
        # Supprimer d'abord les sous-actions
        SousAction.query.filter_by(plan_action_id=plan_id).delete()
        
        # Supprimer le plan
        db.session.delete(plan_action)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Plan supprim√© avec succ√®s',
            'redirect': url_for('voir_plans_action_risque', risque_id=plan_action.risque_id)
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/dispositif/<int:dispositif_id>')
@login_required
def detail_dispositif(dispositif_id):
    """D√©tail d'un dispositif de ma√Ætrise"""
    dispositif = DispositifMaitrise.query.get_or_404(dispositif_id)
    
    if not check_client_access(dispositif):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_dispositifs_risque', risque_id=dispositif.risque_id))
    
    # R√©cup√©rer les v√©rifications tri√©es par date
    verifications = VerificationDispositif.query\
        .filter_by(dispositif_id=dispositif_id)\
        .order_by(VerificationDispositif.date_verification.desc())\
        .all()
    
    # R√©cup√©rer les documents
    documents = DocumentDispositif.query\
        .filter_by(dispositif_id=dispositif_id)\
        .order_by(DocumentDispositif.uploaded_at.desc())\
        .all()
    
    # V√©rifier si un plan d'action est li√©
    plan_action = None
    if dispositif.plan_action_id:
        plan_action = PlanAction.query.get(dispositif.plan_action_id)
    
    # Calculer les jours restants avant la prochaine v√©rification
    jours_restants = None
    if dispositif.prochaine_verification:
        aujourdhui = datetime.now().date()
        jours_restants = (dispositif.prochaine_verification - aujourdhui).days
    
    return render_template('dispositifs/detail.html',
                         dispositif=dispositif,
                         verifications=verifications,
                         documents=documents,
                         plan_action=plan_action,
                         jours_restants=jours_restants,
                         current_user=current_user,
                         datetime=datetime)


@app.route('/dispositif/<int:dispositif_id>/modifier', methods=['GET', 'POST'])
@login_required
def modifier_dispositif(dispositif_id):
    """Modifier un dispositif de ma√Ætrise"""
    dispositif = DispositifMaitrise.query.get_or_404(dispositif_id)
    
    if not check_client_access(dispositif):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))
    
    # V√©rifier les permissions
    if (current_user.id != dispositif.created_by and 
        not current_user.has_permission('can_manage_controls')):
        flash('Vous n\'√™tes pas autoris√© √† modifier ce dispositif', 'error')
        return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))
    
    form = DispositifMaitriseForm(obj=dispositif)
    
    # Pr√©-remplir les choix
    utilisateurs = get_client_filter(User).filter_by(is_active=True).all()
    form.responsable_id.choices = [(0, 'Non assign√©')] + \
        [(u.id, f"{u.username} - {u.role}") for u in utilisateurs]
    
    directions = get_client_filter(Direction).all()
    form.direction_id.choices = [(0, 'Non sp√©cifi√©')] + \
        [(d.id, d.nom) for d in directions]
    
    services = get_client_filter(Service).all()
    form.service_id.choices = [(0, 'Non sp√©cifi√©')] + \
        [(s.id, s.nom) for s in services]
    
    if form.validate_on_submit():
        dispositif.nom = form.nom.data
        dispositif.description = form.description.data
        dispositif.type_dispositif = form.type_dispositif.data
        dispositif.nature = form.nature.data
        dispositif.frequence = form.frequence.data
        dispositif.responsable_id = form.responsable_id.data if form.responsable_id.data != 0 else None
        dispositif.direction_id = form.direction_id.data if form.direction_id.data != 0 else None
        dispositif.service_id = form.service_id.data if form.service_id.data != 0 else None
        dispositif.efficacite_attendue = form.efficacite_attendue.data if form.efficacite_attendue.data != 0 else None
        dispositif.date_mise_en_place = form.date_mise_en_place.data
        dispositif.updated_at = datetime.utcnow()
        
        db.session.commit()
        flash('Dispositif modifi√© avec succ√®s', 'success')
        return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))
    
    return render_template('dispositifs/form.html',
                         form=form,
                         risque=dispositif.risque,
                         action='modifier')

@app.route('/dispositif/<int:dispositif_id>/verification/formulaire')
@csrf.exempt  
@login_required
def formulaire_verification_dispositif(dispositif_id):
    """Retourne le formulaire HTML pour ajouter une v√©rification"""
    try:
        dispositif = DispositifMaitrise.query.get_or_404(dispositif_id)
        
        if not check_client_access(dispositif):
            return '<div class="alert alert-danger">Acc√®s non autoris√©</div>'
        
        # G√©n√©rer le token CSRF
        csrf_token_value = generate_csrf()
        
        html = f'''
        <form method="POST" action="/dispositif/{dispositif_id}/verification/ajouter" id="formVerification">
            <input type="hidden" name="csrf_token" value="{csrf_token_value}">
            
            <div class="mb-3">
                <label class="form-label">Date de v√©rification :</label>
                <input type="date" class="form-control" name="date_verification" 
                       value="{datetime.now().date().isoformat()}" required>
            </div>
            
            <div class="mb-3">
                <label class="form-label">Type de v√©rification :</label>
                <select class="form-select" name="type_verification" required>
                    <option value="">-- S√©lectionner --</option>
                    <option value="Test">Test</option>
                    <option value="Observation">Observation</option>
                    <option value="Revue documentaire">Revue documentaire</option>
                    <option value="Entretien">Entretien</option>
                    <option value="Simulation">Simulation</option>
                    <option value="Autre">Autre</option>
                </select>
            </div>
            
            <div class="mb-3">
                <label class="form-label">R√©sultat :</label>
                <select class="form-select" name="resultat" required>
                    <option value="">-- S√©lectionner --</option>
                    <option value="Conforme">Conforme</option>
                    <option value="Non conforme">Non conforme</option>
                    <option value="√Ä corriger">√Ä corriger</option>
                    <option value="√Ä am√©liorer">√Ä am√©liorer</option>
                </select>
            </div>
            
            <div class="mb-3">
                <label class="form-label">Commentaire :</label>
                <textarea class="form-control" name="commentaire" rows="3" 
                          placeholder="D√©tails de la v√©rification, observations, recommandations..."></textarea>
            </div>
            
            <div class="mb-3">
                <label class="form-label">V√©rificateur :</label>
                <input type="text" class="form-control" name="verificateur" 
                       value="{current_user.username}" readonly>
                <small class="text-muted">Vous serez enregistr√© comme v√©rificateur</small>
            </div>
        </form>
        '''
        
        return html
        
    except Exception as e:
        print(f"‚ùå Erreur formulaire v√©rification: {e}")
        return f'<div class="alert alert-danger">Erreur: {str(e)}</div>'
    
@app.route('/risque/<int:risque_id>/plans-action/liste')
@login_required
def voir_plans_action_risque(risque_id):
    """Voir tous les plans d'action d'un risque - VERSION CORRIG√âE"""
    risque = Risque.query.get_or_404(risque_id)
    
    if not check_client_access(risque):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_risque', id=risque_id))
    
    # V√©rifier si on veut voir les archives ou non
    voir_archives = request.args.get('archives', 'non') == 'oui'
    
    # Construire la requ√™te
    query = get_client_filter(PlanAction)\
        .filter_by(risque_id=risque_id)
    
    # Filtrer selon statut_archive
    if voir_archives:
        plans_action = query.filter(PlanAction.statut_archive == 'archive')\
                           .order_by(PlanAction.updated_at.desc())\
                           .all()
    else:
        plans_action = query.filter(PlanAction.statut_archive == 'actif')\
                           .order_by(PlanAction.created_at.desc())\
                           .all()
    
    # Pr√©parer les donn√©es pour le template
    plans_with_attrs = []
    for plan in plans_action:
        # Assurez-vous que statut_archive existe
        statut_archive_value = getattr(plan, 'statut_archive', 'actif')
        plans_with_attrs.append({
            'plan': plan,
            'statut_archive': statut_archive_value,
            'has_statut_archive': hasattr(plan, 'statut_archive')
        })
    
    # R√©cup√©rer TOUS les plans pour calculer les statistiques
    tous_plans = get_client_filter(PlanAction)\
        .filter_by(risque_id=risque_id)\
        .all()
    
    # Calcul des statistiques
    plans_actifs = [p for p in tous_plans if getattr(p, 'statut_archive', 'actif') == 'actif']
    plans_archives = [p for p in tous_plans if getattr(p, 'statut_archive', 'actif') == 'archive']
    
    stats = {
        'total': len(plans_actifs),
        'en_cours': len([p for p in plans_actifs if p.statut == 'en_cours']),
        'termines': len([p for p in plans_actifs if p.statut == 'termine']),
        'en_retard': len([p for p in plans_actifs if getattr(p, 'est_en_retard', False)]),
        'archives': len(plans_archives)
    }
    
    # R√©cup√©rer les responsables uniques
    responsables_uniques = []
    for plan in plans_action:
        if plan.responsable and plan.responsable not in responsables_uniques:
            responsables_uniques.append(plan.responsable)
    
    # Convertir en JSON pour les graphiques
    plans_action_json = [plan.to_dict() for plan in plans_action]
    
    return render_template('plans_action/liste_risque.html',
                         risque=risque,
                         plans_with_attrs=plans_with_attrs,  # Chang√© ici
                         plans_action=plans_action,  # Garder pour compatibilit√©
                         plans_action_json=plans_action_json,
                         stats=stats,
                         responsables_uniques=responsables_uniques,
                         voir_archives=voir_archives)

@app.template_filter('average')
def average_filter(values):
    """Calculate average of a list, ignoring None values"""
    if not values:
        return 0
    valid_values = [v for v in values if v is not None]
    if not valid_values:
        return 0
    return sum(valid_values) / len(valid_values)

@app.template_filter('default_if_none')
def default_if_none(value, default=0):
    """Return default value if value is None"""
    return value if value is not None else default


@app.route('/dispositif/<int:dispositif_id>/evaluer', methods=['GET', 'POST'])
@login_required
def evaluer_dispositif(dispositif_id):
    """√âvaluer l'efficacit√© d'un dispositif de ma√Ætrise"""
    dispositif = DispositifMaitrise.query.get_or_404(dispositif_id)
    
    if not check_client_access(dispositif):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_dispositifs_risque', risque_id=dispositif.risque_id))
    
    form = EvaluationDispositifForm()
    
    if form.validate_on_submit():
        # Mettre √† jour les valeurs d'√©valuation
        dispositif.efficacite_reelle = form.efficacite_reelle.data
        dispositif.couverture = form.couverture.data
        dispositif.date_derniere_verification = datetime.utcnow().date()
        dispositif.prochaine_verification = form.prochaine_verification.data
        dispositif.commentaire_evaluation = form.commentaire.data  # Stocker le commentaire
        dispositif.updated_at = datetime.utcnow()
        
        # CORRECTION : V√©rifier que les valeurs ne sont pas None avant comparaison
        efficacite_reelle = dispositif.efficacite_reelle or 0
        efficacite_attendue = dispositif.efficacite_attendue or 0
        
        # D√©terminer le r√©sultat
        if efficacite_attendue == 0:
            resultat = 'Non √©valu√©'
        elif efficacite_reelle < efficacite_attendue:
            resultat = '√Ä am√©liorer'
        else:
            resultat = 'Conforme'
        
        # 1. Cr√©er une v√©rification d'√©valuation
        verification = VerificationDispositif(
            dispositif_id=dispositif.id,
            date_verification=datetime.utcnow().date(),
            type_verification='√âvaluation',
            resultat=resultat,  # Utiliser la variable calcul√©e
            commentaire=form.commentaire.data or f"√âvaluation: {efficacite_reelle}/5 (attendu: {efficacite_attendue}/5)",
            verificateur_id=current_user.id,
            client_id=current_user.client_id
        )
        db.session.add(verification)
        
        # 2. CALCULER LA R√âDUCTION TH√âORIQUE DU RISQUE
        # Mettre √† jour le risque associ√© avec la nouvelle r√©duction
        if dispositif.risque:
            # Calculer la r√©duction bas√©e sur l'efficacit√© r√©elle et la couverture
            if dispositif.efficacite_reelle and dispositif.couverture:
                # Formule : (efficacit√© + couverture) / 2, puis normalis√© √† 30% max
                score_moyen = (dispositif.efficacite_reelle + dispositif.couverture) / 2
                reduction_pourcentage = (score_moyen / 5) * 30.0  # 30% maximum
                
                # Stocker la r√©duction dans le dispositif
                dispositif.reduction_risque_pourcentage = reduction_pourcentage
                
                # Mettre √† jour le risque (optionnel)
                # Vous pourriez avoir un champ 'reduction_cumulee' dans le mod√®le Risque
                # risque.reduction_cumulee = calculer_toutes_reductions()
        
        # 3. Si efficacit√© insuffisante, cr√©er un plan d'action
        if dispositif.efficacite_reelle and dispositif.efficacite_attendue:
            if dispositif.efficacite_reelle < dispositif.efficacite_attendue:
                try:
                    from services.audit_service import creer_plan_action_automatique
                    creer_plan_action_automatique(
                        risque_id=dispositif.risque_id,
                        dispositif_id=dispositif.id,
                        titre=f"Am√©lioration dispositif {dispositif.reference}",
                        description=f"Dispositif insuffisamment efficace ({dispositif.efficacite_reelle}/5 vs {dispositif.efficacite_attendue}/5 attendus)\n\nCommentaire: {form.commentaire.data}",
                        responsable_id=dispositif.responsable_id or current_user.id,
                        echeance=datetime.utcnow().date() + timedelta(days=30)
                    )
                except ImportError:
                    # Si le service n'existe pas, cr√©er un plan d'action simple
                    plan = PlanAction(
                        reference=f"PA-{datetime.utcnow().strftime('%Y%m%d')}-{dispositif.id}",
                        nom=f"Am√©lioration dispositif {dispositif.reference}",
                        description=f"Dispositif insuffisamment efficace ({dispositif.efficacite_reelle}/5 vs {dispositif.efficacite_attendue}/5 attendus)",
                        risque_id=dispositif.risque_id,
                        dispositif_id=dispositif.id,
                        responsable_id=dispositif.responsable_id or current_user.id,
                        date_debut=datetime.utcnow().date(),
                        date_fin_prevue=datetime.utcnow().date() + timedelta(days=30),
                        statut='en_cours',
                        priorite='haute',
                        client_id=current_user.client_id,
                        created_by=current_user.id
                    )
                    db.session.add(plan)
        
        db.session.commit()
        
        # 4. Notifier l'utilisateur avec la r√©duction calcul√©e
        reduction_msg = ""
        if hasattr(dispositif, 'reduction_risque_pourcentage') and dispositif.reduction_risque_pourcentage:
            reduction_msg = f" R√âDUCTION TH√âORIQUE DU RISQUE: {dispositif.reduction_risque_pourcentage:.1f}%"
        
        flash(f'√âvaluation enregistr√©e avec succ√®s.{reduction_msg}', 'success')
        return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))
    
    # PR√â-REMPLIR LE FORMULAIRE (GET request)
    # CORRECTION : Utiliser getattr avec valeur par d√©faut pour √©viter None
    form.efficacite_reelle.data = getattr(dispositif, 'efficacite_reelle', None)
    form.couverture.data = getattr(dispositif, 'couverture', None)
    form.commentaire.data = getattr(dispositif, 'commentaire_evaluation', None)
    
    if dispositif.prochaine_verification:
        form.prochaine_verification.data = dispositif.prochaine_verification
    
    return render_template('dispositifs/evaluation.html',
                         form=form,
                         dispositif=dispositif)

@app.route('/api/verification/<int:verification_id>', methods=['PUT', 'DELETE'])
@login_required
def api_verification(verification_id):
    """API pour modifier ou supprimer une v√©rification"""
    verification = VerificationDispositif.query.get_or_404(verification_id)
    
    if not check_client_access(verification):
        return jsonify({'error': 'Acc√®s non autoris√©'}), 403
    
    if request.method == 'PUT':
        # Modifier la v√©rification
        data = request.get_json()
        
        if 'commentaire' in data:
            verification.commentaire = data['commentaire']
        if 'resultat' in data:
            verification.resultat = data['resultat']
        if 'date_verification' in data:
            verification.date_verification = datetime.strptime(data['date_verification'], '%Y-%m-%d').date()
        
        verification.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'V√©rification modifi√©e',
            'verification': {
                'id': verification.id,
                'commentaire': verification.commentaire,
                'resultat': verification.resultat,
                'date_verification': verification.date_verification.strftime('%Y-%m-%d')
            }
        })
    
    elif request.method == 'DELETE':
        # Supprimer la v√©rification
        dispositif_id = verification.dispositif_id
        db.session.delete(verification)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'V√©rification supprim√©e',
            'redirect': url_for('detail_dispositif', dispositif_id=dispositif_id)
        })

@app.route('/dispositif/<int:dispositif_id>/lier-plan-action', methods=['POST'])
@login_required
def lier_dispositif_plan_action(dispositif_id):
    """Lier un dispositif √† un plan d'action existant"""
    try:
        dispositif = DispositifMaitrise.query.get_or_404(dispositif_id)
        
        if not check_client_access(dispositif):
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return jsonify({'error': 'Acc√®s non autoris√©'}), 403
            flash('Acc√®s non autoris√©', 'error')
            return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))
        
        plan_action_id = request.form.get('plan_action_id')
        if not plan_action_id:
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return jsonify({'error': 'Veuillez s√©lectionner un plan d\'action'}), 400
            flash('Veuillez s√©lectionner un plan d\'action', 'error')
            return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))
        
        plan_action = PlanAction.query.get(plan_action_id)
        if not plan_action or not check_client_access(plan_action):
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return jsonify({'error': 'Plan d\'action non trouv√© ou inaccessible'}), 404
            flash('Plan d\'action non trouv√© ou inaccessible', 'error')
            return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))
        
        # V√©rifier que le plan d'action appartient bien au m√™me risque
        if plan_action.risque_id != dispositif.risque_id:
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return jsonify({'error': 'Le plan d\'action n\'appartient pas au m√™me risque'}), 400
            flash('Le plan d\'action n\'appartient pas au m√™me risque', 'error')
            return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))
        
        # Lier le dispositif au plan d'action
        dispositif.plan_action_id = plan_action_id
        dispositif.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        message = f'Dispositif li√© au plan d\'action {plan_action.reference}'
        
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({
                'success': True,
                'message': message,
                'plan_reference': plan_action.reference,
                'plan_id': plan_action.id
            })
        
        flash(message, 'success')
        return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur liaison dispositif-plan: {e}")
        
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'error': str(e)}), 500
        
        flash(f'Erreur: {str(e)}', 'error')
        return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))

# ============================================================================
# API DISPOSITIFS DE MA√éTRISE
# ============================================================================

@app.route('/api/dispositifs/risque/<int:risque_id>')
@login_required
def api_dispositifs_par_risque(risque_id):
    """API: Liste des dispositifs d'un risque (JSON pour AJAX)"""
    try:
        risque = Risque.query.get_or_404(risque_id)
        
        if not check_client_access(risque):
            return jsonify({'error': 'Acc√®s non autoris√©'}), 403
        
        dispositifs = get_client_filter(DispositifMaitrise)\
            .filter_by(risque_id=risque_id, is_archived=False)\
            .order_by(DispositifMaitrise.reference.asc())\
            .all()
        
        return jsonify({
            'success': True,
            'risque': {
                'id': risque.id,
                'reference': risque.reference,
                'intitule': risque.intitule
            },
            'dispositifs': [{
                'id': d.id,
                'reference': d.reference,
                'nom': d.nom,
                'type': d.type_dispositif,
                'nature': d.nature,
                'frequence': d.frequence,
                'efficacite_reelle': d.efficacite_reelle,
                'efficacite_attendue': d.efficacite_attendue,
                'couverture': d.couverture,
                'statut': d.statut,
                'responsable': d.responsable.username if d.responsable else None,
                'date_derniere_verification': d.date_derniere_verification.strftime('%Y-%m-%d') if d.date_derniere_verification else None,
                'prochaine_verification': d.prochaine_verification.strftime('%Y-%m-%d') if d.prochaine_verification else None,
                'plan_action_id': d.plan_action_id
            } for d in dispositifs],
            'count': len(dispositifs)
        })
        
    except Exception as e:
        print(f"‚ùå Erreur API dispositifs: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/dispositif/<int:dispositif_id>/statistiques')
@login_required
def api_statistiques_dispositif(dispositif_id):
    """API: Statistiques d'un dispositif pour graphiques"""
    try:
        dispositif = DispositifMaitrise.query.get_or_404(dispositif_id)
        
        if not check_client_access(dispositif):
            return jsonify({'error': 'Acc√®s non autoris√©'}), 403
        
        # Historique des v√©rifications
        verifications = VerificationDispositif.query\
            .filter_by(dispositif_id=dispositif_id)\
            .order_by(VerificationDispositif.date_verification.asc())\
            .all()
        
        # Calcul des tendances
        dates = []
        efficacites = []
        resultats = {'Conforme': 0, 'Non conforme': 0, '√Ä corriger': 0}
        
        for v in verifications:
            dates.append(v.date_verification.strftime('%Y-%m-%d'))
            
            # Convertir r√©sultat en score
            if v.resultat == 'Conforme':
                efficacites.append(4)  # Bon score
                resultats['Conforme'] += 1
            elif v.resultat == 'Non conforme':
                efficacites.append(1)  # Mauvais score
                resultats['Non conforme'] += 1
            else:
                efficacites.append(2)  # Score moyen
                resultats['√Ä corriger'] += 1
        
        return jsonify({
            'success': True,
            'dispositif': {
                'reference': dispositif.reference,
                'nom': dispositif.nom,
                'type': dispositif.type_dispositif,
                'efficacite_reelle': dispositif.efficacite_reelle,
                'efficacite_attendue': dispositif.efficacite_attendue,
                'couverture': dispositif.couverture,
                'niveau_efficacite': dispositif.get_niveau_efficacite(),
                'statut': dispositif.statut
            },
            'historique': {
                'dates': dates,
                'efficacites': efficacites,
                'verifications_count': len(verifications)
            },
            'resultats': resultats,
            'documents_count': len(dispositif.documents),
            'derniere_verification': dispositif.date_derniere_verification.strftime('%Y-%m-%d') if dispositif.date_derniere_verification else None,
            'prochaine_verification': dispositif.prochaine_verification.strftime('%Y-%m-%d') if dispositif.prochaine_verification else None
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@app.route('/api/cartographie/<int:cartographie_id>/couverture')
@login_required
def api_couverture_cartographie(cartographie_id):
    """API: Analyse de couverture d'une cartographie"""
    try:
        cartographie = Cartographie.query.get_or_404(cartographie_id)
        
        if not check_client_access(cartographie):
            return jsonify({'error': 'Acc√®s non autoris√©'}), 403
        
        from services.dispositif_service import DispositifService
        rapport = DispositifService.generer_rapport_couverture(cartographie_id)
        
        return jsonify({
            'success': True,
            'rapport': rapport
        })
        
    except Exception as e:
        print(f"‚ùå Erreur API couverture: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/plan-action-risque/<int:plan_id>/progression-detail')
@login_required
def progression_detail_plan_risque(plan_id):
    """API: D√©tail de la progression d'un plan"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan_action):
        return jsonify({'error': 'Acc√®s non autoris√©'}), 403
    
    details = plan_action.get_progression_detail()
    
    return jsonify({
        'success': True,
        'details': details,
        'plan': {
            'reference': plan_action.reference,
            'nom': plan_action.nom,
            'statut': plan_action.statut,
            'progression': plan_action.pourcentage_realisation
        }
    })


@app.route('/plan-action-risque/<int:plan_id>/changer-statut-rapide', methods=['POST'])
@login_required
def changer_statut_plan_risque_rapide(plan_id):
    """Changer rapidement le statut d'un plan d'action"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan_action):
        return jsonify({'error': 'Acc√®s non autoris√©'}), 403
    
    data = request.get_json()
    nouveau_statut = data.get('statut')
    ancien_statut = data.get('ancien_statut', plan_action.statut)
    
    if not nouveau_statut:
        return jsonify({'error': 'Statut manquant'}), 400
    
    # Valider le statut
    statuts_valides = ['en_attente', 'en_cours', 'termine', 'suspendu', 'annule']
    if nouveau_statut not in statuts_valides:
        return jsonify({'error': 'Statut invalide'}), 400
    
    # Enregistrer l'ancien statut
    ancien_statut_plan = plan_action.statut
    
    # Changer le statut
    plan_action.statut = nouveau_statut
    plan_action.updated_at = datetime.utcnow()
    
    # Journalisation CORRIG√âE - convertir dict en string JSON
    try:
        from models import JournalActivite
        journal = JournalActivite(
            utilisateur_id=current_user.id,
            action='changement_statut_plan',
            details=json.dumps({  # CONVERTIR EN STRING JSON
                'plan_id': plan_id,
                'plan_reference': plan_action.reference,
                'ancien_statut': ancien_statut_plan,
                'nouveau_statut': nouveau_statut
            }),
            entite_type='plan_action',
            entite_id=plan_id,
            client_id=current_user.client_id
        )
        db.session.add(journal)
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur journalisation: {e}")
        # Ne pas bloquer si le journal √©choue
    
    db.session.commit()
    
    return jsonify({
        'success': True,
        'message': f'Statut chang√© de {ancien_statut_plan} √† {nouveau_statut}',
        'nouveau_statut': nouveau_statut
    })

@app.route('/plan-action-risque/<int:plan_id>/changer-statut', methods=['POST'])
@csrf.exempt  
@login_required
def changer_statut_plan_risque(plan_id):
    """Changer le statut d'un plan d'action risque - VERSION CORRIG√âE"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan_action):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_id))
    
    # V√©rifier les permissions
    if (current_user.id != plan_action.created_by and 
        not current_user.has_permission('can_manage_plans')):
        flash('Vous n\'√™tes pas autoris√© √† modifier ce plan', 'error')
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_id))
    
    # R√©cup√©rer les donn√©es du formulaire
    nouveau_statut = request.form.get('statut')
    commentaire = request.form.get('commentaire', '')
    
    if nouveau_statut not in ['en_attente', 'en_cours', 'termine', 'suspendu', 'annule']:
        flash('Statut invalide', 'error')
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_id))
    
    try:
        ancien_statut = plan_action.statut
        plan_action.statut = nouveau_statut
        plan_action.updated_at = datetime.utcnow()
        
        # ============================================================
        # CALCUL AUTOMATIQUE DE LA PROGRESSION BAS√âE SUR LE STATUT
        # ============================================================
        if nouveau_statut == 'termine':
            # Si le plan est marqu√© comme termin√©
            plan_action.date_fin_reelle = datetime.utcnow().date()
            plan_action.pourcentage_realisation = 100
            
            # Marquer TOUTES les sous-actions comme termin√©es √† 100%
            for sous_action in plan_action.sous_actions:
                sous_action.statut = 'termine'
                sous_action.pourcentage_realisation = 100
                if not sous_action.date_fin_reelle:
                    sous_action.date_fin_reelle = datetime.utcnow().date()
                sous_action.updated_at = datetime.utcnow()
                
        elif nouveau_statut == 'en_cours':
            # Si le plan passe en cours
            if plan_action.pourcentage_realisation == 0:
                plan_action.pourcentage_realisation = 10  # Valeur initiale
            
            # Marquer les sous-actions sans statut comme "en_cours"
            for sous_action in plan_action.sous_actions:
                if sous_action.statut == 'a_faire' or sous_action.statut is None:
                    sous_action.statut = 'en_cours'
                    if sous_action.pourcentage_realisation == 0:
                        sous_action.pourcentage_realisation = 50  # Valeur moyenne
                    sous_action.updated_at = datetime.utcnow()
                    
        elif nouveau_statut == 'en_attente':
            # Si le plan revient en attente
            plan_action.pourcentage_realisation = 0
            plan_action.date_fin_reelle = None
            
            # Remettre toutes les sous-actions en attente
            for sous_action in plan_action.sous_actions:
                sous_action.statut = 'a_faire'
                sous_action.pourcentage_realisation = 0
                sous_action.date_fin_reelle = None
                sous_action.updated_at = datetime.utcnow()
                
        elif nouveau_statut == 'suspendu':
            # Suspendu : progression inchang√©e, seulement le statut change
            # Ne pas toucher √† la progression
            pass
            
        elif nouveau_statut == 'annule':
            # Si le plan est annul√©
            plan_action.pourcentage_realisation = 0
            
            # Annuler toutes les sous-actions
            for sous_action in plan_action.sous_actions:
                sous_action.statut = 'annule'
                sous_action.pourcentage_realisation = 0
                sous_action.updated_at = datetime.utcnow()
        # ============================================================
        
        # Calculer la progression r√©elle (bas√©e sur les sous-actions)
        # Cette m√©thode devrait mettre √† jour plan_action.pourcentage_realisation
        plan_action.progression_reelle
        
        # Enregistrer un historique si n√©cessaire
        if commentaire:
            # Vous pourriez stocker ce commentaire dans un champ d√©di√©
            # ou cr√©er une table d'historique
            pass
        
        db.session.commit()
        
        flash(f'Statut chang√© de "{ancien_statut}" √† "{nouveau_statut}". Progression: {plan_action.pourcentage_realisation}%', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur: {str(e)}', 'error')
    
    return redirect(url_for('detail_plan_action_risque', plan_id=plan_id))

@app.route('/plan-action-risque/<int:plan_id>/changer-progression', methods=['POST'])
@login_required
def changer_progression_plan(plan_id):
    """Changer manuellement la progression d'un plan (0, 25, 50, 75, 100%) - VERSION MULTI-TENANT"""
    plan = PlanAction.query.get_or_404(plan_id)
    
    # V√âRIFICATION MULTI-TENANT
    if not check_client_access(plan):
        return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
    
    data = request.get_json()
    progression = data.get('progression')
    
    # Accepter seulement les valeurs fixes
    if progression not in [0, 25, 50, 75, 100]:
        return jsonify({'success': False, 'error': 'Progression invalide. Valeurs accept√©es: 0, 25, 50, 75, 100%'}), 400
    
    # V√©rifier les permissions
    if not (current_user.is_client_admin or 
            current_user.id == plan.created_by or 
            current_user.id == plan.responsable_id or
            current_user.has_permission('can_manage_action_plans')):
        return jsonify({'success': False, 'error': 'Permission insuffisante'}), 403
    
    try:
        ancienne_progression = plan.pourcentage_realisation
        plan.pourcentage_realisation = progression
        plan.updated_at = datetime.utcnow()
        
        # Ajuster automatiquement le statut bas√© sur la progression
        if progression == 100:
            plan.statut = 'termine'
            plan.date_fin_reelle = datetime.utcnow().date()
        elif progression >= 50 and plan.statut == 'en_attente':
            plan.statut = 'en_cours'
        elif progression == 0 and plan.statut != 'en_attente':
            plan.statut = 'en_attente'
        
        db.session.commit()
        
        return jsonify({
            'success': True, 
            'message': f'Progression chang√©e de {ancienne_progression}% √† {progression}%',
            'progression': progression,
            'statut': plan.statut
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/plan-action-risque/<int:plan_id>/changer-statut-rapide', methods=['POST'])
@login_required
def changer_statut_plan_rapide(plan_id):
    """Changer le statut d'un plan d'action rapidement"""
    plan = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan):
        return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
    
    if not current_user.can_edit_plan(plan):
        return jsonify({'success': False, 'error': 'Permission insuffisante'}), 403
    
    data = request.get_json()
    nouveau_statut = data.get('statut')
    
    if nouveau_statut not in ['en_attente', 'en_cours', 'termine', 'suspendu', 'annule']:
        return jsonify({'success': False, 'error': 'Statut invalide'}), 400
    
    ancien_statut = plan.statut
    plan.statut = nouveau_statut
    plan.updated_at = datetime.utcnow()
    
    # Journaliser le changement
    journal = JournalActivite(
        utilisateur_id=current_user.id,
        action='changement_statut_plan',
        details={
            'plan_id': plan.id,
            'plan_reference': plan.reference,
            'ancien_statut': ancien_statut,
            'nouveau_statut': nouveau_statut
        },
        entite_type='plan_action',
        entite_id=plan.id,
        client_id=current_user.client_id
    )
    
    try:
        db.session.add(journal)
        db.session.commit()
        return jsonify({'success': True, 'message': 'Statut mis √† jour'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/plan-action-risque/<int:plan_id>/changer-responsable-rapide', methods=['POST'])
@login_required
def changer_responsable_plan_rapide(plan_id):
    """Changer le responsable d'un plan d'action rapidement"""
    plan = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan):
        return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
    
    if not current_user.can_edit_plan(plan):
        return jsonify({'success': False, 'error': 'Permission insuffisante'}), 403
    
    data = request.get_json()
    responsable_id = data.get('responsable_id')
    
    # V√©rifier que le responsable existe dans le m√™me client
    responsable = User.query.filter_by(id=responsable_id, client_id=current_user.client_id).first()
    if not responsable:
        return jsonify({'success': False, 'error': 'Responsable non trouv√©'}), 404
    
    ancien_responsable = plan.responsable_id
    plan.responsable_id = responsable_id
    plan.updated_at = datetime.utcnow()
    
    # Journaliser le changement
    journal = JournalActivite(
        utilisateur_id=current_user.id,
        action='changement_responsable_plan',
        details={
            'plan_id': plan.id,
            'plan_reference': plan.reference,
            'ancien_responsable': ancien_responsable,
            'nouveau_responsable': responsable_id
        },
        entite_type='plan_action',
        entite_id=plan.id,
        client_id=current_user.client_id
    )
    
    try:
        db.session.add(journal)
        db.session.commit()
        return jsonify({'success': True, 'message': 'Responsable mis √† jour'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/plan-action-risque/<int:plan_id>/archiver', methods=['POST'])
@login_required
def archiver_plan_action_risque(plan_id):
    """Archiver un plan d'action"""
    plan = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('voir_plans_action_risque', risque_id=plan.risque_id))
    
    if not current_user.can_edit_plan(plan):
        flash('Permission insuffisante pour archiver ce plan', 'error')
        return redirect(url_for('voir_plans_action_risque', risque_id=plan.risque_id))
    
    plan.is_archived = True
    plan.archived_at = datetime.utcnow()
    plan.archived_by = current_user.id
    plan.updated_at = datetime.utcnow()
    
    # Journaliser
    journal = JournalActivite(
        utilisateur_id=current_user.id,
        action='archivage_plan_action',
        details={
            'plan_id': plan.id,
            'plan_reference': plan.reference,
            'risque_id': plan.risque_id,
            'risque_reference': plan.risque.reference if plan.risque else None
        },
        entite_type='plan_action',
        entite_id=plan.id,
        client_id=current_user.client_id
    )
    
    try:
        db.session.add(journal)
        db.session.commit()
        flash('Plan d\'action archiv√© avec succ√®s', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de l\'archivage: {str(e)}', 'error')
    
    return redirect(url_for('voir_plans_action_risque', risque_id=plan.risque_id))


@app.route('/plan-action-risque/<int:plan_id>/supprimer', methods=['DELETE'])
@login_required
def supprimer_plan_action_risque(plan_id):
    """Supprimer d√©finitivement un plan d'action"""
    plan = PlanAction.query.get_or_404(plan_id)
    risque_id = plan.risque_id
    
    if not check_client_access(plan):
        return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
    
    # Seuls admin client et super admin peuvent supprimer
    if not (current_user.role == 'super_admin' or current_user.is_client_admin):
        return jsonify({'success': False, 'error': 'Permission insuffisante'}), 403
    
    try:
        db.session.delete(plan)
        db.session.commit()
        
        # D√©terminer la redirection
        voir_archives = request.args.get('archives', 'non') == 'oui'
        if voir_archives:
            redirect_url = url_for('voir_plans_action_risque', risque_id=risque_id, archives='oui')
        else:
            redirect_url = url_for('voir_plans_action_risque', risque_id=risque_id)
            
        return jsonify({
            'success': True, 
            'message': 'Plan d\'action supprim√©',
            'redirect': redirect_url
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/plan-action-risque/<int:plan_id>/desarchiver', methods=['POST'])
@login_required
def desarchiver_plan_action_risque(plan_id):
    """D√©sarchiver un plan d'action"""
    plan = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('voir_plans_action_risque', risque_id=plan.risque_id, archives='oui'))
    
    if not current_user.can_edit_plan(plan):
        flash('Permission insuffisante pour d√©sarchiver ce plan', 'error')
        return redirect(url_for('voir_plans_action_risque', risque_id=plan.risque_id, archives='oui'))
    
    plan.is_archived = False
    plan.archived_at = None
    plan.archived_by = None
    plan.updated_at = datetime.utcnow()
    
    # Journaliser
    journal = JournalActivite(
        utilisateur_id=current_user.id,
        action='desarchivage_plan_action',
        details={
            'plan_id': plan.id,
            'plan_reference': plan.reference,
            'risque_id': plan.risque_id,
            'risque_reference': plan.risque.reference if plan.risque else None
        },
        entite_type='plan_action',
        entite_id=plan.id,
        client_id=current_user.client_id
    )
    
    try:
        db.session.add(journal)
        db.session.commit()
        flash('Plan d\'action d√©sarchiv√© avec succ√®s', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors du d√©sarchivage: {str(e)}', 'error')
    
    return redirect(url_for('voir_plans_action_risque', risque_id=plan.risque_id, archives='oui'))

@app.route('/sous-action-risque/<int:sous_action_id>/modifier', methods=['GET', 'POST'])
@login_required
def modifier_sous_action_risque(sous_action_id):
    """Modifier une sous-action d'un plan risque"""
    sous_action = SousAction.query.get_or_404(sous_action_id)
    plan_action = sous_action.plan_action
    
    if not check_client_access(plan_action):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_action.id))
    
    # V√©rifier les permissions
    if (current_user.id != plan_action.created_by and 
        current_user.id != sous_action.responsable_id and
        not current_user.has_permission('can_manage_plans')):
        flash('Vous n\'√™tes pas autoris√© √† modifier cette sous-action', 'error')
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_action.id))
    
    form = SousActionForm(obj=sous_action)
    
    # Pr√©-remplir les choix
    utilisateurs = get_client_filter(User).filter_by(is_active=True).all()
    form.responsable_id.choices = [(0, 'Non assign√©')] + \
        [(u.id, f"{u.username} - {u.role}") for u in utilisateurs]
    
    if form.validate_on_submit():
        sous_action.description = form.description.data
        sous_action.date_debut = form.date_debut.data
        sous_action.date_fin_prevue = form.date_fin_prevue.data
        sous_action.responsable_id = form.responsable_id.data if form.responsable_id.data != 0 else None
        
        # Si le formulaire a un champ commentaire
        if hasattr(form, 'commentaire') and hasattr(sous_action, 'commentaire'):
            sous_action.commentaire = form.commentaire.data
            
        sous_action.updated_at = datetime.utcnow()
        
        db.session.commit()
        flash('Sous-action modifi√©e avec succ√®s', 'success')
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_action.id))
    
    return render_template('plans_action/form_sous_action.html',
                         form=form,
                         plan=plan_action,
                         action='modifier',
                         sous_action=sous_action)

@app.route('/plan-action-risque/<int:plan_id>/terminer', methods=['POST'])
@login_required
def terminer_plan_complet_risque(plan_id):
    """Terminer compl√®tement un plan d'action (toutes les sous-actions)"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan_action):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_id))
    
    # V√©rifier les permissions
    if (current_user.id != plan_action.created_by and 
        not current_user.has_permission('can_manage_plans')):
        flash('Vous n\'√™tes pas autoris√© √† terminer ce plan', 'error')
        return redirect(url_for('detail_plan_action_risque', plan_id=plan_id))
    
    try:
        # Marquer le plan comme termin√©
        plan_action.statut = 'termine'
        plan_action.date_fin_reelle = datetime.utcnow().date()
        plan_action.pourcentage_realisation = 100
        
        # Marquer toutes les sous-actions comme termin√©es
        sous_actions = SousAction.query.filter_by(plan_action_id=plan_id).all()
        for sous_action in sous_actions:
            sous_action.statut = 'termine'
            sous_action.pourcentage_realisation = 100
            if not sous_action.date_fin_reelle:
                sous_action.date_fin_reelle = datetime.utcnow().date()
        
        plan_action.updated_at = datetime.utcnow()
        db.session.commit()
        
        flash('Plan d\'action termin√© avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur: {str(e)}', 'error')
    
    return redirect(url_for('detail_plan_action_risque', plan_id=plan_id))

@app.route('/plan-action-risque/<int:plan_id>/reorganiser-sous-actions', methods=['POST'])
@login_required
def reorganiser_sous_actions_risque(plan_id):
    """R√©organiser l'ordre des sous-actions"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan_action):
        return jsonify({'error': 'Acc√®s non autoris√©'}), 403
    
    data = request.get_json()
    ids = data.get('ids', [])
    
    try:
        # Mettre √† jour l'ordre (vous pourriez avoir un champ 'ordre' dans SousAction)
        for index, sous_action_id in enumerate(ids, 1):
            sous_action = SousAction.query.get(sous_action_id)
            if sous_action and sous_action.plan_action_id == plan_id:
                # Si vous avez un champ 'ordre' dans le mod√®le
                if hasattr(sous_action, 'ordre'):
                    sous_action.ordre = index
                sous_action.updated_at = datetime.utcnow()
        
        db.session.commit()
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

# ============================================================================
# ROUTES POUR LES SOUS-ACTIONS (AJAX)
# ============================================================================
@app.route('/sous-action-risque/<int:sous_action_id>/changer-statut', methods=['POST'])
@login_required
def changer_statut_sous_action(sous_action_id):
    """Changer le statut d'une sous-action"""
    sous_action = SousAction.query.get_or_404(sous_action_id)
    plan = sous_action.plan_action
    
    if not check_client_access(plan):
        return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
    
    data = request.get_json()
    nouveau_statut = data.get('statut')
    progression = data.get('progression')
    
    if nouveau_statut not in ['a_faire', 'en_cours', 'termine', 'retarde']:
        return jsonify({'success': False, 'error': 'Statut invalide'}), 400
    
    try:
        ancien_statut = sous_action.statut
        sous_action.statut = nouveau_statut
        
        if progression is not None:
            sous_action.pourcentage_realisation = progression
        
        # Ajuster automatiquement la progression bas√©e sur le statut
        if nouveau_statut == 'termine' and sous_action.pourcentage_realisation < 100:
            sous_action.pourcentage_realisation = 100
            sous_action.date_fin_reelle = datetime.utcnow().date()
        elif nouveau_statut == 'en_cours' and sous_action.pourcentage_realisation < 50:
            sous_action.pourcentage_realisation = 50
        elif nouveau_statut == 'a_faire' and sous_action.pourcentage_realisation > 0:
            sous_action.pourcentage_realisation = 25
        
        sous_action.updated_at = datetime.utcnow()
        
        # Recalculer la progression du plan
        plan.progression_reelle
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Statut chang√© √† {nouveau_statut}',
            'progression': sous_action.pourcentage_realisation,
            'statut': sous_action.statut,
            'couleur': 'success' if sous_action.pourcentage_realisation >= 100 else 
                      'warning' if sous_action.pourcentage_realisation >= 50 else 'danger',
            'plan_progression': plan.pourcentage_realisation
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/sous-action-risque/<int:sous_action_id>/changer-progression', methods=['POST'])
@login_required
def changer_progression_sous_action(sous_action_id):
    """Changer la progression d'une sous-action (0, 25, 50, 75, 100)"""
    sous_action = SousAction.query.get_or_404(sous_action_id)
    plan = sous_action.plan_action
    
    if not check_client_access(plan):
        return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
    
    data = request.get_json()
    progression = data.get('progression')
    
    # Accepter seulement les valeurs fixes
    if progression not in [0, 25, 50, 75, 100]:
        return jsonify({'success': False, 'error': 'Progression invalide. Valeurs: 0, 25, 50, 75, 100%'}), 400
    
    try:
        ancienne_progression = sous_action.pourcentage_realisation
        sous_action.pourcentage_realisation = progression
        
        # Ajuster automatiquement le statut bas√© sur la progression
        if progression == 100:
            sous_action.statut = 'termine'
            sous_action.date_fin_reelle = datetime.utcnow().date()
        elif progression >= 50 and sous_action.statut == 'a_faire':
            sous_action.statut = 'en_cours'
        elif progression < 50 and sous_action.statut == 'termine':
            sous_action.statut = 'a_faire'
        
        sous_action.updated_at = datetime.utcnow()
        
        # Recalculer la progression du plan
        plan.progression_reelle
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Progression chang√©e de {ancienne_progression}% √† {progression}%',
            'progression': progression,
            'statut': sous_action.statut,
            'plan_progression': plan.pourcentage_realisation
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/plan-action-risque/<int:plan_id>/progression-detail', methods=['GET'])
@login_required
def progression_detail_plan(plan_id):
    """Obtenir les d√©tails de progression d'un plan"""
    plan = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan):
        return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
    
    details = plan.get_progression_detail()
    
    return jsonify({
        'success': True,
        'details': details
    })

@app.route('/plan-action-risque/<int:plan_id>/set-progression-fixe', methods=['POST'])
@login_required
def set_progression_fixe_plan(plan_id):
    """D√©finir une progression fixe pour un plan (0, 25, 50, 75, 100)"""
    plan = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan):
        return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
    
    data = request.get_json()
    progression = data.get('progression')
    
    # Accepter seulement les valeurs fixes
    if progression not in [0, 25, 50, 75, 100]:
        return jsonify({'success': False, 'error': 'Progression invalide. Valeurs: 0, 25, 50, 75, 100%'}), 400
    
    try:
        ancienne_progression = plan.pourcentage_realisation
        plan.pourcentage_realisation = progression
        plan.updated_at = datetime.utcnow()
        
        # Ajuster automatiquement le statut bas√© sur la progression
        if progression == 100:
            plan.statut = 'termine'
            plan.date_fin_reelle = datetime.utcnow().date()
        elif progression >= 50 and plan.statut in ['en_attente', 'suspendu']:
            plan.statut = 'en_cours'
        elif progression == 0 and plan.statut != 'en_attente':
            plan.statut = 'en_attente'
        
        # Ajuster les sous-actions proportionnellement
        for sous_action in plan.sous_actions:
            if sous_action.statut != 'annule':
                sous_action.pourcentage_realisation = progression
                
                # Ajuster le statut de la sous-action
                if progression == 100:
                    sous_action.statut = 'termine'
                    if not sous_action.date_fin_reelle:
                        sous_action.date_fin_reelle = datetime.utcnow().date()
                elif progression >= 50:
                    sous_action.statut = 'en_cours'
                else:
                    sous_action.statut = 'a_faire'
                
                sous_action.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({
            'success': True, 
            'message': f'Progression chang√©e de {ancienne_progression}% √† {progression}%',
            'progression': progression,
            'statut': plan.statut
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/plans-action/disponibles')
@login_required
def api_plans_action_disponibles():
    """API: Liste des plans d'action disponibles pour liaison"""
    try:
        risque_id = request.args.get('risque_id', type=int)
        
        if not risque_id:
            return jsonify({'error': 'risque_id requis'}), 400
        
        # V√©rifier l'acc√®s au risque
        risque = Risque.query.get_or_404(risque_id)
        if not check_client_access(risque):
            return jsonify({'error': 'Acc√®s non autoris√©'}), 403
        
        # R√©cup√©rer les plans d'action du m√™me risque
        plans = get_client_filter(PlanAction)\
            .filter_by(risque_id=risque_id, is_archived=False)\
            .filter(PlanAction.statut.in_(['en_cours', 'en_retard', 'en_attente']))\
            .order_by(PlanAction.created_at.desc())\
            .all()
        
        # Convertir les objets PlanAction en dictionnaires
        plans_data = []
        for p in plans:
            plan_dict = {
                'id': p.id,
                'reference': p.reference,
                'nom': p.nom,
                'statut': p.statut,
                'priorite': getattr(p, 'priorite', 'moyenne'),
                'responsable': p.responsable.username if p.responsable else None,
                'date_echeance': p.date_fin_prevue.strftime('%d/%m/%Y') if p.date_fin_prevue else None,
                'dispositif_id': p.dispositif_id
            }
            plans_data.append(plan_dict)
        
        return jsonify({
            'success': True,
            'plans': plans_data,  # Utilisez le dictionnaire, pas l'objet
            'count': len(plans_data)
        })
        
    except Exception as e:
        print(f"‚ùå Erreur API plans action disponibles: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500


@app.route('/api/dispositif/<int:dispositif_id>/creer-plan-action', methods=['POST'])
@login_required
def api_creer_plan_action_dispositif(dispositif_id):
    """API: Cr√©er un plan d'action automatiquement pour un dispositif"""
    try:
        dispositif = DispositifMaitrise.query.get_or_404(dispositif_id)
        
        if not check_client_access(dispositif):
            return jsonify({'error': 'Acc√®s non autoris√©'}), 403
        
        # V√©rifier si un plan existe d√©j√†
        if dispositif.plan_action_id:
            return jsonify({
                'success': False,
                'message': 'Un plan d\'action est d√©j√† li√© √† ce dispositif'
            })
        
        # V√©rifier que l'efficacit√© est insuffisante
        if not dispositif.efficacite_reelle or not dispositif.efficacite_attendue:
            return jsonify({
                'success': False,
                'message': 'Dispositif non √©valu√© ou efficacit√© attendue manquante'
            })
        
        if dispositif.efficacite_reelle >= dispositif.efficacite_attendue:
            return jsonify({
                'success': False,
                'message': 'L\'efficacit√© r√©elle est suffisante'
            })
        
        # Cr√©er le plan d'action
        from services.audit_service import creer_plan_action_automatique
        
        plan = creer_plan_action_automatique(
            risque_id=dispositif.risque_id,
            dispositif_id=dispositif.id,
            titre=f"Am√©lioration dispositif {dispositif.reference}",
            description=f"Dispositif inefficace ({dispositif.efficacite_reelle}/5 vs {dispositif.efficacite_attendue}/5 attendus). {dispositif.nom}",
            responsable_id=dispositif.responsable_id or current_user.id,
            echeance=datetime.utcnow().date() + timedelta(days=30)
        )
        
        if plan:
            return jsonify({
                'success': True,
                'message': f'Plan d\'action {plan.reference} cr√©√© avec succ√®s',
                'plan_id': plan.id,
                'plan_reference': plan.reference
            })
        else:
            return jsonify({
                'success': False,
                'message': 'Erreur lors de la cr√©ation du plan'
            })
            
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@app.route('/api/dispositifs/a-verifier')
@login_required
def api_dispositifs_a_verifier():
    """API: Liste des dispositifs n√©cessitant une v√©rification"""
    try:
        jours_alerte = request.args.get('jours', 30, type=int)
        
        from services.dispositif_service import DispositifService
        resultats = DispositifService.detecter_dispositifs_a_verifier(
            client_id=current_user.client_id,
            jours_alerte=jours_alerte
        )
        
        return jsonify({
            'success': True,
            'dispositifs': [{
                'id': r['dispositif'].id,
                'reference': r['dispositif'].reference,
                'nom': r['dispositif'].nom,
                'risque_reference': r['dispositif'].risque.reference,
                'jours_restants': r['jours_restants'],
                'niveau': r['niveau'],
                'message': r['message'],
                'risque_id': r['dispositif'].risque_id
            } for r in resultats],
            'count': len(resultats),
            'critique': len([r for r in resultats if r['niveau'] == 'critique']),
            'alerte': len([r for r in resultats if r['niveau'] == 'alerte'])
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@app.route('/api/dispositif/<int:dispositif_id>/verification/formulaire')
@login_required
def api_formulaire_verification(dispositif_id):
    """API: Retourne le formulaire HTML pour une nouvelle v√©rification"""
    try:
        dispositif = DispositifMaitrise.query.get_or_404(dispositif_id)
        
        if not check_client_access(dispositif):
            return '<div class="alert alert-danger">Acc√®s non autoris√©</div>'
        
        # G√©n√©rer le formulaire HTML
        html = f'''
        <form method="POST" action="/dispositif/{dispositif_id}/verification/ajouter" id="formVerification">
            <input type="hidden" name="csrf_token" value="{csrf_token()}">
            
            <div class="mb-3">
                <label class="form-label">Date de v√©rification :</label>
                <input type="date" class="form-control" name="date_verification" 
                       value="{datetime.now().date().isoformat()}" required>
            </div>
            
            <div class="mb-3">
                <label class="form-label">Type de v√©rification :</label>
                <select class="form-select" name="type_verification" required>
                    <option value="">-- S√©lectionner --</option>
                    <option value="Test">Test</option>
                    <option value="Observation">Observation</option>
                    <option value="Revue documentaire">Revue documentaire</option>
                    <option value="Entretien">Entretien</option>
                    <option value="Simulation">Simulation</option>
                </select>
            </div>
            
            <div class="mb-3">
                <label class="form-label">R√©sultat :</label>
                <select class="form-select" name="resultat" required>
                    <option value="">-- S√©lectionner --</option>
                    <option value="Conforme">Conforme</option>
                    <option value="Non conforme">Non conforme</option>
                    <option value="√Ä corriger">√Ä corriger</option>
                </select>
            </div>
            
            <div class="mb-3">
                <label class="form-label">Commentaire :</label>
                <textarea class="form-control" name="commentaire" rows="3" 
                          placeholder="D√©tails de la v√©rification, observations..."></textarea>
            </div>
            
            <div class="alert alert-info">
                <i class="fas fa-info-circle"></i>
                Cette v√©rification mettra √† jour automatiquement :
                <ul class="mb-0 mt-1">
                    <li>Date de derni√®re v√©rification</li>
                    <li>Date de prochaine v√©rification (+6 mois)</li>
                    <li>Si r√©sultat "Non conforme", suggestion de plan d'action</li>
                </ul>
            </div>
        </form>
        '''
        
        return html
        
    except Exception as e:
        return f'<div class="alert alert-danger">Erreur: {str(e)}</div>'


@app.route('/dispositif/<int:dispositif_id>/verification/ajouter', methods=['POST'])
@login_required
def ajouter_verification_dispositif(dispositif_id):
    """Ajouter une v√©rification √† un dispositif"""
    try:
        dispositif = DispositifMaitrise.query.get_or_404(dispositif_id)
        
        if not check_client_access(dispositif):
            flash('Acc√®s non autoris√©', 'error')
            return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))
        
        # Cr√©er la v√©rification
        verification = VerificationDispositif(
            dispositif_id=dispositif_id,
            date_verification=datetime.strptime(request.form['date_verification'], '%Y-%m-%d').date(),
            type_verification=request.form['type_verification'],
            resultat=request.form['resultat'],
            commentaire=request.form.get('commentaire', ''),
            verificateur_id=current_user.id,
            client_id=current_user.client_id
        )
        
        db.session.add(verification)
        
        # Mettre √† jour le dispositif
        dispositif.date_derniere_verification = verification.date_verification
        dispositif.prochaine_verification = verification.date_verification + timedelta(days=180)  # +6 mois
        dispositif.updated_at = datetime.utcnow()
        
        # Si non conforme, sugg√©rer un plan d'action
        if verification.resultat == 'Non conforme':
            dispositif.statut = '√†_am√©liorer'
            
            # Notification pour cr√©ation de plan d'action
            from services.notification_service import NotificationService
            NotificationService.create(
                destinataire_id=dispositif.responsable_id or current_user.id,
                type_notif='warning',
                titre=f"Dispositif non conforme: {dispositif.reference}",
                message=f"La v√©rification du {verification.date_verification.strftime('%d/%m/%Y')} a r√©v√©l√© une non-conformit√©. Un plan d'action est recommand√©.",
                entite_type='dispositif',
                entite_id=dispositif.id,
                actions=[{
                    'url': f'/dispositif/{dispositif.id}',
                    'label': 'Voir le dispositif',
                    'icon': 'eye'
                }],
                user_id=current_user.id
            )
        
        db.session.commit()
        
        flash('V√©rification enregistr√©e avec succ√®s', 'success')
        
        # Redirection selon le contexte
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'success': True, 'redirect': url_for('detail_dispositif', dispositif_id=dispositif_id)})
        else:
            return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))
            
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur ajout v√©rification: {e}")
        
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'error': str(e)}), 500
        else:
            flash(f'Erreur: {str(e)}', 'error')
            return redirect(url_for('detail_dispositif', dispositif_id=dispositif_id))


@app.route('/api/dispositifs/stats-globales')
@login_required
def api_stats_globales_dispositifs():
    """API: Statistiques globales des dispositifs pour le dashboard"""
    try:
        # Stats pour le client courant
        total = get_client_filter(DispositifMaitrise)\
            .filter_by(is_archived=False)\
            .count()
        
        actifs = get_client_filter(DispositifMaitrise)\
            .filter_by(is_archived=False, statut='actif')\
            .count()
        
        a_verifier = get_client_filter(DispositifMaitrise)\
            .filter_by(is_archived=False)\
            .filter(
                (DispositifMaitrise.prochaine_verification <= datetime.now().date()) |
                (DispositifMaitrise.prochaine_verification.is_(None))
            )\
            .count()
        
        efficaces = get_client_filter(DispositifMaitrise)\
            .filter_by(is_archived=False)\
            .filter(DispositifMaitrise.efficacite_reelle >= 4)\
            .count()
        
        # R√©partition par type
        repartition = db.session.query(
            DispositifMaitrise.type_dispositif,
            db.func.count(DispositifMaitrise.id)
        )\
        .filter_by(is_archived=False)\
        .group_by(DispositifMaitrise.type_dispositif)\
        .all()
        
        return jsonify({
            'success': True,
            'stats': {
                'total': total,
                'actifs': actifs,
                'a_verifier': a_verifier,
                'efficaces': efficaces,
                'taux_efficacite': (efficaces / total * 100) if total > 0 else 0
            },
            'repartition': {r[0]: r[1] for r in repartition if r[0]},
            'derniere_mise_a_jour': datetime.utcnow().isoformat()
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

    
@app.route('/dispositif/<int:dispositif_id>/document/formulaire')
@login_required
def formulaire_document_dispositif(dispositif_id):
    """Retourne le formulaire HTML pour ajouter un document"""
    try:
        dispositif = DispositifMaitrise.query.get_or_404(dispositif_id)
        
        if not check_client_access(dispositif):
            return '<div class="alert alert-danger">Acc√®s non autoris√©</div>'
        
        # G√©n√©rer le token CSRF
        csrf_token_value = generate_csrf()
        
        html = f'''
        <form method="POST" action="/dispositif/{dispositif_id}/document/upload" 
              enctype="multipart/form-data" id="formDocument">
            <input type="hidden" name="csrf_token" value="{csrf_token_value}">
            
            <div class="mb-3">
                <label class="form-label">Fichier :</label>
                <input type="file" class="form-control" name="fichier" required>
                <small class="text-muted">Formats autoris√©s : PDF, Word, Excel, PowerPoint, TXT, JPG, PNG</small>
            </div>
            
            <div class="mb-3">
                <label class="form-label">Type de document :</label>
                <select class="form-select" name="type_document" required>
                    <option value="">-- S√©lectionner --</option>
                    <option value="Proc√©dure">Proc√©dure</option>
                    <option value="Mode op√©ratoire">Mode op√©ratoire</option>
                    <option value="Fiche de contr√¥le">Fiche de contr√¥le</option>
                    <option value="Rapport">Rapport</option>
                    <option value="Documentation">Documentation</option>
                    <option value="Autre">Autre</option>
                </select>
            </div>
            
            <div class="mb-3">
                <label class="form-label">Description :</label>
                <textarea class="form-control" name="description" rows="2" 
                          placeholder="Description du document..."></textarea>
            </div>
        </form>
        '''
        
        return html
        
    except Exception as e:
        print(f"‚ùå Erreur formulaire document: {e}")
        return f'<div class="alert alert-danger">Erreur: {str(e)}</div>'





@app.route('/sous-action/<int:sous_action_id>/espace-travail')
@login_required
def espace_travail_sous_action(sous_action_id):
    """Espace de travail individuel pour une sous-action"""
    sous_action = SousAction.query.get_or_404(sous_action_id)
    
    if not check_client_access(sous_action):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    # R√©cup√©rer le plan d'action parent
    plan_action = sous_action.plan_action
    
    # R√©cup√©rer les commentaires sp√©cifiques √† cette sous-action
    commentaires = CommentairePlanAction.query\
        .filter_by(sous_action_id=sous_action_id)\
        .order_by(CommentairePlanAction.created_at.desc())\
        .all()
    
    # R√©cup√©rer les fichiers sp√©cifiques √† cette sous-action
    fichiers = FichierPlanAction.query\
        .filter_by(sous_action_id=sous_action_id)\
        .order_by(FichierPlanAction.created_at.desc())\
        .all()
    
    # Form pour ajouter un commentaire
    form_commentaire = CommentaireSousActionForm()
    
    # V√©rifier si c'est un plan risque ou audit
    is_risque_plan = (plan_action.risque_id is not None)
    
    return render_template('sous_action/espace_travail.html',
                         sous_action=sous_action,
                         plan_action=plan_action,
                         commentaires=commentaires,
                         fichiers=fichiers,
                         form_commentaire=form_commentaire,
                         is_risque_plan=is_risque_plan,
                         current_user=current_user)

# ============================================================================
# ROUTES POUR LES PLANS D'ACTION IND√âPENDANTS
# ============================================================================

@app.route('/plans-action/independants')
@login_required
def liste_plans_action_independants():
    """Liste des plans d'action ind√©pendants (sans risque ni audit)"""
    # Filtrer les plans sans risque_id ET sans audit_id
    query = get_client_filter(PlanAction).filter(
        PlanAction.risque_id == None,
        PlanAction.audit_id == None
    )
    
    # V√©rifier si on veut voir les archives
    voir_archives = request.args.get('archives', 'non') == 'oui'
    
    if voir_archives:
        plans = query.filter(PlanAction.statut_archive == 'archive')\
                     .order_by(PlanAction.updated_at.desc()).all()
    else:
        plans = query.filter(PlanAction.statut_archive == 'actif')\
                     .order_by(PlanAction.created_at.desc()).all()
    
    # Calcul des statistiques
    stats = {
        'total': len([p for p in plans if p.statut_archive == 'actif']),
        'en_cours': len([p for p in plans if p.statut == 'en_cours' and p.statut_archive == 'actif']),
        'termines': len([p for p in plans if p.statut == 'termine' and p.statut_archive == 'actif']),
        'en_retard': len([p for p in plans if p.est_en_retard and p.statut_archive == 'actif']),
        'archives': len([p for p in plans if p.statut_archive == 'archive'])
    }
    
    return render_template('plans_action/liste_independants.html',
                         plans=plans,
                         stats=stats,
                         voir_archives=voir_archives,
                         datetime=datetime)

@app.route('/plans-action/independant/nouveau', methods=['GET', 'POST'])
@login_required
def nouveau_plan_action_independant():
    """Cr√©er un nouveau plan d'action ind√©pendant"""
    
    # Cr√©er un formulaire personnalis√© pour √©viter les probl√®mes de validation
    from flask_wtf import FlaskForm
    from wtforms import StringField, TextAreaField, SelectField, DateField
    from wtforms.validators import DataRequired, Optional
    
    class PlanIndependantForm(FlaskForm):
        nom = StringField('Nom du plan', validators=[DataRequired()])
        description = TextAreaField('Description', validators=[Optional()])
        responsable_id = SelectField('Responsable', coerce=int, choices=[], validators=[Optional()])
        date_debut = DateField('Date de d√©but', format='%Y-%m-%d', validators=[Optional()])
        date_fin_prevue = DateField('Date d\'√©ch√©ance', format='%Y-%m-%d', validators=[Optional()])
    
    form = PlanIndependantForm()
    
    # Pr√©parer les choix avec une option vide
    form.responsable_id.choices = [(0, 'Non assign√©')] + \
        [(u.id, f"{u.username} - {u.role}") 
         for u in get_client_filter(User).filter_by(is_active=True).all()]
    
    if form.validate_on_submit():
        try:
            # G√©n√©rer une r√©f√©rence unique
            from sqlalchemy import func
            
            # Compter les plans ind√©pendants existants
            count = PlanAction.query.filter(
                PlanAction.risque_id == None,
                PlanAction.audit_id == None,
                PlanAction.client_id == current_user.client_id
            ).count()
            
            reference = f"PI-{count + 1:04d}"
            
            plan_action = PlanAction(
                reference=reference,
                nom=form.nom.data,
                description=form.description.data,
                date_debut=form.date_debut.data,
                date_fin_prevue=form.date_fin_prevue.data,
                responsable_id=form.responsable_id.data if form.responsable_id.data and form.responsable_id.data != 0 else None,
                created_by=current_user.id,
                client_id=current_user.client_id,
                statut='en_attente',
                priorite='moyenne',
                # Pas de risque_id, pas d'audit_id
            )
            
            db.session.add(plan_action)
            db.session.commit()
            
            flash('Plan d\'action ind√©pendant cr√©√© avec succ√®s', 'success')
            return redirect(url_for('detail_plan_action_independant', plan_id=plan_action.id))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur lors de la cr√©ation: {str(e)}', 'error')
            print(f"Erreur cr√©ation plan ind√©pendant: {e}")
            import traceback
            traceback.print_exc()
    
    return render_template('plans_action/form_independant.html',
                         form=form,
                         action='creer')

@app.route('/plan-action-independant/<int:plan_id>')
@login_required
def detail_plan_action_independant(plan_id):
    """D√©tail d'un plan d'action ind√©pendant"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    # V√©rifier que c'est bien un plan ind√©pendant
    if plan_action.risque_id or plan_action.audit_id:
        flash('Ce plan n\'est pas un plan ind√©pendant', 'error')
        return redirect(url_for('liste_plans_action_independants'))
    
    if not check_client_access(plan_action):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    # R√©cup√©rer les sous-actions
    sous_actions = SousAction.query\
        .filter_by(plan_action_id=plan_id)\
        .order_by(SousAction.created_at.asc())\
        .all()
    
    # R√©cup√©rer les commentaires r√©cents
    commentaires = CommentairePlanAction.query\
        .filter_by(plan_action_id=plan_id)\
        .order_by(CommentairePlanAction.created_at.desc())\
        .limit(20)\
        .all()
    
    # Calculer l'avancement
    total_sous_actions = len(sous_actions)
    sous_actions_terminees = sum(1 for s in sous_actions if s.statut == 'termine')
    pourcentage_avancement = (sous_actions_terminees / total_sous_actions * 100) if total_sous_actions > 0 else 0
    
    return render_template('plans_action/detail_independant.html',
                         plan=plan_action,
                         sous_actions=sous_actions,
                         commentaires=commentaires,
                         pourcentage_avancement=pourcentage_avancement,
                         sous_actions_terminees=sous_actions_terminees,
                         total_sous_actions=total_sous_actions,
                         datetime=datetime)

@app.route('/plan-action-independant/<int:plan_id>/modifier', methods=['GET', 'POST'])
@login_required
def modifier_plan_action_independant(plan_id):
    """Modifier un plan d'action ind√©pendant"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    # V√©rifier que c'est bien un plan ind√©pendant
    if plan_action.risque_id or plan_action.audit_id:
        flash('Ce plan n\'est pas un plan ind√©pendant', 'error')
        return redirect(url_for('liste_plans_action_independants'))
    
    if not check_client_access(plan_action):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    # V√©rifier les permissions
    if (current_user.id != plan_action.created_by and 
        not current_user.has_permission('can_manage_plans')):
        flash('Vous n\'√™tes pas autoris√© √† modifier ce plan d\'action', 'error')
        return redirect(url_for('detail_plan_action_independant', plan_id=plan_id))
    
    # Cr√©er un formulaire personnalis√©
    from flask_wtf import FlaskForm
    from wtforms import StringField, TextAreaField, SelectField, DateField
    from wtforms.validators import DataRequired, Optional
    
    class PlanIndependantForm(FlaskForm):
        nom = StringField('Nom du plan', validators=[DataRequired()])
        description = TextAreaField('Description', validators=[Optional()])
        responsable_id = SelectField('Responsable', coerce=int, choices=[], validators=[Optional()])
        date_debut = DateField('Date de d√©but', format='%Y-%m-%d', validators=[Optional()])
        date_fin_prevue = DateField('Date d\'√©ch√©ance', format='%Y-%m-%d', validators=[Optional()])
    
    form = PlanIndependantForm(obj=plan_action)
    
    # Pr√©parer les choix
    form.responsable_id.choices = [(0, 'Non assign√©')] + \
        [(u.id, f"{u.username} - {u.role}") 
         for u in get_client_filter(User).filter_by(is_active=True).all()]
    
    # Pr√©-remplir les valeurs
    if request.method == 'GET':
        form.responsable_id.data = plan_action.responsable_id or 0
    
    if form.validate_on_submit():
        try:
            plan_action.nom = form.nom.data
            plan_action.description = form.description.data
            plan_action.responsable_id = form.responsable_id.data if form.responsable_id.data != 0 else None
            plan_action.date_debut = form.date_debut.data
            plan_action.date_fin_prevue = form.date_fin_prevue.data
            plan_action.updated_at = datetime.utcnow()
            
            db.session.commit()
            flash('Plan d\'action modifi√© avec succ√®s', 'success')
            return redirect(url_for('detail_plan_action_independant', plan_id=plan_id))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur: {str(e)}', 'error')
            print(f"Erreur modification plan ind√©pendant: {e}")
            import traceback
            traceback.print_exc()
    
    return render_template('plans_action/form_independant.html',
                         form=form,
                         plan=plan_action,
                         action='modifier')


@app.route('/plan-action-independant/<int:plan_id>/archiver', methods=['POST'])
@login_required
def archiver_plan_action_independant(plan_id):
    """Archiver un plan d'action ind√©pendant"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan_action):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_plan_action_independant', plan_id=plan_id))
    
    # V√©rifier les permissions
    if (current_user.id != plan_action.created_by and 
        not current_user.has_permission('can_manage_plans')):
        flash('Vous n\'√™tes pas autoris√© √† archiver ce plan', 'error')
        return redirect(url_for('detail_plan_action_independant', plan_id=plan_id))
    
    try:
        plan_action.archiver(current_user.id, "Archiv√© manuellement")
        db.session.commit()
        flash('Plan d\'action archiv√© avec succ√®s', 'success')
        
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'success': True})
        
        return redirect(url_for('liste_plans_action_independants'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur: {str(e)}', 'error')
        return redirect(url_for('detail_plan_action_independant', plan_id=plan_id))


@app.route('/plan-action-independant/<int:plan_id>/desarchiver', methods=['POST'])
@login_required
def desarchiver_plan_action_independant(plan_id):
    """D√©sarchiver un plan d'action ind√©pendant"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan_action):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_plan_action_independant', plan_id=plan_id))
    
    if not current_user.has_permission('can_manage_plans'):
        flash('Vous n\'√™tes pas autoris√© √† d√©sarchiver ce plan', 'error')
        return redirect(url_for('detail_plan_action_independant', plan_id=plan_id))
    
    try:
        plan_action.desarchiver()
        db.session.commit()
        flash('Plan d\'action d√©sarchiv√© avec succ√®s', 'success')
        return redirect(url_for('liste_plans_action_independants', archives='oui'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur: {str(e)}', 'error')
        return redirect(url_for('detail_plan_action_independant', plan_id=plan_id))



def generer_reference_plan_independant():
    """G√©n√®re une r√©f√©rence unique pour un plan ind√©pendant"""
    from sqlalchemy import func
    
    base_ref = "PI-"  # Plan Ind√©pendant
    
    # Compter les plans ind√©pendants existants
    count = PlanAction.query.filter(
        PlanAction.risque_id == None,
        PlanAction.audit_id == None,
        PlanAction.client_id == current_user.client_id
    ).count()
    
    return f"{base_ref}{count + 1:04d}"

# ============================================================================
# ============================================================================
# ============================================================================



@app.route('/admin/nettoyer-archives', methods=['POST'])
@login_required
def nettoyer_archives():
    """Nettoyer toutes les archives (admin seulement)"""
    if current_user.role != 'admin':
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('risques_archives'))
    
    try:
        # Compter avant suppression pour l'affichage
        nb_risques = Risque.query.filter_by(is_archived=True).count()
        
        # R√©cup√©rer tous les risques archiv√©s
        risques_archives = Risque.query.filter_by(is_archived=True).all()
        
        for risque in risques_archives:
            # Supprimer les √©valuations
            EvaluationRisque.query.filter_by(risque_id=risque.id).delete()
            
            # Supprimer les KRI
            kri = KRI.query.filter_by(risque_id=risque.id).first()
            if kri:
                MesureKRI.query.filter_by(kri_id=kri.id).delete()
                db.session.delete(kri)
            
            # Supprimer le risque
            db.session.delete(risque)
        
        db.session.commit()
        flash(f'{nb_risques} risques archiv√©s ont √©t√© supprim√©s d√©finitivement', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors du nettoyage : {str(e)}', 'error')
    
    return redirect(url_for('risques_archives'))

@app.route('/cartographie/nouvelle', methods=['GET', 'POST'])
@login_required
def nouvelle_cartographie():
    """Cr√©er une nouvelle cartographie avec notification - VERSION MULTI-TENANT"""
    form = CartographieForm()
    
    # Utiliser des valeurs num√©riques pour les choix
    # FILTRER LES DIRECTIONS PAR CLIENT
    directions = [(d.id, d.nom) for d in get_client_filter(Direction).all()]
    form.direction_id.choices = [(0, 'S√©lectionnez une direction')] + directions
    form.service_id.choices = [(0, 'S√©lectionnez un service')]
    
    if form.validate_on_submit():
        type_cartographie = request.form.get('type_cartographie', 'direction')
        
        # G√©rer les valeurs 0 comme None
        direction_id = form.direction_id.data if form.direction_id.data and form.direction_id.data != 0 else None
        service_id = form.service_id.data if type_cartographie == 'service' and form.service_id.data and form.service_id.data != 0 else None
        
        # Validation suppl√©mentaire
        if not direction_id:
            flash('Veuillez s√©lectionner une direction', 'error')
            return render_template('cartographie/form.html', form=form)
            
        if type_cartographie == 'service' and not service_id:
            flash('Veuillez s√©lectionner un service pour une cartographie par service', 'error')
            return render_template('cartographie/form.html', form=form)
        
        # R√©cup√©rer la direction pour v√©rifier l'acc√®s client
        direction = Direction.query.get(direction_id)
        if direction and not check_client_access(direction):
            flash('Acc√®s non autoris√© √† cette direction', 'error')
            return redirect(url_for('liste_cartographies'))
        
        # R√©cup√©rer le service pour v√©rifier l'acc√®s client (si applicable)
        if service_id:
            service = Service.query.get(service_id)
            if service and not check_client_access(service):
                flash('Acc√®s non autoris√© √† ce service', 'error')
                return redirect(url_for('liste_cartographies'))
        
        # Cr√©er la cartographie avec client_id
        cartographie = Cartographie(
            nom=form.nom.data,
            description=form.description.data,
            direction_id=direction_id,
            service_id=service_id,
            created_by=current_user.id,
            client_id=current_user.client_id  # IMPORTANT : ajouter le client_id
        )
        
        db.session.add(cartographie)
        db.session.flush()
        
        # ==================== NOTIFICATION ====================
        try:
            from services.notification_service import NotificationService
            from models import Notification
            
            actions = [
                {'url': f'/cartographie/{cartographie.id}', 'label': 'Voir la cartographie', 'icon': 'map'},
                {'url': f'/cartographie/{cartographie.id}/risque/nouveau', 'label': 'Ajouter un risque', 'icon': 'plus'}
            ]
            
            NotificationService.create(
                destinataire_id=current_user.id,
                type_notif=Notification.TYPE_SUCCESS,
                titre=f"Nouvelle cartographie cr√©√©e: {cartographie.nom}",
                message=f"La cartographie '{cartographie.nom}' a √©t√© cr√©√©e avec succ√®s",
                entite_type='cartographie',
                entite_id=cartographie.id,
                actions=actions,
                user_id=current_user.id
            )
        except ImportError:
            from models import Notification
            notif = Notification(
                type_notification='success',
                titre=f"Cartographie cr√©√©e",
                message=f"La cartographie '{cartographie.nom}' a √©t√© cr√©√©e",
                destinataire_id=current_user.id,
                entite_type='cartographie',
                entite_id=cartographie.id
            )
            db.session.add(notif)
        # =====================================================
        
        db.session.commit()
        
        flash('Cartographie cr√©√©e avec succ√®s', 'success')
        return redirect(url_for('liste_cartographies'))
    
    return render_template('cartographie/form.html', form=form)


@app.route('/kri/nouveau', methods=['GET'])
@login_required
def nouveau_kri_sans_risque():
    """Page de cr√©ation d'un nouvel indicateur (KRI ou KPI) avec ou sans risque associ√©"""
    
    print(f"üîç [DEBUG] nouveau_kri_sans_risque() - D√©but")
    print(f"   User: {current_user.username}, Role: {current_user.role}")
    
    # V√©rifier la permission
    if not current_user.has_permission('can_manage_kri'):
        flash('Vous n\'avez pas les permissions pour cr√©er un indicateur', 'error')
        return redirect(url_for('liste_kri'))
    
    # V√©rifier la formule d'abonnement
    if current_user.client and current_user.client.formule:
        formule = current_user.client.formule
        if not formule.can_access_module('suivi_kri'):
            return render_template('errors/formule_restricted.html',
                                 module_name='Indicateurs KRI/KPI',
                                 current_formule=formule)
    
    # ============================================
    # 1. R√©cup√©rer les risques disponibles
    # ============================================
    try:
        if current_user.role == 'super_admin':
            # Super admin : soit tous les risques, soit filtr√©s par client en session
            viewing_client_id = session.get('viewing_client_id')
            if viewing_client_id:
                risques = Risque.query.filter_by(
                    client_id=viewing_client_id,
                    is_archived=False
                ).order_by(Risque.reference).all()
            else:
                risques = Risque.query.filter_by(is_archived=False)\
                    .order_by(Risque.reference).all()
        else:
            # Utilisateur normal : risques de son client
            if hasattr(current_user, 'client_id') and current_user.client_id:
                risques = Risque.query.filter_by(
                    client_id=current_user.client_id,
                    is_archived=False
                ).order_by(Risque.reference).all()
            else:
                # Fallback : risques cr√©√©s par l'utilisateur
                risques = Risque.query.filter_by(
                    created_by=current_user.id,
                    is_archived=False
                ).order_by(Risque.reference).all()
        
        print(f"‚úÖ Risques trouv√©s: {len(risques)}")
        
    except Exception as e:
        print(f"‚ùå Erreur r√©cup√©ration risques: {e}")
        risques = []
        flash('Erreur lors de la r√©cup√©ration des risques', 'warning')
    
    # ============================================
    # 2. R√©cup√©rer les utilisateurs pour le responsable
    # ============================================
    try:
        if current_user.role == 'super_admin':
            utilisateurs = User.query.filter_by(is_active=True)\
                .order_by(User.username).all()
        else:
            if hasattr(current_user, 'client_id') and current_user.client_id:
                utilisateurs = User.query.filter_by(
                    client_id=current_user.client_id,
                    is_active=True
                ).order_by(User.username).all()
            else:
                utilisateurs = User.query.filter_by(is_active=True)\
                    .order_by(User.username).limit(50).all()
        
        print(f"‚úÖ Utilisateurs trouv√©s: {len(utilisateurs)}")
        
    except Exception as e:
        print(f"‚ùå Erreur r√©cup√©ration utilisateurs: {e}")
        utilisateurs = []
    
    # ============================================
    # 3. R√©cup√©rer les param√®tres optionnels
    # ============================================
    risque_preselectionne_id = request.args.get('risque_id', type=int)
    type_preselectionne = request.args.get('type', 'kri')  # kri ou kpi
    
    risque_associe = None
    if risque_preselectionne_id:
        # V√©rifier que le risque existe et est accessible
        try:
            risque_associe = next((r for r in risques if r.id == risque_preselectionne_id), None)
            if risque_associe:
                print(f"‚úÖ Risque pr√©-s√©lectionn√©: {risque_associe.reference}")
            else:
                print(f"‚ö†Ô∏è Risque {risque_preselectionne_id} non trouv√© dans la liste")
                risque_preselectionne_id = None
        except Exception as e:
            print(f"‚ùå Erreur v√©rification risque pr√©-s√©lectionn√©: {e}")
            risque_preselectionne_id = None
    
    # ============================================
    # 4. Pr√©parer les donn√©es pour le template
    # ============================================
    
    # Ajouter un attribut _display_text √† chaque risque pour faciliter l'affichage
    for risque in risques:
        risque._display_text = f"{risque.reference} - {risque.intitule}"
    
    # Cr√©er le formulaire WTForms (uniquement pour les champs qui existent)
    from forms import KRIForm
    form = KRIForm()
    
    # Remplir UNIQUEMENT les champs qui existent dans KRIForm
    # responsive_mesure_id existe dans KRIForm
    if hasattr(form, 'responsable_mesure_id'):
        form.responsable_mesure_id.choices = [('', 'S√©lectionnez un responsable...')] + \
                                             [(str(u.id), f"{u.username} ({u.role})") for u in utilisateurs]
    
    # sens_evaluation_seuil existe dans KRIForm
    if hasattr(form, 'sens_evaluation_seuil'):
        form.sens_evaluation_seuil.data = 'superieur'
    
    # frequence_mesure existe dans KRIForm
    if hasattr(form, 'frequence_mesure'):
        form.frequence_mesure.data = 'mensuel'  # Valeur par d√©faut
    
    # NOTE: Les champs risque_id et type_indicateur ne sont PAS dans KRIForm
    # Ils sont g√©r√©s directement dans le template HTML via des selects manuels
    
    print(f"üîç [DEBUG] nouveau_kri_sans_risque() - Fin")
    print(f"   Risques disponibles: {len(risques)}")
    print(f"   Utilisateurs disponibles: {len(utilisateurs)}")
    print(f"   Risque pr√©-s√©lectionn√©: {risque_preselectionne_id if risque_preselectionne_id else 'Aucun'}")
    print(f"   Type pr√©-s√©lectionn√©: {type_preselectionne}")
    
    # ============================================
    # 5. Rendre le template avec toutes les variables
    # ============================================
    return render_template(
        'kri/form.html',
        action='creer',
        form=form,  # Le formulaire WTForms (avec seulement les champs qui existent)
        utilisateurs=utilisateurs,
        risques_disponibles=risques,  # Liste des risques pour le select manuel
        kri=None,
        risque_id=risque_preselectionne_id,  # Pour pr√©-s√©lectionner dans le select
        risque_associe=risque_associe,
        type_preselectionne=type_preselectionne,  # Pour pr√©-s√©lectionner le type
        datetime=datetime,
        now=datetime.utcnow
    )

@app.route('/api/services/<int:direction_id>')
@login_required
def api_services_par_direction(direction_id):
    services = Service.query.filter_by(direction_id=direction_id).all()
    return jsonify([{'id': s.id, 'nom': s.nom} for s in services])

@app.route('/cartographie/<int:id>')
@login_required
def detail_cartographie(id):
    """D√©tail d'une cartographie avec int√©gration des dispositifs de ma√Ætrise"""
    
    # 1. R√©cup√©rer la cartographie avec v√©rification d'acc√®s
    cartographie = Cartographie.query.get_or_404(id)
    
    if not check_client_access(cartographie):
        flash('Acc√®s non autoris√© √† cette cartographie', 'error')
        return redirect(url_for('liste_cartographies'))
    
    print(f"üîç Chargement cartographie: {cartographie.nom} (ID: {id})")
    
    # 2. Gestion des campagnes
    campagne_active = get_client_filter(CampagneEvaluation)\
        .filter_by(
            cartographie_id=id,
            statut='en_cours'
        ).first()
    
    if not campagne_active:
        annee_courante = datetime.now().year
        campagne_active = CampagneEvaluation(
            cartographie_id=id,
            nom=f"Campagne {annee_courante}",
            description=f"√âvaluation annuelle {annee_courante}",
            date_debut=datetime.now().date(),
            statut='en_cours',
            created_by=current_user.id
        )
        
        if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
            campagne_active.client_id = current_user.client_id
        
        db.session.add(campagne_active)
        db.session.commit()
        print(f"‚úÖ Campagne par d√©faut cr√©√©e: {campagne_active.nom}")
    
    # 3. R√©cup√©rer toutes les campagnes pour le s√©lecteur
    campagnes = get_client_filter(CampagneEvaluation)\
        .filter_by(cartographie_id=id)\
        .order_by(CampagneEvaluation.created_at.desc())\
        .all()
    
    # 4. R√©cup√©rer les risques avec leurs √©valuations et dispositifs
    risques_avec_evaluation = []
    evaluations_campagne = []
    total_dispositifs = 0
    
    for risque in cartographie.risques:
        # Ignorer les risques archiv√©s
        if hasattr(risque, 'is_archived') and risque.is_archived:
            continue
        
        # V√©rifier l'acc√®s au risque
        if not check_client_access(risque):
            print(f"‚ö†Ô∏è Risque {risque.reference} inaccessible, ignor√©")
            continue
        
        # R√©cup√©rer l'√©valuation de la campagne active
        evaluation = get_client_filter(EvaluationRisque)\
            .filter_by(
                risque_id=risque.id,
                campagne_id=campagne_active.id
            ).order_by(EvaluationRisque.created_at.desc()).first()
        
        # R√©cup√©rer les dispositifs de ma√Ætrise du risque (non archiv√©s)
        dispositifs_risque = []
        try:
            dispositifs_risque = get_client_filter(DispositifMaitrise)\
                .filter_by(
                    risque_id=risque.id,
                    is_archived=False
                )\
                .order_by(DispositifMaitrise.reference.asc())\
                .all()
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur chargement dispositifs pour risque {risque.id}: {e}")
            # Si la table n'existe pas encore, on continue
            dispositifs_risque = []
        
        # Ajouter au total global
        total_dispositifs += len(dispositifs_risque)
        
        # Ajouter les dispositifs au risque pour le template
        risque.dispositifs_maitrise_list = dispositifs_risque
        
        if evaluation:
            # V√©rifier que l'√©valuation a des valeurs valides
            impact = (evaluation.impact_conf or 
                     evaluation.impact_val or 
                     evaluation.impact_pre)
            probabilite = (evaluation.probabilite_conf or 
                          evaluation.probabilite_val or 
                          evaluation.probabilite_pre)
            
            if impact and probabilite and impact > 0 and probabilite > 0:
                evaluations_campagne.append(evaluation)
            
            risques_avec_evaluation.append({
                'risque': risque,
                'evaluation': evaluation,
                'est_evalue': True
            })
        else:
            risques_avec_evaluation.append({
                'risque': risque,
                'evaluation': None,
                'est_evalue': False
            })
    
    print(f"üìä Cartographie {cartographie.nom}: {len(evaluations_campagne)} √©valuations valides")
    print(f"üõ°Ô∏è Total dispositifs de ma√Ætrise: {total_dispositifs}")
    
    # 5. G√©n√©ration des matrices (si √©valuations disponibles)
    if evaluations_campagne:
        try:
            from utils import generer_matrice_risques, generer_matrice_risque_specifique
            
            print(f"üîÑ G√©n√©ration matrice classique...")
            matrice_classique = generer_matrice_risques(evaluations_campagne, 'classique')
            
            print(f"üîÑ G√©n√©ration matrice criticit√©...")
            matrice_criticite = generer_matrice_risques(evaluations_campagne, 'criticite')
            
            print(f"üîÑ G√©n√©ration matrice priorisation...")
            matrice_priorisation = generer_matrice_risques(evaluations_campagne, 'priorisation')
            
            # G√©n√©rer une matrice par d√©faut avec le premier risque en surbrillance
            risque_surbrillance = None
            risques_actifs = [r for r in cartographie.risques 
                            if not getattr(r, 'is_archived', False) 
                            and check_client_access(r)]
            
            if risques_actifs:
                risque_surbrillance = risques_actifs[0]
                evaluation_surbrillance = None
                for eval_item in evaluations_campagne:
                    if eval_item.risque_id == risque_surbrillance.id:
                        evaluation_surbrillance = eval_item
                        break
                
                if evaluation_surbrillance:
                    print(f"üéØ G√©n√©ration matrice surbrillance pour: {risque_surbrillance.reference}")
                    matrice_surbrillance = generer_matrice_risque_specifique(evaluations_campagne, risque_surbrillance)
                else:
                    matrice_surbrillance = None
            else:
                matrice_surbrillance = None
                
        except Exception as e:
            print(f"‚ùå Erreur g√©n√©ration matrices: {e}")
            import traceback
            traceback.print_exc()
            matrice_classique = None
            matrice_criticite = None
            matrice_priorisation = None
            matrice_surbrillance = None
    else:
        print(f"‚ö†Ô∏è Aucune √©valuation valide trouv√©e")
        matrice_classique = None
        matrice_criticite = None
        matrice_priorisation = None
        matrice_surbrillance = None
    
    # 6. Tableau de Bordeaux bas√© sur la campagne active
    tableau_bordeaux = generer_tableau_bordeaux_campagne(cartographie.risques, campagne_active.id)
    
    # 7. Statistiques globales
    nb_risques_total = len([r for r in cartographie.risques 
                           if not getattr(r, 'is_archived', False) 
                           and check_client_access(r)])
    nb_risques_evalues = len([r for r in risques_avec_evaluation if r['est_evalue']])
    progression_campagne = int((nb_risques_evalues / nb_risques_total * 100) if nb_risques_total > 0 else 0)
    
    # 8. Statistiques suppl√©mentaires sur les dispositifs
    stats_dispositifs = {
        'total': total_dispositifs,
        'par_type': {},
        'efficaces': 0,
        'a_verifier': 0
    }
    
    # Calculer les statistiques des dispositifs
    try:
        # R√©cup√©rer tous les dispositifs de la cartographie
        tous_dispositifs = []
        for risque in cartographie.risques:
            if hasattr(risque, 'is_archived') and risque.is_archived:
                continue
                
            if not check_client_access(risque):
                continue
                
            dispositifs = get_client_filter(DispositifMaitrise)\
                .filter_by(
                    risque_id=risque.id,
                    is_archived=False
                )\
                .all()
            
            for dispositif in dispositifs:
                # Statistiques par type
                if dispositif.type_dispositif:
                    stats_dispositifs['par_type'][dispositif.type_dispositif] = \
                        stats_dispositifs['par_type'].get(dispositif.type_dispositif, 0) + 1
                
                # Dispositifs efficaces (efficacit√© r√©elle >= 4)
                if dispositif.efficacite_reelle and dispositif.efficacite_reelle >= 4:
                    stats_dispositifs['efficaces'] += 1
                
                # Dispositifs √† v√©rifier (date d√©pass√©e ou pas de date)
                aujourdhui = datetime.now().date()
                if (dispositif.prochaine_verification and 
                    dispositif.prochaine_verification <= aujourdhui) or \
                   not dispositif.prochaine_verification:
                    stats_dispositifs['a_verifier'] += 1
                
                tous_dispositifs.append(dispositif)
                
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur calcul stats dispositifs: {e}")
        # En cas d'erreur, on continue avec les stats de base
    
    # 9. Analyse de couverture des risques
    analyse_couverture = []
    for item in risques_avec_evaluation:
        risque = item['risque']
        try:
            # Compter les dispositifs du risque
            nb_dispositifs = len(risque.dispositifs_maitrise_list)
            
            # Calculer l'efficacit√© moyenne si disponible
            efficacite_moyenne = None
            if risque.dispositifs_maitrise_list:
                efficacites = [d.efficacite_reelle for d in risque.dispositifs_maitrise_list 
                             if d.efficacite_reelle is not None]
                if efficacites:
                    efficacite_moyenne = sum(efficacites) / len(efficacites)
            
            analyse_couverture.append({
                'risque_id': risque.id,
                'reference': risque.reference,
                'nb_dispositifs': nb_dispositifs,
                'efficacite_moyenne': efficacite_moyenne,
                'niveau_risque': item['evaluation'].niveau_risque if item['evaluation'] else None,
                'score': item['evaluation'].score_risque if item['evaluation'] else None
            })
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur analyse couverture risque {risque.id}: {e}")
    
    # 10. Pr√©parer les donn√©es pour le template
    try:
        # Trier les risques par score d√©croissant pour l'affichage
        risques_avec_evaluation_tries = sorted(
            risques_avec_evaluation,
            key=lambda x: (
                x['evaluation'].score_risque if x['evaluation'] and x['evaluation'].score_risque else 0,
                x['risque'].reference
            ),
            reverse=True
        )
    except:
        risques_avec_evaluation_tries = risques_avec_evaluation
    
    print(f"‚úÖ Pr√©paration termin√©e: {len(risques_avec_evaluation)} risques, {total_dispositifs} dispositifs")
    
    # 11. Rendu du template
    return render_template('cartographie/detail.html',
                         # Donn√©es principales
                         cartographie=cartographie,
                         campagne_active=campagne_active,
                         campagnes=campagnes,
                         
                         # Risques et √©valuations
                         risques_avec_evaluation=risques_avec_evaluation_tries,
                         
                         # Statistiques
                         nb_risques_total=nb_risques_total,
                         nb_risques_evalues=nb_risques_evalues,
                         progression_campagne=progression_campagne,
                         
                         # Matrices
                         matrice_classique=matrice_classique,
                         matrice_criticite=matrice_criticite,
                         matrice_priorisation=matrice_priorisation,
                         matrice_surbrillance=matrice_surbrillance,
                         
                         # Tableau de Bordeaux
                         tableau_bordeaux=tableau_bordeaux,
                         
                         # NOUVEAU : Donn√©es des dispositifs de ma√Ætrise
                         total_dispositifs=total_dispositifs,
                         stats_dispositifs=stats_dispositifs,
                         analyse_couverture=analyse_couverture,
                         
                         # Variables pour le template
                         current_user=current_user)


def generer_tableau_bordeaux_campagne(risques, campagne_id):
    """G√©n√®re le tableau de Bordeaux pour une campagne sp√©cifique"""
    tableau = {
        'actions_prioritaires': [],
        'surveillance_renforcee': [],
        'surveillance_courante': [],
        'actions_limitees': []
    }
    
    for risque in risques:
        # V√©rifier l'acc√®s et l'archivage
        if (hasattr(risque, 'is_archived') and risque.is_archived) or not check_client_access(risque):
            continue
            
        # R√©cup√©rer l'√©valuation de la campagne
        evaluation = get_client_filter(EvaluationRisque)\
            .filter_by(
                risque_id=risque.id,
                campagne_id=campagne_id
            ).first()
        
        if evaluation and check_client_access(evaluation):
            # Calculer les valeurs finales
            impact_final = (evaluation.impact_conf or 
                           evaluation.impact_val or 
                           evaluation.impact_pre)
            probabilite_final = (evaluation.probabilite_conf or 
                                evaluation.probabilite_val or 
                                evaluation.probabilite_pre)
            
            if impact_final and probabilite_final:
                score = impact_final * probabilite_final
                
                item = {
                    'risque': risque,
                    'evaluation': evaluation,
                    'score': score,
                    'impact': impact_final,
                    'probabilite': probabilite_final
                }
                
                if score >= 17:  # Critique
                    tableau['actions_prioritaires'].append(item)
                elif score >= 11:  # √âlev√©
                    tableau['surveillance_renforcee'].append(item)
                elif score >= 5:  # Moyen
                    tableau['surveillance_courante'].append(item)
                else:  # Faible
                    tableau['actions_limitees'].append(item)
    
    return tableau

@app.route('/cartographie/<int:cartographie_id>/evaluer-tous/<int:campagne_id>')
@login_required
def evaluer_tous_risques(cartographie_id, campagne_id):
    """Page pour √©valuer tous les risques d'une campagne avec isolation"""
    
    # 1. R√©cup√©rer la cartographie avec v√©rification d'acc√®s
    cartographie = Cartographie.query.get_or_404(cartographie_id)
    
    if not check_client_access(cartographie):
        flash('Acc√®s non autoris√© √† cette cartographie', 'error')
        return redirect(url_for('liste_cartographies'))
    
    # 2. R√©cup√©rer la campagne - SOLUTION SIMPLE SANS get_client_filter()
    if current_user.role == 'super_admin':
        # Super admin peut tout voir
        campagne = CampagneEvaluation.query.get_or_404(campagne_id)
    else:
        # Client normal : filtrer par client_id
        campagne = CampagneEvaluation.query.filter_by(
            id=campagne_id,
            client_id=current_user.client_id
        ).first_or_404()
    
    # V√©rification suppl√©mentaire de s√©curit√©
    if not check_client_access(campagne):
        flash('Acc√®s non autoris√© √† cette campagne', 'error')
        return redirect(url_for('detail_cartographie', id=cartographie_id))
    
    # 3. V√©rifier que la campagne appartient √† la cartographie
    if campagne.cartographie_id != cartographie_id:
        flash('Cette campagne ne correspond pas √† cette cartographie', 'error')
        return redirect(url_for('detail_cartographie', id=cartographie_id))
    
    # 4. R√©cup√©rer tous les risques non archiv√©s ET accessibles
    risques = []
    for risque in cartographie.risques:
        # Ignorer les risques archiv√©s
        if hasattr(risque, 'is_archived') and risque.is_archived:
            continue
            
        # V√©rifier l'acc√®s
        if check_client_access(risque):
            risques.append(risque)
    
    # 5. Pour chaque risque, v√©rifier s'il a une √©valuation dans cette campagne
    risques_avec_evaluation = []
    for risque in risques:
        # R√©cup√©rer l'√©valuation avec filtre client
        if current_user.role == 'super_admin':
            evaluation = EvaluationRisque.query.filter_by(
                risque_id=risque.id,
                campagne_id=campagne_id
            ).first()
        else:
            evaluation = EvaluationRisque.query.filter_by(
                risque_id=risque.id,
                campagne_id=campagne_id,
                client_id=current_user.client_id
            ).first()
        
        # V√©rification de s√©curit√© suppl√©mentaire
        if evaluation and not check_client_access(evaluation):
            evaluation = None
        
        risques_avec_evaluation.append({
            'risque': risque,
            'evaluation': evaluation,
            'est_evalue': evaluation is not None
        })
    
    return render_template('cartographie/evaluer_tous.html',
                         cartographie=cartographie,
                         campagne=campagne,
                         risques_avec_evaluation=risques_avec_evaluation)

# ==================== ROUTES NOTIFICATIONS ====================

@app.route('/notifications')
@login_required
def liste_notifications():
    """Page compl√®te des notifications avec isolation multi-tenant"""
    try:
        print(f"üîî LISTE NOTIFICATIONS - Utilisateur: {current_user.username} (client_id: {current_user.client_id})")
        
        # R√©cup√©rer les param√®tres de pagination
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        
        # R√©cup√©rer les filtres
        type_filter = request.args.get('type')
        urgence_filter = request.args.get('urgence')
        statut_filter = request.args.get('statut')
        show_all = request.args.get('show_all', 'false') == 'true'
        
        # CORRECTION : Filtrer par client d'abord, puis par utilisateur
        query = Notification.query
        
        # Isolation multi-tenant
        if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
            # V√©rifier si la table Notification a client_id
            try:
                # Filtrer par client_id si disponible
                if hasattr(Notification, 'client_id'):
                    query = query.filter(Notification.client_id == current_user.client_id)
                    print(f"üîí Isolation par client_id: {current_user.client_id}")
                else:
                    # Sinon filtrer par destinataire seulement
                    print(f"‚ö†Ô∏è Table Notification sans client_id, isolation limit√©e")
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur isolation: {e}")
        
        # Filtrer par destinataire (toujours n√©cessaire)
        query = query.filter(Notification.destinataire_id == current_user.id)
        
        # DEBUG: V√©rifier la requ√™te SQL g√©n√©r√©e
        try:
            print(f"üîç Requ√™te de base: {str(query)}")
        except:
            pass
        
        # Appliquer les filtres
        if type_filter and type_filter != 'all':
            query = query.filter(Notification.type_notification == type_filter)
            print(f"üîç Filtre type: {type_filter}")
        
        if urgence_filter and urgence_filter != 'all':
            query = query.filter(Notification.urgence == urgence_filter)
            print(f"üîç Filtre urgence: {urgence_filter}")
        
        if statut_filter == 'non_lue':
            query = query.filter(Notification.est_lue == False)
            print(f"üîç Filtre statut: non_lue")
        elif statut_filter == 'lue':
            query = query.filter(Notification.est_lue == True)
            print(f"üîç Filtre statut: lue")
        
        # Pour super admin uniquement: option pour voir toutes les notifications
        if current_user.role == 'super_admin' and show_all:
            query = Notification.query
            if statut_filter == 'non_lue':
                query = query.filter(Notification.est_lue == False)
            elif statut_filter == 'lue':
                query = query.filter(Notification.est_lue == True)
            print(f"üîç Super admin - Voir toutes les notifications")
        
        # Trier par date de cr√©ation (les plus r√©centes d'abord)
        query = query.order_by(Notification.created_at.desc())
        
        # Paginer les r√©sultats
        notifications = query.paginate(
            page=page, 
            per_page=per_page, 
            error_out=False
        )
        
        print(f"üìä R√©sultats: {notifications.total} notifications totales, page {page}/{notifications.pages}")
        
        # D√©finir les types de notifications pour le filtre
        types = {
            'all': 'Tous les types',
            'nouvelle_constatation': 'üìù Nouvelle constatation',
            'nouvelle_recommandation': 'üí° Nouvelle recommandation',
            'nouveau_plan': 'üìã Nouveau plan d\'action',
            'echeance': '‚è∞ √âch√©ance proche',
            'retard': '‚ö†Ô∏è Retard',
            'kri_alerte': 'üìä Alerte KRI',
            'veille': 'üìö Veille r√©glementaire',
            'audit_demarre': '‚ñ∂Ô∏è Audit d√©marr√©',
            'audit_termine': '‚úÖ Audit termin√©',
            'risque_evalue': 'üìà Risque √©valu√©',
            'systeme': '‚öôÔ∏è Syst√®me',
            'info': '‚ÑπÔ∏è Information',
            'success': '‚úÖ Succ√®s',
            'warning': '‚ö†Ô∏è Avertissement',
            'error': '‚ùå Erreur'
        }
        
        # D√©finir les niveaux d'urgence
        urgences = {
            'all': 'Tous les niveaux',
            'normal': '‚ö™ Normal',
            'important': 'üü° Important',
            'urgent': 'üî¥ Urgent'
        }
        
        # Calculer les statistiques
        stats_query = Notification.query.filter(Notification.destinataire_id == current_user.id)
        if current_user.role != 'super_admin' and hasattr(Notification, 'client_id'):
            stats_query = stats_query.filter(Notification.client_id == current_user.client_id)
        
        stats = {
            'total': stats_query.count(),
            'non_lues': stats_query.filter(Notification.est_lue == False).count(),
            'lues': stats_query.filter(Notification.est_lue == True).count(),
            'urgentes': stats_query.filter(Notification.urgence == 'urgent', Notification.est_lue == False).count()
        }
        
        print(f"üìä Statistiques: {stats['non_lues']} non lues / {stats['total']} totales")
        
        # Pr√©parer les donn√©es pour le template
        notifications_data = []
        for notification in notifications.items:
            # V√©rifier l'acc√®s pour chaque notification
            if not check_client_access(notification):
                print(f"‚ö†Ô∏è Notification {notification.id} inaccessible pour {current_user.username}")
                continue
                
            # Pr√©parer les donn√©es de notification
            notification_dict = {
                'id': notification.id,
                'type': notification.type_notification,
                'titre': notification.titre,
                'message': notification.message,
                'urgence': notification.urgence,
                'est_lue': notification.est_lue,
                'created_at': notification.created_at,
                'entite_type': notification.entite_type,
                'entite_id': notification.entite_id,
                'actions_possibles': notification.actions_possibles or [],
                'donnees_supplementaires': notification.donnees_supplementaires or {}
            }
            
            # Ajouter les m√©thodes si disponibles
            try:
                notification_dict['time_ago'] = notification.get_time_ago()
            except:
                notification_dict['time_ago'] = format_time_ago(notification.created_at) if notification.created_at else ''
            
            try:
                notification_dict['icon'] = notification.get_icon()
            except:
                notification_dict['icon'] = get_notification_icon(notification.type_notification)
            
            try:
                notification_dict['color'] = notification.get_color()
            except:
                notification_dict['color'] = get_notification_color(notification.urgence)
            
            try:
                notification_dict['url'] = notification.get_url()
            except:
                notification_dict['url'] = get_notification_url(notification.entite_type, notification.entite_id)
            
            notifications_data.append(notification_dict)
        
        # Rendre le template avec les donn√©es
        return render_template(
            'notifications/liste.html',
            notifications=notifications,
            notifications_data=notifications_data,
            types=types,
            urgences=urgences,
            stats=stats,
            page=page,
            per_page=per_page,
            type_filter=type_filter or 'all',
            urgence_filter=urgence_filter or 'all',
            statut_filter=statut_filter or 'all',
            current_user=current_user,
            show_all=show_all,
            mark_as_read=request.args.get('mark_as_read', 'true')
        )
        
    except Exception as e:
        print(f"‚ùå ERREUR CRITIQUE dans liste_notifications: {e}")
        import traceback
        traceback.print_exc()
        
        # En cas d'erreur, retourner une version simplifi√©e
        flash(f'Erreur lors du chargement des notifications: {str(e)[:100]}...', 'error')
        return redirect(url_for('dashboard'))


def format_time_ago(dt):
    """Formate le temps √©coul√© depuis une date"""
    if not dt:
        return "R√©cemment"
    
    now = datetime.utcnow()
    diff = now - dt
    
    if diff.days > 365:
        years = diff.days // 365
        return f"{years} an{'s' if years > 1 else ''}"
    elif diff.days > 30:
        months = diff.days // 30
        return f"{months} mois"
    elif diff.days > 7:
        weeks = diff.days // 7
        return f"{weeks} semaine{'s' if weeks > 1 else ''}"
    elif diff.days > 0:
        return f"{diff.days} jour{'s' if diff.days > 1 else ''}"
    elif diff.seconds >= 3600:
        hours = diff.seconds // 3600
        return f"{hours} heure{'s' if hours > 1 else ''}"
    elif diff.seconds >= 60:
        minutes = diff.seconds // 60
        return f"{minutes} minute{'s' if minutes > 1 else ''}"
    else:
        return "√Ä l'instant"

def get_notification_icon(notification_type):
    """Retourne l'ic√¥ne selon le type de notification"""
    icons = {
        'nouvelle_constatation': 'exclamation-circle',
        'nouvelle_recommandation': 'lightbulb',
        'nouveau_plan': 'tasks',
        'echeance': 'calendar-exclamation',
        'retard': 'clock',
        'kri_alerte': 'chart-line',
        'veille': 'balance-scale',
        'audit_demarre': 'play-circle',
        'audit_termine': 'check-circle',
        'risque_evalue': 'exclamation-triangle',
        'systeme': 'cog',
        'info': 'info-circle',
        'success': 'check-circle',
        'warning': 'exclamation-triangle',
        'error': 'times-circle'
    }
    return icons.get(notification_type, 'bell')

def get_notification_color(urgence):
    """Retourne la couleur selon l'urgence"""
    colors = {
        'urgent': 'danger',
        'important': 'warning',
        'normal': 'info'
    }
    return colors.get(urgence, 'secondary')

def get_notification_url(entite_type, entite_id):
    """Retourne l'URL vers l'entit√©"""
    if not entite_type or not entite_id:
        return None
    
    urls = {
        'audit': f'/audit/{entite_id}',
        'constatation': f'/audit/constatation/{entite_id}',
        'recommandation': f'/audit/recommandation/{entite_id}',
        'plan_action': f'/audit/plan-action/{entite_id}',
        'risque': f'/risque/{entite_id}',
        'kri': f'/kri/{entite_id}',
        'cartographie': f'/cartographie/{entite_id}',
        'processus': f'/processus/{entite_id}',
        'veille': f'/veille/{entite_id}',
        'questionnaire': f'/questionnaire/{entite_id}'
    }
    return urls.get(entite_type)


# Route pour lire une notification
@app.route('/notifications/notification/<int:notification_id>/lire')
@login_required
def lire_notification(notification_id):
    """Lire une notification sp√©cifique"""
    notification = Notification.query.get_or_404(notification_id)
    
    if notification.destinataire_id != current_user.id:
        abort(403)
    
    # Marquer comme lue
    notification.est_lue = True
    notification.read_at = datetime.utcnow()
    db.session.commit()
    
    # Rediriger vers la page appropri√©e BAS√âE SUR LE TYPE D'ENTIT√â
    if notification.entite_type and notification.entite_id:
        # Redirection bas√©e sur le type d'entit√© - CORRIG√âE
        if notification.entite_type == 'cartographie':
            return redirect(url_for('detail_cartographie', id=notification.entite_id))
        elif notification.entite_type == 'questionnaire':
            return redirect(url_for('detail_questionnaire', id=notification.entite_id))
        elif notification.entite_type == 'audit':
            return redirect(url_for('detail_audit', id=notification.entite_id))
        elif notification.entite_type == 'kri':
            return redirect(url_for('detail_kri', kri_id=notification.entite_id))
        elif notification.entite_type == 'risque':
            # Chercher le risque pour obtenir cartographie_id
            risque = Risque.query.get(notification.entite_id)
            if risque and risque.cartographie_id:
                return redirect(url_for('detail_risque', id=notification.entite_id))
        elif notification.entite_type == 'processus':
            return redirect(url_for('detail_processus', id=notification.entite_id))
        elif notification.entite_type == 'veille':
            return redirect(url_for('detail_veille', veille_id=notification.entite_id))
        elif notification.entite_type == 'direction':
            return redirect(url_for('admin_directions'))
        elif notification.entite_type == 'logigramme':
            return redirect(url_for('editer_logigramme', id=notification.entite_id))
        elif notification.entite_type == 'constatation':
            # Chercher la constatation pour obtenir audit_id
            constatation = Constatation.query.get(notification.entite_id)
            if constatation:
                return redirect(url_for('detail_audit', id=constatation.audit_id))
        elif notification.entite_type == 'recommandation':
            recommandation = Recommandation.query.get(notification.entite_id)
            if recommandation:
                return redirect(url_for('detail_audit', id=recommandation.audit_id))
        elif notification.entite_type == 'plan_action':
            plan = PlanAction.query.get(notification.entite_id)
            if plan:
                return redirect(url_for('detail_audit', id=plan.audit_id))
    
    # Par d√©faut, retourner √† la liste des notifications
    return redirect(url_for('liste_notifications'))


# Route pour marquer comme lue via API
@app.route('/api/notifications/<int:notification_id>/toggle-lue', methods=['POST'])
@login_required
def api_toggle_notification_lue(notification_id):
    """API pour basculer l'√©tat lu/non lu"""
    notification = Notification.query.get_or_404(notification_id)
    
    if notification.destinataire_id != current_user.id:
        abort(403)
    
    notification.est_lue = not notification.est_lue
    notification.read_at = datetime.utcnow() if notification.est_lue else None
    
    db.session.commit()
    
    return jsonify({
        'success': True,
        'est_lue': notification.est_lue
    })

# Route pour supprimer une notification
@app.route('/notifications/notification/<int:notification_id>/supprimer', methods=['DELETE'])
@login_required
def supprimer_notification(notification_id):
    """Supprimer une notification"""
    notification = Notification.query.get_or_404(notification_id)
    
    if notification.destinataire_id != current_user.id:
        abort(403)
    
    db.session.delete(notification)
    db.session.commit()
    
    return jsonify({'success': True})

# Route pour marquer toutes les notifications comme lues
@app.route('/notifications/marquer-toutes-lues', methods=['POST'])
@login_required
def marquer_toutes_lues():
    """Marquer toutes les notifications comme lues"""
    Notification.query.filter_by(
        destinataire_id=current_user.id,
        est_lue=False
    ).update({
        'est_lue': True,
        'read_at': datetime.utcnow()
    })
    
    db.session.commit()
    
    return jsonify({'success': True})

# Route pour supprimer toutes les notifications lues
@app.route('/notifications/supprimer-toutes-lues', methods=['DELETE'])
@login_required
def supprimer_toutes_lues():
    """Supprimer toutes les notifications lues"""
    Notification.query.filter_by(
        destinataire_id=current_user.id,
        est_lue=True
    ).delete()
    
    db.session.commit()
    
    return jsonify({'success': True})

# ==================== ROUTES API POUR DROPDOWN ====================

@app.route('/api/notifications/count')
@login_required
def api_notifications_count():
    """API pour obtenir le nombre de notifications non lues"""
    count = Notification.query.filter_by(
        destinataire_id=current_user.id,
        est_lue=False
    ).count()
    
    return jsonify({'count': count})

@app.route('/api/notifications/recent')
@login_required
def api_notifications_recent():
    """API pour les notifications r√©centes (pour dropdown)"""
    limit = request.args.get('limit', 5, type=int)
    
    notifications = Notification.query.filter_by(
        destinataire_id=current_user.id
    ).order_by(
        Notification.created_at.desc()
    ).limit(limit).all()
    
    notifications_data = []
    for notif in notifications:
        # Construire l'URL de redirection
        url = '#'
        if hasattr(notif, 'get_url') and callable(notif.get_url):
            url = notif.get_url()
        elif notif.entite_type and notif.entite_id:
            if notif.entite_type == 'cartographie':
                url = url_for('liste_cartographies')
            elif notif.entite_type == 'questionnaire':
                url = url_for('liste_questionnaires')
        
        notifications_data.append({
            'id': notif.id,
            'titre': notif.titre,
            'message': notif.message,
            'est_lue': notif.est_lue,
            'urgence': notif.urgence,
            'created_at': notif.created_at.isoformat() if notif.created_at else None,
            'url': url,
            'icon': 'bell',
            'color': 'primary'
        })
    
    return jsonify({
        'notifications': notifications_data,
        'count': Notification.query.filter_by(
            destinataire_id=current_user.id,
            est_lue=False
        ).count()
    })

# ==================== ROUTE PREFERENCES (simplifi√©e) ====================


@app.route('/risque/nouveau/<int:cartographie_id>', methods=['GET', 'POST'])
@login_required
def nouveau_risque(cartographie_id):
    """Cr√©er un nouveau risque avec isolation"""
    
    # CORRECTION : Utiliser get_client_filter pour la cartographie
    cartographie = get_client_filter(Cartographie).filter_by(id=cartographie_id).first_or_404()
    
    # V√©rifier l'acc√®s √† la cartographie
    if not check_client_access(cartographie):
        flash('Acc√®s non autoris√© √† cette cartographie', 'error')
        return redirect(url_for('liste_cartographies'))
    
    # V√©rifier les permissions
    if not current_user.has_permission('can_manage_risks'):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    form = RisqueForm()
    
    # CORRECTION : R√©cup√©rer les configurations de listes d√©roulantes avec isolation
    categories_liste = get_client_filter(ConfigurationListeDeroulante)\
        .filter_by(nom_technique='categorie')\
        .first()
    
    types_risque_liste = get_client_filter(ConfigurationListeDeroulante)\
        .filter_by(nom_technique='type_risque')\
        .first()
    
    # CORRECTION : R√©cup√©rer les champs configur√©s avec isolation
    champs_configures = get_client_filter(ConfigurationChampRisque)\
        .filter_by(est_actif=True)\
        .order_by('section', 'ordre_affichage')\
        .all()
    
    # Configuration fichiers
    config_fichiers = {
        'extensions': list(app.config.get('ALLOWED_EXTENSIONS', {'pdf', 'doc', 'docx', 'xls', 'xlsx', 'jpg', 'png', 'txt'})),
        'taille_max_mo': app.config.get('MAX_CONTENT_LENGTH', 10 * 1024 * 1024) // (1024 * 1024),
        'categories': ['document', 'image', 'analyse', 'autre']
    }
    
    if form.validate_on_submit():
        try:
            # CORRECTION : G√©n√©rer une r√©f√©rence automatique avec isolation client
            dernier_risque = get_client_filter(Risque)\
                .order_by(Risque.id.desc())\
                .first()
            
            # Format de r√©f√©rence tenant-aware
            if current_user.role == 'super_admin':
                prefix = "RISQ"
            else:
                client_ref = current_user.client.reference if current_user.client else "CLIENT"
                prefix = f"RISQ-{client_ref}"
            
            nouvelle_ref = f"{prefix}-{(dernier_risque.id + 1) if dernier_risque else 1:04d}"
            
            # Cr√©er le risque avec client_id automatique
            risque = Risque(
                reference=nouvelle_ref,
                intitule=form.intitule.data,
                description=form.description.data,
                processus_concerne=form.processus_concerne.data,
                categorie=request.form.get('categorie', form.categorie.data) if categories_liste else form.categorie.data,
                type_risque=request.form.get('type_risque', form.type_risque.data) if types_risque_liste else form.type_risque.data,
                cause_racine=form.cause_racine.data,
                consequences=form.consequences.data,
                cartographie_id=cartographie_id,
                created_by=current_user.id
            )
            
            # CORRECTION : Ajouter automatiquement client_id pour les clients normaux
            if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
                risque.client_id = current_user.client_id
            
            db.session.add(risque)
            db.session.flush()  # Pour obtenir l'ID du risque
            
            # G√©rer les champs personnalis√©s
            for champ in champs_configures:
                field_name = f'champ_{champ.nom_technique}'
                fichier_name = f'fichier_{champ.nom_technique}'
                
                if champ.type_champ == 'fichier':
                    # Gestion des fichiers
                    if fichier_name in request.files:
                        fichier = request.files[fichier_name]
                        if fichier and fichier.filename:
                            nom_fichier = secure_filename(fichier.filename)
                            timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
                            nom_unique = f"{timestamp}_{nom_fichier}"
                            
                            dossier = os.path.join(app.config['UPLOAD_FOLDER'], 'risques', str(risque.id))
                            os.makedirs(dossier, exist_ok=True)
                            chemin = os.path.join(dossier, nom_unique)
                            
                            fichier.save(chemin)
                            
                            champ_perso = ChampPersonnaliseRisque(
                                risque_id=risque.id,
                                nom_technique=champ.nom_technique
                            )
                            
                            # CORRECTION : Ajouter client_id
                            if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
                                champ_perso.client_id = current_user.client_id
                            
                            champ_perso.set_valeur(nom_fichier)
                            db.session.add(champ_perso)
                else:
                    # Gestion des autres types de champs
                    if field_name in request.form:
                        valeur = request.form[field_name]
                        
                        if champ.type_champ == 'checkbox':
                            valeur = valeur == 'true'
                        elif champ.type_champ == 'multiselect':
                            valeurs = request.form.getlist(field_name)
                            valeur = valeurs
                        
                        # Ne cr√©er le champ que si valeur non vide ou champ obligatoire
                        if valeur or (champ.est_obligatoire and valeur != ''):
                            champ_perso = ChampPersonnaliseRisque(
                                risque_id=risque.id,
                                nom_technique=champ.nom_technique
                            )
                            
                            # CORRECTION : Ajouter client_id
                            if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
                                champ_perso.client_id = current_user.client_id
                            
                            champ_perso.set_valeur(valeur)
                            db.session.add(champ_perso)
            
            # G√©rer les fichiers additionnels
            for i in range(10):
                fichier_key = f'fichier_additionnel_{i}'
                categorie_key = f'categorie_fichier_{i}'
                description_key = f'description_fichier_{i}'
                
                if fichier_key in request.files:
                    fichier = request.files[fichier_key]
                    if fichier and fichier.filename:
                        nom_fichier = secure_filename(fichier.filename)
                        timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
                        nom_unique = f"{timestamp}_{nom_fichier}"
                        
                        dossier = os.path.join(app.config['UPLOAD_FOLDER'], 'risques', str(risque.id))
                        os.makedirs(dossier, exist_ok=True)
                        chemin = os.path.join(dossier, nom_unique)
                        
                        fichier.save(chemin)
                        
                        fichier_db = FichierRisque(
                            risque_id=risque.id,
                            nom_fichier=nom_fichier,
                            chemin_fichier=chemin,
                            type_fichier=fichier.content_type,
                            taille=os.path.getsize(chemin),
                            categorie=request.form.get(categorie_key, 'document'),
                            description=request.form.get(description_key, ''),
                            uploaded_by=current_user.id
                        )
                        
                        # CORRECTION : Ajouter client_id
                        if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
                            fichier_db.client_id = current_user.client_id
                        
                        db.session.add(fichier_db)
            
            db.session.commit()
            
            # üî• D√âCLENCHEMENT AUTOMATIQUE DES MISES √Ä JOUR
            if 'declencher_mise_a_jour_risque' in globals():
                declencher_mise_a_jour_risque(risque.id, 'creation', current_user.id)
            
            # ==================== NOTIFICATION POUR LE CR√âATEUR ====================
            try:
                if 'Notification' in globals():
                    notification = Notification(
                        destinataire_id=current_user.id,
                        type_notification=Notification.TYPE_SYSTEME,
                        titre=f"Nouveau risque cr√©√©: {risque.reference}",
                        message=f"Le risque '{risque.intitule}' a √©t√© cr√©√© avec succ√®s dans la cartographie '{cartographie.nom}'.",
                        urgence=Notification.URGENCE_NORMAL,
                        entite_type='risque',
                        entite_id=risque.id,
                        donnees_supplementaires={
                            'cartographie_id': cartographie_id,
                            'cartographie_nom': cartographie.nom,
                            'createur': current_user.username
                        }
                    )
                    
                    # CORRECTION : Ajouter client_id
                    if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
                        notification.client_id = current_user.client_id
                    
                    db.session.add(notification)
                    db.session.commit()
            except Exception as e:
                print(f"Erreur cr√©ation notification risque: {e}")
            # ===============================================================================
            
            flash('Risque cr√©√© avec succ√®s', 'success')
            return redirect(url_for('detail_cartographie', id=cartographie_id))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur lors de la cr√©ation du risque: {str(e)}', 'error')
            print(f"‚ùå Erreur cr√©ation risque: {e}")
            import traceback
            traceback.print_exc()
    
    return render_template('cartographie/risque_form.html',
                         form=form,
                         cartographie=cartographie,
                         action='creer',
                         categories_liste=categories_liste,
                         types_risque_liste=types_risque_liste,
                         champs_configures=champs_configures,
                         valeurs_existantes={},
                         config_fichiers=config_fichiers)


@app.route('/cartographie/<int:cartographie_id>/risque/<int:risque_id>/matrice')
@login_required
def matrice_risque_specifique(cartographie_id, risque_id):
    """Matrice de risque sp√©cifique avec isolation"""
    
    # CORRECTION : V√©rifier l'acc√®s avec get_client_filter
    cartographie = get_client_filter(Cartographie)\
        .filter_by(id=cartographie_id)\
        .first_or_404()
    
    # V√©rifier l'acc√®s √† la cartographie
    if not check_client_access(cartographie):
        flash('Acc√®s non autoris√© √† cette cartographie', 'error')
        return redirect(url_for('liste_cartographies'))
    
    # CORRECTION : V√©rifier l'acc√®s au risque
    risque_cible = get_client_filter(Risque)\
        .filter_by(id=risque_id, cartographie_id=cartographie_id)\
        .first_or_404()
    
    if not check_client_access(risque_cible):
        flash('Acc√®s non autoris√© √† ce risque', 'error')
        return redirect(url_for('detail_cartographie', id=cartographie_id))
    
    # V√©rifier que le risque appartient √† la cartographie (s√©curit√© suppl√©mentaire)
    if risque_cible.cartographie_id != cartographie_id:
        flash('Ce risque ne fait pas partie de cette cartographie', 'error')
        return redirect(url_for('detail_cartographie', id=cartographie_id))
    
    # CORRECTION : R√©cup√©rer TOUTES les √©valuations VALIDES avec isolation
    evaluations = []
    
    # R√©cup√©rer les risques de la cartographie avec isolation
    risques_cartographie = get_client_filter(Risque)\
        .filter_by(cartographie_id=cartographie_id, is_archived=False)\
        .all()
    
    print(f"üéØ Matrice sp√©cifique - Cartographie: {cartographie.nom} (ID: {cartographie_id})")
    print(f"üéØ Risque cible: {risque_cible.reference} (ID: {risque_id})")
    print(f"üìä Total risques dans cartographie: {len(risques_cartographie)}")
    
    for risque in risques_cartographie:
        # V√©rifier l'acc√®s au risque
        if not check_client_access(risque):
            print(f"‚ö†Ô∏è Risque {risque.reference} inaccessible pour l'utilisateur")
            continue
            
        # Ignorer les risques archiv√©s (double v√©rification)
        if hasattr(risque, 'is_archived') and risque.is_archived:
            print(f"‚ùå Risque {risque.reference} archiv√© - ignor√©")
            continue
            
        # Prendre TOUTES les √©valuations pour avoir une vue compl√®te
        for evaluation in risque.evaluations:
            # V√©rifier l'acc√®s √† l'√©valuation
            if not check_client_access(evaluation):
                continue
                
            # V√©rifier que l'√©valuation a des valeurs valides selon la priorit√©
            impact = (evaluation.impact_conf or 
                     evaluation.impact_val or 
                     evaluation.impact_pre)
            probabilite = (evaluation.probabilite_conf or 
                          evaluation.probabilite_val or 
                          evaluation.probabilite_pre)
            
            if impact and probabilite and impact > 0 and probabilite > 0:
                evaluations.append(evaluation)
                print(f"   ‚úÖ √âvaluation ajout√©e: Risque {risque.reference}, Impact: {impact}, Probabilit√©: {probabilite}")
    
    print(f"üìä Total √©valuations valides et accessibles: {len(evaluations)}")
    
    # G√©n√©rer la matrice avec le risque en surbrillance
    try:
        if 'generer_matrice_risque_specifique' in globals():
            matrice_surbrillance = generer_matrice_risque_specifique(evaluations, risque_cible)
        else:
            # Fallback si la fonction n'est pas disponible
            print("‚ö†Ô∏è Fonction generer_matrice_risque_specifique non disponible")
            matrice_surbrillance = {
                'evaluations': evaluations,
                'risque_cible': {
                    'id': risque_cible.id,
                    'reference': risque_cible.reference,
                    'intitule': risque_cible.intitule
                },
                'message': 'Matrice g√©n√©r√©e en mode de secours'
            }
            
        print(f"‚úÖ Matrice g√©n√©r√©e avec {len(evaluations)} √©valuations")
        
    except Exception as e:
        print(f"‚ùå Erreur g√©n√©ration matrice sp√©cifique: {e}")
        import traceback
        traceback.print_exc()
        flash('Erreur lors de la g√©n√©ration de la matrice', 'error')
        return redirect(url_for('detail_cartographie', id=cartographie_id))
    
    # Ajouter des statistiques pour le template
    stats = {
        'total_risques': len(risques_cartographie),
        'total_evaluations': len(evaluations),
        'risque_cible_nom': risque_cible.intitule,
        'risque_cible_reference': risque_cible.reference
    }
    
    return render_template('cartographie/matrice_risque.html',
                         cartographie=cartographie,
                         risque_cible=risque_cible,
                         matrice_surbrillance=matrice_surbrillance,
                         stats=stats,
                         current_user=current_user)

from PIL import Image as PILImage, ImageDraw, ImageFont
import io

@app.route('/logigramme/<int:activite_id>/export-visuel')
@login_required
def export_logigramme_visuel(activite_id):
    """Export PDF avec diagramme visuel utilisant Pillow"""
    try:
        activite = ProcessusActivite.query.filter_by(
            id=activite_id, 
            created_by=current_user.id
        ).first_or_404()
        
        elements = ElementLogigramme.query.filter_by(activite_id=activite_id).all()
        liens = LienLogigramme.query.filter_by(activite_id=activite_id).all()
        
        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=landscape(A4))
        story = []
        
        styles = getSampleStyleSheet()
        
        # Titre
        story.append(Paragraph(f"<b>LOGIGRAMME VISUEL - {activite.nom}</b>", 
                             ParagraphStyle('Title', parent=styles['Heading1'], fontSize=16, alignment=1)))
        
        if activite.description:
            story.append(Paragraph(f"<i>{activite.description}</i>", 
                                 ParagraphStyle('Desc', alignment=1, textColor=colors.grey)))
        
        story.append(Spacer(1, 20))
        
        # === CR√âER UN DIAGRAMME AVEC PILLOW ===
        
        # Cr√©er une image avec Pillow
        img_width, img_height = 800, 400
        img = PILImage.new('RGB', (img_width, img_height), color='white')
        draw = ImageDraw.Draw(img)
        
        try:
            # Charger une police (utiliser une police par d√©faut si √©choue)
            try:
                font = ImageFont.truetype("arial.ttf", 12)
            except:
                font = ImageFont.load_default()
            
            # Organiser les √©l√©ments en grille
            num_elements = len(elements)
            cols = min(3, num_elements)
            rows = (num_elements + cols - 1) // cols
            
            cell_width = img_width // cols
            cell_height = img_height // rows
            
            element_positions = {}
            
            # Dessiner les √©l√©ments
            for i, element in enumerate(elements):
                col = i % cols
                row = i // cols
                
                x = col * cell_width + cell_width // 2
                y = row * cell_height + cell_height // 2
                
                element_positions[element.id] = (x, y)
                
                # Couleur selon le type
                colors_map = {
                    'debut': '#10b981',
                    'fin': '#6b7280',
                    'action': '#3b82f6',
                    'controle': '#f59e0b',
                    'risque': '#ef4444',
                    'organisation': '#8b5cf6',
                    'titre': '#1e293b'
                }
                
                color = colors_map.get(element.type_element, '#94a3b8')
                
                # Dessiner un rectangle
                rect_size = 80
                draw.rectangle([x - rect_size//2, y - rect_size//4, 
                              x + rect_size//2, y + rect_size//4],
                             fill=color, outline='black', width=2)
                
                # Ajouter le texte
                text = element.libelle[:15] + '...' if len(element.libelle) > 15 else element.libelle
                text_bbox = draw.textbbox((0, 0), text, font=font)
                text_width = text_bbox[2] - text_bbox[0]
                text_height = text_bbox[3] - text_bbox[1]
                
                draw.text((x - text_width//2, y - text_height//2),
                         text, fill='white', font=font)
                
                # Type en petit
                type_text = element.type_element.upper()
                type_bbox = draw.textbbox((0, 0), type_text, font=ImageFont.load_default())
                type_width = type_bbox[2] - type_bbox[0]
                
                draw.text((x - type_width//2, y - rect_size//4 - 15),
                         type_text, fill='black', font=ImageFont.load_default())
            
            # Dessiner les liens
            for lien in liens:
                if lien.element_source_id in element_positions and lien.element_cible_id in element_positions:
                    x1, y1 = element_positions[lien.element_source_id]
                    x2, y2 = element_positions[lien.element_cible_id]
                    
                    # Type de lien
                    lien_type = lien.style.get('type', 'normal') if lien.style else 'normal'
                    if lien_type == 'oui':
                        line_color = '#10b981'
                    elif lien_type == 'non':
                        line_color = '#ef4444'
                    else:
                        line_color = '#475569'
                    
                    # Dessiner la ligne
                    draw.line([x1, y1 + 20, x2, y2 - 20],
                             fill=line_color, width=3)
                    
                    # Fl√®che
                    draw.polygon([x2, y2 - 20,
                                x2 - 10, y2 - 30,
                                x2 + 10, y2 - 30],
                               fill=line_color, outline=line_color)
            
            # Ajouter un titre √† l'image
            title = f"Diagramme de {activite.nom}"
            title_bbox = draw.textbbox((0, 0), title, font=font)
            title_width = title_bbox[2] - title_bbox[0]
            draw.text((img_width//2 - title_width//2, 20),
                     title, fill='black', font=font)
            
        except Exception as e:
            print(f"Erreur cr√©ation image: {e}")
            # Dessiner un message d'erreur simple
            draw.rectangle([0, 0, img_width, img_height], fill='white')
            draw.text((img_width//2 - 100, img_height//2),
                     "Diagramme non disponible", fill='red')
        
        # Sauvegarder l'image dans un buffer
        img_buffer = BytesIO()
        img.save(img_buffer, format='PNG')
        img_buffer.seek(0)
        
        # Ajouter l'image au PDF
        story.append(Paragraph("<b>Repr√©sentation graphique:</b>", styles['Heading2']))
        story.append(Spacer(1, 10))
        
        pdf_img = Image(img_buffer, width=400, height=200)
        pdf_img.hAlign = 'CENTER'
        story.append(pdf_img)
        
        story.append(Spacer(1, 20))
        
        # === L√âGENDE ===
        story.append(Paragraph("<b>L√©gende:</b>", styles['Heading2']))
        
        legende_data = [
            ['D√©but', 'Point de d√©part', 'üü¢'],
            ['Action', 'Activit√© √† r√©aliser', 'üîµ'],
            ['Contr√¥le', 'Point de d√©cision', 'üü°'],
            ['Risque', 'Risque identifi√©', 'üî¥'],
            ['Fin', 'Point de fin', '‚ö´'],
            ['Lien OUI', 'Connexion positive', '‚îÅ‚îÅ‚îÅ‚ñ∂'],
            ['Lien NON', 'Connexion n√©gative', '‚∏∫‚∏∫‚ñ∂']
        ]
        
        legende_table = Table(legende_data, colWidths=[3*cm, 6*cm, 2*cm])
        legende_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#f1f5f9')),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('GRID', (0, 0), (-1, -1), 0.25, colors.grey),
            ('PADDING', (0, 0), (-1, -1), 5)
        ]))
        
        story.append(legende_table)
        
        # === INFORMATIONS ===
        story.append(Spacer(1, 20))
        
        info_data = [
            ['Nom du processus:', activite.nom],
            ['√âl√©ments:', str(len(elements))],
            ['Connexions:', str(len(liens))],
            ['Date d\'export:', datetime.now().strftime('%d/%m/%Y %H:%M:%S')]
        ]
        
        info_table = Table(info_data, colWidths=[4*cm, 5*cm])
        info_table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (0, -1), 'RIGHT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ('PADDING', (0, 0), (-1, -1), 6)
        ]))
        
        story.append(info_table)
        
        # G√©n√©rer le PDF
        doc.build(story)
        buffer.seek(0)
        
        return send_file(
            buffer,
            as_attachment=True,
            download_name=f"logigramme_visuel_{activite.nom}.pdf",
            mimetype='application/pdf'
        )
        
    except Exception as e:
        print(f"‚ùå Erreur export visuel: {str(e)}")
        import traceback
        traceback.print_exc()
        return f"Erreur: {str(e)}", 500




@app.route('/logigramme/<int:activite_id>/export-json')
@login_required
def export_logigramme_json(activite_id):
    """Exporter les donn√©es du logigramme en JSON"""
    activite = ProcessusActivite.query.filter_by(
        id=activite_id, 
        created_by=current_user.id
    ).first_or_404()
    
    elements = ElementLogigramme.query.filter_by(activite_id=activite_id).all()
    liens = LienLogigramme.query.filter_by(activite_id=activite_id).all()
    
    data = {
        'logigramme': {
            'id': activite.id,
            'nom': activite.nom,
            'description': activite.description,
            'created_at': activite.created_at.isoformat() if activite.created_at else None,
            'updated_at': activite.updated_at.isoformat() if activite.updated_at else None
        },
        'elements': [
            {
                'id': e.id,
                'type': e.type_element,
                'libelle': e.libelle,
                'description': e.description,
                'position_x': e.position_x,
                'position_y': e.position_y,
                'style': e.style or {}
            } for e in elements
        ],
        'liens': [
            {
                'id': l.id,
                'source_id': l.element_source_id,
                'cible_id': l.element_cible_id,
                'libelle': l.libelle,
                'style': l.style or {}
            } for l in liens
        ],
        'metadata': {
            'export_date': datetime.now().isoformat(),
            'total_elements': len(elements),
            'total_liens': len(liens),
            'export_format': 'json',
            'version': '1.0'
        }
    }
    
    buffer = BytesIO()
    import json
    buffer.write(json.dumps(data, indent=2, ensure_ascii=False).encode('utf-8'))
    buffer.seek(0)
    
    return send_file(
        buffer,
        as_attachment=True,
        download_name=f"logigramme_{activite.nom}.json",
        mimetype='application/json'
    )


@app.route('/risque/<int:risque_id>/evaluer-campagne/<int:campagne_id>', methods=['GET', 'POST'])
@login_required
def evaluer_risque_campagne(risque_id, campagne_id):
    """√âvaluer un risque dans une campagne sp√©cifique"""
    risque = Risque.query.get_or_404(risque_id)
    campagne = CampagneEvaluation.query.get_or_404(campagne_id)
    
    # V√©rifier la coh√©rence
    if risque.cartographie_id != campagne.cartographie_id:
        flash('Le risque et la campagne ne correspondent pas √† la m√™me cartographie', 'error')
        return redirect(url_for('detail_cartographie', id=risque.cartographie_id))
    
    # S'assurer que cette campagne est active
    # D√©sactiver les autres campagnes actives de cette cartographie
    CampagneEvaluation.query.filter_by(
        cartographie_id=risque.cartographie_id,
        statut='en_cours'
    ).update({'statut': 'terminee'})
    
    # Activer cette campagne
    campagne.statut = 'en_cours'
    db.session.commit()
    
    # Rediriger vers l'√©valuation triphas√©e
    flash(f'Campagne "{campagne.nom}" activ√©e', 'success')
    return redirect(url_for('evaluer_risque_triphase', id=risque_id))



@app.route('/risque/<int:id>/evaluation', methods=['GET', 'POST'])
@login_required
def evaluer_risque(id):
    """√âvaluation d'un risque avec v√©rification d'acc√®s"""
    
    # CORRECTION : R√©cup√©rer avec v√©rification d'acc√®s
    risque = Risque.query.get_or_404(id)
    
    # V√©rifier l'acc√®s au risque
    if not check_client_access(risque):
        flash('Acc√®s non autoris√© √† ce risque', 'error')
        return redirect(url_for('liste_risques'))
    
    form = EvaluationForm()
    
    if form.validate_on_submit():
        score_risque = form.impact.data * form.probabilite.data
        niveau_risque, couleur = calculer_niveau_risque(form.impact.data, form.probabilite.data)
        
        evaluation = EvaluationRisque(
            risque_id=id,
            type_evaluation='pre_evaluation',
            evaluateur_id=current_user.id,
            impact=form.impact.data,
            probabilite=form.probabilite.data,
            niveau_maitrise=form.niveau_maitrise.data,
            commentaire=form.commentaire.data,
            score_risque=score_risque,
            niveau_risque=niveau_risque
        )
        
        # CORRECTION : Ajouter automatiquement client_id
        if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
            evaluation.client_id = current_user.client_id
        
        db.session.add(evaluation)
        db.session.commit()
        
        # üî• D√âCLENCHEMENT AUTOMATIQUE DES MISES √Ä JOUR
        donnees_evaluation = {
            'niveau_risque': niveau_risque,
            'score_risque': score_risque,
            'impact': form.impact.data,
            'probabilite': form.probabilite.data
        }
        declencher_mise_a_jour_risque(id, 'evaluation', current_user.id, donnees_evaluation)
        
        # üî• SYNCHRONISATION SP√âCIFIQUE DES MATRICES
        synchroniser_matrices_apres_evaluation(risque.cartographie_id)
        
        flash('√âvaluation enregistr√©e avec succ√®s', 'success')
        return redirect(url_for('detail_cartographie', id=risque.cartographie_id))
    
    return render_template('cartographie/evaluation.html', form=form, risque=risque)


def synchroniser_matrices_apres_evaluation(cartographie_id):
    """Synchronise toutes les matrices apr√®s une √©valuation avec v√©rification d'acc√®s"""
    from models import Cartographie
    
    # CORRECTION : V√©rifier l'acc√®s √† la cartographie
    cartographie = Cartographie.query.get(cartographie_id)
    if not cartographie:
        return
    
    if not check_client_access(cartographie):
        print(f"‚ö†Ô∏è Acc√®s non autoris√© √† la cartographie {cartographie_id}")
        return
    
    print(f"üîÑ Synchronisation des matrices pour {cartographie.nom}")
    
    # Marquer la cartographie comme n√©cessitant une reg√©n√©ration des matrices
    cartographie.derniere_sync_matrices = datetime.utcnow()
    
    try:
        db.session.commit()
        print(f"‚úÖ Matrices marqu√©es pour reg√©n√©ration pour {cartographie.nom}")
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur synchronisation matrices: {str(e)}")

def invalider_cache_matrices(cartographie_id):
    """Invalide le cache des matrices avec v√©rification d'acc√®s"""
    
    # CORRECTION : V√©rifier l'acc√®s √† la cartographie
    cartographie = Cartographie.query.get(cartographie_id)
    if not cartographie or not check_client_access(cartographie):
        print(f"‚ö†Ô∏è Acc√®s non autoris√© pour invalider cache de cartographie {cartographie_id}")
        return
    
    cache_keys = [
        f'matrice_classique_{cartographie_id}',
        f'matrice_criticite_{cartographie_id}', 
        f'matrice_priorisation_{cartographie_id}',
        f'matrice_surbrillance_{cartographie_id}'
    ]
    
    for key in cache_keys:
        # Impl√©mentation de l'invalidation du cache
        print(f"üóëÔ∏è Cache matrice invalid√©: {key}")



# ============================================
# ROUTES POUR LA GESTION DES SOURCES
# ============================================

@app.route('/kri/sources')
@login_required
def liste_sources_donnees():
    """Liste des sources de donn√©es"""
    from models import SourceDonnee
    
    sources = get_client_filter(SourceDonnee).order_by(SourceDonnee.nom).all()
    
    # Statistiques
    stats = {
        'total': len(sources),
        'actives': len([s for s in sources if s.statut == 'actif']),
        'api': len([s for s in sources if s.type_source == 'api']),
        'fichier': len([s for s in sources if s.type_source == 'fichier']),
        'bdd': len([s for s in sources if s.type_source == 'base_donnees'])
    }
    
    return render_template('kri/sources/liste.html', sources=sources, stats=stats)

@app.route('/kri/sources/nouvelle', methods=['GET', 'POST'])
@login_required
def nouvelle_source_donnee():
    """Cr√©er une nouvelle source de donn√©es - VERSION CORRIG√âE"""
    
    from flask_wtf import FlaskForm
    from wtforms import StringField, TextAreaField, SelectField, IntegerField
    from wtforms.validators import DataRequired, Optional
    
    class SourceForm(FlaskForm):
        nom = StringField('Nom', validators=[DataRequired()])
        description = TextAreaField('Description', validators=[Optional()])
        type_source = SelectField('Type de source', choices=[
            ('api', 'API REST'),
            ('base_donnees', 'Base de donn√©es'),
            ('fichier', 'Fichier (CSV/Excel)'),
            ('autre', 'Autre')
        ], validators=[DataRequired()])
        frequence_rafraichissement = IntegerField('Fr√©quence (secondes)', default=86400)
        
        # Champs pour API
        api_url = StringField('URL', validators=[Optional()])
        api_method = SelectField('M√©thode', choices=[
            ('GET', 'GET'),
            ('POST', 'POST'),
            ('PUT', 'PUT')
        ], default='GET')
        api_headers = TextAreaField('Headers (JSON)', validators=[Optional()])
        
        # Champs pour fichier
        fichier_chemin = StringField('Chemin du fichier', validators=[Optional()])
        fichier_format = SelectField('Format', choices=[
            ('csv', 'CSV'),
            ('excel', 'Excel'),
            ('json', 'JSON')
        ], default='csv')
        
        # Champs pour base de donn√©es
        bdd_type = SelectField('Type BDD', choices=[
            ('postgresql', 'PostgreSQL'),
            ('mysql', 'MySQL'),
            ('sqlite', 'SQLite')
        ], default='postgresql')
        bdd_host = StringField('H√¥te', validators=[Optional()])
        bdd_port = IntegerField('Port', validators=[Optional()])
        bdd_nom = StringField('Nom de la base', validators=[Optional()])
        bdd_requete = TextAreaField('Requ√™te SQL', validators=[Optional()])
        
        # Authentification
        auth_type = SelectField('Type d\'authentification', choices=[
            ('', 'Aucune'),
            ('basic', 'Basic Auth'),
            ('bearer', 'Bearer Token'),
            ('api_key', 'API Key')
        ], default='')
        auth_username = StringField('Nom d\'utilisateur', validators=[Optional()])
        auth_password = StringField('Mot de passe', validators=[Optional()])
        auth_token = StringField('Token', validators=[Optional()])
        auth_key_name = StringField('Nom de la cl√©', validators=[Optional()])
        auth_key_value = StringField('Valeur de la cl√©', validators=[Optional()])
        auth_in_header = StringField('Dans header', default='true')
    
    form = SourceForm()
    
    if form.validate_on_submit():
        try:
            # Construire la config_connexion selon le type
            config_connexion = {}
            
            if form.type_source.data == 'api':
                config_connexion = {
                    'url': form.api_url.data,
                    'method': form.api_method.data,
                    'headers': form.api_headers.data or '{}'
                }
            elif form.type_source.data == 'fichier':
                config_connexion = {
                    'chemin': form.fichier_chemin.data,
                    'format': form.fichier_format.data
                }
            elif form.type_source.data == 'base_donnees':
                config_connexion = {
                    'type': form.bdd_type.data,
                    'host': form.bdd_host.data,
                    'port': form.bdd_port.data,
                    'database': form.bdd_nom.data,
                    'requete': form.bdd_requete.data
                }
            
            # Construire auth_config si n√©cessaire
            auth_config = None
            if form.auth_type.data:
                auth_config = {'type': form.auth_type.data}
                if form.auth_type.data == 'basic':
                    auth_config['username'] = form.auth_username.data
                    auth_config['password'] = form.auth_password.data
                elif form.auth_type.data == 'bearer':
                    auth_config['token'] = form.auth_token.data
                elif form.auth_type.data == 'api_key':
                    auth_config['key_name'] = form.auth_key_name.data
                    auth_config['key_value'] = form.auth_key_value.data
                    auth_config['in_header'] = form.auth_in_header.data == 'true'
            
            # Cr√©er la source
            source = SourceDonnee(
                nom=form.nom.data,
                description=form.description.data,
                type_source=form.type_source.data,
                config_connexion=config_connexion,
                auth_config=auth_config,
                frequence_rafraichissement=form.frequence_rafraichissement.data,
                statut='actif',
                created_by=current_user.id,
                client_id=current_user.client_id,
                prochaine_execution=datetime.utcnow()
            )
            
            db.session.add(source)
            db.session.commit()
            
            flash('‚úÖ Source cr√©√©e avec succ√®s', 'success')
            return redirect(url_for('liste_sources_donnees'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'‚ùå Erreur lors de la cr√©ation: {str(e)}', 'error')
    
    return render_template('kri/sources/form.html', 
                         form=form, 
                         action='creer',
                         current_user=current_user)


@app.route('/kri/sources/<int:id>/editer', methods=['GET', 'POST'])
@login_required
def editer_source_donnee(id):
    """Modifier une source de donn√©es existante"""
    
    from flask_wtf import FlaskForm
    from wtforms import StringField, TextAreaField, SelectField, IntegerField
    from wtforms.validators import DataRequired, Optional
    
    class SourceForm(FlaskForm):
        nom = StringField('Nom', validators=[DataRequired()])
        description = TextAreaField('Description', validators=[Optional()])
        type_source = SelectField('Type de source', choices=[
            ('api', 'API REST'),
            ('base_donnees', 'Base de donn√©es'),
            ('fichier', 'Fichier (CSV/Excel)'),
            ('autre', 'Autre')
        ], validators=[DataRequired()])
        frequence_rafraichissement = IntegerField('Fr√©quence (secondes)', default=86400)
        
        # Champs pour API
        api_url = StringField('URL', validators=[Optional()])
        api_method = SelectField('M√©thode', choices=[
            ('GET', 'GET'),
            ('POST', 'POST'),
            ('PUT', 'PUT')
        ], default='GET')
        api_headers = TextAreaField('Headers (JSON)', validators=[Optional()])
        
        # Champs pour fichier
        fichier_chemin = StringField('Chemin du fichier', validators=[Optional()])
        fichier_format = SelectField('Format', choices=[
            ('csv', 'CSV'),
            ('excel', 'Excel'),
            ('json', 'JSON')
        ], default='csv')
        
        # Champs pour base de donn√©es
        bdd_type = SelectField('Type BDD', choices=[
            ('postgresql', 'PostgreSQL'),
            ('mysql', 'MySQL'),
            ('sqlite', 'SQLite')
        ], default='postgresql')
        bdd_host = StringField('H√¥te', validators=[Optional()])
        bdd_port = IntegerField('Port', validators=[Optional()])
        bdd_nom = StringField('Nom de la base', validators=[Optional()])
        bdd_requete = TextAreaField('Requ√™te SQL', validators=[Optional()])
        
        # Authentification
        auth_type = SelectField('Type d\'authentification', choices=[
            ('', 'Aucune'),
            ('basic', 'Basic Auth'),
            ('bearer', 'Bearer Token'),
            ('api_key', 'API Key')
        ], default='')
        auth_username = StringField('Nom d\'utilisateur', validators=[Optional()])
        auth_password = StringField('Mot de passe', validators=[Optional()])
        auth_token = StringField('Token', validators=[Optional()])
        auth_key_name = StringField('Nom de la cl√©', validators=[Optional()])
        auth_key_value = StringField('Valeur de la cl√©', validators=[Optional()])
        auth_in_header = StringField('Dans header', default='true')
    
    source = get_client_filter(SourceDonnee).filter_by(id=id).first_or_404()
    form = SourceForm(obj=source)
    
    # Pr√©-remplir les champs avec la config existante
    if request.method == 'GET':
        config = source.config_connexion or {}
        auth = source.auth_config or {}
        
        if source.type_source == 'api':
            form.api_url.data = config.get('url')
            form.api_method.data = config.get('method', 'GET')
            form.api_headers.data = config.get('headers', '{}')
        elif source.type_source == 'fichier':
            form.fichier_chemin.data = config.get('chemin')
            form.fichier_format.data = config.get('format', 'csv')
        elif source.type_source == 'base_donnees':
            form.bdd_type.data = config.get('type', 'postgresql')
            form.bdd_host.data = config.get('host')
            form.bdd_port.data = config.get('port')
            form.bdd_nom.data = config.get('database')
            form.bdd_requete.data = config.get('requete')
        
        if auth:
            form.auth_type.data = auth.get('type')
            if auth.get('type') == 'basic':
                form.auth_username.data = auth.get('username')
                form.auth_password.data = auth.get('password')
            elif auth.get('type') == 'bearer':
                form.auth_token.data = auth.get('token')
            elif auth.get('type') == 'api_key':
                form.auth_key_name.data = auth.get('key_name')
                form.auth_key_value.data = auth.get('key_value')
                form.auth_in_header.data = 'true' if auth.get('in_header') else 'false'
    
    if form.validate_on_submit():
        try:
            # Construire la config_connexion selon le type
            config_connexion = {}
            
            if form.type_source.data == 'api':
                config_connexion = {
                    'url': form.api_url.data,
                    'method': form.api_method.data,
                    'headers': form.api_headers.data or '{}'
                }
            elif form.type_source.data == 'fichier':
                config_connexion = {
                    'chemin': form.fichier_chemin.data,
                    'format': form.fichier_format.data
                }
            elif form.type_source.data == 'base_donnees':
                config_connexion = {
                    'type': form.bdd_type.data,
                    'host': form.bdd_host.data,
                    'port': form.bdd_port.data,
                    'database': form.bdd_nom.data,
                    'requete': form.bdd_requete.data
                }
            
            # Construire auth_config si n√©cessaire
            auth_config = None
            if form.auth_type.data:
                auth_config = {'type': form.auth_type.data}
                if form.auth_type.data == 'basic':
                    auth_config['username'] = form.auth_username.data
                    auth_config['password'] = form.auth_password.data
                elif form.auth_type.data == 'bearer':
                    auth_config['token'] = form.auth_token.data
                elif form.auth_type.data == 'api_key':
                    auth_config['key_name'] = form.auth_key_name.data
                    auth_config['key_value'] = form.auth_key_value.data
                    auth_config['in_header'] = form.auth_in_header.data == 'true'
            
            # Mettre √† jour la source
            source.nom = form.nom.data
            source.description = form.description.data
            source.type_source = form.type_source.data
            source.config_connexion = config_connexion
            source.auth_config = auth_config
            source.frequence_rafraichissement = form.frequence_rafraichissement.data
            source.updated_at = datetime.utcnow()
            
            db.session.commit()
            
            flash('‚úÖ Source modifi√©e avec succ√®s', 'success')
            return redirect(url_for('liste_sources_donnees'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'‚ùå Erreur lors de la modification: {str(e)}', 'error')
    
    return render_template('kri/sources/form.html', 
                         form=form, 
                         source=source,
                         action='editer',
                         current_user=current_user)

@app.route('/kri/sources/<int:id>')
@login_required
def detail_source_donnee(id):
    """D√©tail d'une source"""
    source = get_client_filter(SourceDonnee).filter_by(id=id).first_or_404()
    
    # R√©cup√©rer les collectes r√©centes
    collectes = CollecteDonnee.query\
        .join(SourceKRILink)\
        .filter(SourceKRILink.source_id == id)\
        .order_by(CollecteDonnee.date_collecte.desc())\
        .limit(50).all()
    
    return render_template('kri/sources/detail.html', source=source, collectes=collectes)


@app.route('/kri/sources/<int:id>/executer', methods=['POST'])
@login_required
def executer_source(id):
    """Ex√©cuter manuellement une source"""
    source = get_client_filter(SourceDonnee).filter_by(id=id).first_or_404()
    
    from collecte_engine import CollecteEngine
    engine = CollecteEngine(app, db)
    resultat = engine.collecter_source(id, force=True)
    
    if resultat['erreurs']:
        return jsonify({'success': False, 'errors': resultat['erreurs']})
    
    return jsonify({'success': True, 'result': resultat})


@app.route('/kri/<int:kri_id>/lier-source', methods=['POST'])
@login_required
def lier_source_kri(kri_id):
    """Lier une source √† un KRI"""
    kri = get_client_filter(KRI).filter_by(id=kri_id).first_or_404()
    
    data = request.json
    link = SourceKRILink(
        source_id=data['source_id'],
        kri_id=kri_id,
        chemin_donnee=data.get('chemin'),
        mapping_config=data.get('mapping', {}),
        seuil_min=data.get('seuil_min'),
        seuil_max=data.get('seuil_max')
    )
    
    db.session.add(link)
    db.session.commit()
    
    return jsonify({'success': True, 'id': link.id})


@app.route('/api/kri/<int:kri_id>/historique-collectes')
@login_required
def historique_collectes_kri(kri_id):
    """API pour historique des collectes"""
    collectes = CollecteDonnee.query\
        .join(SourceKRILink)\
        .filter(SourceKRILink.kri_id == kri_id)\
        .order_by(CollecteDonnee.date_collecte.desc())\
        .limit(30).all()
    
    data = [{
        'date': c.date_collecte.isoformat(),
        'valeur': c.valeur,
        'source': c.source_link.source.nom,
        'statut': c.statut
    } for c in collectes]
    
    return jsonify(data)


@app.route('/api/kri/sources/stats')
@login_required
def stats_sources():
    """Stats pour le dashboard"""
    from sqlalchemy import func
    
    today = datetime.utcnow().date()
    collectes_today = CollecteDonnee.query\
        .filter(func.date(CollecteDonnee.date_collecte) == today)\
        .count()
    
    total_kri_lies = SourceKRILink.query\
        .join(SourceDonnee)\
        .filter(SourceDonnee.client_id == current_user.client_id)\
        .count()
    
    return jsonify({
        'collectes_today': collectes_today,
        'total_kri_lies': total_kri_lies
    })


@app.route('/api/kri/sources/disponibles')
@login_required
def api_sources_disponibles():
    """API pour r√©cup√©rer les sources disponibles"""
    sources = get_client_filter(SourceDonnee).filter_by(statut='actif').all()
    return jsonify([{
        'id': s.id,
        'nom': s.nom,
        'type_source': s.type_source,
        'description': s.description
    } for s in sources])

@app.route('/api/kri/transformateurs')
@login_required
def api_transformateurs():
    """API pour r√©cup√©rer les transformateurs disponibles"""
    transformateurs = TransformateurDonnee.query.all()
    return jsonify([{
        'nom': t.nom,
        'description': t.description,
        'type': t.type_transform
    } for t in transformateurs])

@app.route('/api/kri/<int:kri_id>/lier-source', methods=['POST'])
@login_required
def lier_source_kri_api(kri_id):
    """API pour lier une source √† un KRI"""
    kri = get_client_filter(KRI).filter_by(id=kri_id).first_or_404()
    
    data = request.json
    
    # V√©rifier que la source existe
    source = get_client_filter(SourceDonnee).filter_by(id=data['source_id']).first()
    if not source:
        return jsonify({'success': False, 'error': 'Source non trouv√©e'})
    
    # Cr√©er le lien
    link = SourceKRILink(
        source_id=data['source_id'],
        kri_id=kri_id,
        chemin_donnee=data.get('chemin_donnee'),
        mapping_config=data.get('mapping_config', {}),
        seuil_min=data.get('seuil_min'),
        seuil_max=data.get('seuil_max'),
        transformateur=data.get('transformateur')
    )
    
    db.session.add(link)
    db.session.commit()
    
    return jsonify({'success': True, 'id': link.id})

@app.route('/api/kri/links/<int:link_id>/collecter', methods=['POST'])
@login_required
def forcer_collecte_link(link_id):
    """Force une collecte pour un lien sp√©cifique"""
    link = SourceKRILink.query.get_or_404(link_id)
    
    # V√©rifier l'acc√®s au KRI
    if not check_client_access(link.kri):
        return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'})
    
    from collecte_engine import CollecteEngine
    engine = CollecteEngine(app, db)
    
    try:
        # Collecter uniquement pour ce lien
        resultat = engine.collecter_source(link.source_id, force=True)
        
        # Trouver la collecte pour ce lien
        collecte = CollecteDonnee.query.filter_by(
            source_link_id=link_id
        ).order_by(CollecteDonnee.date_collecte.desc()).first()
        
        if collecte and collecte.mesure_kri_id:
            return jsonify({
                'success': True,
                'valeur': collecte.valeur,
                'mesure_id': collecte.mesure_kri_id
            })
        else:
            return jsonify({'success': True, 'message': 'Collecte effectu√©e, aucune nouvelle mesure'})
            
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/kri/<int:kri_id>/historique-collectes')
@login_required
def historique_collectes_kri_api(kri_id):
    """API pour l'historique des collectes d'un KRI"""
    kri = get_client_filter(KRI).filter_by(id=kri_id).first_or_404()
    
    collectes = CollecteDonnee.query\
        .join(SourceKRILink)\
        .filter(SourceKRILink.kri_id == kri_id)\
        .order_by(CollecteDonnee.date_collecte.desc())\
        .limit(30).all()
    
    data = [{
        'date': c.date_collecte.isoformat(),
        'valeur': c.valeur,
        'source': c.source_link.source.nom,
        'statut': c.statut
    } for c in collectes]
    
    return jsonify(data)


@app.route('/debug/creer-source-exemple')
@login_required
def creer_source_exemple():
    """Route temporaire pour cr√©er une source exemple"""
    
    # V√©rifier s'il existe d√©j√† des sources
    from models import SourceDonnee
    if SourceDonnee.query.count() > 0:
        return "‚úÖ Des sources existent d√©j√†"
    
    # Cr√©er une source API exemple
    source = SourceDonnee(
        nom="API Exemple - Satisfaction Client",
        description="Source de donn√©es exemple pour tester le syst√®me",
        type_source="api",
        config_connexion={
            "url": "https://api.example.com/v1/satisfaction",
            "method": "GET",
            "headers": {
                "Content-Type": "application/json"
            }
        },
        auth_config=None,
        frequence_rafraichissement=86400,  # 24h
        statut='actif',
        created_by=current_user.id,
        client_id=current_user.client_id
    )
    
    db.session.add(source)
    db.session.commit()
    
    # Cr√©er aussi une source fichier exemple
    source2 = SourceDonnee(
        nom="Fichier CSV - Donn√©es qualit√©",
        description="Import depuis fichier CSV",
        type_source="fichier",
        config_connexion={
            "chemin": "/uploads/donnees_qualite.csv",
            "format": "csv"
        },
        frequence_rafraichissement=604800,  # 7 jours
        statut='actif',
        created_by=current_user.id,
        client_id=current_user.client_id
    )
    
    db.session.add(source2)
    db.session.commit()
    
    return f"‚úÖ 2 sources cr√©√©es avec succ√®s ! IDs: {source.id}, {source2.id}"




@app.route('/kri', methods=['GET', 'POST'])
@login_required
def liste_kri():
    """Liste des indicateurs (KRI et KPI) avec isolation compl√®te"""
    
    # V√âRIFICATION FORMULE : v√©rifier si le client a acc√®s au module "kri"
    if current_user.client and current_user.client.formule:
        formule = current_user.client.formule
        
        # V√©rifier si la formule donne acc√®s au module "kri"
        if not formule.can_access_module('suivi_kri'):
            # Afficher une page d'upgrade
            try:
                # R√©cup√©rer toutes les formules actives
                all_formules = FormuleAbonnement.query.filter(
                    FormuleAbonnement.is_active == True
                ).all()
                
                # Filtrer celles qui ont le module kri
                upgrade_suggestions = []
                for f in all_formules:
                    if f.modules.get('kri', False):
                        upgrade_suggestions.append(f)
                
                # Trier par prix
                upgrade_suggestions.sort(key=lambda x: x.prix_mensuel or 0)
                
                return render_template('errors/formule_restricted.html', 
                                     module_name='Indicateurs KRI/KPI',
                                     current_formule=formule,
                                     upgrade_suggestions=upgrade_suggestions[:3])
                
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur recherche formules upgrade: {e}")
                flash('Ce module n\'est pas inclus dans votre formule actuelle', 'error')
                return redirect(url_for('dashboard'))
    
    # V√©rifier la permission de g√©rer les KRI
    if not current_user.has_permission('can_manage_kri'):
        flash('Acc√®s refus√© : permission de g√©rer les KRI requise', 'error')
        return redirect(url_for('dashboard'))
    
    if request.method == 'POST':
        return creer_kri_depuis_liste()
    
    # CORRECTION : Utiliser get_client_filter
    kris = get_client_filter(KRI)\
        .filter_by(est_actif=True)\
        .order_by(
            KRI.type_indicateur.desc(),  # KRI d'abord, puis KPI
            KRI.nom
        ).all()
    
    # CORRECTION : Filtrer les KRI accessibles
    accessible_kris = []
    for kri in kris:
        # V√©rifier l'acc√®s au KRI
        if check_client_access(kri):
            # V√©rifier aussi l'acc√®s au risque associ√© si pr√©sent
            if kri.risque_id:
                risque = Risque.query.get(kri.risque_id)
                if risque and not check_client_access(risque):
                    print(f"‚ö†Ô∏è KRI {kri.id} ignor√© (risque inaccessible)")
                    continue
            
            accessible_kris.append(kri)
    
    # Calculer les statistiques uniquement sur les KRI accessibles
    stats = {
        'total': len(accessible_kris),
        'kris': len([k for k in accessible_kris if k.type_indicateur == 'kri']),
        'kpis': len([k for k in accessible_kris if k.type_indicateur == 'kpi']),
        'actifs': len([k for k in accessible_kris if k.est_actif]),
        'alertes': len([k for k in accessible_kris if getattr(k, 'est_en_alerte', False)]),
        'avec_risque': len([k for k in accessible_kris if k.risque_id]),
        'sans_risque': len([k for k in accessible_kris if not k.risque_id])
    }
    
    # ‚úÖ CORRECTION 1 : R√©cup√©rer les utilisateurs du m√™me client AVEC TRI
    if current_user.role == 'super_admin':
        utilisateurs = User.query.filter_by(is_active=True)\
            .order_by(User.username.asc()).all()
    else:
        utilisateurs = get_client_filter(User).filter_by(is_active=True)\
            .order_by(User.username.asc()).all()
    
    # ‚úÖ CORRECTION 2 : R√©cup√©rer les risques accessibles du m√™me client AVEC TRI
    risques_query = get_client_filter(Risque).filter_by(is_archived=False)\
        .order_by(Risque.reference.asc())
    
    risques_disponibles = []
    for risque in risques_query.all():
        if check_client_access(risque):
            risques_disponibles.append(risque)
    
    # Calculer la tendance pour chaque indicateur accessible
    for kri in accessible_kris:
        # R√©cup√©rer seulement les mesures accessibles
        mesures_accessibles = []
        if hasattr(kri, 'mesures'):
            for mesure in kri.mesures:
                if check_client_access(mesure):
                    mesures_accessibles.append(mesure)
        
        kri.tendance = calculer_tendance_kri(mesures_accessibles) if mesures_accessibles else 'stable'
        
        # Ajouter d'autres informations utiles
        kri.nb_mesures = len(mesures_accessibles)
        
        # Derni√®re valeur
        derniere_mesure = kri.get_derniere_mesure()
        if derniere_mesure:
            kri.derniere_valeur = derniere_mesure.valeur
            kri.valeur_formatee = f"{derniere_mesure.valeur:.2f}"
            kri.date_derniere_mesure = derniere_mesure.date_mesure
        else:
            kri.derniere_valeur = None
            kri.valeur_formatee = "N/A"
            kri.date_derniere_mesure = None
        
        # D√©terminer la couleur selon la tendance
        if kri.tendance == 'positive':
            kri.couleur_tendance = 'success'
        elif kri.tendance == 'negative':
            kri.couleur_tendance = 'danger'
        else:
            kri.couleur_tendance = 'warning'
        
        # ‚úÖ AJOUT : D√©terminer l'√©tat d'alerte
        if derniere_mesure:
            kri.etat_alerte = kri.get_etat_alerte(derniere_mesure.valeur)
            kri.couleur_etat = kri.get_couleur_etat(derniere_mesure.valeur)
            kri.libelle_etat = kri.get_libelle_etat(derniere_mesure.valeur)
        else:
            kri.etat_alerte = 'inconnu'
            kri.couleur_etat = 'secondary'
            kri.libelle_etat = 'N/A'
    
    # ‚úÖ AJOUT : V√©rifier les permissions pour l'affichage
    can_view_users = current_user.has_permission('can_view_users_list')
    can_edit_users = current_user.has_permission('can_edit_users')
    
    # Debug info
    print(f"üîç Liste KRI - Utilisateur: {current_user.username}, R√¥le: {current_user.role}")
    print(f"üîç KRI trouv√©s: {len(kris)}, Accessibles: {len(accessible_kris)}")
    print(f"üîç Utilisateurs disponibles: {len(utilisateurs)}")
    print(f"üîç Risques disponibles: {len(risques_disponibles)}")
    print(f"üîç Permissions - can_view_users_list: {can_view_users}, can_edit_users: {can_edit_users}")
    
    return render_template('kri/liste.html', 
                         kris=accessible_kris,
                         stats=stats,
                         utilisateurs=utilisateurs,
                         risques_disponibles=risques_disponibles,
                         can_view_users=can_view_users,
                         can_edit_users=can_edit_users,
                         datetime=datetime)

@app.route('/kri/<int:kri_id>')
@login_required
def detail_kri_short(kri_id):
    """Redirection vers la fiche d√©taill√©e d'un KRI (route courte)"""
    return redirect(url_for('detail_kri', kri_id=kri_id))

# ========================
# ROUTES KRI CORRIG√âES
# ========================
@app.route('/kri/nouveau', methods=['GET'])
@login_required
def nouveau_kri_form():
    """Afficher le formulaire de cr√©ation d'un indicateur"""
    
    print(f"üîç [DEBUG] D√©but nouveau_kri_form()")
    print(f"   User: {current_user.username}, Role: {current_user.role}")
    
    # Cr√©er le formulaire
    from forms import KRIForm
    form = KRIForm()
    
    # Remplir les choix du formulaire
    # 1. Risques
    if current_user.role == 'super_admin':
        risques_query = Risque.query.filter_by(is_archived=False)
    else:
        if hasattr(current_user, 'client_id') and current_user.client_id:
            risques_query = Risque.query.filter_by(
                client_id=current_user.client_id,
                is_archived=False
            )
        else:
            # Fallback : risques cr√©√©s par l'utilisateur
            risques_query = Risque.query.filter_by(
                created_by=current_user.id,
                is_archived=False
            )
    
    risques = risques_query.order_by(Risque.reference).all()
    print(f"üîç Risques trouv√©s: {len(risques)}")
    
    # Ajouter les choix au formulaire
    form.risque_id.choices = [('', 'S√©lectionnez un risque...')] + \
                             [(str(r.id), f"{r.reference} - {r.intitule}") for r in risques]
    
    # 2. Utilisateurs responsables
    if current_user.role == 'super_admin':
        users = User.query.filter_by(is_active=True).all()
    else:
        if hasattr(current_user, 'client_id') and current_user.client_id:
            users = User.query.filter_by(
                client_id=current_user.client_id,
                is_active=True
            ).all()
        else:
            users = User.query.filter_by(is_active=True).all()
    
    form.responsable_mesure_id.choices = [('', 'S√©lectionnez un responsable...')] + \
                                         [(str(u.id), f"{u.username} ({u.role})") for u in users]
    
    # 3. Cat√©gories
    form.categorie.choices = [
        ('', 'S√©lectionnez...'),
        ('operationnel', 'Op√©rationnel'),
        ('financier', 'Financier'),
        ('qualite', 'Qualit√©'),
        ('securite', 'S√©curit√©'),
        ('conformite', 'Conformit√©'),
        ('rh', 'Ressources Humaines'),
        ('technologique', 'Technologique'),
        ('autre', 'Autre')
    ]
    
    print(f"üîç [DEBUG] Fin nouveau_kri_form()")
    print(f"   Risques dans form.risque_id.choices: {len(form.risque_id.choices) - 1}")
    
    # Passer le formulaire au template
    return render_template('kri/form.html',
                         action='creer',
                         form=form,  # <-- IMPORTANT : passer le formulaire
                         utilisateurs=users,
                         risques_disponibles=risques)  # <-- Pour le d√©bogage

@app.route('/kri/nouveau/<int:risque_id>', methods=['GET', 'POST'])
@login_required
def nouveau_kri(risque_id):
    """Cr√©er un KRI associ√© √† un risque sp√©cifique avec notification et isolation"""
    
    if request.method == 'GET':
        """Afficher le formulaire pour cr√©er un KRI associ√© √† un risque sp√©cifique"""
        # CORRECTION : Utiliser get_client_object_or_404 pour v√©rifier l'acc√®s
        risque = get_client_object_or_404(Risque, risque_id)
        
        # V√©rifier les permissions
        if not current_user.has_permission('can_manage_kri'):
            flash('Vous n\'avez pas les permissions pour cr√©er un indicateur', 'error')
            return redirect(url_for('detail_risque', id=risque_id))
        
        # V√©rifier s'il y a d√©j√† un KRI pour ce risque
        kri_existant = get_client_filter(KRI)\
            .filter_by(risque_id=risque_id, type_indicateur='kri', est_actif=True)\
            .first()
        
        if kri_existant:
            flash(f'Un KRI existe d√©j√† pour ce risque: {kri_existant.nom}', 'warning')
            return redirect(url_for('detail_risque', id=risque_id))
        
        # Pr√©parer les donn√©es pour le template
        utilisateurs = get_client_filter(User).filter_by(is_active=True).all()
        
        # CORRECTION : Utiliser la fonction utilitaire
        risques_disponibles = get_risques_pour_formulaire()
        
        print(f"üîç DEBUG cr√©ation KRI pour risque {risque_id}: {len(risques_disponibles)} risques disponibles")
        
        return render_template('kri/form.html',
                             action='creer',
                             risque_id=risque_id,
                             risque_associe=risque,
                             utilisateurs=utilisateurs,
                             risques_disponibles=risques_disponibles)
    
    elif request.method == 'POST':
        """Traiter la cr√©ation du KRI"""
        try:
            # CORRECTION : R√©cup√©rer le risque avec v√©rification d'acc√®s
            risque = get_client_object_or_404(Risque, risque_id)
            
            # CORRECTION : Cr√©er le KRI avec client_id automatique
            kri = KRI(
                type_indicateur='kri',
                risque_id=risque_id,
                nom=request.form.get('nom'),
                description=request.form.get('description'),
                formule_calcul=request.form.get('formule_calcul'),
                unite_mesure=request.form.get('unite_mesure'),
                seuil_alerte=float(request.form.get('seuil_alerte', 0)) if request.form.get('seuil_alerte') else None,
                seuil_critique=float(request.form.get('seuil_critique', 0)) if request.form.get('seuil_critique') else None,
                sens_evaluation_seuil=request.form.get('sens_evaluation_seuil', 'superieur'),
                frequence_mesure=request.form.get('frequence_mesure'),
                responsable_mesure_id=request.form.get('responsable_mesure_id'),
                categorie=request.form.get('categorie'),
                source_donnees=request.form.get('source_donnees'),
                notes_internes=request.form.get('notes_internes'),
                est_actif=True,
                created_by=current_user.id
            )
            
            # CORRECTION : Ajouter automatiquement le client_id
            if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
                kri.client_id = current_user.client_id
            
            db.session.add(kri)
            db.session.flush()
            
            # ==================== NOTIFICATION POUR LE RESPONSABLE KRI ====================
            if kri.responsable_mesure_id:
                try:
                    notification = Notification(
                        destinataire_id=kri.responsable_mesure_id,
                        type_notification=Notification.TYPE_KRI_ALERTE,
                        titre=f"Nouveau KRI cr√©√©: {kri.nom}",
                        message=f"Vous √™tes d√©sormais responsable du KRI '{kri.nom}' pour le risque '{risque.intitule}'.",
                        urgence=Notification.URGENCE_NORMAL,
                        entite_type='kri',
                        entite_id=kri.id,
                        donnees_supplementaires={
                            'risque_reference': risque.reference,
                            'risque_intitule': risque.intitule,
                            'seuil_alerte': kri.seuil_alerte,
                            'seuil_critique': kri.seuil_critique,
                            'frequence_mesure': kri.frequence_mesure
                        }
                    )
                    db.session.add(notification)
                except Exception as e:
                    print(f"Erreur cr√©ation notification KRI: {e}")
            
            # ==================== NOTIFICATION POUR LE CR√âATEUR ====================
            notification_createur = Notification(
                destinataire_id=current_user.id,
                type_notification=Notification.TYPE_SYSTEME,
                titre=f"KRI cr√©√©: {kri.nom}",
                message=f"Le KRI '{kri.nom}' a √©t√© cr√©√© avec succ√®s pour le risque '{risque.intitule}'.",
                urgence=Notification.URGENCE_NORMAL,
                entite_type='kri',
                entite_id=kri.id,
                donnees_supplementaires={
                    'risque_reference': risque.reference,
                    'responsable_id': kri.responsable_mesure_id
                }
            )
            db.session.add(notification_createur)
            # ===============================================================================
            
            db.session.commit()
            
            flash(f'KRI cr√©√© avec succ√®s pour le risque {risque.reference}', 'success')
            return redirect(url_for('detail_risque', id=risque_id))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur lors de la cr√©ation du KRI: {str(e)}', 'error')
            return redirect(url_for('detail_risque', id=risque_id))

def get_risques_pour_formulaire():
    """
    R√©cup√®re les risques disponibles pour les formulaires KRI
    avec une gestion d'erreur robuste
    """
    try:
        # Pour super admin, on peut vouloir voir tous les risques
        if current_user.role == 'super_admin':
            # Option 1: Voir tous les risques non archiv√©s
            risques = Risque.query.filter_by(is_archived=False)\
                .order_by(Risque.reference)\
                .all()
            
            # Option 2: Filtrer par client si un client sp√©cifique est visualis√©
            viewing_client_id = session.get('viewing_client_id')
            if viewing_client_id:
                risques = Risque.query.filter_by(
                    client_id=viewing_client_id,
                    is_archived=False
                ).order_by(Risque.reference).all()
        else:
            # Pour les utilisateurs normaux: utiliser get_client_filter
            risques = get_client_filter(Risque)\
                .filter_by(is_archived=False)\
                .order_by(Risque.reference)\
                .all()
        
        # S'assurer que tous les risques ont les attributs n√©cessaires
        risques_valides = []
        for risque in risques:
            try:
                # V√©rifier que le risque a les attributs de base
                if hasattr(risque, 'reference') and hasattr(risque, 'intitule'):
                    # Formatage pour l'affichage
                    risque._display_text = f"{risque.reference} - {risque.intitule}"
                    risques_valides.append(risque)
                else:
                    print(f"‚ö†Ô∏è Risque {risque.id} manque d'attributs")
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur sur risque {risque.id}: {e}")
                continue
        
        print(f"‚úÖ {len(risques_valides)} risques valides pour le formulaire")
        return risques_valides
        
    except Exception as e:
        print(f"‚ùå Erreur get_risques_pour_formulaire: {e}")
        import traceback
        traceback.print_exc()
        return []

    
@app.route('/kri/<int:kri_id>/modifier', methods=['GET', 'POST'])
@login_required
def modifier_kri(kri_id):
    """Modifier un indicateur (KRI ou KPI) existant avec isolation"""
    
    # R√©cup√©rer avec v√©rification d'acc√®s
    kri = get_client_filter(KRI).filter_by(id=kri_id).first_or_404()
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_kri') or 
            current_user.id == kri.created_by or
            current_user.id == kri.responsable_mesure_id):
        flash('Vous n\'avez pas les permissions pour modifier cet indicateur', 'error')
        return redirect(url_for('liste_kri'))
    
    # R√©cup√©rer les risques disponibles
    utilisateurs = get_client_filter(User).filter_by(is_active=True).all()
    
    # Pour les risques, utiliser une m√©thode qui fonctionne
    if current_user.role == 'super_admin':
        risques_disponibles = Risque.query.filter_by(is_archived=False).all()
    else:
        risques_disponibles = Risque.query.filter_by(
            client_id=current_user.client_id,
            is_archived=False
        ).all()
    
    print(f"üîç Modifier KRI {kri_id}: {len(risques_disponibles)} risques disponibles")
    
    if request.method == 'POST':
        try:
            # R√©cup√©rer les donn√©es du formulaire
            type_indicateur = request.form.get('type_indicateur', 'kri')
            risque_id = request.form.get('risque_id')
            nom = request.form.get('nom')
            description = request.form.get('description')
            formule_calcul = request.form.get('formule_calcul')
            unite_mesure = request.form.get('unite_mesure')
            frequence_mesure = request.form.get('frequence_mesure')
            seuil_alerte = request.form.get('seuil_alerte')
            seuil_critique = request.form.get('seuil_critique')
            seuil_cible = request.form.get('seuil_cible')  # NOUVEAU
            sens_evaluation_seuil = request.form.get('sens_evaluation_seuil', 'superieur')
            responsable_mesure_id = request.form.get('responsable_mesure_id')
            categorie = request.form.get('categorie')
            source_donnees = request.form.get('source_donnees')
            notes_internes = request.form.get('notes_internes')
            
            # Validation
            if not nom:
                flash('Le nom de l\'indicateur est obligatoire', 'error')
                return redirect(url_for('modifier_kri', kri_id=kri_id))
            
            if not frequence_mesure:
                flash('La fr√©quence de mesure est obligatoire', 'error')
                return redirect(url_for('modifier_kri', kri_id=kri_id))
            
            # Validation sp√©cifique pour les KPI
            if type_indicateur == 'kpi' and seuil_cible and not unite_mesure:
                flash('Veuillez sp√©cifier une unit√© de mesure pour la cible', 'warning')
            
            # Mettre √† jour l'indicateur
            kri.type_indicateur = type_indicateur
            kri.risque_id = int(risque_id) if risque_id else None
            kri.nom = nom
            kri.description = description
            kri.formule_calcul = formule_calcul
            kri.unite_mesure = unite_mesure
            kri.frequence_mesure = frequence_mesure
            kri.seuil_alerte = float(seuil_alerte) if seuil_alerte else None
            kri.seuil_critique = float(seuil_critique) if seuil_critique else None
            kri.seuil_cible = float(seuil_cible) if seuil_cible and type_indicateur == 'kpi' else None  # NOUVEAU
            kri.sens_evaluation_seuil = sens_evaluation_seuil
            kri.responsable_mesure_id = int(responsable_mesure_id) if responsable_mesure_id else None
            kri.categorie = categorie
            kri.source_donnees = source_donnees
            kri.notes_internes = notes_internes
            kri.updated_at = datetime.utcnow()
            
            db.session.commit()
            
            # Message de confirmation adapt√©
            if type_indicateur == 'kpi' and seuil_cible:
                flash(f'{kri.get_type_display()} modifi√© avec succ√®s (Cible: {seuil_cible} {unite_mesure})', 'success')
            else:
                flash(f'{kri.get_type_display()} modifi√© avec succ√®s', 'success')
            
            return redirect(url_for('detail_kri', kri_id=kri.id))
            
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Erreur modification: {e}")
            flash(f'Erreur lors de la modification: {str(e)}', 'error')
            return redirect(url_for('modifier_kri', kri_id=kri_id))
    
    # M√©thode GET : afficher le formulaire pr√©-rempli
    return render_template('kri/form.html',
                         action='modifier',
                         kri=kri,
                         utilisateurs=utilisateurs,
                         risques_disponibles=risques_disponibles)

@app.route('/kri/<int:kri_id>/archiver', methods=['POST'])
@login_required
def archiver_kri(kri_id):
    """Archiver un KRI avec isolation"""
    
    # CORRECTION : R√©cup√©rer avec v√©rification d'acc√®s
    kri = get_client_filter(KRI).filter_by(id=kri_id).first_or_404()
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_kri') or 
            current_user.id == kri.created_by):
        flash('Vous n\'avez pas les permissions pour archiver cet indicateur', 'error')
        return redirect(url_for('liste_kri'))
    
    try:
        kri.est_actif = False
        kri.archived_at = datetime.utcnow()
        kri.archived_by = current_user.id
        kri.updated_at = datetime.utcnow()
        
        db.session.commit()
        flash(f'Indicateur "{kri.nom}" archiv√© avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur archivage: {e}")
        flash(f'Erreur lors de l\'archivage: {str(e)}', 'error')
    
    return redirect(url_for('liste_kri'))


@app.route('/kri/<int:kri_id>/restaurer', methods=['POST'])
@login_required
def restaurer_kri(kri_id):
    """Restaurer un KRI archiv√© avec isolation"""
    
    # CORRECTION : R√©cup√©rer avec v√©rification d'acc√®s (inclut les archiv√©s)
    kri = KRI.query.get_or_404(kri_id)
    
    if not check_client_access(kri):
        flash('Acc√®s non autoris√© √† ce KRI', 'error')
        return redirect(url_for('kris_archives'))
    
    if current_user.role != 'admin' and current_user.id != kri.archived_by:
        flash('Vous n\'√™tes pas autoris√© √† restaurer ce KRI', 'error')
        return redirect(url_for('kris_archives'))
    
    try:
        kri.est_actif = True
        kri.archived_at = None
        kri.archived_by = None
        kri.updated_at = datetime.utcnow()
        
        db.session.commit()
        flash(f'Indicateur "{kri.nom}" restaur√© avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur restauration: {e}")
        flash(f'Erreur lors de la restauration: {str(e)}', 'error')
    
    return redirect(url_for('kris_archives'))


@app.route('/kri/<int:kri_id>/supprimer-definitivement', methods=['POST'])
@login_required
def supprimer_definitivement_kri(kri_id):
    """Supprimer d√©finitivement un KRI archiv√© avec isolation"""
    
    if current_user.role != 'admin':
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('kris_archives'))
    
    # CORRECTION : V√©rifier l'acc√®s m√™me pour admin
    kri = KRI.query.get_or_404(kri_id)
    
    if not check_client_access(kri):
        flash('Acc√®s non autoris√© √† ce KRI', 'error')
        return redirect(url_for('kris_archives'))
    
    # V√©rifier que le KRI est bien archiv√©
    if kri.est_actif:
        flash('Seuls les KRI archiv√©s peuvent √™tre supprim√©s d√©finitivement', 'error')
        return redirect(url_for('kris_archives'))
    
    try:
        # CORRECTION : Supprimer les mesures avec v√©rification d'acc√®s
        mesures = get_client_filter(MesureKRI).filter_by(kri_id=kri_id).all()
        for mesure in mesures:
            db.session.delete(mesure)
        
        # Supprimer le KRI
        nom_kri = kri.nom
        db.session.delete(kri)
        db.session.commit()
        
        flash(f'Indicateur "{nom_kri}" supprim√© d√©finitivement avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur suppression d√©finitive: {e}")
        flash(f'Erreur lors de la suppression: {str(e)}', 'error')
    
    return redirect(url_for('kris_archives'))


@app.route('/kris/archives')
@login_required
def kris_archives():
    """Liste des KRI archiv√©s avec isolation"""
    
    # CORRECTION : Filtrer par client
    kris_archives = get_client_filter(KRI).filter_by(est_actif=False).all()
    
    # Compter les KRI vs KPI
    stats = {
        'total': len(kris_archives),
        'kris': len([k for k in kris_archives if k.type_indicateur == 'kri']),
        'kpis': len([k for k in kris_archives if k.type_indicateur == 'kpi'])
    }
    
    form = KRIForm()  # Formulaire pour le CSRF
    return render_template('kri/archives.html', 
                         kris=kris_archives,
                         stats=stats,
                         form=form,
                         datetime=datetime,
                         now=datetime.utcnow)


@app.route('/kri/<int:kri_id>/dupliquer', methods=['POST'])
@login_required
def dupliquer_kri(kri_id):
    """Dupliquer un KRI (AJAX) avec isolation"""
    try:
        # CORRECTION : V√©rifier l'acc√®s au KRI original
        kri_original = get_client_filter(KRI).filter_by(id=kri_id).first_or_404()
        
        # V√©rifier les permissions
        if not current_user.has_permission('can_manage_kri'):
            return jsonify({
                'success': False,
                'error': 'Permission refus√©e'
            }), 403
        
        # Compter les copies existantes dans le m√™me client
        copies_existantes = get_client_filter(KRI).filter(
            KRI.nom.like(f"{kri_original.nom} (Copie%")
        ).count()
        
        nom_copie = f"{kri_original.nom} (Copie {copies_existantes + 1})" if copies_existantes > 0 else f"{kri_original.nom} (Copie)"
        
        # Cr√©er la copie avec TOUS les champs n√©cessaires
        nouveau_kri = KRI(
            type_indicateur=kri_original.type_indicateur,
            risque_id=kri_original.risque_id,
            nom=nom_copie,
            description=kri_original.description,
            formule_calcul=kri_original.formule_calcul,
            unite_mesure=kri_original.unite_mesure,
            seuil_alerte=kri_original.seuil_alerte,
            seuil_critique=kri_original.seuil_critique,
            seuil_cible=kri_original.seuil_cible,  # NOUVEAU
            sens_evaluation_seuil=kri_original.sens_evaluation_seuil,
            frequence_mesure=kri_original.frequence_mesure,
            responsable_mesure_id=kri_original.responsable_mesure_id,
            categorie=kri_original.categorie,
            source_donnees=kri_original.source_donnees,
            notes_internes=kri_original.notes_internes,
            created_by=current_user.id,
            est_actif=True
        )
        
        # CORRECTION : Ajouter automatiquement le client_id
        if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
            nouveau_kri.client_id = current_user.client_id
        elif hasattr(kri_original, 'client_id'):
            nouveau_kri.client_id = kri_original.client_id
        
        db.session.add(nouveau_kri)
        db.session.commit()
        
        # Journaliser l'action
        from models import log_activity
        log_activity(current_user.id, 'duplication_indicateur',
                    f"Duplication de l'indicateur {kri_original.nom} vers {nom_copie}",
                    'kri', nouveau_kri.id)
        
        # Retourner une r√©ponse JSON pour les requ√™tes AJAX
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or request.is_json:
            return jsonify({
                'success': True,
                'message': f'Indicateur dupliqu√© avec succ√®s: {nom_copie}',
                'new_kri_id': nouveau_kri.id,
                'nom_copie': nom_copie,
                'type': nouveau_kri.type_indicateur
            })
        else:
            # Pour les requ√™tes normales, rediriger
            flash(f'Indicateur dupliqu√© avec succ√®s: {nom_copie}', 'success')
            return redirect(url_for('liste_kri'))
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur duplication: {e}")
        
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or request.is_json:
            return jsonify({
                'success': False,
                'error': str(e)
            }), 500
        else:
            flash(f'Erreur lors de la duplication: {str(e)}', 'error')
            return redirect(url_for('liste_kri'))


def get_risques_pour_formulaire():
    """
    R√©cup√®re les risques disponibles pour les formulaires KRI
    avec une gestion d'erreur robuste
    """
    try:
        # Pour super admin, on peut vouloir voir tous les risques
        if current_user.role == 'super_admin':
            # Option 1: Voir tous les risques non archiv√©s
            risques = Risque.query.filter_by(is_archived=False)\
                .order_by(Risque.reference)\
                .all()
            
            # Option 2: Filtrer par client si un client sp√©cifique est visualis√©
            viewing_client_id = session.get('viewing_client_id')
            if viewing_client_id:
                risques = Risque.query.filter_by(
                    client_id=viewing_client_id,
                    is_archived=False
                ).order_by(Risque.reference).all()
        else:
            # Pour les utilisateurs normaux: utiliser get_client_filter
            risques = get_client_filter(Risque)\
                .filter_by(is_archived=False)\
                .order_by(Risque.reference)\
                .all()
        
        # S'assurer que tous les risques ont les attributs n√©cessaires
        risques_valides = []
        for risque in risques:
            try:
                # V√©rifier que le risque a les attributs de base
                if hasattr(risque, 'reference') and hasattr(risque, 'intitule'):
                    # Formatage pour l'affichage
                    risque._display_text = f"{risque.reference} - {risque.intitule}"
                    risques_valides.append(risque)
                else:
                    print(f"‚ö†Ô∏è Risque {risque.id} manque d'attributs")
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur sur risque {risque.id}: {e}")
                continue
        
        print(f"‚úÖ {len(risques_valides)} risques valides pour le formulaire")
        return risques_valides
        
    except Exception as e:
        print(f"‚ùå Erreur get_risques_pour_formulaire: {e}")
        import traceback
        traceback.print_exc()
        return []


@app.route('/kri/<int:kri_id>/changer-statut', methods=['POST'])
@login_required
def changer_statut_kri(kri_id):
    """Changer le statut d'un KRI (archiver/restaurer) - AJAX"""
    try:
        # R√©cup√©rer le KRI avec v√©rification d'acc√®s
        kri = get_client_filter(KRI).filter_by(id=kri_id).first_or_404()
        
        action = request.form.get('action', 'archiver')
        
        if action == 'archiver':
            # V√©rifier les permissions
            if not (current_user.has_permission('can_manage_kri') or 
                    current_user.id == kri.created_by):
                return jsonify({
                    'success': False,
                    'error': 'Permission refus√©e'
                }), 403
            
            # Archiver le KRI
            kri.est_actif = False
            kri.archived_at = datetime.utcnow()
            kri.archived_by = current_user.id
            kri.updated_at = datetime.utcnow()
            
            message = 'Indicateur archiv√© avec succ√®s'
            
        elif action == 'restaurer':
            # V√©rifier les permissions (uniquement admin ou super_admin pour restaurer)
            if current_user.role not in ['admin', 'super_admin']:
                return jsonify({
                    'success': False,
                    'error': 'Seuls les administrateurs peuvent restaurer des indicateurs'
                }), 403
            
            # Restaurer le KRI
            kri.est_actif = True
            kri.archived_at = None
            kri.archived_by = None
            kri.updated_at = datetime.utcnow()
            
            message = 'Indicateur restaur√© avec succ√®s'
        
        else:
            return jsonify({
                'success': False,
                'error': 'Action non reconnue'
            }), 400
        
        db.session.commit()
        
        # Journaliser l'action
        try:
            from models import log_activity  # Assurez-vous que cette fonction existe
            log_activity(current_user.id, 
                        f'kri_{action}', 
                        f"{action.capitalize()} du KRI {kri.nom}",
                        'kri', kri.id)
        except:
            pass  # Ignorer si la journalisation √©choue
        
        return jsonify({
            'success': True,
            'message': message,
            'est_actif': kri.est_actif
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur changement statut KRI {kri_id}: {e}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/api/kri/<int:kri_id>')
@login_required
def api_get_kri(kri_id):
    """API pour r√©cup√©rer les donn√©es d'un KRI sp√©cifique avec isolation"""
    try:
        # CORRECTION : Utiliser get_client_filter
        kri = get_client_filter(KRI).filter_by(id=kri_id).first()
        
        if not kri:
            return jsonify({
                'success': False,
                'error': 'KRI non trouv√© ou acc√®s non autoris√©'
            }), 404
        
        # V√©rifier les permissions
        if not (current_user.has_permission('can_manage_kri') or 
                current_user.id == kri.created_by or
                current_user.id == kri.responsable_mesure_id):
            return jsonify({
                'success': False,
                'error': 'Permission refus√©e'
            }), 403
        
        # Pr√©parer la r√©ponse
        response = {
            'success': True,
            'kri': {
                'id': kri.id,
                'nom': kri.nom,
                'type_indicateur': kri.type_indicateur,
                'description': kri.description,
                'unite_mesure': kri.unite_mesure,
                'frequence_mesure': kri.frequence_mesure,
                'seuil_alerte': kri.seuil_alerte,
                'seuil_critique': kri.seuil_critique,
                'sens_evaluation_seuil': kri.sens_evaluation_seuil,
                'responsable_mesure_id': kri.responsable_mesure_id,
                'est_actif': kri.est_actif,
                'created_at': kri.created_at.isoformat() if kri.created_at else None,
                'updated_at': kri.updated_at.isoformat() if kri.updated_at else None
            }
        }
        
        # Ajouter le risque associ√© si existe
        if kri.risque and check_client_access(kri.risque):
            response['kri']['risque'] = {
                'id': kri.risque.id,
                'reference': kri.risque.reference,
                'intitule': kri.risque.intitule
            }
        
        # Ajouter les derni√®res mesures (filtr√©es par client)
        mesures = get_client_filter(MesureKRI).filter_by(kri_id=kri_id).all()
        if mesures:
            derniere_mesure = sorted(mesures, key=lambda x: x.date_mesure, reverse=True)[0]
            response['kri']['derniere_mesure'] = {
                'valeur': derniere_mesure.valeur,
                'date_mesure': derniere_mesure.date_mesure.isoformat(),
                'commentaire': derniere_mesure.commentaire
            }
        
        return jsonify(response)
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/kri/<int:kri_id>/detail')
@login_required
def detail_kri(kri_id):
    """Fiche d√©taill√©e d'un KRI avec historique complet et isolation"""
    
    # CORRECTION : Utiliser get_client_filter
    kri = get_client_filter(KRI).filter_by(id=kri_id).first_or_404()
    
    # CORRECTION : Filtrer les mesures par client
    mesures = get_client_filter(MesureKRI)\
        .filter_by(kri_id=kri_id)\
        .order_by(MesureKRI.date_mesure.desc())\
        .all()
    
    # Regrouper les mesures par p√©riode/campagne (ex: mensuel)
    mesures_par_periode = {}
    for mesure in mesures:
        # Format de p√©riode (ex: "Janvier 2024")
        periode = mesure.date_mesure.strftime('%B %Y')
        if periode not in mesures_par_periode:
            mesures_par_periode[periode] = []
        mesures_par_periode[periode].append(mesure)
    
    # Calculer les statistiques
    statistiques = {}
    if mesures:
        valeurs = [m.valeur for m in mesures]
        statistiques = {
            'moyenne': sum(valeurs) / len(valeurs),
            'minimum': min(valeurs),
            'maximum': max(valeurs),
            'tendance': calculer_tendance_kri(mesures),
            'nb_mesures': len(valeurs)
        }
    
    return render_template('kri/detail.html',
                         kri=kri,
                         mesures=mesures,
                         mesures_par_periode=mesures_par_periode,
                         statistiques=statistiques,
                         datetime=datetime)

def get_risques_pour_kri():
    """
    R√©cup√®re TOUS les risques disponibles pour les KRI
    Inclut une v√©rification sp√©ciale pour √©viter les probl√®mes d'affichage
    """
    try:
        # 1. Version filtr√©e par client
        if current_user.role != 'super_admin':
            risques = get_client_filter(Risque)\
                .filter_by(is_archived=False)\
                .options(db.joinedload(Risque.cartographie))\
                .all()
        else:
            # Super admin voit tout
            risques = Risque.query\
                .filter_by(is_archived=False)\
                .options(db.joinedload(Risque.cartographie))\
                .all()
        
        print(f"üîç DEBUG get_risques_pour_kri: {len(risques)} risques trouv√©s")
        
        # 2. V√©rifier que les risques sont bien format√©s pour le template
        formatted_risques = []
        for risque in risques:
            # S'assurer que les attributs n√©cessaires existent
            if hasattr(risque, 'reference') and hasattr(risque, 'intitule'):
                formatted_risques.append(risque)
            else:
                print(f"‚ö†Ô∏è Risque {risque.id} manque d'attributs: reference={hasattr(risque, 'reference')}, intitule={hasattr(risque, 'intitule')}")
        
        print(f"‚úÖ {len(formatted_risques)} risques correctement format√©s")
        return formatted_risques
        
    except Exception as e:
        print(f"‚ùå Erreur get_risques_pour_kri: {e}")
        return []
    

# Route pour √©diter une mesure (AJAX)
@app.route('/kri/mesure/<int:mesure_id>/editer', methods=['GET'])
@csrf.exempt  
@login_required
def editer_mesure_kri(mesure_id):
    """Retourner le formulaire d'√©dition d'une mesure (AJAX)"""
    mesure = MesureKRI.query.get_or_404(mesure_id)
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_kri') or 
            current_user.id == mesure.created_by):
        return jsonify({'error': 'Permission refus√©e'}), 403
    
    html = f'''
    <form method="POST" action="/kri/mesure/{mesure.id}/modifier">
        <!-- REMPLACER LE csrf_token PAR un champ vide -->
        <input type="hidden" name="no_csrf" value="1">
        
        <div class="mb-3">
            <label class="form-label">Valeur *</label>
            <div class="input-group">
                <input type="number" step="0.01" class="form-control" name="valeur" 
                       value="{mesure.valeur}" required>
                <span class="input-group-text">{mesure.kri.unite_mesure}</span>
            </div>
        </div>
        
        <div class="mb-3">
            <label class="form-label">Date de mesure *</label>
            <input type="date" class="form-control" name="date_mesure" 
                   value="{mesure.date_mesure.strftime('%Y-%m-%d')}" required>
        </div>
        
        <div class="mb-3">
            <label class="form-label">Commentaire</label>
            <textarea class="form-control" name="commentaire" rows="3">{mesure.commentaire or ''}</textarea>
        </div>
        
        <div class="d-flex gap-2 justify-content-end">
            <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Annuler</button>
            <button type="submit" class="btn btn-primary">Enregistrer</button>
        </div>
    </form>
    '''
    
    return html

# Route pour modifier une mesure (POST)
@app.route('/kri/mesure/<int:mesure_id>/modifier', methods=['POST'])
@csrf.exempt
@login_required
def modifier_mesure_kri(mesure_id):
    """Modifier une mesure existante"""
    mesure = MesureKRI.query.get_or_404(mesure_id)
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_kri') or 
            current_user.id == mesure.created_by):
        flash('Permission refus√©e', 'error')
        return redirect(request.referrer or url_for('detail_kri', kri_id=mesure.kri_id))
    
    try:
        mesure.valeur = float(request.form['valeur'])
        mesure.date_mesure = datetime.strptime(request.form['date_mesure'], '%Y-%m-%d')
        mesure.commentaire = request.form.get('commentaire', '')
        mesure.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        flash('Mesure modifi√©e avec succ√®s', 'success')
        return redirect(request.referrer or url_for('detail_kri', kri_id=mesure.kri_id))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la modification: {str(e)}', 'error')
        return redirect(request.referrer or url_for('detail_kri', kri_id=mesure.kri_id))

    
# Route pour supprimer une mesure
@app.route('/kri/mesure/<int:mesure_id>/supprimer', methods=['POST'])
@login_required
def supprimer_mesure_kri(mesure_id):
    """Supprimer une mesure"""
    mesure = MesureKRI.query.get_or_404(mesure_id)
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_kri') or 
            current_user.id == mesure.created_by):
        return jsonify({'success': False, 'error': 'Permission refus√©e'}), 403
    
    try:
        kri_id = mesure.kri_id
        db.session.delete(mesure)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Mesure supprim√©e avec succ√®s'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

# Route pour ajouter un fichier √† un KRI
@app.route('/kri/<int:kri_id>/fichier/ajouter', methods=['POST'])
@login_required
def ajouter_fichier_kri(kri_id):
    """Ajouter un fichier √† un KRI"""
    kri = KRI.query.get_or_404(kri_id)
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_kri') or 
            current_user.id == kri.created_by or
            current_user.id == kri.responsable_mesure_id):
        flash('Vous n\'avez pas les permissions pour ajouter un fichier', 'error')
        return redirect(url_for('detail_kri', kri_id=kri_id))
    
    if 'fichier' not in request.files:
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(url_for('detail_kri', kri_id=kri_id))
    
    fichier = request.files['fichier']
    
    if fichier.filename == '':
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(url_for('detail_kri', kri_id=kri_id))
    
    # V√©rifier l'extension
    allowed_extensions = app.config['ALLOWED_EXTENSIONS']
    if '.' in fichier.filename:
        extension = fichier.filename.rsplit('.', 1)[1].lower()
        if extension not in allowed_extensions:
            flash(f'Extension non autoris√©e: {extension}', 'error')
            return redirect(url_for('detail_kri', kri_id=kri_id))
    
    # V√©rifier la taille (max 10Mo)
    max_size = 10 * 1024 * 1024
    fichier.seek(0, 2)
    size = fichier.tell()
    fichier.seek(0)
    
    if size > max_size:
        flash(f'Fichier trop volumineux ({size/1024/1024:.2f} Mo). Maximum: 10 Mo', 'error')
        return redirect(url_for('detail_kri', kri_id=kri_id))
    
    # Sauvegarder le fichier
    nom_fichier = secure_filename(fichier.filename)
    timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
    nom_unique = f"{timestamp}_{nom_fichier}"
    
    dossier = os.path.join(app.config['UPLOAD_FOLDER'], 'kri', str(kri_id))
    os.makedirs(dossier, exist_ok=True)
    chemin = os.path.join(dossier, nom_unique)
    
    fichier.save(chemin)
    
    # Enregistrer en base (vous devez cr√©er un mod√®le FichierKRI similaire √† FichierRisque)
    fichier_db = FichierKRI(
        kri_id=kri_id,
        nom_fichier=nom_fichier,
        chemin_fichier=chemin,
        type_fichier=fichier.content_type,
        taille=size,
        categorie=request.form.get('categorie', 'document'),
        description=request.form.get('description', ''),
        uploaded_by=current_user.id
    )
    
    db.session.add(fichier_db)
    db.session.commit()
    
    flash('Fichier ajout√© avec succ√®s', 'success')
    return redirect(url_for('detail_kri', kri_id=kri_id))

# Route pour t√©l√©charger un fichier
@app.route('/kri/fichier/<int:fichier_id>/telecharger')
@login_required
def telecharger_fichier_kri(fichier_id):
    """T√©l√©charger un fichier attach√© √† un KRI"""
    fichier = FichierKRI.query.get_or_404(fichier_id)
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_kri') or 
            fichier.kri.created_by == current_user.id or
            current_user.id == fichier.uploaded_by):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_kri', kri_id=fichier.kri_id))
    
    return send_file(fichier.chemin_fichier, 
                    as_attachment=True, 
                    download_name=fichier.nom_fichier)

# Route pour supprimer un fichier
@app.route('/kri/fichier/<int:fichier_id>/supprimer', methods=['POST'])
@login_required
def supprimer_fichier_kri(fichier_id):
    """Supprimer un fichier attach√© √† un KRI"""
    fichier = FichierKRI.query.get_or_404(fichier_id)
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_kri') or 
            fichier.kri.created_by == current_user.id or
            current_user.id == fichier.uploaded_by):
        return jsonify({'success': False, 'error': 'Permission refus√©e'}), 403
    
    try:
        # Supprimer le fichier physique
        if os.path.exists(fichier.chemin_fichier):
            os.remove(fichier.chemin_fichier)
        
        # Supprimer l'enregistrement en base
        db.session.delete(fichier)
        db.session.commit()
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500



@app.route('/kri/<int:kri_id>/ajouter-mesure-periodique', methods=['POST'])
@login_required
def ajouter_mesure_periodique(kri_id):
    """Ajouter une mesure p√©riodique avec commentaire"""
    kri = KRI.query.get_or_404(kri_id)
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_kri') or 
            current_user.id == kri.responsable_mesure_id):
        flash('Vous n\'avez pas les permissions pour ajouter une mesure', 'error')
        return redirect(url_for('detail_kri', kri_id=kri_id))
    
    valeur = request.form.get('valeur')
    commentaire = request.form.get('commentaire', '')
    date_mesure = request.form.get('date_mesure', datetime.now().strftime('%Y-%m-%d'))
    
    if not valeur:
        flash('Veuillez saisir une valeur', 'error')
        return redirect(url_for('detail_kri', kri_id=kri_id))
    
    try:
        mesure = MesureKRI(
            kri_id=kri_id,
            valeur=float(valeur),
            date_mesure=datetime.strptime(date_mesure, '%Y-%m-%d'),
            commentaire=commentaire,
            created_by=current_user.id
        )
        
        db.session.add(mesure)
        db.session.commit()
        
        # Journaliser l'action
        log_activity(current_user.id, 'mesure_kri_ajoutee',
                    f'Ajout mesure KRI {kri.nom}: {valeur} {kri.unite_mesure}',
                    'kri', kri_id)
        
        flash('Mesure ajout√©e avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de l\'ajout: {str(e)}', 'error')
    
    return redirect(url_for('detail_kri', kri_id=kri_id))

    
@app.route('/kri/<int:kri_id>/modifier', methods=['GET'])
@login_required
def afficher_modifier_kri(kri_id):
    """Afficher le formulaire de modification d'un KRI"""
    from forms import KRIForm
    
    # R√©cup√©rer le KRI avec v√©rification d'acc√®s
    kri = get_client_filter(KRI).filter_by(id=kri_id).first_or_404()
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_kri') or 
            current_user.id == kri.created_by or
            current_user.id == kri.responsable_mesure_id):
        flash('Vous n\'avez pas les permissions pour modifier cet indicateur', 'error')
        return redirect(url_for('liste_kri'))
    
    form = KRIForm(obj=kri)
    
    # ‚úÖ CORRECTION : Filtrer les utilisateurs par client
    if current_user.role == 'super_admin':
        utilisateurs = User.query.filter_by(is_active=True).all()
    else:
        utilisateurs = User.query.filter_by(
            client_id=current_user.client_id,
            is_active=True
        ).all()
    
    # Pr√©parer les choix du formulaire
    form.responsable_mesure_id.choices = [('', 'S√©lectionnez un responsable')] + \
                                         [(u.id, f"{u.username} ({u.role})") for u in utilisateurs]
    
    # R√©cup√©rer les risques disponibles
    if current_user.role == 'super_admin':
        risques_disponibles = Risque.query.filter_by(is_archived=False).all()
    else:
        risques_disponibles = Risque.query.filter_by(
            client_id=current_user.client_id,
            is_archived=False
        ).all()
    
    return render_template('kri/modifier.html', 
                         form=form, 
                         kri=kri,
                         utilisateurs=utilisateurs,
                         risques_disponibles=risques_disponibles)

@app.route('/kri/creer-depuis-liste', methods=['POST'])
@login_required
def creer_kri_depuis_liste():
    """Cr√©er un indicateur (KRI ou KPI) depuis la liste"""
    
    # R√©cup√©ration des donn√©es
    type_indicateur = request.form.get('type_indicateur', 'kri')
    risque_id = request.form.get('risque_id')
    nom = request.form.get('nom')
    description = request.form.get('description')
    formule_calcul = request.form.get('formule_calcul')
    unite_mesure = request.form.get('unite_mesure')
    frequence_mesure = request.form.get('frequence_mesure')
    
    # Seuils d'alerte et cible
    seuil_alerte = request.form.get('seuil_alerte')
    seuil_critique = request.form.get('seuil_critique')
    seuil_cible = request.form.get('seuil_cible')
    
    sens_evaluation_seuil = request.form.get('sens_evaluation_seuil', 'superieur')
    responsable_mesure_id = request.form.get('responsable_mesure_id')
    categorie = request.form.get('categorie')
    source_donnees = request.form.get('source_donnees')
    notes_internes = request.form.get('notes_internes')
    
    # Validation
    if not nom:
        flash('Le nom de l\'indicateur est obligatoire', 'error')
        return redirect(url_for('liste_kri'))
    
    if not frequence_mesure:
        flash('La fr√©quence de mesure est obligatoire', 'error')
        return redirect(url_for('liste_kri'))
    
    # Validation sp√©cifique pour les KPI : alerte si cible d√©finie mais pas d'unit√©
    if type_indicateur == 'kpi' and seuil_cible and not unite_mesure:
        flash('Veuillez sp√©cifier une unit√© de mesure pour la cible', 'warning')
    
    # ‚úÖ CORRECTION 1 : V√©rifier que le responsable appartient au m√™me client
    if responsable_mesure_id and responsable_mesure_id.strip():
        try:
            responsable_id = int(responsable_mesure_id)
            if current_user.role != 'super_admin':
                # V√©rifier que le responsable est du m√™me client
                responsable = User.query.get(responsable_id)
                if not responsable or (hasattr(current_user, 'client_id') and 
                                       responsable.client_id != current_user.client_id):
                    flash('Le responsable s√©lectionn√© n\'est pas valide pour votre client', 'error')
                    return redirect(url_for('liste_kri'))
        except ValueError:
            flash('Responsable invalide', 'error')
            return redirect(url_for('liste_kri'))
    
    # V√©rifier si un risque est sp√©cifi√©
    risque = None
    if risque_id and risque_id.strip():
        try:
            risque_id_int = int(risque_id)
            # ‚úÖ Utiliser get_client_object_or_404 pour v√©rifier l'acc√®s
            risque = get_client_object_or_404(Risque, risque_id_int)
            
            # Pour les KRI, v√©rifier s'il y a d√©j√† un KRI pour ce risque
            if type_indicateur == 'kri':
                kri_existant = get_client_filter(KRI).filter_by(
                    risque_id=risque_id_int, 
                    type_indicateur='kri',
                    est_actif=True
                ).first()
                
                if kri_existant:
                    flash(f'Un KRI existe d√©j√† pour le risque {risque.reference}', 'warning')
                    # On peut quand m√™me cr√©er, mais on pr√©vient l'utilisateur
        except ValueError:
            flash('Risque invalide', 'error')
            return redirect(url_for('liste_kri'))
    
    # Cr√©er l'indicateur
    kri = KRI(
        type_indicateur=type_indicateur,
        risque_id=int(risque_id) if risque_id and risque_id.strip() else None,
        nom=nom,
        description=description,
        formule_calcul=formule_calcul,
        unite_mesure=unite_mesure,
        frequence_mesure=frequence_mesure,
        seuil_alerte=float(seuil_alerte) if seuil_alerte and seuil_alerte.strip() else None,
        seuil_critique=float(seuil_critique) if seuil_critique and seuil_critique.strip() else None,
        seuil_cible=float(seuil_cible) if seuil_cible and seuil_cible.strip() and type_indicateur == 'kpi' else None,
        sens_evaluation_seuil=sens_evaluation_seuil,
        responsable_mesure_id=int(responsable_mesure_id) if responsable_mesure_id and responsable_mesure_id.strip() else None,
        categorie=categorie,
        source_donnees=source_donnees,
        notes_internes=notes_internes,
        created_by=current_user.id,
        client_id=current_user.client_id if hasattr(current_user, 'client_id') and current_user.client_id else None
    )
    
    try:
        db.session.add(kri)
        db.session.commit()
        
        # ‚úÖ CORRECTION 2 : Importer log_activity depuis utils, PAS depuis models
        from utils import log_activity
        log_activity(current_user.id, 'creation_indicateur',
                    f"Cr√©ation de l'indicateur {kri.nom} ({kri.get_type_display()})",
                    'kri', kri.id)
        
        # Notification pour le responsable
        if kri.responsable_mesure_id and kri.responsable_mesure_id != current_user.id:
            try:
                notification = Notification(
                    destinataire_id=kri.responsable_mesure_id,
                    type_notification=Notification.TYPE_KRI_ALERTE,
                    titre=f"Vous √™tes responsable d'un nouvel indicateur",
                    message=f"Vous avez √©t√© assign√© comme responsable de l'indicateur '{kri.nom}'.",
                    urgence=Notification.URGENCE_NORMAL,
                    entite_type='kri',
                    entite_id=kri.id
                )
                db.session.add(notification)
                db.session.commit()
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur cr√©ation notification: {e}")
        
        type_affichage = kri.get_type_display()
        if risque:
            message = f'{type_affichage} "{nom}" cr√©√© avec succ√®s pour le risque {risque.reference}'
        else:
            message = f'{type_affichage} "{nom}" cr√©√© avec succ√®s'
        
        # Message suppl√©mentaire si cible d√©finie
        if type_indicateur == 'kpi' and seuil_cible:
            message += f" (Cible: {seuil_cible} {unite_mesure})"
        
        flash(message, 'success')
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur cr√©ation KRI: {e}")
        import traceback
        traceback.print_exc()
        flash(f'Erreur lors de la cr√©ation: {str(e)}', 'error')
    
    # Redirection selon le contexte
    if risque_id and risque_id.strip():
        return redirect(url_for('detail_risque', id=int(risque_id)))
    else:
        return redirect(url_for('liste_kri'))




def synchroniser_kri_apres_modification(kri_id, action_type, user_id):
    """Synchroniser les donn√©es apr√®s modification d'un KRI"""
    try:
        kri = KRI.query.get(kri_id)
        if not kri:
            return False
        
        print(f"üîÑ Synchronisation KRI {kri_id} apr√®s {action_type}")
        
        # Mettre √† jour les indicateurs li√©s
        if kri.risque:
            # Recalculer les tendances
            kri.tendance = calculer_tendance_kri(kri.mesures)
            
            # Mettre √† jour le timestamp
            kri.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        # Synchronisation globale si n√©cessaire
        from utils import synchroniser_donnees_globales
        synchroniser_donnees_globales()
        
        print(f"‚úÖ KRI {kri_id} synchronis√© avec succ√®s")
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur synchronisation KRI {kri_id}: {str(e)}")
        return False

# Route suppl√©mentaire utile : API pour v√©rifier les seuils
@app.route('/api/kri/<int:kri_id>/verifier-seuils', methods=['GET'])
@login_required
def api_verifier_seuils_kri(kri_id):
    """API pour v√©rifier l'√©tat des seuils d'un KRI (utile pour les alertes)"""
    try:
        kri = get_client_filter(KRI).filter_by(id=kri_id).first_or_404()
        
        derniere_mesure = kri.get_derniere_mesure()
        
        if not derniere_mesure:
            return jsonify({
                'success': True,
                'has_measure': False,
                'message': 'Aucune mesure disponible'
            })
        
        etat = kri.get_etat_alerte(derniere_mesure.valeur)
        couleur = kri.get_couleur_etat(derniere_mesure.valeur)
        
        # Calculer l'√©cart par rapport √† la cible si c'est un KPI
        ecart_cible = None
        if kri.type_indicateur == 'kpi' and kri.seuil_cible:
            ecart_cible = kri.get_ecart_par_rapport_cible(derniere_mesure.valeur)
        
        response = {
            'success': True,
            'kri_id': kri.id,
            'kri_nom': kri.nom,
            'type': kri.type_indicateur,
            'derniere_mesure': {
                'valeur': derniere_mesure.valeur,
                'date': derniere_mesure.date_mesure.isoformat(),
                'commentaire': derniere_mesure.commentaire
            },
            'etat': {
                'code': etat,
                'libelle': kri.get_libelle_etat(derniere_mesure.valeur),
                'couleur': couleur
            },
            'seuils': {
                'alerte': kri.seuil_alerte,
                'critique': kri.seuil_critique,
                'cible': kri.seuil_cible
            },
            'sens_evaluation': kri.sens_evaluation_seuil
        }
        
        # Ajouter l'√©cart par rapport √† la cible si disponible
        if ecart_cible is not None:
            response['ecart_cible'] = {
                'valeur': ecart_cible,
                'texte': f"{ecart_cible:+.1f}% par rapport √† la cible"
            }
        
        return jsonify(response)
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/kri/<int:kri_id>/rapport-pdf')
@login_required
def telecharger_rapport_kri_pdf(kri_id):
    """G√©n√©rer et t√©l√©charger un rapport PDF professionnel pour un KRI"""
    
    # Imports
    from weasyprint import HTML, CSS
    from weasyprint.text.fonts import FontConfiguration
    import os
    from flask import make_response
    import tempfile
    
    try:
        # 1. R√©cup√©rer le KRI
        kri = get_client_filter(KRI).filter_by(id=kri_id).first_or_404()
        
        # 2. R√©cup√©rer les mesures
        mesures = get_client_filter(MesureKRI)\
            .filter_by(kri_id=kri_id)\
            .order_by(MesureKRI.date_mesure.desc())\
            .all()
        
        # 3. R√©cup√©rer la derni√®re mesure
        derniere_mesure = kri.get_derniere_mesure() if hasattr(kri, 'get_derniere_mesure') else None
        
        # 4. Calculer les statistiques
        statistiques = {}
        if mesures:
            valeurs = [m.valeur for m in mesures]
            statistiques = {
                'moyenne': sum(valeurs) / len(valeurs) if valeurs else 0,
                'minimum': min(valeurs) if valeurs else 0,
                'maximum': max(valeurs) if valeurs else 0,
                'nb_mesures': len(valeurs)
            }
            
            # Calculer la tendance
            if len(valeurs) >= 3:
                if valeurs[0] > valeurs[-1] * 1.05:
                    tendance = 'hausse'
                elif valeurs[0] < valeurs[-1] * 0.95:
                    tendance = 'baisse'
                else:
                    tendance = 'stable'
            else:
                tendance = 'stable'
            statistiques['tendance'] = tendance
        
        # 5. Calculer l'√©cart par rapport √† la cible - VERSION DIFF√âRENCE ABSOLUE
        difference_cible = None
        interpretation = None
        if kri.type_indicateur == 'kpi' and kri.seuil_cible and derniere_mesure:
            if hasattr(kri, 'get_difference_cible'):
                difference_cible = kri.get_difference_cible(derniere_mesure.valeur)
            if hasattr(kri, 'get_interpretation_difference'):
                interpretation = kri.get_interpretation_difference(derniere_mesure.valeur)
        
        # 6. Rendre le template
        rendered_html = render_template(
            'kri/rapport_pdf.html',
            kri=kri,
            mesures=mesures,
            statistiques=statistiques,
            derniere_mesure=derniere_mesure,
            difference_cible=difference_cible,
            interpretation=interpretation,
            datetime=datetime,
            date_generation=datetime.utcnow(),
            now=datetime.utcnow
        )
        
        # 7. Configuration des polices
        font_config = FontConfiguration()
        
        # 8. Chemins CSS
        css_files = []
        
        # Chercher le fichier CSS principal
        css_paths = [
            os.path.join(app.root_path, 'static', 'css', 'style.css'),
            os.path.join(app.root_path, 'static', 'css', 'bootstrap.min.css'),
            os.path.join(app.static_folder, 'css', 'style.css') if hasattr(app, 'static_folder') else None
        ]
        
        for css_path in css_paths:
            if css_path and os.path.exists(css_path):
                try:
                    css_files.append(CSS(filename=css_path, font_config=font_config))
                except Exception as e:
                    print(f"‚ö†Ô∏è Erreur chargement CSS {css_path}: {e}")
        
        # 9. G√©n√©rer le PDF
        try:
            if css_files:
                pdf = HTML(string=rendered_html).write_pdf(
                    stylesheets=css_files,
                    font_config=font_config
                )
            else:
                pdf = HTML(string=rendered_html).write_pdf(font_config=font_config)
        except Exception as e:
            print(f"‚ùå Erreur g√©n√©ration PDF: {e}")
            # Fallback simple
            pdf = HTML(string=rendered_html).write_pdf()
        
        # 10. Cr√©er la r√©ponse
        response = make_response(pdf)
        response.headers['Content-Type'] = 'application/pdf'
        
        # Nom du fichier
        nom_fichier = f"rapport_{kri.type_indicateur}_{kri.nom}".replace(' ', '_')
        nom_fichier = ''.join(c for c in nom_fichier if c.isalnum() or c in '._-')
        filename = f"{nom_fichier}_{datetime.utcnow().strftime('%Y%m%d_%H%M')}.pdf"
        
        response.headers['Content-Disposition'] = f'attachment; filename={filename}'
        
        # Log
        print(f"‚úÖ PDF g√©n√©r√©: {filename}")
        
        return response
        
    except Exception as e:
        print(f"‚ùå Erreur g√©n√©rale: {e}")
        import traceback
        traceback.print_exc()
        flash("Erreur lors de la g√©n√©ration du rapport PDF.", 'error')
        return redirect(url_for('detail_kri', kri_id=kri_id))


# ========================
# ROUTES IA POUR KRI
# ========================

@app.route('/api/risque/<int:risque_id>/generer-kris-ia', methods=['GET'])
@login_required
@csrf.exempt
def generer_kris_ia(risque_id):
    """G√©n√©rer des suggestions de KRI via IA pour un risque"""
    try:
        # R√©cup√©rer le risque avec v√©rification d'acc√®s
        risque = get_client_object_or_404(Risque, risque_id)
        
        # Pr√©parer les donn√©es du risque de mani√®re s√©curis√©e
        risque_data = {
            'id': risque.id,
            'reference': risque.reference,
            'intitule': risque.intitule,
            'description': risque.description,
            'categorie': risque.categorie,
            'probabilite': getattr(risque, 'probabilite', 'Non √©valu√©e'),
            'impact': getattr(risque, 'impact', 'Non √©valu√©'),
            'score_risque': getattr(risque, 'score_risque', 'Non calcul√©'),
        }
        
        # Ajouter les infos de processus si disponible (avec v√©rification)
        try:
            if hasattr(risque, 'processus') and risque.processus:
                if hasattr(risque.processus, 'nom'):
                    risque_data['processus'] = {'nom': risque.processus.nom}
                elif isinstance(risque.processus, dict):
                    risque_data['processus'] = risque.processus
                else:
                    risque_data['processus'] = {'nom': str(risque.processus)}
            else:
                risque_data['processus'] = None
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur r√©cup√©ration processus: {e}")
            risque_data['processus'] = None
        
        # Ajouter le responsable si disponible (avec v√©rification)
        try:
            if hasattr(risque, 'responsable') and risque.responsable:
                if hasattr(risque.responsable, 'username'):
                    risque_data['responsable'] = {'username': risque.responsable.username}
                elif isinstance(risque.responsable, dict):
                    risque_data['responsable'] = risque.responsable
                else:
                    risque_data['responsable'] = {'username': str(risque.responsable)}
            else:
                risque_data['responsable'] = None
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur r√©cup√©ration responsable: {e}")
            risque_data['responsable'] = None
        
        # G√©n√©rer les KRI via IA
        from services.kri_ia_service import kri_ia_service
        suggestions = kri_ia_service.generer_kris_pour_risque(risque_data)
        
        return jsonify({
            'success': True,
            'risque_id': risque_id,
            'risque_reference': risque.reference,
            'suggestions': suggestions,
            'count': len(suggestions),
            'metadata': {
                'generated_at': datetime.utcnow().isoformat(),
                'mode': 'simulation' if kri_ia_service.mode_simulation else 'reel'
            }
        })
        
    except Exception as e:
        print(f"‚ùå Erreur g√©n√©ration KRI IA: {e}")
        import traceback
        traceback.print_exc()
        
        return jsonify({
            'success': False,
            'error': str(e),
            'message': 'Erreur lors de la g√©n√©ration des suggestions'
        }), 500

@app.route('/api/kri/ia/appliquer-suggestion', methods=['POST'])
@login_required
@csrf.exempt
def appliquer_suggestion_kri_ia():
    """Appliquer une suggestion de KRI IA - VERSION CORRIG√âE"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({
                'success': False, 
                'error': 'Donn√©es manquantes',
                'code': 'missing_data'
            }), 400
        
        risque_id = data.get('risque_id')
        suggestion = data.get('suggestion')
        
        # D√âBOGAGE
        print(f"üîç Application suggestion KRI IA:")
        print(f"  Risque ID: {risque_id}")
        print(f"  Suggestion re√ßue: {suggestion.get('nom', 'Non nomm√©') if suggestion else 'Aucune'}")
        
        if not risque_id:
            return jsonify({
                'success': False, 
                'error': 'ID de risque manquant',
                'code': 'missing_risque_id'
            }), 400
        
        if not suggestion:
            return jsonify({
                'success': False, 
                'error': 'Suggestion manquante',
                'code': 'missing_suggestion'
            }), 400
        
        # V√©rifier l'acc√®s au risque
        risque = get_client_object_or_404(Risque, risque_id)
        
        print(f"  Risque trouv√©: {risque.reference}")
        
        # V√©rifier s'il y a d√©j√† un KRI pour ce risque
        kri_existant = get_client_filter(KRI).filter_by(
            risque_id=risque_id, 
            type_indicateur='kri',
            est_actif=True
        ).first()
        
        if kri_existant:
            print(f"  ‚ö†Ô∏è KRI existant: {kri_existant.id} - {kri_existant.nom}")
            return jsonify({
                'success': False,
                'error': 'Un KRI existe d√©j√† pour ce risque',
                'existing_kri_id': kri_existant.id,
                'existing_kri_nom': kri_existant.nom,
                'redirect_url': url_for('detail_kri', kri_id=kri_existant.id)
            }), 409  # 409 Conflict
        
        # Cr√©er le KRI
        kri = KRI(
            type_indicateur='kri',
            risque_id=risque_id,
            nom=suggestion.get('nom', f"KRI - {risque.reference}"),
            description=suggestion.get('description', ''),
            formule_calcul=suggestion.get('formule_calcul', ''),
            unite_mesure=suggestion.get('unite_mesure', ''),
            seuil_alerte=float(suggestion.get('seuil_alerte', 0)) if suggestion.get('seuil_alerte') else None,
            seuil_critique=float(suggestion.get('seuil_critique', 0)) if suggestion.get('seuil_critique') else None,
            sens_evaluation_seuil=suggestion.get('sens_evaluation_seuil', 'superieur'),
            frequence_mesure=suggestion.get('frequence_mesure', 'mensuel'),
            responsable_mesure_id=current_user.id,  # Par d√©faut l'utilisateur courant
            categorie=suggestion.get('categorie', 'operationnel'),
            source_donnees='G√©n√©r√© par IA',
            notes_internes=f"G√©n√©r√© par IA le {datetime.utcnow().strftime('%d/%m/%Y %H:%M')}",
            created_by=current_user.id,
            est_actif=True
        )
        
        # Ajouter le client_id
        if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
            kri.client_id = current_user.client_id
        elif hasattr(risque, 'client_id'):
            kri.client_id = risque.client_id
        
        # Ajouter les m√©tadonn√©es IA si pr√©sentes
        if '_metadata' in suggestion:
            if not kri.notes_internes:
                kri.notes_internes = ''
            kri.notes_internes += f"\n\nM√©tadonn√©es IA: {json.dumps(suggestion['_metadata'], indent=2)}"
        
        db.session.add(kri)
        db.session.commit()
        
        print(f"  ‚úÖ KRI cr√©√©: {kri.id} - {kri.nom}")
        
        # Journaliser l'action
        log_activity(current_user.id, 'kri_ia_appliquee',
                    f"KRI IA appliqu√©: {kri.nom} pour risque {risque.reference}",
                    'kri', kri.id)
        
        # Notification pour l'utilisateur
        try:
            notification = Notification(
                destinataire_id=current_user.id,
                type_notification=Notification.TYPE_KRI_ALERTE,
                titre=f"KRI cr√©√© via IA: {kri.nom}",
                message=f"Le KRI '{kri.nom}' a √©t√© cr√©√© avec succ√®s pour le risque {risque.reference}.",
                urgence=Notification.URGENCE_NORMAL,
                entite_type='kri',
                entite_id=kri.id,
                donnees_supplementaires={
                    'risque_reference': risque.reference,
                    'mode_generation': 'ia'
                }
            )
            db.session.add(notification)
            db.session.commit()
            print(f"  üì¢ Notification cr√©√©e pour utilisateur {current_user.id}")
        except Exception as e:
            print(f"  ‚ö†Ô∏è Erreur cr√©ation notification: {e}")
            db.session.rollback()
        
        return jsonify({
            'success': True,
            'message': 'KRI cr√©√© avec succ√®s',
            'kri_id': kri.id,
            'kri_nom': kri.nom,
            'kri_reference': f"KRI-{kri.id:04d}",
            'redirect_url': url_for('detail_kri', kri_id=kri.id)
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur application suggestion KRI IA: {e}")
        import traceback
        traceback.print_exc()
        
        return jsonify({
            'success': False,
            'error': str(e),
            'code': 'server_error'
        }), 500

@app.route('/api/risque/<int:risque_id>/kris/suggestions', methods=['GET'])
@login_required
@csrf.exempt
def suggestions_kris_fallback(risque_id):
    """Suggestions de KRI (fallback si IA √©choue)"""
    try:
        # R√©cup√©rer le risque
        risque = get_client_object_or_404(Risque, risque_id)
        
        # Suggestions g√©n√©riques qui fonctionnent toujours
        suggestions = [
            {
                "nom": f"Taux d'occurrence - {risque.reference}",
                "description": f"Mesure la fr√©quence d'apparition du risque : {risque.intitule}",
                "formule_calcul": "(Nombre d'occurrences / P√©riode) √ó 100",
                "unite_mesure": "%",
                "categorie": "operationnel",
                "seuil_alerte": 5.0,
                "seuil_critique": 10.0,
                "sens_evaluation_seuil": "superieur",
                "frequence_mesure": "mensuel",
                "justification": "Indicateur de base pour surveiller la fr√©quence du risque"
            },
            {
                "nom": f"Impact moyen - {risque.reference}",
                "description": f"Impact financier moyen du risque {risque.intitule}",
                "formule_calcul": "Somme des impacts / Nombre d'occurrences",
                "unite_mesure": "‚Ç¨",
                "categorie": "financier",
                "seuil_alerte": 5000.0,
                "seuil_critique": 10000.0,
                "sens_evaluation_seuil": "superieur",
                "frequence_mesure": "trimestriel",
                "justification": "Mesure l'impact financier du risque"
            }
        ]
        
        # Ajouter une suggestion bas√©e sur la cat√©gorie
        categorie = getattr(risque, 'categorie', '').lower()
        
        if 'securite' in categorie or 'conformite' in categorie:
            suggestions.append({
                "nom": f"Taux de conformit√© - {risque.reference}",
                "description": "Pourcentage de conformit√© aux exigences",
                "formule_calcul": "(Nombre de contr√¥les conformes / Total des contr√¥les) √ó 100",
                "unite_mesure": "%",
                "categorie": "conformite",
                "seuil_alerte": 90.0,
                "seuil_critique": 80.0,
                "sens_evaluation_seuil": "inferieur",
                "frequence_mesure": "trimestriel",
                "justification": "Surveille le niveau de conformit√©"
            })
        
        # Ajouter des m√©tadonn√©es
        for suggestion in suggestions:
            suggestion['_metadata'] = {
                'generated_at': datetime.utcnow().isoformat(),
                'mode': 'fallback',
                'score_confiance': 85.0
            }
        
        return jsonify({
            'success': True,
            'risque_id': risque_id,
            'risque_reference': risque.reference,
            'suggestions': suggestions,
            'count': len(suggestions),
            'metadata': {
                'generated_at': datetime.utcnow().isoformat(),
                'mode': 'fallback',
                'note': 'Suggestions g√©n√©riques (IA non disponible)'
            }
        })
        
    except Exception as e:
        print(f"‚ùå Erreur suggestions fallback: {e}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/api/kri/ia/ajuster-suggestion', methods=['POST'])
@login_required
@csrf.exempt
def ajuster_suggestion_kri_ia():
    """Ajuster une suggestion de KRI IA avant application"""
    try:
        data = request.get_json()
        
        suggestion = data.get('suggestion')
        ajustements = data.get('ajustements', {})
        
        if not suggestion:
            return jsonify({'success': False, 'error': 'Suggestion manquante'}), 400
        
        from services.kri_ia_service import kri_ia_service
        suggestion_ajustee = kri_ia_service.ajuster_kri(suggestion, ajustements)
        
        return jsonify({
            'success': True,
            'suggestion_ajustee': suggestion_ajustee,
            'metadata': {
                'ajusted_at': datetime.utcnow().isoformat()
            }
        })
        
    except Exception as e:
        print(f"‚ùå Erreur ajustement suggestion: {e}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/risque/<int:id>/kri/ia', methods=['GET'])
@login_required
def creer_kri_ia_depuis_risque(id):
    """Cr√©er un KRI via IA depuis un risque existant"""
    risque = get_client_object_or_404(Risque, id)
    
    # V√©rifier les permissions
    if not current_user.has_permission('can_manage_kri'):
        flash('Vous n\'avez pas les permissions pour cr√©er un KRI', 'error')
        return redirect(url_for('detail_risque', id=id))
    
    # V√©rifier s'il y a d√©j√† un KRI
    kri_existant = get_client_filter(KRI).filter_by(
        risque_id=id, 
        type_indicateur='kri',
        est_actif=True
    ).first()
    
    if kri_existant:
        flash(f'Un KRI existe d√©j√† pour ce risque: {kri_existant.nom}', 'warning')
        return redirect(url_for('detail_risque', id=id))
    
    # Rediriger vers le formulaire avec pr√©-remplissage IA
    return redirect(url_for('nouveau_kri', risque_id=id))
    

@app.route('/risque/<int:id>/evaluation-triphase', methods=['GET', 'POST'])
@login_required
def evaluer_risque_triphase(id):
    """√âvaluation triphas√©e d'un risque avec gestion robuste des erreurs SQL"""
    
    # √âTAPE CRITIQUE : R√©initialiser la connexion DB si elle est corrompue
    try:
        db.session.execute(text('SELECT 1'))
    except Exception as e:
        if "current transaction is aborted" in str(e):
            print("‚ö†Ô∏è Session DB corrompue d√©tect√©e, r√©initialisation...")
            db.session.rollback()
            db.session.remove()
            db.session.close_all()
            print("‚úÖ Session DB r√©initialis√©e")
    
    try:
        # R√©cup√©rer le risque avec une approche progressive et robuste
        risque = None
        
        # ESSAI 1: Avec eager loading complet (si les relations existent)
        try:
            # Construction progressive de la requ√™te avec options
            query = Risque.query
            
            # Essayer d'ajouter les options une par une avec gestion d'erreur
            try:
                if hasattr(Risque, 'cartographie'):
                    query = query.options(joinedload(Risque.cartographie))
            except Exception as e:
                print(f"‚ö†Ô∏è Impossible de charger cartographie: {e}")
            
            try:
                # Essayer les deux possibilit√©s pour le KRI
                if hasattr(Risque, 'kri'):
                    query = query.options(joinedload(Risque.kri))
                    try:
                        # Essayer de charger les mesures si KRI existe
                        if hasattr(KRI, 'mesures'):
                            query = query.options(joinedload(Risque.kri).joinedload(KRI.mesures))
                    except:
                        pass
                elif hasattr(Risque, 'kris'):
                    query = query.options(joinedload(Risque.kris))
            except Exception as e:
                print(f"‚ö†Ô∏è Impossible de charger KRI: {e}")
            
            try:
                if hasattr(Risque, 'dispositifs_maitrise'):
                    query = query.options(joinedload(Risque.dispositifs_maitrise))
            except Exception as e:
                print(f"‚ö†Ô∏è Impossible de charger dispositifs: {e}")
            
            try:
                if hasattr(Risque, 'plans_action'):
                    query = query.options(joinedload(Risque.plans_action))
            except Exception as e:
                print(f"‚ö†Ô∏è Impossible de charger plans_action: {e}")
            
            # Ex√©cuter la requ√™te
            risque = query.get(id)
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur avec eager loading: {e}")
            risque = None
        
        # ESSAI 2: Fallback sur requ√™te simple si eager loading a √©chou√©
        if not risque:
            try:
                print("üîÑ Fallback sur requ√™te simple...")
                risque = Risque.query.get(id)
            except Exception as e:
                print(f"‚ùå Erreur r√©cup√©ration simple: {e}")
                risque = None
        
        # V√©rifier si le risque a √©t√© trouv√©
        if not risque:
            flash('Risque non trouv√©', 'error')
            return redirect(url_for('dashboard'))
        
        # V√©rifier l'acc√®s
        if not check_client_access(risque):
            flash('Acc√®s non autoris√© √† ce risque', 'error')
            return redirect(url_for('dashboard'))
        
        # ========== CHARGEMENT DES DONN√âES COMPL√âMENTAIRES ==========
        
        # R√©cup√©rer les utilisateurs
        users = []
        try:
            if current_user.role == 'super_admin':
                users = User.query.filter(User.is_active == True).all()
            else:
                users = get_client_filter(User).filter(User.is_active == True).all()
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur r√©cup√©ration utilisateurs: {e}")
            users = []
        
        # Pr√©parer le formulaire
        form = EvaluationTriPhaseForm()
        form.referent_pre_evaluation_id.choices = [(0, 'S√©lectionnez un r√©f√©rent...')] + \
            [(u.id, f"{u.username} - {u.role}") for u in users if u]
        
        # R√©cup√©rer les risques de la m√™me cartographie
        risques_cartographie = []
        try:
            risques_cartographie = get_client_filter(Risque)\
                .filter_by(cartographie_id=risque.cartographie_id)\
                .order_by(Risque.is_archived.asc(), Risque.reference.asc())\
                .all()
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur r√©cup√©ration risques cartographie: {e}")
            risques_cartographie = []
        
        # ========== GESTION DE LA CAMPAGNE ==========
        
        campagne_active = None
        try:
            campagne_active = get_client_filter(CampagneEvaluation)\
                .filter_by(
                    cartographie_id=risque.cartographie_id,
                    statut='en_cours'
                ).first()
            
            if not campagne_active:
                # Cr√©er une campagne par d√©faut
                annee_courante = datetime.now().year
                campagne_active = CampagneEvaluation(
                    cartographie_id=risque.cartographie_id,
                    nom=f"Campagne {annee_courante}",
                    description=f"√âvaluation annuelle {annee_courante}",
                    date_debut=datetime.now().date(),
                    statut='en_cours',
                    created_by=current_user.id
                )
                
                # Ajouter client_id
                if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
                    campagne_active.client_id = current_user.client_id
                elif current_user.role == 'super_admin' and hasattr(risque, 'client_id'):
                    campagne_active.client_id = risque.client_id
                
                db.session.add(campagne_active)
                db.session.commit()
                print(f"‚úÖ Campagne cr√©√©e: {campagne_active.nom}")
                
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur gestion campagne: {e}")
            db.session.rollback()
            campagne_active = None
        
        # R√©cup√©rer l'√©valuation en cours
        evaluation_en_cours = None
        if campagne_active:
            try:
                evaluation_en_cours = get_client_filter(EvaluationRisque)\
                    .options(
                        joinedload(EvaluationRisque.referent_pre_evaluation),
                        joinedload(EvaluationRisque.validateur),
                        joinedload(EvaluationRisque.evaluateur_final)
                    )\
                    .filter_by(
                        risque_id=id,
                        campagne_id=campagne_active.id
                    ).first()
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur r√©cup√©ration √©valuation: {e}")
                evaluation_en_cours = None
        
        # ========== GESTION DU POST ==========
        
        if request.method == 'POST':
            print(f"üì® Formulaire soumis par {current_user.username}")
            
            try:
                # D√©tection du bouton soumis
                bouton_soumis = None
                for key, value in request.form.items():
                    if value in ['submit_phase1', 'submit_phase2', 'submit_phase3']:
                        bouton_soumis = value
                        break
                
                if not bouton_soumis:
                    if 'impact_conf' in request.form:
                        bouton_soumis = 'submit_phase3'
                    elif 'impact_val' in request.form:
                        bouton_soumis = 'submit_phase2'
                    else:
                        bouton_soumis = 'submit_phase1'
                
                # PHASE 1
                if bouton_soumis == 'submit_phase1':
                    print("üîÑ Traitement Phase 1...")
                    
                    try:
                        impact_pre = int(request.form.get('impact_pre', 0))
                        probabilite_pre = int(request.form.get('probabilite_pre', 0))
                        niveau_maitrise_pre = int(request.form.get('niveau_maitrise_pre', 3))
                    except (ValueError, TypeError):
                        flash('Valeurs invalides', 'error')
                        return redirect(url_for('evaluer_risque_triphase', id=id))
                    
                    if impact_pre == 0 or probabilite_pre == 0:
                        flash('S√©lectionnez impact et probabilit√©', 'error')
                        return redirect(url_for('evaluer_risque_triphase', id=id))
                    
                    # Calculs
                    score_risque = impact_pre * probabilite_pre
                    niveau_risque, _ = calculer_niveau_risque(impact_pre, probabilite_pre)
                    referent_id = request.form.get('referent_pre_evaluation_id')
                    commentaire = request.form.get('commentaire_pre_evaluation', '')
                    
                    if evaluation_en_cours:
                        # Mise √† jour
                        evaluation_en_cours.referent_pre_evaluation_id = int(referent_id) if referent_id and referent_id != '0' else None
                        evaluation_en_cours.date_pre_evaluation = datetime.utcnow()
                        evaluation_en_cours.impact_pre = impact_pre
                        evaluation_en_cours.probabilite_pre = probabilite_pre
                        evaluation_en_cours.niveau_maitrise_pre = niveau_maitrise_pre
                        evaluation_en_cours.commentaire_pre_evaluation = commentaire
                        evaluation_en_cours.score_risque = score_risque
                        evaluation_en_cours.niveau_risque = niveau_risque
                        evaluation_en_cours.statut_validation = 'en_attente'
                        evaluation_en_cours.updated_at = datetime.utcnow()
                    else:
                        # Cr√©ation
                        evaluation = EvaluationRisque(
                            risque_id=id,
                            campagne_id=campagne_active.id if campagne_active else None,
                            referent_pre_evaluation_id=int(referent_id) if referent_id and referent_id != '0' else None,
                            date_pre_evaluation=datetime.utcnow(),
                            impact_pre=impact_pre,
                            probabilite_pre=probabilite_pre,
                            niveau_maitrise_pre=niveau_maitrise_pre,
                            commentaire_pre_evaluation=commentaire,
                            score_risque=score_risque,
                            niveau_risque=niveau_risque,
                            statut_validation='en_attente',
                            created_by=current_user.id
                        )
                        
                        # Client ID
                        if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
                            evaluation.client_id = current_user.client_id
                        elif hasattr(risque, 'client_id'):
                            evaluation.client_id = risque.client_id
                        elif campagne_active and hasattr(campagne_active, 'client_id'):
                            evaluation.client_id = campagne_active.client_id
                        
                        db.session.add(evaluation)
                        evaluation_en_cours = evaluation
                    
                    db.session.commit()
                    flash('‚úÖ Pr√©-√©valuation enregistr√©e', 'success')
                    return redirect(url_for('evaluer_risque_triphase', id=id))
                
                # PHASE 2
                elif bouton_soumis == 'submit_phase2':
                    if not evaluation_en_cours:
                        flash('Compl√©tez d\'abord la Phase 1', 'error')
                        return redirect(url_for('evaluer_risque_triphase', id=id))
                    
                    try:
                        impact_val = int(request.form.get('impact_val', 0))
                        probabilite_val = int(request.form.get('probabilite_val', 0))
                        niveau_maitrise_val = int(request.form.get('niveau_maitrise_val', 0))
                    except (ValueError, TypeError):
                        impact_val = 0
                        probabilite_val = 0
                        niveau_maitrise_val = 0
                    
                    # Calculs finaux
                    impact_final = impact_val if impact_val > 0 else evaluation_en_cours.impact_pre
                    probabilite_final = probabilite_val if probabilite_val > 0 else evaluation_en_cours.probabilite_pre
                    niveau_maitrise_final = niveau_maitrise_val if niveau_maitrise_val > 0 else evaluation_en_cours.niveau_maitrise_pre
                    
                    score_risque = impact_final * probabilite_final
                    niveau_risque, _ = calculer_niveau_risque(impact_final, probabilite_final)
                    
                    # Mise √† jour
                    evaluation_en_cours.validateur_id = current_user.id
                    evaluation_en_cours.date_validation = datetime.utcnow()
                    evaluation_en_cours.impact_val = impact_val if impact_val > 0 else None
                    evaluation_en_cours.probabilite_val = probabilite_val if probabilite_val > 0 else None
                    evaluation_en_cours.niveau_maitrise_val = niveau_maitrise_val if niveau_maitrise_val > 0 else None
                    evaluation_en_cours.score_risque = score_risque
                    evaluation_en_cours.niveau_risque = niveau_risque
                    evaluation_en_cours.commentaire_validation = request.form.get('commentaire_validation', '')
                    evaluation_en_cours.statut_validation = request.form.get('statut_validation', 'en_attente')
                    evaluation_en_cours.updated_at = datetime.utcnow()
                    
                    db.session.commit()
                    flash('‚úÖ √âvaluation valid√©e', 'success')
                    return redirect(url_for('evaluer_risque_triphase', id=id))
                
                # PHASE 3
                elif bouton_soumis == 'submit_phase3':
                    if not evaluation_en_cours:
                        flash('Compl√©tez d\'abord les Phases 1 et 2', 'error')
                        return redirect(url_for('evaluer_risque_triphase', id=id))
                    
                    try:
                        impact_conf = int(request.form.get('impact_conf', 0))
                        probabilite_conf = int(request.form.get('probabilite_conf', 0))
                        niveau_maitrise_conf = int(request.form.get('niveau_maitrise_conf', 0))
                    except (ValueError, TypeError):
                        impact_conf = 0
                        probabilite_conf = 0
                        niveau_maitrise_conf = 0
                    
                    # Valeurs finales
                    impact_val = evaluation_en_cours.impact_val or evaluation_en_cours.impact_pre
                    probabilite_val = evaluation_en_cours.probabilite_val or evaluation_en_cours.probabilite_pre
                    
                    impact_final = impact_conf if impact_conf > 0 else impact_val
                    probabilite_final = probabilite_conf if probabilite_conf > 0 else probabilite_val
                    niveau_maitrise_final = niveau_maitrise_conf if niveau_maitrise_conf > 0 else (evaluation_en_cours.niveau_maitrise_val or evaluation_en_cours.niveau_maitrise_pre)
                    
                    score_risque = impact_final * probabilite_final
                    niveau_risque, _ = calculer_niveau_risque(impact_final, probabilite_final)
                    
                    # Mise √† jour finale
                    evaluation_en_cours.impact_conf = impact_conf if impact_conf > 0 else None
                    evaluation_en_cours.probabilite_conf = probabilite_conf if probabilite_conf > 0 else None
                    evaluation_en_cours.niveau_maitrise_conf = niveau_maitrise_conf if niveau_maitrise_conf > 0 else None
                    evaluation_en_cours.score_risque = score_risque
                    evaluation_en_cours.niveau_risque = niveau_risque
                    evaluation_en_cours.evaluateur_final_id = current_user.id
                    evaluation_en_cours.date_confirmation = datetime.utcnow()
                    evaluation_en_cours.commentaire_confirmation = request.form.get('commentaire_confirmation', '')
                    evaluation_en_cours.updated_at = datetime.utcnow()
                    
                    db.session.commit()
                    
                    # Mettre √† jour le risque
                    risque.derniere_evaluation_date = datetime.utcnow()
                    risque.dernier_score_risque = score_risque
                    risque.dernier_niveau_risque = niveau_risque
                    db.session.commit()
                    
                    flash('üéâ √âvaluation confirm√©e !', 'success')
                    return redirect(url_for('detail_risque', id=id))
                    
            except Exception as e:
                db.session.rollback()
                print(f"‚ùå Erreur POST: {str(e)}")
                flash(f'Erreur: {str(e)}', 'error')
        
        # ========== PR√âPARATION DE LA R√âPONSE ==========
        
        # D√©terminer la phase
        phase_actuelle = 'phase1'
        if evaluation_en_cours:
            if evaluation_en_cours.date_confirmation:
                phase_actuelle = 'termine'
            elif evaluation_en_cours.date_validation:
                phase_actuelle = 'phase3'
            elif evaluation_en_cours.date_pre_evaluation:
                phase_actuelle = 'phase2'
        
        # Pr√©-remplir le formulaire
        if evaluation_en_cours:
            form.referent_pre_evaluation_id.data = evaluation_en_cours.referent_pre_evaluation_id or 0
            form.impact_pre.data = evaluation_en_cours.impact_pre or 0
            form.probabilite_pre.data = evaluation_en_cours.probabilite_pre or 0
            form.niveau_maitrise_pre.data = evaluation_en_cours.niveau_maitrise_pre or 0
            form.commentaire_pre_evaluation.data = evaluation_en_cours.commentaire_pre_evaluation or ''
        
        # ========== PR√âPARATION DES DONN√âES POUR LE TEMPLATE ==========
        
        # Cr√©er un dictionnaire de donn√©es s√©curis√©es pour le template
        template_data = {
            'form': form,
            'risque': risque,
            'campagne_active': campagne_active,
            'evaluation_en_cours': evaluation_en_cours,
            'phase_actuelle': phase_actuelle,
            'referents': users,
            'risques_cartographie': risques_cartographie,
            # Ajouter des flags de s√©curit√© pour le template
            'has_dispositifs': hasattr(risque, 'dispositifs_maitrise'),
            'has_kri': hasattr(risque, 'kri') or hasattr(risque, 'kris')
        }
        
        # ========== RENDU DU TEMPLATE ==========
        
        return render_template('cartographie/evaluation_triphase.html', **template_data)
                            
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur globale: {str(e)}")
        import traceback
        traceback.print_exc()
        flash(f'Erreur: {str(e)}', 'error')
        return redirect(url_for('dashboard'))



@app.before_request
def handle_transaction():
    """V√©rifie l'√©tat de la transaction avant chaque requ√™te"""
    try:
        # Tester la connexion
        db.session.execute(text('SELECT 1'))
    except Exception as e:
        print(f"‚ö†Ô∏è Transaction corrompue d√©tect√©e, rollback: {e}")
        db.session.rollback()

@app.teardown_request
def teardown_request(exception=None):
    """Nettoyage apr√®s chaque requ√™te"""
    if exception:
        print(f"üö® Erreur d√©tect√©e, rollback: {exception}")
        db.session.rollback()
    db.session.remove()
@app.route('/cartographie/<int:id>/nouvelle-campagne', methods=['GET', 'POST'])
@login_required
def nouvelle_campagne_cartographie(id):
    """Cr√©er une nouvelle campagne d'√©valuation pour une cartographie"""
    cartographie = Cartographie.query.get_or_404(id)
    
    if request.method == 'POST':
        nom = request.form.get('nom', '').strip()
        if not nom:
            flash('Le nom de la campagne est obligatoire', 'error')
            return redirect(url_for('nouvelle_campagne_cartographie', id=id))
        
        # Terminer l'ancienne campagne active si elle existe
        ancienne_campagne = CampagneEvaluation.query.filter_by(
            cartographie_id=id,
            statut='en_cours'
        ).first()
        
        if ancienne_campagne:
            ancienne_campagne.statut = 'terminee'
            ancienne_campagne.date_fin = datetime.now().date()
            db.session.add(ancienne_campagne)
        
        # Cr√©er la nouvelle campagne
        nouvelle_campagne = CampagneEvaluation(
            cartographie_id=id,
            nom=nom,
            description=request.form.get('description', ''),
            date_debut=datetime.now().date(),
            statut='en_cours',
            created_by=current_user.id
        )
        
        db.session.add(nouvelle_campagne)
        db.session.commit()
        
        flash(f'‚úÖ Nouvelle campagne "{nom}" cr√©√©e avec succ√®s', 'success')
        return redirect(url_for('detail_cartographie', id=id))
    
    return render_template('cartographie/nouvelle_campagne.html', cartographie=cartographie)



app.route('/api/notifications/tester', methods=['POST'])
@login_required
def api_tester_notification():
    """API pour tester une notification"""
    try:
        if NOTIFICATION_SERVICE_AVAILABLE:
            # Cr√©er une notification de test
            notification = NotificationService.create(
                destinataire_id=current_user.id,
                type_notif='info',
                titre='Notification de test',
                message='Ceci est une notification de test pour v√©rifier vos param√®tres.',
                urgence='normal',
                metadata={'test': True}
            )
            
            if notification:
                return jsonify({
                    'success': True,
                    'message': 'Notification de test envoy√©e',
                    'notification_id': notification.id
                })
            else:
                return jsonify({
                    'success': False,
                    'error': 'Impossible de cr√©er la notification'
                }), 400
        else:
            return jsonify({
                'success': False,
                'error': 'Service notifications non disponible'
            }), 503
            
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/notifications/stats')
@login_required
def api_notifications_stats():
    """API pour obtenir les statistiques des notifications"""
    try:
        from datetime import datetime, timedelta
        
        # Calculer les statistiques
        total = Notification.query.filter_by(destinataire_id=current_user.id).count()
        non_lues = Notification.query.filter_by(
            destinataire_id=current_user.id,
            est_lue=False
        ).count()
        
        # Notifications de la semaine
        semaine_pass√©e = datetime.utcnow() - timedelta(days=7)
        semaine = Notification.query.filter(
            Notification.destinataire_id == current_user.id,
            Notification.created_at >= semaine_pass√©e
        ).count()
        
        # Ratio de notifications lues
        ratio_lues = round((total - non_lues) / total * 100, 1) if total > 0 else 0
        
        return jsonify({
            'total': total,
            'non_lues': non_lues,
            'semaine': semaine,
            'ratio_lues': ratio_lues,
            'date': datetime.utcnow().isoformat()
        })
        
    except Exception as e:
        return jsonify({
            'total': 0,
            'non_lues': 0,
            'semaine': 0,
            'ratio_lues': 0,
            'error': str(e)
        })

# ========================
# AJOUTER UN CONTEXT PROCESSOR POUR LES NOTIFICATIONS
# ========================

@app.context_processor
def inject_notifications():
    """Injecter les donn√©es de notifications dans tous les templates"""
    def get_notifications_count():
        if current_user.is_authenticated:
            try:
                if NOTIFICATION_SERVICE_AVAILABLE:
                    return NotificationService.get_count_notifications_non_lues(current_user.id)
                else:
                    # Fallback √† l'ancien syst√®me
                    return Notification.query.filter_by(
                        destinataire_id=current_user.id,
                        est_lue=False
                    ).count()
            except:
                return 0
        return 0
    
    return dict(
        notifications_count=get_notifications_count,
        has_notifications_permission=current_user.is_authenticated and 
            current_user.has_permission('can_view_notifications')
    )

# ========================
# AJOUTER UNE T√ÇCHE DE NETTOYAGE AUTOMATIQUE
# ========================

def nettoyer_notifications_expirees():
    """Nettoyer les notifications expir√©es"""
    with app.app_context():
        try:
            from datetime import datetime
            deleted = Notification.query.filter(
                Notification.expires_at < datetime.utcnow()
            ).delete()
            db.session.commit()
            if deleted > 0:
                print(f"üßπ {deleted} notifications expir√©es nettoy√©es")
        except Exception as e:
            print(f"‚ùå Erreur nettoyage notifications: {e}")

@app.route('/cartographie/<int:cartographie_id>/changer-campagne/<int:campagne_id>')
@login_required
def changer_campagne_cartographie(cartographie_id, campagne_id):
    """Changer la campagne active d'une cartographie"""
    cartographie = Cartographie.query.get_or_404(cartographie_id)
    campagne = CampagneEvaluation.query.get_or_404(campagne_id)
    
    # V√©rifier que la campagne appartient √† la cartographie
    if campagne.cartographie_id != cartographie_id:
        flash('Cette campagne ne correspond pas √† cette cartographie', 'error')
        return redirect(url_for('detail_cartographie', id=cartographie_id))
    
    # Activer cette campagne (et d√©sactiver les autres)
    CampagneEvaluation.query.filter_by(
        cartographie_id=cartographie_id,
        statut='en_cours'
    ).update({'statut': 'terminee'})
    
    campagne.statut = 'en_cours'
    db.session.commit()
    
    flash(f'‚úÖ Campagne "{campagne.nom}" activ√©e', 'success')
    return redirect(url_for('detail_cartographie', id=cartographie_id))


@app.route('/cartographie/<int:cartographie_id>/cloturer-campagne')
@login_required
def cloturer_campagne_cartographie(cartographie_id):
    """Cl√¥turer la campagne active d'une cartographie"""
    cartographie = Cartographie.query.get_or_404(cartographie_id)
    
    campagne_active = CampagneEvaluation.query.filter_by(
        cartographie_id=cartographie_id,
        statut='en_cours'
    ).first()
    
    if not campagne_active:
        flash('Aucune campagne active √† cl√¥turer', 'error')
        return redirect(url_for('detail_cartographie', id=cartographie_id))
    
    campagne_active.statut = 'terminee'
    campagne_active.date_fin = datetime.now().date()
    db.session.commit()
    
    flash(f'‚úÖ Campagne "{campagne_active.nom}" cl√¥tur√©e', 'success')
    return redirect(url_for('detail_cartographie', id=cartographie_id))



def calculer_niveau_risque(impact, probabilite):
    """Calculer le niveau de risque bas√© sur l'impact et la probabilit√©"""
    score = impact * probabilite
    
    if score <= 4:
        return 'Faible', 'success'
    elif score <= 9:
        return 'Moyen', 'warning'
    elif score <= 16:
        return '√âlev√©', 'danger'
    else:
        return 'Critique', 'dark'


def get_niveau_impact(niveau):
    """Retourne la description de l'impact"""
    descriptions = {
        1: "N√©gligeable - Impact minime sur les objectifs",
        2: "Mineur - Impact limit√© sur les objectifs", 
        3: "Mod√©r√© - Impact significatif sur les objectifs",
        4: "Important - Impact majeur sur les objectifs",
        5: "Critique - Impact catastrophique sur les objectifs"
    }
    return descriptions.get(niveau, "Niveau inconnu")


def get_niveau_probabilite(niveau):
    """Retourne la description de la probabilit√©"""
    descriptions = {
        1: "Tr√®s rare - Moins d'une fois par an",
        2: "Rare - Une fois par an", 
        3: "Possible - Plusieurs fois par an",
        4: "Probable - Une fois par mois",
        5: "Tr√®s probable - Une fois par semaine ou plus"
    }
    return descriptions.get(niveau, "Niveau inconnu")


def get_niveau_maitrise(niveau):
    """Retourne la description du niveau de ma√Ætrise"""
    descriptions = {
        1: "Insuffisant - Contr√¥les inexistants ou inefficaces",
        2: "Partiel - Contr√¥les basiques, couverture limit√©e", 
        3: "Ad√©quat - Contr√¥les standard, couverture acceptable",
        4: "Bon - Contr√¥les robustes, couverture √©tendue",
        5: "Excellent - Contr√¥les optimis√©s, couverture compl√®te"
    }
    return descriptions.get(niveau, "Niveau inconnu")


# ------------------------------------------------------------
# Rendre les fonctions disponibles dans Jinja
# ------------------------------------------------------------

app.jinja_env.globals['get_niveau_impact'] = get_niveau_impact
app.jinja_env.globals['get_niveau_probabilite'] = get_niveau_probabilite
app.jinja_env.globals['get_niveau_maitrise'] = get_niveau_maitrise
app.jinja_env.globals['calculer_niveau_risque'] = calculer_niveau_risque

@app.route('/risque/modifier-reference/<int:id>', methods=['POST'])
@csrf.exempt  # <-- AJOUTEZ CETTE LIGNE
@login_required
def modifier_reference_risque(id):
    """Modifier la r√©f√©rence d'un risque"""
    risque = Risque.query.get_or_404(id)
    nouvelle_reference = request.form.get('reference', '').strip()
    
    if nouvelle_reference:
        risque.reference = nouvelle_reference
        db.session.commit()
        flash('R√©f√©rence modifi√©e avec succ√®s', 'success')
    else:
        flash('La r√©f√©rence ne peut pas √™tre vide', 'error')
    
    return redirect(url_for('detail_risque', id=id))


def get_create_table_sql_sqlite(table_name):
    """Retourne le SQL pour cr√©er une table SQLite"""
    create_sqls = {
        'configurations_audit': """
            CREATE TABLE configurations_audit (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nom VARCHAR(200) NOT NULL,
                type_audit VARCHAR(100),
                parametres TEXT,  -- JSON stock√© comme TEXT en SQLite
                is_active BOOLEAN DEFAULT 1,
                client_id INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """,
        'controle_processus': """
            CREATE TABLE controle_processus (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                processus_id INTEGER,
                nom VARCHAR(200) NOT NULL,
                description TEXT,
                type_controle VARCHAR(100),
                frequence VARCHAR(50),
                responsable_id INTEGER,
                client_id INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """,
        'etapes_plan_action': """
            CREATE TABLE etapes_plan_action (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                plan_action_id INTEGER,
                nom VARCHAR(200) NOT NULL,
                description TEXT,
                statut VARCHAR(50) DEFAULT 'a_faire',
                date_debut DATE,
                date_echeance DATE,
                responsable_id INTEGER,
                client_id INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """,
        'fichiers_metadata': """
            CREATE TABLE fichiers_metadata (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nom_fichier VARCHAR(500) NOT NULL,
                chemin VARCHAR(1000),
                taille INTEGER,
                type_mime VARCHAR(100),
                entite_type VARCHAR(50),
                entite_id INTEGER,
                uploaded_by INTEGER,
                client_id INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """,
        'formules_abonnement': """
            CREATE TABLE formules_abonnement (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nom VARCHAR(100) NOT NULL,
                description TEXT,
                prix_mensuel DECIMAL(10,2),
                prix_annuel DECIMAL(10,2),
                modules TEXT,  -- JSON
                limitations TEXT,  -- JSON
                is_active BOOLEAN DEFAULT 1,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """,
        'historique_modification': """
            CREATE TABLE historique_modification (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                entite_type VARCHAR(50) NOT NULL,
                entite_id INTEGER NOT NULL,
                action VARCHAR(100) NOT NULL,
                anciennes_valeurs TEXT,  -- JSON
                nouvelles_valeurs TEXT,  -- JSON
                utilisateur_id INTEGER,
                client_id INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """,
        'lien_processus': """
            CREATE TABLE lien_processus (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                source_id INTEGER NOT NULL,
                cible_id INTEGER NOT NULL,
                type_lien VARCHAR(50),
                client_id INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """,
        'lignes_organisation': """
            CREATE TABLE lignes_organisation (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nom VARCHAR(200) NOT NULL,
                description TEXT,
                couleur VARCHAR(20),
                ordre INTEGER DEFAULT 0,
                client_id INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """,
        'parametres_evaluation': """
            CREATE TABLE parametres_evaluation (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nom VARCHAR(200) NOT NULL,
                valeur TEXT,
                categorie VARCHAR(100),
                client_id INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """,
        'templates_constatations': """
            CREATE TABLE templates_constatations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nom VARCHAR(200) NOT NULL,
                description TEXT,
                categorie VARCHAR(100),
                contenu TEXT,  -- JSON
                is_active BOOLEAN DEFAULT 1,
                client_id INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """,
        'templates_recommandations': """
            CREATE TABLE templates_recommandations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nom VARCHAR(200) NOT NULL,
                description TEXT,
                type_recommandation VARCHAR(100),
                contenu TEXT,  -- JSON
                is_active BOOLEAN DEFAULT 1,
                client_id INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """,
        'titres_organisation': """
            CREATE TABLE titres_organisation (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nom VARCHAR(200) NOT NULL,
                description TEXT,
                niveau INTEGER DEFAULT 1,
                client_id INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """
    }
    
    return create_sqls.get(table_name)


def fix_with_alternative_method(conn, client_id, failed_tables):
    """M√©thode alternative pour corriger les tables probl√©matiques"""
    from sqlalchemy import text
    
    print("üîÑ Application de la m√©thode alternative...")
    
    for table_name, error in failed_tables:
        print(f"\nüîß Traitement alternatif pour '{table_name}'...")
        
        try:
            # 1. V√©rifier si la table a des contraintes qui bloquent l'UPDATE
            # 2. Utiliser une approche transactionnelle plus simple
            
            # D'abord, sauvegarder les IDs des lignes √† mettre √† jour
            get_ids_sql = f"""
                SELECT id FROM {table_name} 
                WHERE client_id IS NULL
                LIMIT 10  # Limiter pour test
            """
            ids_to_update = conn.execute(text(get_ids_sql)).fetchall()
            
            if not ids_to_update:
                print(f"   ‚ÑπÔ∏è Plus de lignes NULL √† mettre √† jour")
                continue
            
            print(f"   üîÑ {len(ids_to_update)} lignes √† mettre √† jour")
            
            # Mettre √† jour par lots
            updated = 0
            for row_id, in ids_to_update:
                try:
                    update_row_sql = f"""
                        UPDATE {table_name} 
                        SET client_id = {client_id}
                        WHERE id = {row_id} AND client_id IS NULL
                    """
                    conn.execute(text(update_row_sql))
                    updated += 1
                    
                    # Commit p√©riodiquement
                    if updated % 10 == 0:
                        conn.commit()
                        
                except Exception as row_error:
                    print(f"   ‚ö†Ô∏è Erreur sur ligne {row_id}: {row_error}")
                    conn.rollback()
                    break
            
            conn.commit()
            print(f"   ‚úÖ {updated} lignes mises √† jour avec succ√®s")
            
        except Exception as e:
            print(f"   ‚ùå √âchec m√©thode alternative: {e}")


@app.cli.command('final-verification')
def final_verification():
    """V√©rification finale du syst√®me multi-tenant"""
    from sqlalchemy import text
    
    print("üîç V√âRIFICATION FINALE DU SYST√àME MULTI-TENANT")
    print("=" * 50)
    
    try:
        with db.engine.connect() as conn:
            # 1. V√©rifier les clients
            print("\n1. üë• CLIENTS")
            clients_sql = """
                SELECT 
                    id, nom, reference, 
                    is_active,
                    (SELECT COUNT(*) FROM user WHERE client_id = clients.id) as users,
                    (SELECT COUNT(*) FROM risques WHERE client_id = clients.id) as risques,
                    (SELECT COUNT(*) FROM audits WHERE client_id = clients.id) as audits
                FROM clients
                ORDER BY id
            """
            clients = conn.execute(text(clients_sql)).fetchall()
            
            print(f"   üìä {len(clients)} client(s) trouv√©(s):")
            for client in clients:
                status = "‚úÖ ACTIF" if client.is_active else "‚ùå INACTIF"
                print(f"   ‚Ä¢ {client.nom} ({client.reference})")
                print(f"     ID: {client.id} | {status}")
                print(f"     üìà Stats: {client.users} users, {client.risques} risques, {client.audits} audits")
            
            # 2. V√©rifier les donn√©es orphelines
            print("\n2. üîç DONN√âES ORPHELINES (sans client_id)")
            
            critical_tables = [
                'user', 'risques', 'audits', 'recommandations',
                'plans_action', 'constatations', 'journal_activites',
                'notifications', 'direction', 'service', 'kri'
            ]
            
            orphan_tables = []
            for table in critical_tables:
                sql = f"""
                    SELECT COUNT(*) as count
                    FROM {table}
                    WHERE client_id IS NULL
                """
                result = conn.execute(text(sql)).scalar()
                if result and result > 0:
                    orphan_tables.append((table, result))
            
            if orphan_tables:
                print("   ‚ùå PROBL√àME: Donn√©es orphelines trouv√©es:")
                for table, count in orphan_tables:
                    print(f"      ‚Ä¢ {table}: {count} lignes")
            else:
                print("   ‚úÖ AUCUNE donn√©e orpheline trouv√©e !")
            
            # 3. Statistiques globales
            print("\n3. üìà STATISTIQUES GLOBALES")
            
            stats_sql = """
                SELECT 
                    (SELECT COUNT(*) FROM user) as total_users,
                    (SELECT COUNT(*) FROM risques) as total_risques,
                    (SELECT COUNT(*) FROM audits) as total_audits,
                    (SELECT COUNT(*) FROM recommandations) as total_recommandations,
                    (SELECT COUNT(*) FROM journal_activites) as total_activites,
                    (SELECT COUNT(*) FROM notifications) as total_notifications
            """
            stats = conn.execute(text(stats_sql)).fetchone()
            
            print(f"   üë• Utilisateurs: {stats.total_users}")
            print(f"   ‚ö†Ô∏è  Risques: {stats.total_risques}")
            print(f"   üîç Audits: {stats.total_audits}")
            print(f"   üí° Recommandations: {stats.total_recommandations}")
            print(f"   üìù Activit√©s journalis√©es: {stats.total_activites}")
            print(f"   üîî Notifications: {stats.total_notifications}")
            
            # 4. V√©rifier la r√©partition par client
            print("\n4. üìä R√âPARTITION PAR CLIENT")
            
            for client in clients:
                print(f"\n   üìã Client: {client.nom} (ID: {client.id})")
                
                # Tables principales
                tables_to_check = [
                    ('user', 'Utilisateurs'),
                    ('risques', 'Risques'),
                    ('audits', 'Audits'),
                    ('recommandations', 'Recommandations'),
                    ('journal_activites', 'Activit√©s'),
                    ('notifications', 'Notifications')
                ]
                
                for table, label in tables_to_check:
                    count_sql = f"SELECT COUNT(*) FROM {table} WHERE client_id = {client.id}"
                    count = conn.execute(text(count_sql)).scalar()
                    print(f"      ‚Ä¢ {label}: {count}")
            
            print("\n" + "=" * 50)
            print("‚úÖ V√âRIFICATION TERMIN√âE AVEC SUCC√àS !")
            print("=" * 50)
            
    except Exception as e:
        print(f"‚ùå Erreur: {e}")
        import traceback
        traceback.print_exc()

@app.cli.command('fix-sqlalchemy-mapper')
def fix_sqlalchemy_mapper():
    """Corrige l'erreur Mapper de SQLAlchemy"""
    from sqlalchemy.orm import configure_mappers
    from sqlalchemy import inspect
    import traceback
    
    print("üîß Correction de l'erreur Mapper SQLAlchemy...")
    
    try:
        # 1. R√©initialiser compl√®tement
        print("üîÑ R√©initialisation de SQLAlchemy...")
        db.session.remove()
        db.session.close_all()
        
        # 2. Forcer la configuration des mappers
        print("üîß Configuration des mappers...")
        configure_mappers()
        
        # 3. V√©rifier les mappers probl√©matiques
        print("üîç V√©rification des mappers...")
        problematic = []
        
        # Liste de tous vos mod√®les
        from app import models  # Importez votre module models
        
        # V√©rifier chaque mod√®le
        model_classes = [
            User, Client, Notification, JournalActivite, JournalActiviteClient,
            Recommandation, Direction, Service, Risque, Audit, KRI,
            # Ajoutez tous vos autres mod√®les ici
        ]
        
        for model_class in model_classes:
            try:
                inspect(model_class)
                print(f"   ‚úÖ {model_class.__name__}: OK")
            except Exception as e:
                problematic.append((model_class.__name__, str(e)))
                print(f"   ‚ùå {model_class.__name__}: {e}")
        
        if problematic:
            print(f"\n‚ö†Ô∏è  {len(problematic)} mod√®les probl√©matiques:")
            for model_name, error in problematic:
                print(f"   ‚Ä¢ {model_name}: {error}")
            
            # Suggestions de correction
            print("\nüîß Suggestions de correction:")
            print("   1. V√©rifier les relations circulaires")
            print("   2. V√©rifier les imports circulaires")
            print("   3. Red√©marrer l'application")
        else:
            print("\n‚úÖ Tous les mappers sont correctement configur√©s")
        
        return problematic
        
    except Exception as e:
        print(f"‚ùå Erreur: {e}")
        traceback.print_exc()
        return []


@app.route('/risque/<int:id>/nouvelle-campagne', methods=['GET', 'POST'])
@login_required
def nouvelle_campagne_evaluation(id):
    """D√©marrer une nouvelle campagne d'√©valuation"""
    risque = Risque.query.get_or_404(id)
    
    # Cr√©er un formulaire simple pour la nouvelle campagne
    from flask_wtf import FlaskForm
    from wtforms import StringField, DateField, TextAreaField, SubmitField
    from wtforms.validators import DataRequired
    
    class NouvelleCampagneForm(FlaskForm):
        campagne_nom = StringField('Nom de la campagne', validators=[DataRequired()])
        campagne_date_debut = DateField('Date de d√©but', format='%Y-%m-%d')
        campagne_date_fin = DateField('Date de fin (optionnel)', format='%Y-%m-%d')
        campagne_objectif = TextAreaField('Objectif (optionnel)')
        submit = SubmitField('Cr√©er la campagne')
    
    form = NouvelleCampagneForm()
    
    if request.method == 'POST':
        # Cr√©er une nouvelle √©valuation
        evaluation = EvaluationRisque(
            risque_id=id,
            campagne_nom=request.form.get('campagne_nom', ''),
            statut_validation='en_attente',
            created_by=current_user.id
        )
        
        # Si une date de d√©but est fournie
        if request.form.get('campagne_date_debut'):
            evaluation.campagne_date_debut = datetime.strptime(
                request.form.get('campagne_date_debut'), 
                '%Y-%m-%d'
            ).date()
        
        # Si une date de fin est fournie
        if request.form.get('campagne_date_fin'):
            evaluation.campagne_date_fin = datetime.strptime(
                request.form.get('campagne_date_fin'), 
                '%Y-%m-%d'
            ).date()
        
        # Objectif
        evaluation.campagne_objectif = request.form.get('campagne_objectif', '')
        
        db.session.add(evaluation)
        db.session.commit()
        
        flash('‚úÖ Nouvelle campagne d\'√©valuation cr√©√©e', 'success')
        return redirect(url_for('evaluer_risque_triphase', id=id))
    
    return render_template('cartographie/nouvelle_campagne.html', 
                         risque=risque, 
                         form=form)  # AJOUTER form ici

# ------------------------------------------------------------
# Route : Nouvelle √©valuation
# ------------------------------------------------------------
@app.route('/api/kri/synchroniser', methods=['POST'])
@login_required
def synchroniser_kri_manuel():
    """Synchronisation manuelle des KRI"""
    try:
        from utils import synchroniser_kri_automatique
        success = synchroniser_kri_automatique()
        
        if success:
            return jsonify({
                'success': True,
                'message': 'KRI synchronis√©s avec succ√®s',
                'timestamp': datetime.utcnow().isoformat()
            })
        else:
            return jsonify({
                'success': False,
                'error': 'Erreur lors de la synchronisation'
            }), 500
            
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500
    
@app.route('/api/risque/<int:risque_id>/kri')
@login_required
def api_kri_risque(risque_id):
    """API pour r√©cup√©rer les KRI d'un risque sp√©cifique"""
    try:
        risque = Risque.query.get_or_404(risque_id)
        kri = KRI.query.filter_by(risque_id=risque_id).first()
        
        if kri:
            # R√©cup√©rer les derni√®res mesures
            derniere_mesure = MesureKRI.query.filter_by(kri_id=kri.id).order_by(MesureKRI.date_mesure.desc()).first()
            
            kri_data = {
                'existe': True,
                'id': kri.id,
                'nom': kri.nom,
                'description': kri.description,
                'unite_mesure': kri.unite_mesure,
                'frequence_mesure': kri.frequence_mesure,
                'seuil_alerte': kri.seuil_alerte,
                'seuil_critique': kri.seuil_critique,
                'responsable_mesure': kri.responsable_mesure.username if kri.responsable_mesure else None,
                'est_actif': kri.est_actif,
                'derniere_mesure': {
                    'valeur': derniere_mesure.valeur if derniere_mesure else None,
                    'date_mesure': derniere_mesure.date_mesure.isoformat() if derniere_mesure else None,
                    'commentaire': derniere_mesure.commentaire if derniere_mesure else None
                } if derniere_mesure else None,
                'tendance': calculer_tendance_kri(kri.mesures) if kri.mesures else 'stable'
            }
        else:
            kri_data = {
                'existe': False,
                'message': 'Aucun KRI associ√© √† ce risque'
            }
        
        return jsonify({
            'success': True,
            'risque_reference': risque.reference,
            'kri': kri_data
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/risque/<int:id>/nouvelle-evaluation', methods=['POST'])
@login_required
@csrf.exempt
def nouvelle_evaluation_risque(id):
    """D√©marrer une nouvelle √©valuation bas√©e sur une √©valuation existante"""
    risque = Risque.query.get_or_404(id)
    evaluation_id = request.form.get('evaluation_id')
    
    try:
        # Si une √©valuation sp√©cifique est fournie, la dupliquer
        if evaluation_id:
            evaluation_source = EvaluationRisque.query.get_or_404(evaluation_id)
            
            # Cr√©er une nouvelle √©valuation bas√©e sur l'existante
            nouvelle_evaluation = EvaluationRisque(
                risque_id=id,
                referent_pre_evaluation_id=evaluation_source.referent_pre_evaluation_id,
                impact_pre=evaluation_source.impact_pre,
                probabilite_pre=evaluation_source.probabilite_pre,
                niveau_maitrise_pre=evaluation_source.niveau_maitrise_pre,
                commentaire_pre_evaluation=evaluation_source.commentaire_pre_evaluation,
                score_risque=evaluation_source.score_risque,
                niveau_risque=evaluation_source.niveau_risque,
                statut_validation='en_attente',
                created_by=current_user.id
            )
            
            db.session.add(nouvelle_evaluation)
            db.session.flush()
            
            # ==================== NOTIFICATION ====================
            notification = Notification(
                destinataire_id=current_user.id,
                type_notification=Notification.TYPE_RISQUE_EVALUE,
                titre=f"Nouvelle √©valuation d√©marr√©e pour {risque.reference}",
                message=f"Une nouvelle √©valuation a √©t√© cr√©√©e √† partir d'une √©valuation pr√©c√©dente pour le risque '{risque.intitule}'.",
                urgence=Notification.URGENCE_NORMAL,
                entite_type='risque',
                entite_id=risque.id,
                donnees_supplementaires={
                    'evaluation_source_id': evaluation_id,
                    'score_risque': nouvelle_evaluation.score_risque,
                    'niveau_risque': nouvelle_evaluation.niveau_risque
                }
            )
            db.session.add(notification)
            # ======================================================
            
            db.session.commit()
            
            flash('üîÑ Nouvelle √©valuation cr√©√©e √† partir de l\'historique', 'success')
        else:
            # Cr√©er une √©valuation vierge
            nouvelle_evaluation = EvaluationRisque(
                risque_id=id,
                type_evaluation='pre_evaluation',
                statut_validation='en_attente',
                created_by=current_user.id
            )
            
            db.session.add(nouvelle_evaluation)
            db.session.flush()
            
            # ==================== NOTIFICATION ====================
            notification = Notification(
                destinataire_id=current_user.id,
                type_notification=Notification.TYPE_RISQUE_EVALUE,
                titre=f"Nouvelle √©valuation d√©marr√©e pour {risque.reference}",
                message=f"Une nouvelle √©valuation vierge a √©t√© cr√©√©e pour le risque '{risque.intitule}'.",
                urgence=Notification.URGENCE_NORMAL,
                entite_type='risque',
                entite_id=risque.id
            )
            db.session.add(notification)
            # ======================================================
            
            db.session.commit()
            
            flash('üÜï Nouvelle √©valuation d√©marr√©e avec succ√®s', 'success')
        
        return redirect(url_for('evaluer_risque_triphase', id=id))
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur lors du d√©marrage de la nouvelle √©valuation: {str(e)}', 'error')
        return redirect(url_for('detail_risque', id=id))


@app.route('/kri/ajouter-mesure/<int:kri_id>', methods=['POST'])
@login_required
def ajouter_mesure_kri(kri_id):
    kri = KRI.query.get_or_404(kri_id)
    
    mesure = MesureKRI(
        kri_id=kri_id,
        valeur=float(request.form['valeur']),
        date_mesure=datetime.now(),
        commentaire=request.form.get('commentaire', ''),
        created_by=current_user.id
    )
    
    db.session.add(mesure)
    db.session.commit()
    flash('Mesure ajout√©e avec succ√®s', 'success')
    return redirect(url_for('liste_kri'))

@app.route('/api/processus/<int:processus_id>/etat-synchronisation')
@login_required
def api_etat_synchronisation_complet(processus_id):
    """API pour v√©rifier l'√©tat de synchronisation - VERSION CORRIG√âE"""
    try:
        processus = Processus.query.get_or_404(processus_id)
        
        # Compter les √©tapes sans position
        etapes_sans_position = EtapeProcessus.query.filter_by(
            processus_id=processus_id
        ).filter(
            (EtapeProcessus.position_x == None) | (EtapeProcessus.position_y == None)
        ).count()
        
        total_etapes = EtapeProcessus.query.filter_by(processus_id=processus_id).count()
        total_liens = LienProcessus.query.filter_by(processus_id=processus_id).count()
        
        # Statistiques compl√®tes
        stats = {
            'processus_id': processus_id,
            'nom_processus': processus.nom,
            'total_etapes': total_etapes,
            'total_liens': total_liens,
            'etapes_sans_position': etapes_sans_position,
            'est_synchronise': etapes_sans_position == 0 and total_etapes > 0,
            'derniere_sync': processus.derniere_sync_organigramme.isoformat() if processus.derniere_sync_organigramme else None
        }
        
        return jsonify(stats)
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500




# ============================================================================
# FILTRES JINJA2 PERSONNALIS√âS
# ============================================================================

@app.template_filter('timesince')
def timesince_filter(dt, default="√† l'instant"):
    """
    Retourne une cha√Æne repr√©sentant le temps √©coul√© depuis la date donn√©e.
    """
    if dt is None:
        return default
    
    now = datetime.utcnow()
    diff = now - dt
    
    seconds = diff.total_seconds()
    days = diff.days
    months = int(days / 30)
    years = int(days / 365)

    if years > 0:
        return f"il y a {years} an{'s' if years > 1 else ''}"
    elif months > 0:
        return f"il y a {months} mois"
    elif days > 0:
        return f"il y a {days} jour{'s' if days > 1 else ''}"
    elif seconds < 60:
        return "√† l'instant"
    elif seconds < 3600:
        minutes = int(seconds / 60)
        return f"il y a {minutes} minute{'s' if minutes > 1 else ''}"
    elif seconds < 86400:
        hours = int(seconds / 3600)
        return f"il y a {hours} heure{'s' if hours > 1 else ''}"
    else:
        return dt.strftime('%d/%m/%Y')

@app.template_filter('max')
def max_filter(sequence, attribute=None):
    """
    Retourne l'√©l√©ment maximum d'une s√©quence selon un attribut.
    """
    if not sequence:
        return None
    if attribute:
        return max(sequence, key=lambda x: getattr(x, attribute, 0))
    return max(sequence)

@app.template_filter('min')
def min_filter(sequence, attribute=None):
    """
    Retourne l'√©l√©ment minimum d'une s√©quence selon un attribut.
    """
    if not sequence:
        return None
    if attribute:
        return min(sequence, key=lambda x: getattr(x, attribute, 0))
    return min(sequence)

@app.route('/admin/migrate-permissions', methods=['GET'])
@login_required
@admin_required
def migrate_permissions():
    """Migrer les permissions des utilisateurs existants"""
    try:
        users = User.query.all()
        count = 0
        
        for user in users:
            # Initialiser les permissions si elles n'existent pas
            if not user.permissions:
                user.permissions = {}
            
            # Mettre √† jour les nouvelles permissions
            updates = {
                'can_manage_regulatory': user.role in ['super_admin', 'admin'],
                'can_view_departments': user.role in ['super_admin', 'admin', 'manager', 'auditeur', 'utilisateur', 'consultant'],
                'can_manage_departments': user.role in ['super_admin', 'admin'],
                'can_view_users_list': user.role in ['super_admin', 'admin'],
                'can_edit_users': user.role in ['super_admin', 'admin']
            }
            
            # Appliquer les mises √† jour
            for perm, value in updates.items():
                if perm not in user.permissions:
                    user.permissions[perm] = value
                    count += 1
        
        db.session.commit()
        flash(f'‚úÖ {count} permissions migr√©es avec succ√®s pour {len(users)} utilisateurs', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur migration: {str(e)}', 'error')
    
    return redirect(url_for('admin_utilisateurs'))
@app.template_filter('min')
def min_filter(value, min_value=0):
    """
    Retourne la valeur minimum entre la valeur donn√©e et une valeur minimale.
    """
    try:
        return min(float(value), float(min_value))
    except (ValueError, TypeError):
        return value
    
@app.route('/processus/<int:id>')
@login_required
def detail_processus(id):
    """Page de d√©tail centr√©e sur l'organigramme"""
    processus = Processus.query.get_or_404(id)
    users = User.query.all()
    
    # Calcul des statistiques en temps r√©el
    stats_organigramme = calculer_statistiques_organigramme(processus)
    
    return render_template('process/detail.html', 
                         processus=processus, 
                         users=users,
                         stats_organigramme=stats_organigramme)

def calculer_statistiques_organigramme(processus):
    """Calcule les statistiques pour l'organigramme"""
    # Compter les √©tapes avec position
    etapes_avec_position = [e for e in processus.etapes if e.position_x is not None and e.position_y is not None]
    
    # Calculer la compl√©tude
    completude = 0
    if processus.etapes:
        completude = int((len(etapes_avec_position) / len(processus.etapes)) * 100)
    
    # Compter les types d'√©tapes
    types_etapes = {}
    for etape in processus.etapes:
        type_etape = etape.type_etape or 'action'
        if type_etape not in types_etapes:
            types_etapes[type_etape] = 0
        types_etapes[type_etape] += 1
    
    return {
        'total_etapes': len(processus.etapes),
        'total_liens': len(processus.liens),
        'total_zones_risque': len(processus.zones_risque_organigramme),
        'types_etapes': types_etapes,
        'completude': completude,
        'etapes_avec_position': len(etapes_avec_position),
        'etapes_sans_position': len(processus.etapes) - len(etapes_avec_position)
    }


@app.route('/veille/rapport')
@login_required
def rapport_veille():
    """Rapport statistique de la veille"""
    # CORRECTION : Utiliser get_client_filter
    veilles_query = get_client_filter(VeilleReglementaire)\
        .filter_by(is_active=True)
    
    veilles = []
    for veille in veilles_query.all():
        if check_client_access(veille):
            veilles.append(veille)
    
    # CORRECTION : Filtrer les actions
    actions = []
    for veille in veilles:
        for action in veille.actions:
            if check_client_access(action):
                actions.append(action)
    
    # Statistiques
    stats = {
        'total_veilles': len(veilles),
        'veilles_en_vigueur': len([v for v in veilles if v.statut == 'en_vigueur']),
        'veilles_projet': len([v for v in veilles if v.statut == 'projet']),
        'veilles_abroge': len([v for v in veilles if v.statut == 'abroge']),
        'actions_total': len(actions),
        'actions_terminees': len([a for a in actions if a.statut == 'termine']),
        'actions_en_cours': len([a for a in actions if a.statut == 'en_cours']),
        'actions_a_faire': len([a for a in actions if a.statut == 'a_faire']),
        'actions_en_retard': len([a for a in actions if a.date_echeance and a.date_echeance < datetime.now().date() and a.statut != 'termine'])
    }
    
    # Distribution par impact
    impacts = {}
    for veille in veilles:
        if veille.impact_estime:
            impacts[veille.impact_estime] = impacts.get(veille.impact_estime, 0) + 1
    
    # Distribution par type
    types = {}
    for veille in veilles:
        if veille.type_reglementation:
            types[veille.type_reglementation] = types.get(veille.type_reglementation, 0) + 1
    
    return render_template('veille/rapport.html', 
                         stats=stats, 
                         impacts=impacts,
                         types=types,
                         veilles=veilles,
                         datetime=datetime,
                         timedelta=timedelta)

@app.route('/veille')
@login_required
def veille_reglementaire():
    """Page principale de la veille r√©glementaire avec v√©rification de formule"""
    
    # V√©rifier si le client a acc√®s au module "veille"
    if current_user.client and current_user.client.formule:
        formule = current_user.client.formule
        
        # CORRECTION : Utiliser la m√©thode can_access_module()
        if not formule.can_access_module('veille'):
            # Afficher une page d'upgrade
            try:
                # R√©cup√©rer toutes les formules actives
                all_formules = FormuleAbonnement.query.filter(
                    FormuleAbonnement.is_active == True
                ).all()
                
                # Filtrer celles qui ont le module veille
                upgrade_suggestions = []
                for f in all_formules:
                    if f.modules.get('veille', False):
                        upgrade_suggestions.append(f)
                
                # Trier par prix
                upgrade_suggestions.sort(key=lambda x: x.prix_mensuel or 0)
                
                return render_template('errors/formule_restricted.html', 
                                     module_name='Veille R√®glementaire',
                                     current_formule=formule,
                                     upgrade_suggestions=upgrade_suggestions[:3])
                
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur recherche formules upgrade: {e}")
                flash('Ce module n\'est pas inclus dans votre formule actuelle', 'error')
                return redirect(url_for('dashboard'))
    
    # V√©rifier la permission de g√©rer la veille r√®glementaire
    if not current_user.has_permission('can_manage_regulatory'):
        flash('Acc√®s refus√© : permission de g√©rer la veille r√®glementaire requise', 'error')
        return redirect(url_for('dashboard'))
    
    # Utiliser get_client_filter pour le multi-tenant
    veilles = get_client_filter(VeilleReglementaire)\
        .filter_by(is_active=True, is_archived=False)\
        .all()
    
    # V√©rifier l'acc√®s pour chaque veille
    accessible_veilles = []
    for veille in veilles:
        if check_client_access(veille):
            accessible_veilles.append(veille)
    
    # Calculer le nombre de jours restants avant application
    for veille in accessible_veilles:
        if veille.date_application:
            days_left = (veille.date_application - datetime.now().date()).days
            veille.days_until_application = days_left
        else:
            veille.days_until_application = None
    
    # G√©n√©rer rapport avec filtrage par client
    actions = get_client_filter(ActionConformite)\
        .filter_by(is_archived=False)\
        .join(VeilleReglementaire).filter(
        VeilleReglementaire.is_active == True,
        VeilleReglementaire.is_archived == False
    ).all()
    
    # Filtrer les actions accessibles
    accessible_actions = [a for a in actions if check_client_access(a)]
    
    rapport = generer_rapport_conformite(accessible_actions) if 'generer_rapport_conformite' in globals() else {
        'taux_conformite': 0,
        'actions_terminees': 0,
        'actions_en_cours': 0,
        'actions_a_faire': 0,
        'actions_retardees': 0,
        'actions_en_retard': []
    }
    
    # R√©cup√©rer les utilisateurs
    if current_user.role == 'super_admin':
        users = User.query.all()
    else:
        users = get_client_filter(User).all()
    
    return render_template('veille/liste.html', 
                         veilles=accessible_veilles, 
                         rapport=rapport,
                         users=users,
                         datetime=datetime,
                         current_user=current_user)

@app.route('/veille/archives')
@login_required
def veille_archives():
    """Afficher les veilles archiv√©es avec isolation"""
    # CORRECTION : Utiliser get_client_filter
    veilles = get_client_filter(VeilleReglementaire)\
        .filter_by(is_archived=True)\
        .order_by(VeilleReglementaire.updated_at.desc())\
        .all()
    
    # V√©rifier l'acc√®s
    accessible_veilles = [v for v in veilles if check_client_access(v)]
    
    return render_template('veille/archives.html', 
                         veilles=accessible_veilles, 
                         datetime=datetime)

@app.route('/veille/nouvelle', methods=['GET', 'POST'])
@login_required
@check_module_access('veille')  # <-- AJOUTER ICI
def nouvelle_veille():
    """Cr√©er une nouvelle veille r√©glementaire avec isolation"""
    form = VeilleReglementaireForm()
    
    # CORRECTION : R√©cup√©rer les veilles r√©centes du m√™me client
    recent_veilles = get_client_filter(VeilleReglementaire)\
        .filter_by(is_active=True, is_archived=False)\
        .order_by(VeilleReglementaire.created_at.desc())\
        .limit(5).all()
    
    if form.validate_on_submit():
        veille = VeilleReglementaire(
            titre=form.titre.data,
            description=form.description.data,
            reference=form.reference.data,
            type_reglementation=form.type_reglementation.data,
            organisme_emetteur=form.organisme_emetteur.data,
            date_publication=form.date_publication.data,
            date_application=form.date_application.data,
            statut=form.statut.data,
            impact_estime=form.impact_estime.data,
            created_by=current_user.id,
            is_active=True,
            is_archived=False
        )
        
        # CORRECTION : Ajouter automatiquement le client_id
        if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
            veille.client_id = current_user.client_id
        
        db.session.add(veille)
        db.session.commit()
        
        flash('Veille r√©glementaire ajout√©e avec succ√®s', 'success')
        return redirect(url_for('veille_reglementaire'))
    
    return render_template('veille/form.html', 
                         form=form, 
                         recent_veilles=recent_veilles,
                         action='create',
                         datetime=datetime)

@app.route('/veille/modifier/<int:id>', methods=['GET', 'POST'])
@login_required
def modifier_veille(id):
    """Modifier une veille existante avec isolation"""
    veille = VeilleReglementaire.query.get_or_404(id)
    
    # CORRECTION : V√©rifier l'acc√®s
    if not check_client_access(veille):
        flash('Acc√®s non autoris√© √† cette veille', 'error')
        return redirect(url_for('veille_reglementaire'))
    
    form = VeilleReglementaireForm(obj=veille)
    
    if form.validate_on_submit():
        veille.titre = form.titre.data
        veille.description = form.description.data
        veille.reference = form.reference.data
        veille.type_reglementation = form.type_reglementation.data
        veille.organisme_emetteur = form.organisme_emetteur.data
        veille.date_publication = form.date_publication.data
        veille.date_application = form.date_application.data
        veille.statut = form.statut.data
        veille.impact_estime = form.impact_estime.data
        veille.updated_at = datetime.utcnow()
        
        db.session.commit()
        flash('Veille modifi√©e avec succ√®s', 'success')
        return redirect(url_for('veille_reglementaire'))
    
    # CORRECTION : R√©cup√©rer les veilles r√©centes du m√™me client
    recent_veilles = get_client_filter(VeilleReglementaire)\
        .filter_by(is_active=True, is_archived=False)\
        .filter(VeilleReglementaire.id != id)\
        .order_by(VeilleReglementaire.created_at.desc())\
        .limit(5).all()
    
    return render_template('veille/form.html', 
                         form=form, 
                         veille=veille,
                         recent_veilles=recent_veilles,
                         action='edit',
                         datetime=datetime)

@app.route('/veille/archiver/<int:id>')
@login_required
def archiver_veille(id):
    """Archiver une veille avec isolation"""
    veille = VeilleReglementaire.query.get_or_404(id)
    
    # CORRECTION : V√©rifier l'acc√®s
    if not check_client_access(veille):
        flash('Acc√®s non autoris√© √† cette veille', 'error')
        return redirect(url_for('veille_reglementaire'))
    
    veille.is_archived = True
    veille.updated_at = datetime.utcnow()
    db.session.commit()
    flash('Veille archiv√©e avec succ√®s', 'success')
    return redirect(url_for('veille_reglementaire'))

@app.route('/veille/restaurer/<int:id>')
@login_required
def restaurer_veille(id):
    """Restaurer une veille archiv√©e avec isolation"""
    veille = VeilleReglementaire.query.get_or_404(id)
    
    # CORRECTION : V√©rifier l'acc√®s
    if not check_client_access(veille):
        flash('Acc√®s non autoris√© √† cette veille', 'error')
        return redirect(url_for('veille_archives'))
    
    veille.is_archived = False
    veille.updated_at = datetime.utcnow()
    db.session.commit()
    flash('Veille restaur√©e avec succ√®s', 'success')
    return redirect(url_for('veille_archives'))

@app.route('/veille/desactiver/<int:id>')
@login_required
def desactiver_veille(id):
    """D√©sactiver une veille avec isolation"""
    veille = VeilleReglementaire.query.get_or_404(id)
    
    # CORRECTION : V√©rifier l'acc√®s
    if not check_client_access(veille):
        flash('Acc√®s non autoris√© √† cette veille', 'error')
        return redirect(url_for('veille_reglementaire'))
    
    veille.is_active = False
    veille.updated_at = datetime.utcnow()
    db.session.commit()
    flash('Veille d√©sactiv√©e avec succ√®s', 'success')
    return redirect(url_for('veille_reglementaire'))

@app.route('/veille/activer/<int:id>')
@login_required
def activer_veille(id):
    """Activer une veille d√©sactiv√©e avec isolation"""
    veille = VeilleReglementaire.query.get_or_404(id)
    
    # CORRECTION : V√©rifier l'acc√®s
    if not check_client_access(veille):
        flash('Acc√®s non autoris√© √† cette veille', 'error')
        return redirect(url_for('veille_reglementaire'))
    
    veille.is_active = True
    veille.updated_at = datetime.utcnow()
    db.session.commit()
    flash('Veille activ√©e avec succ√®s', 'success')
    return redirect(url_for('veille_reglementaire'))

# Dans app.py, apr√®s la cr√©ation de l'app
@app.template_filter('add_days')
def add_days_filter(date, days):
    """Ajouter des jours √† une date dans les templates"""
    if not date:
        return None
    return date + timedelta(days=days)

@app.template_filter('days_until')
def days_until_filter(date):
    """Nombre de jours jusqu'√† une date"""
    if not date:
        return None
    return (date - datetime.now().date()).days

@app.route('/veille/supprimer/<int:id>')
@login_required
def supprimer_veille(id):
    """Supprimer d√©finitivement une veille avec isolation"""
    veille = VeilleReglementaire.query.get_or_404(id)
    
    # CORRECTION : V√©rifier l'acc√®s
    if not check_client_access(veille):
        flash('Acc√®s non autoris√© √† cette veille', 'error')
        return redirect(url_for('veille_archives'))
    
    # V√©rifier qu'elle est bien archiv√©e
    if not veille.is_archived:
        flash('Impossible de supprimer une veille non archiv√©e', 'error')
        return redirect(url_for('veille_reglementaire'))
    
    # Supprimer d'abord les documents associ√©s
    for doc in veille.documents:
        # Supprimer le fichier physique
        file_path = os.path.join(app.config['UPLOAD_FOLDER_VEILLE'], doc.nom_fichier)
        if os.path.exists(file_path):
            try:
                os.remove(file_path)
            except OSError:
                pass
        
        # Supprimer l'entr√©e en base
        db.session.delete(doc)
    
    # Supprimer les actions
    for action in veille.actions:
        db.session.delete(action)
    
    # Supprimer la veille
    db.session.delete(veille)
    db.session.commit()
    
    flash('Veille supprim√©e d√©finitivement', 'success')
    return redirect(url_for('veille_archives'))

@app.route('/veille/ajouter-action/<int:veille_id>', methods=['POST'])
@login_required
def ajouter_action_conformite(veille_id):
    """Ajouter une action de conformit√© √† une veille avec isolation"""
    veille = VeilleReglementaire.query.get_or_404(veille_id)
    
    # CORRECTION : V√©rifier l'acc√®s √† la veille
    if not check_client_access(veille):
        flash('Acc√®s non autoris√© √† cette veille', 'error')
        return redirect(url_for('veille_reglementaire'))
    
    try:
        action = ActionConformite(
            veille_id=veille_id,
            description=request.form['description'],
            responsable_id=int(request.form['responsable_id']),
            date_echeance=datetime.strptime(request.form['date_echeance'], '%Y-%m-%d').date(),
            statut='a_faire',
            is_active=True,
            is_archived=False
        )
        
        # CORRECTION : Ajouter automatiquement le client_id
        if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
            action.client_id = current_user.client_id
        
        db.session.add(action)
        db.session.commit()
        flash('Action de conformit√© ajout√©e avec succ√®s', 'success')
    except Exception as e:
        flash(f'Erreur lors de l\'ajout de l\'action: {str(e)}', 'error')
    
    return redirect(url_for('veille_reglementaire'))

@app.route('/veille/action/modifier-statut/<int:action_id>', methods=['POST'])
@login_required
def modifier_statut_action(action_id):
    """Modifier le statut d'une action avec isolation"""
    action = ActionConformite.query.get_or_404(action_id)
    
    # CORRECTION : V√©rifier l'acc√®s √† l'action
    if not check_client_access(action):
        flash('Acc√®s non autoris√© √† cette action', 'error')
        return redirect(url_for('veille_reglementaire'))
    
    nouveau_statut = request.form['statut']
    
    action.statut = nouveau_statut
    if nouveau_statut == 'termine':
        action.date_accomplissement = datetime.utcnow().date()
    action.updated_at = datetime.utcnow()
    
    db.session.commit()
    flash('Statut de l\'action mis √† jour', 'success')
    return redirect(request.referrer or url_for('veille_reglementaire'))

@app.route('/veille/ajouter-document/<int:veille_id>', methods=['POST'])
@login_required
def ajouter_document_veille(veille_id):
    """Ajouter un document √† une veille avec isolation"""
    veille = VeilleReglementaire.query.get_or_404(veille_id)
    
    # CORRECTION : V√©rifier l'acc√®s √† la veille
    if not check_client_access(veille):
        flash('Acc√®s non autoris√© √† cette veille', 'error')
        return redirect(url_for('veille_reglementaire'))
    
    if 'document' not in request.files:
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(request.referrer)
    
    file = request.files['document']
    if file.filename == '':
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(request.referrer)
    
    if file and allowed_file(file.filename):
        try:
            # G√©n√©rer un nom de fichier unique
            filename = secure_filename(file.filename)
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S_%f')
            unique_filename = f"{timestamp}_{filename}"
            
            # Sauvegarder le fichier
            file_path = os.path.join(app.config['UPLOAD_FOLDER_VEILLE'], unique_filename)
            file.save(file_path)
            
            # Cr√©er l'entr√©e dans la base de donn√©es
            document = VeilleDocument(
                veille_id=veille_id,
                nom_fichier=unique_filename,
                nom_original=filename,
                type_fichier=filename.rsplit('.', 1)[1].lower(),
                taille=os.path.getsize(file_path),
                uploaded_by=current_user.id
            )
            
            # CORRECTION : Ajouter automatiquement le client_id
            if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
                document.client_id = current_user.client_id
            
            db.session.add(document)
            db.session.commit()
            flash('Document ajout√© avec succ√®s', 'success')
        except Exception as e:
            flash(f'Erreur lors du t√©l√©versement: {str(e)}', 'error')
    else:
        flash('Type de fichier non autoris√©', 'error')
    
    return redirect(request.referrer)
@app.route('/veille/telecharger-document/<int:doc_id>')
@login_required
def telecharger_document_veille(doc_id):
    """T√©l√©charger un document avec isolation"""
    document = VeilleDocument.query.get_or_404(doc_id)
    
    # CORRECTION : V√©rifier l'acc√®s au document
    if not check_client_access(document):
        flash('Acc√®s non autoris√© √† ce document', 'error')
        return redirect(request.referrer)
    
    file_path = os.path.join(app.config['UPLOAD_FOLDER_VEILLE'], document.nom_fichier)
    
    if os.path.exists(file_path):
        return send_file(file_path, 
                        as_attachment=True, 
                        download_name=document.nom_original)
    else:
        flash('Fichier introuvable', 'error')
        return redirect(request.referrer)

@app.route('/veille/supprimer-document/<int:doc_id>')
@login_required
def supprimer_document_veille(doc_id):
    """Supprimer un document avec isolation"""
    document = VeilleDocument.query.get_or_404(doc_id)
    
    # CORRECTION : V√©rifier l'acc√®s au document
    if not check_client_access(document):
        flash('Acc√®s non autoris√© √† ce document', 'error')
        return redirect(request.referrer)
    
    file_path = os.path.join(app.config['UPLOAD_FOLDER_VEILLE'], document.nom_fichier)
    
    # Supprimer le fichier physique
    if os.path.exists(file_path):
        try:
            os.remove(file_path)
        except OSError:
            pass
    
    # Supprimer l'entr√©e en base
    db.session.delete(document)
    db.session.commit()
    
    flash('Document supprim√© avec succ√®s', 'success')
    return redirect(request.referrer)

@app.route('/veille/calendrier')
@login_required
def calendrier_veille():
    """Calendrier des √©ch√©ances avec isolation"""
    # R√©cup√©rer les √©ch√©ances des 30 prochains jours
    date_debut = datetime.now().date()
    date_fin = date_debut + timedelta(days=30)
    
    # CORRECTION : Utiliser get_client_filter
    actions_query = get_client_filter(ActionConformite)\
        .filter(ActionConformite.date_echeance.between(date_debut, date_fin))
    
    actions = []
    for action in actions_query.all():
        if check_client_access(action):
            actions.append(action)
    
    # CORRECTION : Utiliser get_client_filter
    veilles_query = get_client_filter(VeilleReglementaire)\
        .filter(
            VeilleReglementaire.date_application.between(date_debut, date_fin),
            VeilleReglementaire.is_active == True
        )
    
    veilles = []
    for veille in veilles_query.all():
        if check_client_access(veille):
            veilles.append(veille)
    
    return render_template('veille/calendrier.html', 
                         actions=actions, 
                         veilles=veilles,
                         date_debut=date_debut,
                         date_fin=date_fin,
                         datetime=datetime,
                         timedelta=timedelta)

@app.route('/veille/action/archiver/<int:action_id>')
@login_required
def archiver_action_get(action_id):
    """Archiver une action avec isolation"""
    action = ActionConformite.query.get_or_404(action_id)
    
    # CORRECTION : V√©rifier l'acc√®s
    if not check_client_access(action):
        flash('Acc√®s non autoris√© √† cette action', 'error')
        return redirect(request.referrer or url_for('veille_reglementaire'))
    
    action.is_archived = True
    action.updated_at = datetime.utcnow()
    db.session.commit()
    flash('Action archiv√©e avec succ√®s', 'success')
    return redirect(request.referrer or url_for('veille_reglementaire'))

@app.route('/veille/action/restaurer/<int:action_id>', methods=['GET', 'POST'])
@login_required
def restaurer_action(action_id):
    """Restaurer une action archiv√©e avec isolation"""
    try:
        action = ActionConformite.query.get_or_404(action_id)
        
        # CORRECTION : V√©rifier l'acc√®s
        if not check_client_access(action):
            flash('Acc√®s non autoris√© √† cette action', 'error')
            return redirect(request.referrer or url_for('veille_reglementaire'))
        
        action.is_archived = False
        action.updated_at = datetime.utcnow()
        db.session.commit()
        flash('Action restaur√©e avec succ√®s', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la restauration: {str(e)}', 'error')
    
    return redirect(request.referrer or url_for('veille_reglementaire'))

@app.route('/veille/action/supprimer/<int:action_id>', methods=['GET', 'POST'])
@login_required
def supprimer_action(action_id):
    """Supprimer d√©finitivement une action avec isolation"""
    try:
        action = ActionConformite.query.get_or_404(action_id)
        
        # CORRECTION : V√©rifier l'acc√®s
        if not check_client_access(action):
            flash('Acc√®s non autoris√© √† cette action', 'error')
            return redirect(request.referrer or url_for('veille_reglementaire'))
        
        # V√©rifier qu'elle est bien archiv√©e
        if not action.is_archived:
            flash('Impossible de supprimer une action non archiv√©e', 'error')
            return redirect(request.referrer or url_for('veille_reglementaire'))
        
        db.session.delete(action)
        db.session.commit()
        flash('Action supprim√©e d√©finitivement', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la suppression: {str(e)}', 'error')
    
    return redirect(request.referrer or url_for('veille_reglementaire'))

@app.route('/veille/action/modifier-responsable/<int:action_id>', methods=['POST'])
@login_required
def modifier_responsable_action(action_id):
    """Modifier le responsable d'une action avec isolation"""
    action = ActionConformite.query.get_or_404(action_id)
    
    # CORRECTION : V√©rifier l'acc√®s
    if not check_client_access(action):
        flash('Acc√®s non autoris√© √† cette action', 'error')
        return redirect(request.referrer or url_for('veille_reglementaire'))
    
    nouveau_responsable_id = request.form.get('responsable_id')
    
    if nouveau_responsable_id:
        # CORRECTION : V√©rifier que le nouveau responsable appartient au m√™me client
        if current_user.role != 'super_admin':
            new_responsable = User.query.get(nouveau_responsable_id)
            if not new_responsable or new_responsable.client_id != current_user.client_id:
                flash('Le nouveau responsable doit appartenir au m√™me client', 'error')
                return redirect(request.referrer or url_for('veille_reglementaire'))
        
        action.responsable_id = int(nouveau_responsable_id)
        action.updated_at = datetime.utcnow()
        db.session.commit()
        flash('Responsable modifi√© avec succ√®s', 'success')
    
    return redirect(request.referrer or url_for('veille_reglementaire'))

# Dans votre app.py, mettez √† jour vos routes existantes :

@app.route('/notifications/preferences', methods=['GET', 'POST'])
@login_required
def preferences_notifications():
    """G√©rer les pr√©f√©rences de notifications"""
    from forms import NotificationPreferencesForm
    
    form = NotificationPreferencesForm()
    
    if request.method == 'GET':
        # Utiliser la m√©thode populate_from_user (maintenant corrig√©e)
        try:
            if hasattr(form, 'populate_from_user'):
                form.populate_from_user(current_user)
            else:
                # Fallback si la m√©thode n'existe pas
                prefs = getattr(current_user, 'preferences_notifications', {})
                email_prefs = prefs.get('email', {})
                web_prefs = prefs.get('web', {})
                
                # Remplir les champs email
                for field_name in ['nouvelle_constatation', 'nouvelle_recommandation', 
                                 'nouveau_plan', 'echeance_7j', 'retard', 'validation_requise']:
                    field = getattr(form, f'email_{field_name}', None)
                    if field and field_name in email_prefs:
                        field.data = email_prefs[field_name]
                
                # Remplir la fr√©quence
                if hasattr(form, 'frequence_email'):
                    form.frequence_email.data = prefs.get('frequence_email', 'quotidien')
                    
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur chargement pr√©f√©rences: {e}")
            flash('Erreur lors du chargement des pr√©f√©rences', 'error')
    
    if form.validate_on_submit():
        try:
            # Utiliser la m√©thode save_to_user si disponible
            if hasattr(form, 'save_to_user'):
                form.save_to_user(current_user)
            else:
                # Fallback manuel
                prefs = {
                    'email': {},
                    'web': {},
                    'frequence_email': 'quotidien'
                }
                
                # Sauvegarder les pr√©f√©rences email
                for field_name in ['nouvelle_constatation', 'nouvelle_recommandation',
                                 'nouveau_plan', 'echeance_7j', 'retard', 'validation_requise']:
                    field = getattr(form, f'email_{field_name}', None)
                    if field:
                        prefs['email'][field_name] = field.data
                
                # Sauvegarder la fr√©quence
                if hasattr(form, 'frequence_email'):
                    prefs['frequence_email'] = form.frequence_email.data
                
                current_user.preferences_notifications = prefs
            
            db.session.commit()
            flash('Pr√©f√©rences de notifications sauvegard√©es avec succ√®s', 'success')
            return redirect(url_for('liste_notifications'))
            
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Erreur sauvegarde pr√©f√©rences: {e}")
            flash(f'Erreur lors de la sauvegarde: {str(e)}', 'error')
    
    return render_template('notifications/preferences.html', 
                         form=form,
                         current_user=current_user)

@app.route('/api/notifications/preferences', methods=['GET', 'POST'])
@login_required
def api_preferences_notifications():
    """API pour g√©rer les pr√©f√©rences de notifications"""
    if request.method == 'GET':
        return jsonify(current_user.preferences_notifications)
    
    elif request.method == 'POST':
        data = request.get_json()
        
        try:
            current_user.preferences_notifications = data
            db.session.commit()
            return jsonify({
                'success': True, 
                'message': 'Pr√©f√©rences mises √† jour',
                'preferences': current_user.preferences_notifications
            })
        except Exception as e:
            return jsonify({'success': False, 'error': str(e)}), 400





@app.route('/api/notifications/<int:notification_id>/marquer-lue', methods=['POST'])
@login_required
def api_marquer_notification_lue(notification_id):
    """API pour marquer une notification comme lue"""
    notification = Notification.query.get_or_404(notification_id)
    
    if notification.destinataire_id != current_user.id:
        abort(403)
    
    notification.est_lue = True
    notification.read_at = datetime.utcnow()
    db.session.commit()
    
    return jsonify({'success': True})

@app.route('/api/notifications/marquer-toutes-lues', methods=['POST'])
@login_required
def api_marquer_toutes_lues():
    """API pour marquer toutes les notifications comme lues"""
    Notification.query.filter_by(
        destinataire_id=current_user.id,
        est_lue=False
    ).update({'est_lue': True})
    db.session.commit()
    return jsonify({'success': True})


@app.route('/commentaire/ajouter', methods=['POST'])
@csrf.exempt
@login_required
def ajouter_commentaire():
    """Ajouter un commentaire"""
    form = CommentaireForm()
    
    if form.validate_on_submit():
        type_entite = form.type_entite.data
        entite_id = form.entite_id.data
        
        commentaire = Commentaire(
            contenu=form.contenu.data,
            type_entite=type_entite,
            entite_id=entite_id,
            utilisateur_id=current_user.id
        )
        
        db.session.add(commentaire)
        db.session.commit()
        
        flash('Commentaire ajout√© avec succ√®s', 'success')
    
    # Rediriger vers la page appropri√©e
    referer = request.referrer or url_for('dashboard')
    return redirect(referer)



@app.route('/veille/action/archives')
@login_required
def archives_actions():
    """Afficher les actions archiv√©es"""
    actions = ActionConformite.query.filter_by(is_archived=True)\
        .order_by(ActionConformite.updated_at.desc()).all()
    return render_template('veille/archives_actions.html', actions=actions, datetime=datetime, timedelta=timedelta)

# ========================
# ROUTES POUR LES RAPPORTS CLICABLES
# ========================

@app.route('/veille/rapport/actions-a-faire')
@login_required
def rapport_actions_a_faire():
    """Afficher toutes les actions √† faire"""
    statut = request.args.get('statut', 'a_faire')
    
    # Filtrer par statut et exclure les actions archiv√©es
    actions = ActionConformite.query.filter_by(statut=statut, is_archived=False)\
        .join(VeilleReglementaire).filter(VeilleReglementaire.is_active == True)\
        .order_by(ActionConformite.date_echeance).all()
    
    titre_statut = {
        'a_faire': '√Ä faire',
        'en_cours': 'En cours',
        'termine': 'Termin√©es'
    }.get(statut, 'Actions')
    
    return render_template('veille/rapport_actions_a_faire.html', 
                         actions=actions, 
                         titre_statut=titre_statut,
                         statut_selected=statut,
                         datetime=datetime,
                         timedelta=timedelta)


@app.route('/veille/rapport/veilles-en-vigueur')
@login_required
def rapport_veilles_en_vigueur():
    """Afficher toutes les veilles en vigueur"""
    veilles = VeilleReglementaire.query.filter_by(
        statut='en_vigueur', 
        is_active=True, 
        is_archived=False
    ).order_by(VeilleReglementaire.date_application).all()
    
    return render_template('veille/rapport_veilles_en_vigueur.html', 
                         veilles=veilles, 
                         datetime=datetime,
                         timedelta=timedelta)

@app.route('/veille/rapport/veilles-projets')
@login_required
def rapport_veilles_projets():
    """Afficher toutes les veilles en projet"""
    veilles = VeilleReglementaire.query.filter_by(
        statut='projet', 
        is_active=True, 
        is_archived=False
    ).order_by(VeilleReglementaire.created_at.desc()).all()
    
    return render_template('veille/rapport_veilles_projets.html', 
                         veilles=veilles, 
                         datetime=datetime,
                         timedelta=timedelta)

@app.route('/veille/<int:veille_id>')
@login_required
def detail_veille(veille_id):
    """Page d√©taill√©e d'une veille"""
    veille = VeilleReglementaire.query.get_or_404(veille_id)
    # Filtrer les actions non archiv√©es pour cette veille
    actions_actives = ActionConformite.query.filter_by(
        veille_id=veille_id, 
        is_archived=False
    ).all()
    
    return render_template('veille/detail_veille.html', 
                         veille=veille, 
                         actions_actives=actions_actives,
                         datetime=datetime,
                         timedelta=timedelta)

# ========================
# FONCTION HELPER POUR RAPPORT - CORRIG√âE
# ========================

def generer_rapport_conformite(actions):
    """G√©n√©rer un rapport de conformit√©"""
    # Filtrer uniquement les actions non archiv√©es
    actions_non_archivees = [a for a in actions if not a.is_archived]
    
    actions_terminees = len([a for a in actions_non_archivees if a.statut == 'termine'])
    actions_en_cours = len([a for a in actions_non_archivees if a.statut == 'en_cours'])
    actions_a_faire = len([a for a in actions_non_archivees if a.statut == 'a_faire'])
    actions_retardees = len([a for a in actions_non_archivees if a.date_echeance and a.date_echeance < datetime.now().date() and a.statut != 'termine'])
    
    total_actions = actions_terminees + actions_en_cours + actions_a_faire
    taux_conformite = (actions_terminees / total_actions * 100) if total_actions > 0 else 0
    
    # Calculer les actions en retard avec d√©tails
    actions_en_retard = []
    for action in actions_non_archivees:
        if action.date_echeance and action.date_echeance < datetime.now().date() and action.statut != 'termine':
            jours_retard = (datetime.now().date() - action.date_echeance).days
            actions_en_retard.append({
                'action': action,
                'jours_retard': jours_retard
            })
    
    # Calculer le total pour les barres de progression
    total_progress = actions_terminees + actions_en_cours + actions_retardees
    
    # Calculer les pourcentages pour les barres de progression
    pct_terminees = (actions_terminees / total_progress * 100) if total_progress > 0 else 0
    pct_en_cours = (actions_en_cours / total_progress * 100) if total_progress > 0 else 0
    pct_retardees = (actions_retardees / total_progress * 100) if total_progress > 0 else 0
    
    return {
        'taux_conformite': taux_conformite,
        'actions_terminees': actions_terminees,
        'actions_en_cours': actions_en_cours,
        'actions_a_faire': actions_a_faire,
        'actions_retardees': actions_retardees,
        'actions_en_retard': actions_en_retard,
        'pct_terminees': pct_terminees,  # Ajout√©
        'pct_en_cours': pct_en_cours,    # Ajout√©
        'pct_retardees': pct_retardees,  # Ajout√©
        'total_progress': total_progress  # Ajout√©
    }

@app.route('/api/evaluation/<int:evaluation_id>/details')
@login_required
def api_details_evaluation(evaluation_id):
    """API pour r√©cup√©rer les d√©tails d'une √©valuation sp√©cifique"""
    evaluation = EvaluationRisque.query.get_or_404(evaluation_id)
    
    return jsonify({
        'success': True,
        'impact_pre': evaluation.impact_pre,
        'probabilite_pre': evaluation.probabilite_pre,
        'niveau_maitrise_pre': evaluation.niveau_maitrise_pre,
        'commentaire_pre_evaluation': evaluation.commentaire_pre_evaluation,
        'impact_val': evaluation.impact_val,
        'probabilite_val': evaluation.probabilite_val,
        'statut_validation': evaluation.statut_validation,
        'commentaire_validation': evaluation.commentaire_validation,
        'impact_conf': evaluation.impact_conf,
        'probabilite_conf': evaluation.probabilite_conf,
        'score_risque': evaluation.score_risque,
        'niveau_risque': evaluation.niveau_risque,
        'date_confirmation': evaluation.date_confirmation.isoformat() if evaluation.date_confirmation else None,
        'url_modification': url_for('evaluer_risque_triphase', id=evaluation.risque_id)
    })


# API pour les donn√©es
@app.route('/api/risques/critiques')
@login_required
def api_risques_critiques():
    risques_critiques = []
    for risque in Risque.query.all():
        evaluation = EvaluationRisque.query.filter_by(
            risque_id=risque.id, 
            statut='valide'
        ).order_by(EvaluationRisque.created_at.desc()).first()
        
        if evaluation and evaluation.niveau_risque in ['√âlev√©', 'Critique']:
            risques_critiques.append({
                'id': risque.id,
                'reference': risque.reference,
                'intitule': risque.intitule,
                'niveau_risque': evaluation.niveau_risque,
                'score': evaluation.score_risque
            })
    
    return jsonify(risques_critiques)

# API pour r√©cup√©rer l'√©volution d'un KRI
@app.route('/api/kri/<int:kri_id>/evolution')
@login_required
def api_kri_evolution(kri_id):
    """API pour r√©cup√©rer les donn√©es d'√©volution d'un KRI"""
    try:
        kri = KRI.query.get_or_404(kri_id)
        
        # R√©cup√©rer les mesures tri√©es par date
        mesures = MesureKRI.query.filter_by(kri_id=kri_id)\
            .order_by(MesureKRI.date_mesure.asc())\
            .all()
        
        dates = [mesure.date_mesure.strftime('%Y-%m-%d') for mesure in mesures]
        valeurs = [float(mesure.valeur) for mesure in mesures]
        
        return jsonify({
            'success': True,
            'kri': {
                'id': kri.id,
                'nom': kri.nom,
                'unite_mesure': kri.unite_mesure
            },
            'dates': dates,
            'valeurs': valeurs
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/admin/utilisateurs')
@login_required
def liste_utilisateurs():
    if current_user.role != 'admin':
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    users = User.query.all()
    return render_template('admin/utilisateurs.html', users=users)

@app.route('/admin/utilisateur/creer', methods=['POST'])
@login_required
def creer_utilisateur():
    if current_user.role != 'admin':
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    username = request.form['username']
    email = request.form['email']
    role = request.form['role']
    department = request.form.get('department')
    password = request.form['password']
    confirm_password = request.form['confirm_password']
    
    if password != confirm_password:
        flash('Les mots de passe ne correspondent pas', 'error')
        return redirect(url_for('liste_utilisateurs'))
    
    if User.query.filter_by(username=username).first():
        flash('Ce nom d\'utilisateur existe d√©j√†', 'error')
        return redirect(url_for('liste_utilisateurs'))
    
    user = User(
        username=username,
        email=email,
        role=role,
        department=department
    )
    user.set_password(password)
    
    db.session.add(user)
    db.session.commit()
    flash('Utilisateur cr√©√© avec succ√®s', 'success')
    return redirect(url_for('liste_utilisateurs'))

@app.route('/admin/utilisateur/<int:user_id>/modifier', methods=['POST'])
@login_required
def modifier_utilisateur(user_id):
    if current_user.role != 'admin':
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    user = User.query.get_or_404(user_id)
    user.username = request.form['username']
    user.email = request.form['email']
    user.role = request.form['role']
    user.department = request.form.get('department')
    user.is_active = 'is_active' in request.form
    
    if request.form['password']:
        user.set_password(request.form['password'])
    
    db.session.commit()
    flash('Utilisateur modifi√© avec succ√®s', 'success')
    return redirect(url_for('liste_utilisateurs'))

@app.route('/admin/utilisateur/<int:user_id>/toggle', methods=['POST'])
@login_required
def toggle_user(user_id):
    if current_user.role != 'admin':
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    user = User.query.get_or_404(user_id)
    if user.id == current_user.id:
        flash('Vous ne pouvez pas d√©sactiver votre propre compte', 'error')
        return redirect(url_for('liste_utilisateurs'))
    
    user.is_active = not user.is_active
    db.session.commit()
    
    status = 'activ√©' if user.is_active else 'd√©sactiv√©'
    flash(f'Utilisateur {status} avec succ√®s', 'success')
    return redirect(url_for('liste_utilisateurs'))


# Dans toutes vos routes, assurez-vous d'utiliser les bons noms de tables
@app.route('/admin/directions')
@login_required
def admin_directions():
    """Gestion des directions avec filtrage multi-tenant"""
    # V√©rifier la permission de voir les d√©partements
    if not current_user.has_permission('can_view_departments'):
        flash('Acc√®s refus√© : permission de voir les directions/services requise', 'error')
        return redirect(url_for('dashboard'))
    
    # Utiliser get_client_filter pour le multi-tenant
    if current_user.role == 'super_admin':
        directions = Direction.query.filter_by(is_archived=False, is_active=True).all()
        users = User.query.all()
        total_services = Service.query.filter_by(is_archived=False, is_active=True).count()
        total_cartographies = Cartographie.query.count()
        directions_archivees = Direction.query.filter_by(is_archived=True).count()
    else:
        # Filtrer par client
        directions = get_client_filter(Direction).filter_by(
            is_archived=False, 
            is_active=True
        ).all()
        users = get_client_filter(User).all()
        total_services = get_client_filter(Service).filter_by(
            is_archived=False,
            is_active=True
        ).count()
        total_cartographies = get_client_filter(Cartographie).count()
        directions_archivees = get_client_filter(Direction).filter_by(
            is_archived=True
        ).count()
    
    return render_template('admin/directions.html', 
                         directions=directions, 
                         users=users,
                         total_services=total_services,
                         total_cartographies=total_cartographies,
                         directions_archivees=directions_archivees)

@app.route('/admin/direction/<int:direction_id>/supprimer', methods=['DELETE'])
@login_required
def supprimer_direction(direction_id):
    """Supprimer une direction et ses services (soft delete)"""
    # V√©rifier la permission de g√©rer les d√©partements
    if not current_user.has_permission('can_manage_departments'):
        return jsonify({'success': False, 'error': 'Permission non autoris√©e'}), 403
    
    direction = Direction.query.get_or_404(direction_id)
    
    # V√©rifier l'acc√®s au client
    if not check_client_access(direction):
        return jsonify({'success': False, 'error': 'Acc√®s non autoris√© √† cette direction'}), 403
    
    try:
        # üî¥ CORRECTION: Utiliser ProcessusActivite au lieu de Processus
        has_cartographies = Cartographie.query.filter_by(direction_id=direction_id, is_archived=False).count() > 0
        has_processus = ProcessusActivite.query.filter_by(direction_id=direction_id, is_archived=False).count() > 0
        
        if has_cartographies or has_processus:
            return jsonify({
                'success': False, 
                'error': f'Cette direction est utilis√©e dans {has_cartographies} cartographie(s) et {has_processus} processus. Archivez-la au lieu de la supprimer.'
            }), 400
        
        # Soft delete des services associ√©s
        services = Service.query.filter_by(direction_id=direction_id).all()
        for service in services:
            service.is_active = False
            service.is_archived = True
            service.archived_at = datetime.utcnow()
            service.archived_by = current_user.id
        
        # Soft delete de la direction
        direction.is_active = False
        direction.is_archived = True
        direction.archived_at = datetime.utcnow()
        direction.archived_by = current_user.id
        
        # Journaliser l'action
        log_activity(current_user.id, 'suppression_direction',
                    f"Suppression direction {direction.nom}",
                    'direction', direction.id)
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Direction "{direction.nom}" supprim√©e avec succ√®s'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/admin/service/<int:service_id>/supprimer', methods=['DELETE'])
@login_required
def supprimer_service(service_id):
    """Supprimer un service (soft delete)"""
    # V√©rifier la permission de g√©rer les d√©partements
    if not current_user.has_permission('can_manage_departments'):
        return jsonify({'success': False, 'error': 'Permission non autoris√©e'}), 403
    
    service = Service.query.get_or_404(service_id)
    
    # V√©rifier l'acc√®s au client
    if not check_client_access(service):
        return jsonify({'success': False, 'error': 'Acc√®s non autoris√© √† ce service'}), 403
    
    try:
        # üî¥ CORRECTION: Utiliser ProcessusActivite au lieu de Processus
        has_cartographies = Cartographie.query.filter_by(service_id=service_id, is_archived=False).count() > 0
        has_processus = ProcessusActivite.query.filter_by(service_id=service_id, is_archived=False).count() > 0
        
        if has_cartographies or has_processus:
            return jsonify({
                'success': False, 
                'error': f'Ce service est utilis√© dans {has_cartographies} cartographie(s) et {has_processus} processus. Archivez-le au lieu de le supprimer.'
            }), 400
        
        # Soft delete du service
        service.is_active = False
        service.is_archived = True
        service.archived_at = datetime.utcnow()
        service.archived_by = current_user.id
        
        # Journaliser l'action
        log_activity(current_user.id, 'suppression_service',
                    f"Suppression service {service.nom}",
                    'service', service.id)
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Service "{service.nom}" supprim√© avec succ√®s'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

# ============================================
# ROUTES POUR L'ORGANIGRAMME (√† ajouter dans app.py)
# ============================================


@app.route('/admin/organigramme/png')
@login_required
def admin_organigramme_png():
    """T√©l√©charger l'organigramme en PNG (version simplifi√©e)"""
    
    if not current_user.has_permission('can_export_data'):
        flash('Permission d\'export requise', 'error')
        return redirect(url_for('admin_organigramme'))
    
    flash('Le format PNG n\'est plus support√©. Utilisez le format PDF.', 'info')
    return redirect(url_for('admin_organigramme'))


def generer_organigramme_html(directions, config=None):
    """
    G√©n√®re un organigramme HTML/CSS moderne
    """
    if config:
        if hasattr(config, 'nom_entreprise'):
            nom_entreprise = config.nom_entreprise
            couleur_primaire = config.couleur_primaire
            couleur_secondaire = config.couleur_secondaire
            pied_de_page = config.pied_de_page
            logo = config.logo_entreprise
        else:
            nom_entreprise = config.get('nom_entreprise', 'Entreprise')
            couleur_primaire = config.get('couleur_primaire', '#2563eb')
            couleur_secondaire = config.get('couleur_secondaire', '#10b981')
            pied_de_page = config.get('pied_de_page', 'Document confidentiel')
            logo = config.get('logo_entreprise')
    else:
        nom_entreprise = "Organigramme de l'entreprise"
        couleur_primaire = "#2563eb"
        couleur_secondaire = "#10b981"
        pied_de_page = "Document confidentiel"
        logo = None
    
    # Statistiques
    total_directions = len(directions)
    total_services = sum(len([s for s in d.services if s.is_active]) for d in directions)
    
    html = f"""
    <!DOCTYPE html>
    <html lang="fr">
    <head>
        <meta charset="UTF-8">
        <style>
            :root {{
                --primary: {couleur_primaire};
                --secondary: {couleur_secondaire};
            }}
            body {{
                font-family: Arial, sans-serif;
                margin: 20px;
                padding: 20px;
                background: #f5f5f5;
            }}
            .org-header {{
                background: white;
                padding: 20px;
                border-radius: 10px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                margin-bottom: 20px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }}
            .org-title h1 {{
                color: var(--primary);
                margin: 0;
            }}
            .org-stats {{
                display: flex;
                gap: 20px;
            }}
            .stat-card {{
                background: #f8f9fa;
                padding: 10px 20px;
                border-radius: 5px;
                text-align: center;
            }}
            .stat-number {{
                font-size: 24px;
                font-weight: bold;
                color: var(--primary);
            }}
            .org-grid {{
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 20px;
            }}
            .direction-card {{
                background: white;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                overflow: hidden;
            }}
            .direction-header {{
                background: var(--primary);
                color: white;
                padding: 15px;
            }}
            .direction-header h2 {{
                margin: 0 0 10px 0;
            }}
            .direction-responsable {{
                background: rgba(255,255,255,0.1);
                padding: 10px;
                border-radius: 5px;
            }}
            .direction-body {{
                padding: 15px;
            }}
            .services-list {{
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 10px;
                margin-top: 10px;
            }}
            .service-item {{
                background: #f8f9fa;
                padding: 10px;
                border-left: 3px solid var(--secondary);
            }}
            .service-name {{
                font-weight: bold;
            }}
            .org-footer {{
                text-align: center;
                margin-top: 20px;
                color: #666;
            }}
        </style>
    </head>
    <body>
        <div class="org-header">
            <div style="display: flex; align-items: center;">
                {f'<img src="{logo}" style="max-height: 50px; margin-right: 15px;">' if logo else ''}
                <div class="org-title">
                    <h1>{nom_entreprise}</h1>
                    <p>G√©n√©r√© le {datetime.now().strftime('%d/%m/%Y %H:%M')}</p>
                </div>
            </div>
            <div class="org-stats">
                <div class="stat-card">
                    <div class="stat-number">{total_directions}</div>
                    <div>Directions</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">{total_services}</div>
                    <div>Services</div>
                </div>
            </div>
        </div>
        
        <div class="org-grid">
    """
    
    for direction in directions:
        services_actifs = [s for s in direction.services if s.is_active]
        
        html += f"""
            <div class="direction-card">
                <div class="direction-header">
                    <h2>{direction.nom}</h2>
                    <div class="direction-responsable">
                        <strong>Responsable:</strong> {direction.responsable.username if direction.responsable else 'Non assign√©'}
                    </div>
                </div>
                <div class="direction-body">
                    <p>{direction.description or 'Aucune description'}</p>
                    <h4>Services ({len(services_actifs)})</h4>
                    <div class="services-list">
        """
        
        for service in services_actifs:
            html += f"""
                        <div class="service-item">
                            <div class="service-name">{service.nom}</div>
                            <div class="service-responsable">
                                {service.responsable.username if service.responsable else 'Non assign√©'}
                            </div>
                        </div>
            """
        
        html += """
                    </div>
                </div>
            </div>
        """
    
    html += f"""
        </div>
        
        <div class="org-footer">
            <p>{pied_de_page}</p>
        </div>
    </body>
    </html>
    """
    
    return html

@app.route('/admin/organigramme/pdf')
@login_required
def admin_organigramme_pdf():
    """G√©n√©rer un PDF de l'organigramme"""
    
    # V√©rifier la permission
    if not current_user.has_permission('can_view_departments'):
        flash('Acc√®s refus√©', 'error')
        return redirect(url_for('dashboard'))
    
    # üî¥ √âTAPE 1: R√©cup√©rer la configuration (COMME DANS LA ROUTE WEB)
    config = ConfigurationOrganigramme.query.filter_by(
        client_id=current_user.client_id
    ).first()
    
    # R√©cup√©rer les directions avec filtrage client
    if current_user.role == 'super_admin':
        directions = Direction.query.filter_by(is_archived=False, is_active=True).all()
    else:
        directions = get_client_filter(Direction).filter_by(
            is_archived=False, 
            is_active=True
        ).all()
    
    # Calculer les statistiques
    total_services = 0
    total_responsables = 0
    
    for direction in directions:
        services_actifs = [s for s in direction.services if s.is_active]
        total_services += len(services_actifs)
        for service in services_actifs:
            if service.a_responsable:
                total_responsables += 1
    
    taux_encadrement = round((total_responsables / total_services * 100) if total_services > 0 else 0)
    
    # üî¥ √âTAPE 2: G√©n√©rer le HTML AVEC LA CONFIG
    html = render_template(
        'admin/organigramme_pdf.html',
        directions=directions,
        config=config,  # ‚Üê C'EST √áA QUI √âTAIT MANQUANT !
        total_services=total_services,
        total_responsables=total_responsables,
        taux_encadrement=taux_encadrement,
        date_generation=datetime.now()
    )
    
    # üî¥ √âTAPE 3: S'assurer que les URLs des logos sont absolues
    if config and config.logo_entreprise:
        # Cr√©er l'URL absolue
        logo_url = url_for('serve_upload', filename=config.logo_entreprise, _external=True)
        
        # Remplacer dans le HTML (m√©thode simple mais efficace)
        html = html.replace(
            '{{ url_for(\'serve_upload\', filename=config.logo_entreprise, _external=True) }}',
            logo_url
        ).replace(
            '{{ url_for("serve_upload", filename=config.logo_entreprise, _external=True) }}',
            logo_url
        )
        
        # Aussi remplacer les URLs dans les attributs src
        import re
        html = re.sub(
            r'src="{{ url_for\([^)]+\) }}"',
            f'src="{logo_url}"',
            html
        )
    
    # üî¥ √âTAPE 4: G√©n√©rer le PDF avec WeasyPrint
    try:
        from weasyprint import HTML
        from weasyprint.text.fonts import FontConfiguration
        
        font_config = FontConfiguration()
        
        pdf = HTML(
            string=html, 
            base_url=request.host_url  # Important pour les URLs relatives
        ).write_pdf(font_config=font_config)
        
        response = make_response(pdf)
        response.headers['Content-Type'] = 'application/pdf'
        response.headers['Content-Disposition'] = f'inline; filename=organigramme_{datetime.now().strftime("%Y%m%d")}.pdf'
        
        return response
        
    except Exception as e:
        print(f"‚ùå Erreur g√©n√©ration PDF: {e}")
        import traceback
        traceback.print_exc()
        
        # En cas d'erreur, retourner le HTML pour debug
        return html

@app.route('/admin/service/<int:service_id>/modifier', methods=['GET', 'POST'])
@login_required
def modifier_service(service_id):
    """Modifier un service existant"""
    
    service = Service.query.get_or_404(service_id)
    
    # V√©rifier l'acc√®s
    if not check_client_access(service):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('admin_directions'))
    
    form = ServiceForm(obj=service)
    
    # R√©cup√©rer les directions du client
    directions = get_client_filter(Direction).filter_by(is_active=True, is_archived=False).all()
    form.direction_id.choices = [(0, '--- S√©lectionner ---')] + [(d.id, d.nom) for d in directions]
    
    # R√©cup√©rer les utilisateurs pour le select
    users = get_client_filter(User).filter_by(is_active=True).all()
    form.responsable_id.choices = [(0, '--- S√©lectionner ---')] + [(u.id, u.username) for u in users]
    
    # Pr√©-remplir le formulaire
    if request.method == 'GET':
        form.nom.data = service.nom
        form.description.data = service.description
        form.direction_id.data = service.direction_id
        
        if service.responsable_id:
            form.type_responsable.data = 'utilisateur'
            form.responsable_id.data = service.responsable_id
        elif service.responsable_nom_manuel:
            form.type_responsable.data = 'manuel'
            form.responsable_nom_manuel.data = service.responsable_nom_manuel
        
        if service.equipe_membres:
            form.equipe_membres.data = '\n'.join(service.equipe_membres)
    
    if form.validate_on_submit():
        try:
            service.nom = form.nom.data
            service.description = form.description.data
            service.direction_id = form.direction_id.data
            
            # Gestion du responsable
            if form.type_responsable.data == 'utilisateur' and form.responsable_id.data and form.responsable_id.data != 0:
                service.responsable_id = form.responsable_id.data
                service.responsable_nom_manuel = None
                service.responsable_type = 'utilisateur'
            elif form.type_responsable.data == 'manuel' and form.responsable_nom_manuel.data:
                service.responsable_id = None
                service.responsable_nom_manuel = form.responsable_nom_manuel.data
                service.responsable_type = 'manuel'
            else:
                service.responsable_id = None
                service.responsable_nom_manuel = None
                service.responsable_type = 'utilisateur'
            
            # Gestion des membres de l'√©quipe
            if form.equipe_membres.data:
                membres = [m.strip() for m in form.equipe_membres.data.split('\n') if m.strip()]
                service.equipe_membres = membres
            else:
                service.equipe_membres = []
            
            db.session.commit()
            flash(f'‚úÖ Service "{service.nom}" modifi√© avec succ√®s', 'success')
            return redirect(url_for('admin_directions'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'‚ùå Erreur: {str(e)}', 'error')
    
    return render_template('admin/service_form.html', form=form, service=service)

@app.route('/api/service/<int:service_id>/equipe')
@login_required
def api_service_equipe(service_id):
    """API pour r√©cup√©rer l'√©quipe d'un service"""
    
    try:
        service = Service.query.get_or_404(service_id)
        
        # V√©rifier l'acc√®s
        if not check_client_access(service):
            return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
        
        # R√©cup√©rer l'√©quipe
        equipe = service.equipe_membres if service.equipe_membres else []
        
        return jsonify({
            'success': True,
            'equipe': equipe,
            'service_id': service.id,
            'service_nom': service.nom
        })
        
    except Exception as e:
        print(f"‚ùå Erreur API √©quipe: {e}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/admin/organigramme/exporter/<format>')
@login_required
def admin_organigramme_exporter(format):
    """Exporter l'organigramme dans diff√©rents formats"""
    
    formats_autorises = ['pdf', 'png', 'html']
    if format not in formats_autorises:
        flash('Format non support√©', 'error')
        return redirect(url_for('admin_organigramme'))
    
    # V√©rifier la permission
    if not current_user.has_permission('can_export_data'):
        flash('Permission d\'export requise', 'error')
        return redirect(url_for('admin_organigramme'))
    
    # R√©cup√©rer les donn√©es
    if current_user.role == 'super_admin':
        directions = Direction.query.filter_by(is_archived=False, is_active=True).all()
    else:
        directions = get_client_filter(Direction).filter_by(
            is_archived=False, 
            is_active=True
        ).all()
    
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    
    try:
        if format == 'pdf':
            buffer = generer_organigramme_pdf(directions)
            filename = f"organigramme_{timestamp}.pdf"
            mimetype = 'application/pdf'
        elif format == 'png':
            buffer = generer_organigramme_png(directions)
            filename = f"organigramme_{timestamp}.png"
            mimetype = 'image/png'
        elif format == 'html':
            html_content = generer_organigramme_html(directions)
            buffer = io.BytesIO(html_content.encode('utf-8'))
            filename = f"organigramme_{timestamp}.html"
            mimetype = 'text/html'
        
        if not buffer:
            flash('Erreur lors de la g√©n√©ration', 'error')
            return redirect(url_for('admin_organigramme'))
        
        return send_file(
            buffer,
            as_attachment=True,
            download_name=filename,
            mimetype=mimetype
        )
    except Exception as e:
        print(f"‚ùå Erreur export: {e}")
        flash(f'Erreur: {str(e)}', 'error')
        return redirect(url_for('admin_organigramme'))


@app.route('/api/organigramme/donnees')
@login_required
def api_organigramme_donnees():
    """API pour obtenir les donn√©es de l'organigramme en JSON"""
    
    if current_user.role == 'super_admin':
        directions = Direction.query.filter_by(is_archived=False, is_active=True).all()
    else:
        directions = get_client_filter(Direction).filter_by(
            is_archived=False, 
            is_active=True
        ).all()
    
    data = {
        'directions': [],
        'total_directions': len(directions),
        'total_services': 0
    }
    
    for direction in directions:
        services_actifs = [s for s in direction.services if s.is_active]
        data['total_services'] += len(services_actifs)
        
        dir_data = {
            'id': direction.id,
            'nom': direction.nom,
            'description': direction.description,
            'responsable': {
                'id': direction.responsable.id if direction.responsable else None,
                'nom': direction.responsable.username if direction.responsable else None
            },
            'services': []
        }
        
        for service in services_actifs:
            dir_data['services'].append({
                'id': service.id,
                'nom': service.nom,
                'responsable': {
                    'id': service.responsable.id if service.responsable else None,
                    'nom': service.responsable.username if service.responsable else None
                }
            })
        
        data['directions'].append(dir_data)
    
    return jsonify(data)


# ============================================
# FONCTIONS DE G√âN√âRATION D'ORGANIGRAMME
# ============================================


# ============================================
# FONCTIONS DE G√âN√âRATION D'ORGANIGRAMME
# ============================================

def get_config_organigramme():
    """R√©cup√®re la configuration organigramme du client connect√©"""
    if current_user.role == 'super_admin':
        return {
            'nom_entreprise': 'Egalyx Control',
            'logo_entreprise': None,
            'couleur_primaire': '#2563eb',
            'couleur_secondaire': '#10b981',
            'pied_de_page': 'Document confidentiel - Super Admin'
        }
    
    config = ConfigurationOrganigramme.query.filter_by(
        client_id=current_user.client_id
    ).first()
    
    if not config:
        return {
            'nom_entreprise': current_user.client.nom if current_user.client else "Entreprise",
            'logo_entreprise': None,
            'couleur_primaire': '#2563eb',
            'couleur_secondaire': '#10b981',
            'pied_de_page': 'Document confidentiel'
        }
    
    return {
        'nom_entreprise': config.nom_entreprise,
        'logo_entreprise': config.logo_entreprise,
        'couleur_primaire': config.couleur_primaire,
        'couleur_secondaire': config.couleur_secondaire,
        'pied_de_page': config.pied_de_page
    }


def generer_organigramme_html(directions, config=None):
    """
    G√©n√®re un organigramme HTML/CSS moderne avec la configuration du client
    """
    if config:
        if hasattr(config, 'nom_entreprise'):
            nom_entreprise = config.nom_entreprise
            couleur_primaire = config.couleur_primaire
            couleur_secondaire = config.couleur_secondaire
            pied_de_page = config.pied_de_page
            logo = config.logo_entreprise
        else:
            nom_entreprise = config.get('nom_entreprise', 'Entreprise')
            couleur_primaire = config.get('couleur_primaire', '#2563eb')
            couleur_secondaire = config.get('couleur_secondaire', '#10b981')
            pied_de_page = config.get('pied_de_page', 'Document confidentiel')
            logo = config.get('logo_entreprise')
    else:
        nom_entreprise = "Organigramme de l'entreprise"
        couleur_primaire = "#2563eb"
        couleur_secondaire = "#10b981"
        pied_de_page = "Document confidentiel"
        logo = None
    

def generer_organigramme_html(directions, config=None):
    """
    G√©n√®re un organigramme HTML/CSS moderne avec la configuration du client
    """
    if config:
        nom_entreprise = config.nom_entreprise
        couleur_primaire = config.couleur_primaire
        couleur_secondaire = config.couleur_secondaire
        pied_de_page = config.pied_de_page
        logo = config.logo_entreprise
    else:
        nom_entreprise = "Organigramme de l'entreprise"
        couleur_primaire = "#2563eb"
        couleur_secondaire = "#10b981"
        pied_de_page = "Document confidentiel - Egalyx Control"
        logo = None
    
    # Statistiques
    total_directions = len(directions)
    total_services = sum(len([s for s in d.services if s.is_active]) for d in directions)
    
    html = f"""
    <!DOCTYPE html>
    <html lang="fr">
    <head>
        <meta charset="UTF-8">
        <style>
            :root {{
                --primary: {couleur_primaire};
                --secondary: {couleur_secondaire};
                --light: #f8fafc;
                --dark: #1e293b;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
                --radius: 12px;
            }}
            
            * {{
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }}
            
            body {{
                font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
                background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
                padding: 40px 20px;
                color: var(--dark);
            }}
            
            .org-header {{
                max-width: 1400px;
                margin: 0 auto 30px;
                background: white;
                border-radius: var(--radius);
                box-shadow: var(--shadow);
                padding: 30px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                border-bottom: 4px solid var(--primary);
            }}
            
            .org-logo {{
                max-height: 60px;
                max-width: 200px;
                object-fit: contain;
                margin-right: 20px;
            }}
            
            .org-title h1 {{
                font-size: 2.5em;
                font-weight: 700;
                color: var(--primary);
                margin-bottom: 5px;
            }}
            
            .org-stats {{
                display: flex;
                gap: 20px;
            }}
            
            .stat-card {{
                background: var(--light);
                padding: 15px 25px;
                border-radius: var(--radius);
                text-align: center;
                border: 1px solid #e2e8f0;
            }}
            
            .stat-number {{
                font-size: 2em;
                font-weight: 700;
                color: var(--primary);
            }}
            
            .org-grid {{
                max-width: 1400px;
                margin: 0 auto;
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
                gap: 25px;
            }}
            
            .direction-card {{
                background: white;
                border-radius: var(--radius);
                box-shadow: var(--shadow);
                overflow: hidden;
            }}
            
            .direction-header {{
                background: var(--primary);
                color: white;
                padding: 20px;
            }}
            
            .direction-header h2 {{
                font-size: 1.5em;
                margin-bottom: 10px;
            }}
            
            .direction-responsable {{
                display: flex;
                align-items: center;
                gap: 10px;
                background: rgba(255,255,255,0.1);
                padding: 10px;
                border-radius: 6px;
            }}
            
            .direction-body {{
                padding: 20px;
            }}
            
            .services-list {{
                margin-top: 15px;
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 10px;
            }}
            
            .service-item {{
                background: var(--light);
                padding: 12px;
                border-radius: 6px;
                border-left: 3px solid var(--secondary);
            }}
            
            .service-name {{
                font-weight: 600;
                margin-bottom: 5px;
            }}
            
            .org-footer {{
                max-width: 1400px;
                margin: 30px auto 0;
                text-align: center;
                color: #64748b;
                font-size: 0.9em;
            }}
        </style>
    </head>
    <body>
        <div class="org-header">
            <div style="display: flex; align-items: center;">
                {f'<img src="{logo}" class="org-logo" alt="Logo">' if logo else ''}
                <div class="org-title">
                    <h1>{nom_entreprise}</h1>
                    <p>G√©n√©r√© le {datetime.now().strftime('%d %B %Y √† %H:%M')}</p>
                </div>
            </div>
            <div class="org-stats">
                <div class="stat-card">
                    <div class="stat-number">{total_directions}</div>
                    <div class="stat-label">Directions</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">{total_services}</div>
                    <div class="stat-label">Services</div>
                </div>
            </div>
        </div>
        
        <div class="org-grid">
    """
    
    for direction in directions:
        services_actifs = [s for s in direction.services if s.is_active]
        
        html += f"""
            <div class="direction-card">
                <div class="direction-header">
                    <h2>{direction.nom}</h2>
                    <div class="direction-responsable">
                        <div>üë§</div>
                        <div>
                            <strong>Responsable:</strong> {direction.responsable.username if direction.responsable else 'Non assign√©'}
                        </div>
                    </div>
                </div>
                <div class="direction-body">
                    <p>{direction.description or 'Aucune description'}</p>
                    <h4>Services ({len(services_actifs)})</h4>
                    <div class="services-list">
        """
        
        for service in services_actifs:
            html += f"""
                        <div class="service-item">
                            <div class="service-name">{service.nom}</div>
                            <div class="service-responsable">
                                {service.responsable.username if service.responsable else 'Non assign√©'}
                            </div>
                        </div>
            """
        
        html += """
                    </div>
                </div>
            </div>
        """
    
    html += f"""
        </div>
        
        <div class="org-footer">
            <p>{pied_de_page}</p>
        </div>
    </body>
    </html>
    """
    
    return html


@app.route('/admin/organigramme/config', methods=['GET', 'POST'])
@login_required
def configurer_organigramme():
    """Configurer l'apparence de l'organigramme"""
    
    if not current_user.has_permission('can_manage_settings'):
        flash('Permission refus√©e', 'error')
        return redirect(url_for('admin_organigramme'))
    
    config = ConfigurationOrganigramme.query.filter_by(
        client_id=current_user.client_id
    ).first()
    
    if not config:
        config = ConfigurationOrganigramme(
            client_id=current_user.client_id,
            nom_entreprise=current_user.client.nom if current_user.client else "Mon Entreprise"
        )
        db.session.add(config)
        db.session.commit()
    
    if request.method == 'POST':
        config.nom_entreprise = request.form.get('nom_entreprise')
        config.couleur_primaire = request.form.get('couleur_primaire')
        config.couleur_secondaire = request.form.get('couleur_secondaire')
        config.pied_de_page = request.form.get('pied_de_page')
        
        # ============================================
        # GESTION DU LOGO CORRIG√âE
        # ============================================
        if 'logo' in request.files:
            logo = request.files['logo']
            if logo and logo.filename != '':
                # V√©rifier l'extension
                allowed_extensions = {'png', 'jpg', 'jpeg', 'gif', 'svg'}
                ext = logo.filename.rsplit('.', 1)[1].lower() if '.' in logo.filename else ''
                
                if ext in allowed_extensions:
                    # V√©rifier la taille (max 2 Mo)
                    logo.seek(0, 2)
                    taille = logo.tell()
                    logo.seek(0)
                    
                    if taille <= 2 * 1024 * 1024:  # 2 Mo
                        from werkzeug.utils import secure_filename
                        import os
                        
                        # üìÅ CR√âER LE DOSSIER SP√âCIFIQUE AU CLIENT
                        upload_folder = os.path.join(app.root_path, 'static', 'uploads')
                        client_folder = os.path.join(upload_folder, 'logos', f"client_{current_user.client_id}")
                        os.makedirs(client_folder, exist_ok=True)
                        
                        # Supprimer l'ancien logo s'il existe
                        if config.logo_entreprise:
                            try:
                                # üî¥ CORRECTION: Nettoyer le chemin pour la suppression
                                old_path = config.logo_entreprise
                                if old_path.startswith('uploads/'):
                                    old_path = old_path.replace('uploads/', '', 1)
                                old_full_path = os.path.join(upload_folder, old_path)
                                
                                if os.path.exists(old_full_path):
                                    os.remove(old_full_path)
                                    print(f"üóëÔ∏è Ancien logo supprim√©: {old_full_path}")
                            except Exception as e:
                                print(f"‚ö†Ô∏è Erreur suppression ancien logo: {e}")
                        
                        # G√©n√©rer un nom unique
                        safe_filename = secure_filename(logo.filename)
                        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                        unique_filename = f"logo_{timestamp}_{safe_filename}"
                        
                        # Sauvegarder le fichier
                        filepath = os.path.join(client_folder, unique_filename)
                        logo.save(filepath)
                        
                        # üî¥ CORRECTION: Chemin pour la base de donn√©es (SANS /static/)
                        # Stocker le chemin relatif √† partir de 'static/uploads/'
                        db_path = f"logos/client_{current_user.client_id}/{unique_filename}"
                        
                        # Mettre √† jour la config
                        config.logo_entreprise = db_path
                        config.logo_nom = safe_filename
                        config.logo_taille = taille
                        
                        flash('‚úÖ Logo upload√© avec succ√®s', 'success')
                    else:
                        flash('‚ùå Logo trop volumineux. Maximum 2 Mo.', 'error')
                else:
                    flash('‚ùå Extension non autoris√©e. Utilisez: PNG, JPG, JPEG, GIF, SVG', 'error')
        
        db.session.commit()
        flash('Configuration mise √† jour', 'success')
        return redirect(url_for('admin_organigramme'))
    
    return render_template('admin/config_organigramme.html', config=config)


@app.route('/admin/test-logo')
@login_required
def test_logo():
    """Page de test pour diagnostiquer les probl√®mes de logo"""
    config = ConfigurationOrganigramme.query.filter_by(
        client_id=current_user.client_id
    ).first()
    
    if not config or not config.logo_entreprise:
        return "Aucun logo configur√©"
    
    info = {
        'logo_path_db': config.logo_entreprise,
        'logo_nom': config.logo_nom,
        'full_path': os.path.join(app.root_path, 'static', 'uploads', config.logo_entreprise),
        'exists': os.path.exists(os.path.join(app.root_path, 'static', 'uploads', config.logo_entreprise)),
        'url_for': url_for('serve_upload', filename=config.logo_entreprise, _external=True)
    }
    
    return f"""
    <h1>Diagnostic Logo</h1>
    <pre>{info}</pre>
    <img src="{url_for('serve_upload', filename=config.logo_entreprise)}" style="max-width: 200px;">
    """



@app.route('/admin/organigramme/logo/supprimer', methods=['POST'])
@login_required
def supprimer_logo_organigramme():
    """Supprimer le logo de l'organigramme du client connect√©"""
    
    if not current_user.has_permission('can_manage_settings'):
        return jsonify({'success': False, 'error': 'Permission refus√©e'}), 403
    
    config = ConfigurationOrganigramme.query.filter_by(
        client_id=current_user.client_id
    ).first()
    
    if not config or not config.logo_entreprise:
        return jsonify({'success': False, 'error': 'Aucun logo trouv√©'}), 404
    
    try:
        # Supprimer le fichier physique
        import os
        
        # üî¥ CORRECTION: Construire le chemin correctement
        # Le chemin stock√© est relatif √† 'static/'
        logo_relative_path = config.logo_entreprise
        full_path = os.path.join(app.root_path, 'static', logo_relative_path)
        
        print(f"üîç Tentative de suppression: {full_path}")
        
        if os.path.exists(full_path):
            os.remove(full_path)
            print(f"‚úÖ Fichier supprim√©: {full_path}")
        else:
            print(f"‚ö†Ô∏è Fichier non trouv√©: {full_path}")
        
        # Supprimer les r√©f√©rences en base
        config.logo_entreprise = None
        config.logo_nom = None
        config.logo_taille = None
        config.logo_type = None
        config.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        from utils import log_activity
        log_activity(current_user.id, 'suppression_logo',
                    f"Suppression du logo organigramme",
                    'configuration', config.id)
        
        return jsonify({
            'success': True,
            'message': 'Logo supprim√© avec succ√®s'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur suppression logo: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500



@app.route('/uploads/<path:filename>')
@login_required
def serve_upload(filename):
    """Servir les fichiers upload√©s avec v√©rification d'acc√®s"""
    from flask import send_from_directory
    
    # D√©code l'URL et nettoie le chemin
    from urllib.parse import unquote
    filename = unquote(filename)
    
    # üî¥ CORRECTION: Supprimer 'uploads/' du d√©but si pr√©sent
    if filename.startswith('uploads/'):
        filename = filename.replace('uploads/', '', 1)
    
    # Construction du chemin complet
    upload_folder = os.path.join(app.root_path, 'static', 'uploads')
    
    # V√©rification de s√©curit√©
    safe_path = os.path.normpath(filename)
    if safe_path.startswith('..') or safe_path.startswith('/'):
        abort(403)
    
    # V√©rifier que le fichier appartient au client connect√©
    if not safe_path.startswith(f'logos/client_{current_user.client_id}/'):
        if current_user.role != 'super_admin':
            # V√©rifier si c'est un logo par d√©faut
            if not safe_path.startswith('logos/default/'):
                abort(403)
    
    return send_from_directory(upload_folder, safe_path)


@app.route('/admin/organigramme')
@login_required
def admin_organigramme():
    """Afficher l'organigramme de l'entreprise"""
    
    # V√©rifier la permission
    if not current_user.has_permission('can_view_departments'):
        flash('Acc√®s refus√©', 'error')
        return redirect(url_for('dashboard'))
    
    # R√©cup√©rer la configuration
    config = ConfigurationOrganigramme.query.filter_by(
        client_id=current_user.client_id
    ).first()
    
    # R√©cup√©rer les directions avec filtrage client
    if current_user.role == 'super_admin':
        directions = Direction.query.filter_by(is_archived=False, is_active=True).all()
    else:
        directions = get_client_filter(Direction).filter_by(
            is_archived=False, 
            is_active=True
        ).all()
    
    # Calculer les statistiques
    total_services = 0
    total_responsables = 0
    directions_avec_resp = 0
    responsables_utilisateurs = 0
    responsables_manuels = 0
    total_membres_equipe = 0
    services_avec_equipe = 0
    
    for direction in directions:
        # Compter les directions avec responsable
        if direction.a_responsable:
            directions_avec_resp += 1
            if direction.responsable_id:
                responsables_utilisateurs += 1
            elif direction.responsable_nom_manuel:
                responsables_manuels += 1
        
        # Compter les services
        services_actifs = [s for s in direction.services if s.is_active]
        total_services += len(services_actifs)
        
        for service in services_actifs:
            # Compter les responsables de service
            if service.a_responsable:
                total_responsables += 1
                if service.responsable_id:
                    responsables_utilisateurs += 1
                elif service.responsable_nom_manuel:
                    responsables_manuels += 1
            
            # Compter les √©quipes
            if service.equipe_membres:
                total_membres_equipe += len(service.equipe_membres)
                services_avec_equipe += 1
    
    # Calculer le taux d'encadrement
    taux_encadrement = round((total_responsables / total_services * 100) if total_services > 0 else 0)
    
    # Passer toutes les variables au template
    return render_template(
        'admin/organigramme.html',
        directions=directions,
        config=config,
        total_services=total_services,
        total_responsables=total_responsables,
        directions_avec_resp=directions_avec_resp,
        responsables_utilisateurs=responsables_utilisateurs,
        responsables_manuels=responsables_manuels,
        total_membres_equipe=total_membres_equipe,
        services_avec_equipe=services_avec_equipe,
        taux_encadrement=taux_encadrement,
        now=datetime.now
    )


@app.route('/admin/direction/<int:direction_id>/archiver', methods=['POST'])
@login_required
def archiver_direction(direction_id):
    """Archiver une direction"""
    
    if not current_user.has_permission('can_manage_departments'):
        return jsonify({'success': False, 'error': 'Permission non autoris√©e'}), 403
    
    direction = Direction.query.get_or_404(direction_id)
    
    if not check_client_access(direction):
        return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
    
    try:
        direction.is_archived = True
        direction.archived_at = datetime.utcnow()
        direction.archived_by = current_user.id
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Direction "{direction.nom}" archiv√©e avec succ√®s'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/admin/direction/<int:direction_id>/restaurer', methods=['POST'])
@login_required
def restaurer_direction(direction_id):
    """Restaurer une direction archiv√©e"""
    # V√©rifier la permission de g√©rer les d√©partements
    if not current_user.has_permission('can_manage_departments'):
        return jsonify({'success': False, 'error': 'Permission non autoris√©e'}), 403
    
    direction = Direction.query.get_or_404(direction_id)
    
    # V√©rifier l'acc√®s au client
    if not check_client_access(direction):
        return jsonify({'success': False, 'error': 'Acc√®s non autoris√© √† cette direction'}), 403
    
    try:
        # Restaurer la direction
        direction.is_archived = False
        direction.is_active = True
        direction.archived_at = None
        direction.archived_by = None
        
        # Restaurer les services associ√©s
        services = Service.query.filter_by(direction_id=direction_id).all()
        for service in services:
            service.is_archived = False
            service.is_active = True
            service.archived_at = None
            service.archived_by = None
        
        # Journaliser l'action
        log_activity(current_user.id, 'restauration_direction',
                    f"Restauration direction {direction.nom}",
                    'direction', direction.id)
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Direction "{direction.nom}" restaur√©e avec succ√®s'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/admin/directions/archivees')
@login_required
def admin_directions_archivees():
    """Afficher les directions archiv√©es"""
    # V√©rifier la permission de voir les d√©partements
    if not current_user.has_permission('can_view_departments'):
        flash('Acc√®s refus√© : permission de voir les directions/services requise', 'error')
        return redirect(url_for('dashboard'))
    
    # Utiliser get_client_filter pour le multi-tenant
    if current_user.role == 'super_admin':
        directions_archivees = Direction.query.filter_by(is_archived=True).all()
    else:
        directions_archivees = get_client_filter(Direction).filter_by(
            is_archived=True
        ).all()
    
    return render_template('admin/directions_archivees.html', 
                         directions_archivees=directions_archivees)



@app.route('/admin/direction/nouvelle', methods=['GET', 'POST'])
@login_required
def nouvelle_direction():
    """Cr√©er une nouvelle direction"""
    
    form = DirectionForm()
    
    # R√©cup√©rer les utilisateurs du client pour le select
    users = get_client_filter(User).filter_by(is_active=True).all()
    form.responsable_id.choices = [(0, '--- S√©lectionner ---')] + [(u.id, u.username) for u in users]
    
    if form.validate_on_submit():
        try:
            direction = Direction(
                nom=form.nom.data,
                description=form.description.data,
                client_id=current_user.client_id
            )
            
            # üî¥ CORRECTION: Gestion du responsable avec v√©rification
            if form.type_responsable.data == 'utilisateur':
                if form.responsable_id.data and form.responsable_id.data > 0:
                    direction.responsable_id = form.responsable_id.data
                    direction.responsable_nom_manuel = None
                    direction.responsable_type = 'utilisateur'
                else:
                    direction.responsable_id = None
                    direction.responsable_nom_manuel = None
                    direction.responsable_type = 'utilisateur'
            elif form.type_responsable.data == 'manuel' and form.responsable_nom_manuel.data:
                direction.responsable_id = None
                direction.responsable_nom_manuel = form.responsable_nom_manuel.data
                direction.responsable_type = 'manuel'
            else:
                direction.responsable_id = None
                direction.responsable_nom_manuel = None
                direction.responsable_type = 'utilisateur'
            
            db.session.add(direction)
            db.session.commit()
            
            flash(f'‚úÖ Direction "{direction.nom}" cr√©√©e avec succ√®s', 'success')
            return redirect(url_for('admin_directions'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'‚ùå Erreur: {str(e)}', 'error')
            print(f"Erreur cr√©ation direction: {e}")
    
    return render_template('admin/direction_form.html', form=form, users=users)


@app.route('/admin/service/nouveau', methods=['GET', 'POST'])
@app.route('/admin/service/nouveau/<int:direction_id>', methods=['GET', 'POST'])
@login_required
def nouveau_service(direction_id=None):
    """Cr√©er un nouveau service"""
    
    form = ServiceForm()
    
    # R√©cup√©rer les directions du client
    directions = get_client_filter(Direction).filter_by(is_active=True, is_archived=False).all()
    form.direction_id.choices = [(0, '--- S√©lectionner ---')] + [(d.id, d.nom) for d in directions]
    
    # Si direction_id est fourni, pr√©-s√©lectionner
    if direction_id:
        form.direction_id.data = direction_id
    
    # R√©cup√©rer les utilisateurs pour le select
    users = get_client_filter(User).filter_by(is_active=True).all()
    form.responsable_id.choices = [(0, '--- S√©lectionner ---')] + [(u.id, u.username) for u in users]
    
    if form.validate_on_submit():
        try:
            service = Service(
                nom=form.nom.data,
                description=form.description.data,
                direction_id=form.direction_id.data,
                client_id=current_user.client_id
            )
            
            # Gestion du responsable selon le type
            if form.type_responsable.data == 'utilisateur' and form.responsable_id.data:
                service.responsable_id = form.responsable_id.data
                service.responsable_nom_manuel = None
            elif form.type_responsable.data == 'manuel' and form.responsable_nom_manuel.data:
                service.responsable_id = None
                service.responsable_nom_manuel = form.responsable_nom_manuel.data
            
            # Gestion des membres de l'√©quipe
            if form.equipe_membres.data:
                # Diviser par ligne et nettoyer
                membres = [m.strip() for m in form.equipe_membres.data.split('\n') if m.strip()]
                service.equipe_membres = membres
            else:
                service.equipe_membres = []
            
            db.session.add(service)
            db.session.commit()
            
            flash(f'‚úÖ Service "{service.nom}" cr√©√© avec succ√®s', 'success')
            return redirect(url_for('admin_directions'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'‚ùå Erreur: {str(e)}', 'error')
    
    return render_template('admin/service_form.html', form=form, direction_id=direction_id)

@app.route('/export/evaluations-triphase-excel')
@login_required
def export_evaluations_triphase_excel():
    """Export Excel complet des √©valuations triphas√©es"""
    try:
        import pandas as pd
        from openpyxl import Workbook
        from openpyxl.styles import PatternFill, Font, Alignment, Border, Side
        from openpyxl.utils.dataframe import dataframe_to_rows
        import io
        from datetime import datetime
        
        # Cr√©er un workbook
        wb = Workbook()
        
        # Supprimer la feuille par d√©faut
        wb.remove(wb.active)
        
        # ============================================================================
        # FEUILLE 1 : SYNTH√àSE G√âN√âRALE
        # ============================================================================
        ws_synthese = wb.create_sheet("Synth√®se G√©n√©rale")
        
        # En-t√™te
        ws_synthese.merge_cells('A1:H1')
        ws_synthese['A1'] = "SYNTH√àSE DES √âVALUATIONS TRIPHAS√âES"
        ws_synthese['A1'].font = Font(size=16, bold=True, color="FFFFFF")
        ws_synthese['A1'].fill = PatternFill(start_color="2C3E50", end_color="2C3E50", fill_type="solid")
        ws_synthese['A1'].alignment = Alignment(horizontal='center', vertical='center')
        
        # Date d'export
        ws_synthese['A2'] = f"Export g√©n√©r√© le : {datetime.now().strftime('%d/%m/%Y √† %H:%M')}"
        ws_synthese['A2'].font = Font(italic=True)
        
        # Statistiques globales
        headers_synthese = ['Statistique', 'Valeur', 'D√©tail']
        data_synthese = [
            ['Total des risques √©valu√©s', EvaluationRisque.query.count(), 'Toutes phases confondues'],
            ['√âvaluations en pr√©-√©valuation', EvaluationRisque.query.filter(EvaluationRisque.date_pre_evaluation.isnot(None)).count(), 'Phase 1'],
            ['√âvaluations valid√©es', EvaluationRisque.query.filter(EvaluationRisque.date_validation.isnot(None)).count(), 'Phase 2'],
            ['√âvaluations confirm√©es', EvaluationRisque.query.filter(EvaluationRisque.date_confirmation.isnot(None)).count(), 'Phase 3'],
            ['Risques critiques', EvaluationRisque.query.filter_by(niveau_risque='Critique').count(), 'Score 17-25'],
            ['Risques √©lev√©s', EvaluationRisque.query.filter_by(niveau_risque='√âlev√©').count(), 'Score 11-16'],
            ['Risques moyens', EvaluationRisque.query.filter_by(niveau_risque='Moyen').count(), 'Score 5-10'],
            ['Risques faibles', EvaluationRisque.query.filter_by(niveau_risque='Faible').count(), 'Score 1-4']
        ]
        
        # Ajouter les en-t√™tes
        for col, header in enumerate(headers_synthese, 1):
            cell = ws_synthese.cell(row=4, column=col)
            cell.value = header
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="34495E", end_color="34495E", fill_type="solid")
            cell.alignment = Alignment(horizontal='center')
        
        # Ajouter les donn√©es
        for row, data in enumerate(data_synthese, 5):
            for col, value in enumerate(data, 1):
                cell = ws_synthese.cell(row=row, column=col)
                cell.value = value
                if col == 1:  # Colonne Statistique
                    cell.font = Font(bold=True)
        
        # Ajuster les largeurs de colonnes
        ws_synthese.column_dimensions['A'].width = 30
        ws_synthese.column_dimensions['B'].width = 15
        ws_synthese.column_dimensions['C'].width = 25
        
        # ============================================================================
        # FEUILLE 2 : D√âTAIL DES √âVALUATIONS
        # ============================================================================
        ws_detail = wb.create_sheet("D√©tail √âvaluations")
        
        # R√©cup√©rer toutes les √©valuations avec leurs risques
        evaluations = EvaluationRisque.query.join(Risque).all()
        
        # En-t√™tes d√©taill√©s
        headers_detail = [
            'ID √âvaluation', 'R√©f√©rence Risque', 'Intitul√© Risque', 'Cat√©gorie',
            'Phase 1 - Impact', 'Phase 1 - Probabilit√©', 'Phase 1 - Score', 'Phase 1 - Niveau',
            'Phase 2 - Impact', 'Phase 2 - Probabilit√©', 'Phase 2 - Score', 'Phase 2 - Niveau', 
            'Phase 3 - Impact', 'Phase 3 - Probabilit√©', 'Phase 3 - Score', 'Phase 3 - Niveau',
            'Score Final', 'Niveau Final', 'Statut', 'Date Pr√©-√©val', 'Date Validation', 'Date Confirmation'
        ]
        
        # Ajouter les en-t√™tes
        for col, header in enumerate(headers_detail, 1):
            cell = ws_detail.cell(row=1, column=col)
            cell.value = header
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="2C3E50", end_color="2C3E50", fill_type="solid")
            cell.alignment = Alignment(horizontal='center')
            cell.border = Border(bottom=Side(style='thin'))
        
        # Couleurs pour les niveaux de risque
        couleur_faible = PatternFill(start_color="27AE60", end_color="27AE60", fill_type="solid")  # Vert
        couleur_moyen = PatternFill(start_color="F39C12", end_color="F39C12", fill_type="solid")   # Orange
        couleur_eleve = PatternFill(start_color="E74C3C", end_color="E74C3C", fill_type="solid")   # Rouge
        couleur_critique = PatternFill(start_color="8B0000", end_color="8B0000", fill_type="solid") # Rouge fonc√©
        
        # Remplir les donn√©es
        for row, eval in enumerate(evaluations, 2):
            # Calculer les scores par phase
            impact_pre = eval.impact_pre or 0
            proba_pre = eval.probabilite_pre or 0
            score_pre = impact_pre * proba_pre
            niveau_pre = calculer_niveau_risque(impact_pre, proba_pre)[0] if impact_pre and proba_pre else "Non √©valu√©"
            
            impact_val = eval.impact_val or impact_pre
            proba_val = eval.probabilite_val or proba_pre
            score_val = impact_val * proba_val
            niveau_val = calculer_niveau_risque(impact_val, proba_val)[0] if impact_val and proba_val else niveau_pre
            
            impact_conf = eval.impact_conf or impact_val
            proba_conf = eval.probabilite_conf or proba_val
            score_conf = impact_conf * proba_conf
            niveau_conf = calculer_niveau_risque(impact_conf, proba_conf)[0] if impact_conf and proba_conf else niveau_val
            
            # Score final (priorit√©: confirmation > validation > pr√©-√©valuation)
            score_final = score_conf or score_val or score_pre
            niveau_final = niveau_conf or niveau_val or niveau_pre
            
            data_row = [
                eval.id,
                eval.risque.reference,
                eval.risque.intitule,
                eval.risque.categorie,
                impact_pre,
                proba_pre,
                score_pre,
                niveau_pre,
                eval.impact_val if eval.impact_val else impact_pre,
                eval.probabilite_val if eval.probabilite_val else proba_pre,
                score_val,
                niveau_val,
                eval.impact_conf if eval.impact_conf else impact_val,
                eval.probabilite_conf if eval.probabilite_conf else proba_val,
                score_conf,
                niveau_conf,
                score_final,
                niveau_final,
                eval.statut_validation or 'En cours',
                eval.date_pre_evaluation.strftime('%d/%m/%Y') if eval.date_pre_evaluation else '',
                eval.date_validation.strftime('%d/%m/%Y') if eval.date_validation else '',
                eval.date_confirmation.strftime('%d/%m/%Y') if eval.date_confirmation else ''
            ]
            
            # Ajouter la ligne
            for col, value in enumerate(data_row, 1):
                cell = ws_detail.cell(row=row, column=col)
                cell.value = value
                
                # Appliquer les couleurs pour les colonnes de niveau
                if col in [8, 12, 16, 18]:  # Colonnes de niveau
                    if value == 'Faible':
                        cell.fill = couleur_faible
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif value == 'Moyen':
                        cell.fill = couleur_moyen
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif value == '√âlev√©':
                        cell.fill = couleur_eleve
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif value == 'Critique':
                        cell.fill = couleur_critique
                        cell.font = Font(color="FFFFFF", bold=True)
                
                # Centrer les scores
                if col in [7, 11, 15, 17]:
                    cell.alignment = Alignment(horizontal='center')
        
        # Ajuster les largeurs de colonnes
        column_widths = [12, 15, 30, 15, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 15, 12, 12, 12]
        for col, width in enumerate(column_widths, 1):
            ws_detail.column_dimensions[chr(64 + col)].width = width
        
        # ============================================================================
        # FEUILLE 3 : MATRICE DES RISQUES
        # ============================================================================
        ws_matrice = wb.create_sheet("Matrice des Risques")
        
        # Cr√©er la matrice 5x5
        ws_matrice.merge_cells('A1:F1')
        ws_matrice['A1'] = "MATRICE DES RISQUES - POSITIONNEMENT"
        ws_matrice['A1'].font = Font(size=14, bold=True, color="FFFFFF")
        ws_matrice['A1'].fill = PatternFill(start_color="2C3E50", end_color="2C3E50", fill_type="solid")
        ws_matrice['A1'].alignment = Alignment(horizontal='center')
        
        # En-t√™tes des probabilit√©s
        probabilites = ['', '1 - Tr√®s rare', '2 - Rare', '3 - Possible', '4 - Probable', '5 - Tr√®s probable']
        for col, proba in enumerate(probabilites, 1):
            cell = ws_matrice.cell(row=3, column=col)
            cell.value = proba
            if col > 1:
                cell.font = Font(bold=True)
                cell.alignment = Alignment(horizontal='center')
                cell.fill = PatternFill(start_color="34495E", end_color="34495E", fill_type="solid")
                cell.font = Font(color="FFFFFF")
        
        # Impacts et donn√©es de la matrice
        impacts = [
            ('5 - Critique', 5),
            ('4 - Important', 4),
            ('3 - Mod√©r√©', 3),
            ('2 - Mineur', 2),
            ('1 - N√©gligeable', 1)
        ]
        
        for row, (impact_label, impact_val) in enumerate(impacts, 4):
            # Label d'impact
            cell = ws_matrice.cell(row=row, column=1)
            cell.value = impact_label
            cell.font = Font(bold=True)
            cell.alignment = Alignment(horizontal='right')
            cell.fill = PatternFill(start_color="34495E", end_color="34495E", fill_type="solid")
            cell.font = Font(color="FFFFFF")
            
            # Cases de la matrice
            for col in range(2, 7):  # Colonnes B √† F
                proba_val = col - 1
                score = impact_val * proba_val
                
                cell = ws_matrice.cell(row=row, column=col)
                cell.value = score
                cell.alignment = Alignment(horizontal='center', vertical='center')
                cell.font = Font(bold=True)
                
                # Appliquer la couleur selon le score
                if score <= 4:
                    cell.fill = couleur_faible
                    cell.font = Font(color="FFFFFF", bold=True)
                elif score <= 10:
                    cell.fill = couleur_moyen
                    cell.font = Font(color="FFFFFF", bold=True)
                elif score <= 16:
                    cell.fill = couleur_eleve
                    cell.font = Font(color="FFFFFF", bold=True)
                else:
                    cell.fill = couleur_critique
                    cell.font = Font(color="FFFFFF", bold=True)
        
        # L√©gende
        ws_matrice['A10'] = "L√âGENDE :"
        ws_matrice['A10'].font = Font(bold=True)
        
        legende_data = [
            ('Faible (1-4)', couleur_faible),
            ('Moyen (5-10)', couleur_moyen),
            ('√âlev√© (11-16)', couleur_eleve),
            ('Critique (17-25)', couleur_critique)
        ]
        
        for row, (texte, couleur) in enumerate(legende_data, 11):
            cell = ws_matrice.cell(row=row, column=1)
            cell.value = texte
            cell.fill = couleur
            cell.font = Font(color="FFFFFF", bold=True)
            cell.alignment = Alignment(horizontal='center')
        
        # ============================================================================
        # FEUILLE 4 : TABLEAU DE BORDEAUX
        # ============================================================================
        ws_bordeaux = wb.create_sheet("Tableau de Bordeaux")
        
        ws_bordeaux.merge_cells('A1:D1')
        ws_bordeaux['A1'] = "TABLEAU DE BORDEAUX - CLASSEMENT DES RISQUES"
        ws_bordeaux['A1'].font = Font(size=14, bold=True, color="FFFFFF")
        ws_bordeaux['A1'].fill = PatternFill(start_color="2C3E50", end_color="2C3E50", fill_type="solid")
        ws_bordeaux['A1'].alignment = Alignment(horizontal='center')
        
        # Cat√©gories du tableau de Bordeaux
        categories = [
            ('ACTIONS PRIORITAIRES (Critiques)', couleur_critique),
            ('SURVEILLANCE RENFORC√âE (√âlev√©s)', couleur_eleve),
            ('SURVEILLANCE COURANTE (Moyens)', couleur_moyen),
            ('ACTIONS LIMIT√âES (Faibles)', couleur_faible)
        ]
        
        row_start = 3
        for cat_index, (categorie, couleur) in enumerate(categories):
            # En-t√™te de cat√©gorie
            ws_bordeaux.merge_cells(f'A{row_start}:D{row_start}')
            cell = ws_bordeaux.cell(row=row_start, column=1)
            cell.value = categorie
            cell.fill = couleur
            cell.font = Font(color="FFFFFF", bold=True)
            cell.alignment = Alignment(horizontal='center')
            
            # Sous-en-t√™tes
            headers_bordeaux = ['R√©f√©rence', 'Intitul√©', 'Score', 'Niveau']
            for col, header in enumerate(headers_bordeaux, 1):
                cell = ws_bordeaux.cell(row=row_start + 1, column=col)
                cell.value = header
                cell.font = Font(bold=True)
                cell.fill = PatternFill(start_color="ECF0F1", end_color="ECF0F1", fill_type="solid")
            
            # R√©cup√©rer les risques par niveau
            niveau = categorie.split('(')[1].replace(')', '').strip()
            risques_niveau = EvaluationRisque.query.filter_by(niveau_risque=niveau).join(Risque).all()
            
            # Trier par score d√©croissant
            risques_niveau.sort(key=lambda x: x.score_risque or 0, reverse=True)
            
            # Ajouter les risques
            for risk_index, eval_risk in enumerate(risques_niveau, row_start + 2):
                data_risk = [
                    eval_risk.risque.reference,
                    eval_risk.risque.intitule,
                    eval_risk.score_risque or 0,
                    eval_risk.niveau_risque or 'Non √©valu√©'
                ]
                
                for col, value in enumerate(data_risk, 1):
                    cell = ws_bordeaux.cell(row=risk_index, column=col)
                    cell.value = value
                    
                    # Appliquer la couleur pour la colonne niveau
                    if col == 4:
                        if value == 'Faible':
                            cell.fill = couleur_faible
                            cell.font = Font(color="FFFFFF", bold=True)
                        elif value == 'Moyen':
                            cell.fill = couleur_moyen
                            cell.font = Font(color="FFFFFF", bold=True)
                        elif value == '√âlev√©':
                            cell.fill = couleur_eleve
                            cell.font = Font(color="FFFFFF", bold=True)
                        elif value == 'Critique':
                            cell.fill = couleur_critique
                            cell.font = Font(color="FFFFFF", bold=True)
            
            row_start = risk_index + 3
        
        # Ajuster les largeurs
        ws_bordeaux.column_dimensions['A'].width = 15
        ws_bordeaux.column_dimensions['B'].width = 40
        ws_bordeaux.column_dimensions['C'].width = 10
        ws_bordeaux.column_dimensions['D'].width = 12
        
        # ============================================================================
        # SAUVEGARDE ET RETOUR DU FICHIER
        # ============================================================================
        # Sauvegarder dans un buffer
        buffer = io.BytesIO()
        wb.save(buffer)
        buffer.seek(0)
        
        # Retourner le fichier Excel
        from flask import Response
        return Response(
            buffer.getvalue(),
            mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={
                "Content-Disposition": f"attachment; filename=evaluations_triphase_{datetime.now().strftime('%Y%m%d_%H%M')}.xlsx"
            }
        )
        
    except Exception as e:
        flash(f'Erreur lors de l\'export Excel: {str(e)}', 'error')
        return redirect(url_for('dashboard'))
    




@app.route('/admin/direction/<int:direction_id>/modifier', methods=['POST'])
@login_required
def modifier_direction(direction_id):
    """Modifier une direction"""
    
    direction = Direction.query.get_or_404(direction_id)
    
    # V√©rifier l'acc√®s
    if not check_client_access(direction):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('admin_directions'))
    
    try:
        direction.nom = request.form.get('nom')
        direction.description = request.form.get('description')
        
        # üî¥ CORRECTION: Gestion robuste du responsable
        type_responsable = request.form.get('type_responsable', 'utilisateur')
        
        # R√©initialiser les champs responsable
        direction.responsable_id = None
        direction.responsable_nom_manuel = None
        
        if type_responsable == 'utilisateur':
            responsable_id = request.form.get('responsable_id')
            # V√©rification stricte : doit √™tre un nombre > 0
            if responsable_id and responsable_id.isdigit() and int(responsable_id) > 0:
                direction.responsable_id = int(responsable_id)
                direction.responsable_type = 'utilisateur'
                print(f"‚úÖ Responsable utilisateur assign√©: {responsable_id}")
            else:
                direction.responsable_type = 'utilisateur'
                print(f"‚ÑπÔ∏è Aucun responsable utilisateur s√©lectionn√©")
        else:  # type manuel
            responsable_nom = request.form.get('responsable_nom_manuel')
            if responsable_nom and responsable_nom.strip():
                direction.responsable_nom_manuel = responsable_nom.strip()
                direction.responsable_type = 'manuel'
                print(f"‚úÖ Responsable manuel assign√©: {responsable_nom}")
            else:
                direction.responsable_type = 'utilisateur'
                print(f"‚ÑπÔ∏è Aucun responsable manuel saisi")
        
        db.session.commit()
        flash(f'‚úÖ Direction "{direction.nom}" modifi√©e avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
        print(f"‚ùå Erreur modification direction: {e}")
        import traceback
        traceback.print_exc()
    
    return redirect(url_for('admin_directions'))


# Routes pour les rapports
@app.route('/rapports')
@login_required
def rapports():
    # Statistiques de base
    total_risques = Risque.query.count()
    total_kri = KRI.query.count()
    total_processus = Processus.query.count()
    
    # Risques par cat√©gorie
    risques_par_categorie = db.session.query(
        Risque.categorie, 
        db.func.count(Risque.id)
    ).group_by(Risque.categorie).all()
    
    # √âvaluations r√©centes
    evaluations_recentes = EvaluationRisque.query.filter(
        EvaluationRisque.created_at >= datetime.now() - timedelta(days=30)
    ).count()
    
    # Top risques critiques
    top_risques = []
    for risque in Risque.query.all():
        derniere_eval = EvaluationRisque.query.filter_by(
            risque_id=risque.id, 
            statut='valide'
        ).order_by(EvaluationRisque.created_at.desc()).first()
        
        if derniere_eval and derniere_eval.niveau_risque in ['√âlev√©', 'Critique']:
            top_risques.append({
                'reference': risque.reference,
                'intitule': risque.intitule,
                'score': derniere_eval.score_risque,
                'cartographie_nom': risque.cartographie.nom
            })
    
    # Trier par score d√©croissant et prendre les 5 premiers
    top_risques = sorted(top_risques, key=lambda x: x['score'], reverse=True)[:5]
    
    # G√©n√©rer matrice consolid√©e
    toutes_evaluations = EvaluationRisque.query.filter_by(statut='valide').all()
    matrice_consolidee = generer_matrice_risques(toutes_evaluations)
    
    return render_template('rapports/index.html',
                         total_risques=total_risques,
                         total_kri=total_kri,
                         total_processus=total_processus,
                         risques_par_categorie=risques_par_categorie,
                         evaluations_recentes=evaluations_recentes,
                         top_risques=top_risques,
                         matrice_consolidee=matrice_consolidee,
                         stats_directions=[],
                         taux_couverture_kri=65,
                         delai_moyen_evaluation=7,
                         actions_retardees=2,
                         taux_processus_documentes=80)


@app.route('/risque/<int:id>')
@login_required
def detail_risque(id):
    """Page de d√©tail d'un risque avec champs personnalis√©s"""
    risque = Risque.query.get_or_404(id)
    
    # V√©rifier si le risque est archiv√©
    if risque.is_archived:
        flash('Ce risque est archiv√©', 'warning')
        return redirect(url_for('risques_archives'))
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_risks') or 
            risque.created_by == current_user.id or
            current_user.id in [e.evaluateur_final_id for e in risque.evaluations if e.evaluateur_final_id] or
            current_user.id in [e.validateur_id for e in risque.evaluations if e.validateur_id]):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    # ========== INT√âGRATION DU PARAM√âTRAGE ==========
    
    # 1. R√©cup√©rer les champs personnalis√©s avec leur configuration
    champs_personnalises = []
    for champ in risque.champs_personnalises:
        config = ConfigurationChampRisque.query.filter_by(
            nom_technique=champ.nom_technique
        ).first()
        # Ajouter la configuration comme attribut de l'objet champ
        champ.config = config
        champs_personnalises.append(champ)
    
    # 2. R√©cup√©rer les fichiers attach√©s
    fichiers = FichierRisque.query.filter_by(risque_id=id).order_by(FichierRisque.created_at.desc()).all()
    
    # 3. Champs disponibles pour ajout (pour le modal)
    champs_disponibles = ConfigurationChampRisque.query.filter_by(
        est_actif=True
    ).order_by('section', 'ordre_affichage').all()
    
    # Filtrer ceux qui ne sont pas d√©j√† ajout√©s
    champs_deja_ajoutes = [c.nom_technique for c in risque.champs_personnalises]
    champs_disponibles = [c for c in champs_disponibles if c.nom_technique not in champs_deja_ajoutes]
    
    # 4. Configuration fichiers
    config_fichiers = {
        'extensions': list(app.config['ALLOWED_EXTENSIONS']),
        'taille_max_mo': 10,
        'categories': ['document', 'image', 'analyse', 'autre']
    }
    
    # 5. Regrouper les champs par section pour l'affichage
    champs_par_section = {
        'general': [],
        'analyse': [],
        'evaluation': [],
        'documentation': [],
        'personnalise': []
    }
    
    for champ in champs_personnalises:
        if champ.config and champ.config.section in champs_par_section:
            champs_par_section[champ.config.section].append(champ)
        else:
            champs_par_section['personnalise'].append(champ)
    
    # ========== DISPOSITIFS DE MA√éTRISE ==========
    
    try:
        # R√©cup√©rer les dispositifs de ma√Ætrise (non archiv√©s)
        dispositifs = DispositifMaitrise.query\
            .filter_by(risque_id=id, is_archived=False)\
            .order_by(DispositifMaitrise.reference.asc())\
            .all()
    except Exception as e:
        # Si la table n'existe pas encore
        print(f"‚ö†Ô∏è Table dispositifs_maitrise non disponible: {e}")
        dispositifs = []
    
    # ========== DONN√âES EXISTANTES ==========
    
    # R√©cup√©rer TOUTES les √©valuations pour l'historique
    toutes_evaluations = EvaluationRisque.query.filter_by(
        risque_id=id
    ).order_by(EvaluationRisque.created_at.desc()).all()
    
    # Filtrer pour n'afficher que les √©valuations significatives :
    # - √âvaluations compl√®tes (termin√©es)
    # - La derni√®re √©valuation en cours (si elle existe)
    evaluations_a_afficher = []
    evaluation_en_cours_id = None
    
    # R√©cup√©rer l'ID de la derni√®re √©valuation (la plus r√©cente)
    derniere_evaluation = toutes_evaluations[0] if toutes_evaluations else None
    if derniere_evaluation:
        evaluation_en_cours_id = derniere_evaluation.id
    
    for evaluation in toutes_evaluations:
        # Inclure toutes les √©valuations termin√©es (Phase 3)
        if evaluation.date_confirmation:
            evaluations_a_afficher.append(evaluation)
        # Inclure aussi l'√©valuation en cours (la plus r√©cente, m√™me si pas termin√©e)
        elif evaluation.id == evaluation_en_cours_id:
            evaluations_a_afficher.append(evaluation)
        # Inclure les √©valuations valid√©es (Phase 2) s'il n'y a pas d'√©valuation en cours
        elif evaluation.date_validation and not evaluation.date_confirmation:
            # V√©rifier si c'est la plus r√©cente de ce type
            evaluations_validees = [e for e in toutes_evaluations 
                                  if e.date_validation and not e.date_confirmation]
            if evaluations_validees and evaluation.id == evaluations_validees[0].id:
                evaluations_a_afficher.append(evaluation)
    
    # √âliminer les doublons (au cas o√π)
    evaluations_a_afficher = list({e.id: e for e in evaluations_a_afficher}.values())
    # Trier par date de cr√©ation d√©croissante
    evaluations_a_afficher.sort(key=lambda x: x.created_at, reverse=True)
    
    # R√©cup√©rer la derni√®re √©valuation pour l'affichage principal
    derniere_evaluation = toutes_evaluations[0] if toutes_evaluations else None
    
    # Variables calcul√©es pour l'affichage de la derni√®re √©valuation
    impact_final = None
    probabilite_final = None
    niveau_maitrise_final = None
    score_final = None
    niveau_risque_final = None
    campagne_info = None
    
    if derniere_evaluation:
        # Calcul des valeurs finales selon la hi√©rarchie triphas√©e
        # Utilisation de la m√©thode get_valeurs_finales() du mod√®le
        valeurs_finales = derniere_evaluation.get_valeurs_finales()
        
        impact_final = valeurs_finales['impact']
        probabilite_final = valeurs_finales['probabilite']
        niveau_maitrise_final = valeurs_finales['niveau_maitrise']
        score_final = valeurs_finales['score']
        niveau_risque_final = valeurs_finales['niveau_risque']
        
        # Informations de campagne
        campagne_info = {
            'nom': derniere_evaluation.campagne_nom,
            'date_debut': derniere_evaluation.campagne_date_debut,
            'date_fin': derniere_evaluation.campagne_date_fin,
            'objectif': derniere_evaluation.campagne_objectif
        }
    
    # R√©cup√©rer les KRI associ√©s s'ils existent (peut √™tre plusieurs)
    kris = KRI.query.filter_by(risque_id=id).order_by(KRI.created_at.desc()).all()
    
    # R√©cup√©rer les listes d√©roulantes pour les cat√©gories et types
    categories_liste = ConfigurationListeDeroulante.query.filter_by(
        nom_technique='categories_risque'
    ).first()
    
    types_risque_liste = ConfigurationListeDeroulante.query.filter_by(
        nom_technique='types_risque'
    ).first()
    
    # ========== CALCULS POUR AFFICHAGE ==========
    
    # Statut de l'√©valuation
    statut_evaluation = 'non_evalue'
    if derniere_evaluation:
        if derniere_evaluation.date_confirmation:
            statut_evaluation = 'termine'
        elif derniere_evaluation.date_validation:
            statut_evaluation = 'valide'
        elif derniere_evaluation.date_pre_evaluation:
            statut_evaluation = 'pre_evalue'
    
    # V√©rifier si l'utilisateur peut modifier l'√©valuation
    peut_modifier_evaluation = False
    if derniere_evaluation:
        peut_modifier_evaluation = (
            current_user.has_permission('can_manage_risks') or
            current_user.id == derniere_evaluation.created_by or
            (derniere_evaluation.referent_pre_evaluation_id and 
             current_user.id == derniere_evaluation.referent_pre_evaluation_id) or
            (derniere_evaluation.validateur_id and 
             current_user.id == derniere_evaluation.validateur_id) or
            (derniere_evaluation.evaluateur_final_id and 
             current_user.id == derniere_evaluation.evaluateur_final_id)
        )
    
    # ========== RENVOI DU TEMPLATE ==========
    
    return render_template('cartographie/risque_detail.html',
                         risque=risque,
                         derniere_evaluation=derniere_evaluation,
                         toutes_evaluations=evaluations_a_afficher,  # Filtr√©es
                         historique_evaluations=evaluations_a_afficher,  # Pour compatibilit√©
                         kris=kris,
                         campagne_info=campagne_info,
                         statut_evaluation=statut_evaluation,
                         peut_modifier_evaluation=peut_modifier_evaluation,
                         
                         # Nouvelles donn√©es pour le param√©trage
                         champs_personnalises=champs_personnalises,
                         champs_par_section=champs_par_section,
                         fichiers=fichiers,
                         champs_disponibles=champs_disponibles,
                         config_fichiers=config_fichiers,
                         categories_liste=categories_liste,
                         types_risque_liste=types_risque_liste,
                         
                         # Variables calcul√©es pour l'√©valuation triphas√©e
                         impact_final=impact_final,
                         probabilite_final=probabilite_final,
                         niveau_maitrise_final=niveau_maitrise_final,
                         score_final=score_final,
                         niveau_risque_final=niveau_risque_final,
                         
                         # NOUVEAU : Dispositifs de ma√Ætrise
                         dispositifs=dispositifs,
                         
                         # Import de datetime pour les calculs dans le template
                         datetime=datetime)

@app.route('/profil/update', methods=['POST'])
@csrf.exempt
@login_required
def update_profil():
    """Mettre √† jour le profil utilisateur"""
    user = current_user
    
    # Mettre √† jour l'email
    if 'email' in request.form:
        user.email = request.form['email'].strip()
    
    # Mettre √† jour le d√©partement
    if 'department' in request.form:
        user.department = request.form['department'].strip()
    
    # Mettre √† jour le mot de passe si fourni
    new_password = request.form.get('new_password', '').strip()
    confirm_password = request.form.get('confirm_password', '').strip()
    
    if new_password:
        if new_password != confirm_password:
            flash('Les mots de passe ne correspondent pas', 'error')
            return redirect(url_for('profil_utilisateur'))
        
        if len(new_password) < 6:
            flash('Le mot de passe doit contenir au moins 6 caract√®res', 'error')
            return redirect(url_for('profil_utilisateur'))
        
        user.set_password(new_password)
        flash('Mot de passe mis √† jour avec succ√®s', 'success')
    
    try:
        db.session.commit()
        flash('Profil mis √† jour avec succ√®s', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la mise √† jour: {str(e)}', 'error')
    
    return redirect(url_for('profil_utilisateur'))

@app.route('/profil', methods=['GET', 'POST'])
@app.route('/profil')
@app.route('/mon-profil')
@login_required
def profil_utilisateur():
    """Page de profil - accessible via /profil ou /mon-profil"""
    # R√©cup√©rer les donn√©es pour les statistiques
    cartographies = Cartographie.query.all()
    kris = KRI.query.all()
    audits = Audit.query.all()
    
    return render_template('utilisateur/profil.html', 
                         user=current_user,
                         cartographies=cartographies,
                         kris=kris,
                         audits=audits)

# Dans la route de suppression
@app.route('/api/logigramme/<int:activite_id>', methods=['DELETE'])
@csrf.exempt
@login_required
def api_supprimer_logigramme(activite_id):
    """API pour supprimer d√©finitivement un logigramme"""
    # Utiliser get_client_filter
    activite = get_client_filter(ProcessusActivite).filter_by(id=activite_id).first_or_404()
    
    # V√âRIFICATION DE PERMISSION
    if not check_client_access(activite):
        return jsonify({'success': False, 'error': 'Non autoris√©'}), 403
    
    # V√©rifier que c'est archiv√©
    if not activite.is_archived:
        return jsonify({'success': False, 'error': 'Seuls les logigrammes archiv√©s peuvent √™tre supprim√©s'}), 400
    
    try:
        # CORRECTION: Utilisez les bons noms de classes
        LienLogigramme.query.filter_by(activite_id=activite_id).delete()
        ElementLogigramme.query.filter_by(activite_id=activite_id).delete()
        
        # Supprimer l'activit√©
        db.session.delete(activite)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Logigramme supprim√© d√©finitivement'
        })
    except Exception as e:
        db.session.rollback()
        print(f"Erreur suppression logigramme: {e}")
        return jsonify({
            'success': False,
            'error': 'Erreur lors de la suppression: ' + str(e)
        }), 500

@app.route('/archives_logigrammes')
@login_required
def archives_logigrammes():
    """Route pour afficher les logigrammes archiv√©s"""
    try:
        print(f"üîç Archives logigrammes - Utilisateur: {current_user.username}")
        
        # V√©rifier la permission
        if not current_user.has_permission('can_manage_logigram'):
            flash('Permission refus√©e', 'error')
            return redirect(url_for('liste_logigrammes'))
        
        # REQU√äTE SIMPLIFI√âE
        query = ProcessusActivite.query
        
        # Filtre client
        if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
            query = query.filter(ProcessusActivite.client_id == current_user.client_id)
        
        # Archiv√©s seulement
        activites_archivees = query.filter_by(is_archived=True)\
                                  .order_by(ProcessusActivite.archived_at.desc()).all()
        
        print(f"üìä Activit√©s archiv√©es trouv√©es: {len(activites_archivees)}")
        
        # Pour chaque activit√©, charger les donn√©es n√©cessaires
        for activite in activites_archivees:
            print(f"  - {activite.id}: {activite.nom} (archiv√© le: {activite.archived_at})")
            
            # Charger direction et service si besoin
            if activite.direction_id:
                activite.direction = Direction.query.get(activite.direction_id)
            
            if activite.service_id:
                activite.service = Service.query.get(activite.service_id)
            
            # Charger le cr√©ateur
            if activite.created_by:
                activite.createur = User.query.get(activite.created_by)
            
            # Compter les √©l√©ments et liens
            activite.nb_elements = ElementLogigramme.query.filter_by(
                activite_id=activite.id
            ).count()
            
            activite.nb_liens = LienLogigramme.query.filter_by(
                activite_id=activite.id
            ).count()
        
        return render_template('logigramme/archives_logigrammes.html',
                             logigrammes=activites_archivees,  # Note: 'logigrammes' pas 'activites_archivees'
                             current_user=current_user)
    
    except Exception as e:
        print(f"‚ùå Erreur archives_logigrammes: {e}")
        import traceback
        traceback.print_exc()
        flash(f'Erreur technique: {str(e)}', 'error')
        return redirect(url_for('liste_logigrammes'))
    
# Route de debug pour v√©rifier l'acc√®s
@app.route('/api/debug/logigramme/<int:activite_id>', methods=['GET'])
@csrf.exempt
@login_required
def debug_logigramme_access(activite_id):
    """Debug: v√©rifier l'acc√®s √† un logigramme"""
    try:
        # M√©thode 1: V√©rification standard
        activite_standard = ProcessusActivite.query.get(activite_id)
        
        # M√©thode 2: V√©rification avec get_client_filter
        activite_filtered = get_client_filter(ProcessusActivite).filter_by(id=activite_id).first()
        
        # M√©thode 3: V√©rification d'acc√®s
        access_granted = check_client_access(activite_standard) if activite_standard else False
        
        return jsonify({
            'success': True,
            'user_id': current_user.id,
            'user_username': current_user.username,
            'user_role': current_user.role,
            'user_client_id': getattr(current_user, 'client_id', None),
            'activite_id': activite_id,
            'activite_nom': activite_standard.nom if activite_standard else None,
            'activite_created_by': activite_standard.created_by if activite_standard else None,
            'activite_client_id': getattr(activite_standard, 'client_id', None) if activite_standard else None,
            'activite_found_standard': activite_standard is not None,
            'activite_found_filtered': activite_filtered is not None,
            'access_granted': access_granted,
            'has_permission_can_manage_logigram': current_user.has_permission('can_manage_logigram'),
            'is_owner': activite_standard and activite_standard.created_by == current_user.id,
            'debug_info': {
                'viewing_client_id': session.get('viewing_client_id'),
                'is_super_admin': current_user.role == 'super_admin'
            }
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/logigramme/test-fix', methods=['GET'])
@login_required
@csrf.exempt
def test_logigramme_fix():
    """Test de r√©solution des probl√®mes"""
    try:
        # Cr√©er un logigramme de test si n√©cessaire
        test_logigramme = ProcessusActivite.query.filter_by(nom="TEST FIX").first()
        
        if not test_logigramme:
            test_logigramme = ProcessusActivite(
                nom="TEST FIX",
                description="Logigramme de test pour les corrections",
                created_by=current_user.id
            )
            
            if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
                test_logigramme.client_id = current_user.client_id
            
            db.session.add(test_logigramme)
            db.session.commit()
        
        return jsonify({
            'success': True,
            'test_logigramme': test_logigramme.to_dict(),
            'user_info': {
                'id': current_user.id,
                'username': current_user.username,
                'role': current_user.role,
                'client_id': getattr(current_user, 'client_id', None)
            },
            'check_client_access': check_client_access(test_logigramme),
            'has_permission': current_user.has_permission('can_manage_logigram')
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    
@app.route('/logigramme/nouveau', methods=['GET', 'POST'])
@login_required
def nouveau_logigramme():
    from models import Direction, Service
    
    # R√©cup√©rer les directions et services
    directions = Direction.query.order_by(Direction.nom).all()
    services = Service.query.order_by(Service.nom).all()
    
    if request.method == 'POST':
        nom = request.form.get('nom')
        description = request.form.get('description')
        direction_id = request.form.get('direction_id')
        service_id = request.form.get('service_id')
        
        if not nom:
            flash('Le nom est obligatoire', 'error')
            return render_template('logigramme/nouveau_logigramme.html', 
                                 directions=directions, services=services)
        
        nouvelle_activite = ProcessusActivite(
            nom=nom,
            description=description,
            direction_id=direction_id if direction_id else None,
            service_id=service_id if service_id else None,
            created_by=current_user.id
        )
        
        try:
            db.session.add(nouvelle_activite)
            db.session.flush()
            
            # ==================== NOTIFICATION ====================
            notification = Notification(
                destinataire_id=current_user.id,
                type_notification=Notification.TYPE_SYSTEME,
                titre=f"Nouveau logigramme cr√©√©: {nouvelle_activite.nom}",
                message=f"Le logigramme '{nouvelle_activite.nom}' a √©t√© cr√©√© avec succ√®s.",
                urgence=Notification.URGENCE_NORMAL,
                entite_type='logigramme',
                entite_id=nouvelle_activite.id,
                donnees_supplementaires={
                    'direction_id': direction_id,
                    'service_id': service_id,
                    'createur': current_user.username
                }
            )
            db.session.add(notification)
            # ======================================================
            
            db.session.commit()
            
            flash('Logigramme cr√©√© avec succ√®s!', 'success')
            return redirect(url_for('editer_logigramme', id=nouvelle_activite.id))
            
        except Exception as e:
            db.session.rollback()
            flash('Erreur lors de la cr√©ation: ' + str(e), 'error')
    
    return render_template('logigramme/nouveau_logigramme.html', 
                         directions=directions, services=services)

@app.route('/liste_logigrammes')
@login_required
def liste_logigrammes():
    from datetime import datetime
    
    # V√âRIFICATION FORMULE
    if current_user.client and current_user.client.formule:
        formule = current_user.client.formule
        if not formule.can_access_module('processus'):
            try:
                all_formules = FormuleAbonnement.query.filter(
                    FormuleAbonnement.is_active == True
                ).all()
                
                upgrade_suggestions = []
                for f in all_formules:
                    if f.modules.get('processus', False):
                        upgrade_suggestions.append(f)
                
                upgrade_suggestions.sort(key=lambda x: x.prix_mensuel or 0)
                
                return render_template('errors/formule_restricted.html', 
                                     module_name='Logigrammes et Processus',
                                     current_formule=formule,
                                     upgrade_suggestions=upgrade_suggestions[:3])
                
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur recherche formules upgrade: {e}")
                flash('Ce module n\'est pas inclus dans votre formule actuelle', 'error')
                return redirect(url_for('dashboard'))
    
    # V√©rifier la permission
    if not current_user.has_permission('can_manage_logigram'):
        flash('Acc√®s refus√© : permission de g√©rer les logigrammes requise', 'error')
        return redirect(url_for('dashboard'))
    
    try:
        # REQU√äTE SIMPLIFI√âE SANS JOINEDLOAD
        query = ProcessusActivite.query
        
        # Filtre client
        if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
            query = query.filter(ProcessusActivite.client_id == current_user.client_id)
        
        # Actifs seulement
        activites_actives = query.filter_by(is_archived=False)\
                                .order_by(ProcessusActivite.created_at.desc()).all()
        
        print(f"üîç LISTE LOGIGRAMMES - Utilisateur: {current_user.username}")
        print(f"   Logigrammes actifs: {len(activites_actives)}")
        
        # Pr√©charger toutes les directions et services
        direction_ids = [a.direction_id for a in activites_actives if a.direction_id]
        service_ids = [a.service_id for a in activites_actives if a.service_id]
        
        directions_dict = {}
        services_dict = {}
        
        if direction_ids:
            directions = Direction.query.filter(Direction.id.in_(direction_ids)).all()
            directions_dict = {d.id: d for d in directions}
        
        if service_ids:
            services = Service.query.filter(Service.id.in_(service_ids)).all()
            services_dict = {s.id: s for s in services}
        
        # Pour chaque activit√©, charger les donn√©es
        total_elements = 0
        total_liens = 0
        
        for activite in activites_actives:
            # Ajouter les objets direction et service
            if activite.direction_id and activite.direction_id in directions_dict:
                activite.direction = directions_dict[activite.direction_id]
            
            if activite.service_id and activite.service_id in services_dict:
                activite.service = services_dict[activite.service_id]
            
            # Compter les √©l√©ments et liens
            activite.nb_elements = ElementLogigramme.query.filter_by(
                activite_id=activite.id
            ).count()
            
            activite.nb_liens = LienLogigramme.query.filter_by(
                activite_id=activite.id
            ).count()
            
            total_elements += activite.nb_elements
            total_liens += activite.nb_liens
        
        # Archiv√©s (compteur seulement)
        query_archives = ProcessusActivite.query
        if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
            query_archives = query_archives.filter(ProcessusActivite.client_id == current_user.client_id)
        
        activites_archivees = query_archives.filter_by(is_archived=True).all()
        
        # Pour les activit√©s archiv√©es, compter aussi
        for activite in activites_archivees[:3]:  # Seulement les 3 premiers pour l'affichage
            activite.nb_elements = ElementLogigramme.query.filter_by(
                activite_id=activite.id
            ).count()
            
            activite.nb_liens = LienLogigramme.query.filter_by(
                activite_id=activite.id
            ).count()
        
        # Directions et services pour les filtres
        if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
            all_directions = Direction.query.filter_by(client_id=current_user.client_id)\
                                          .order_by(Direction.nom).all()
            all_services = Service.query.filter_by(client_id=current_user.client_id)\
                                      .order_by(Service.nom).all()
        else:
            all_directions = Direction.query.order_by(Direction.nom).all()
            all_services = Service.query.order_by(Service.nom).all()
        
        # Statistiques
        stats = {
            'total_actifs': len(activites_actives),
            'total_archives': len(activites_archivees),
            'total_elements': total_elements,
            'total_liens': total_liens,
            'moyenne_elements': round(total_elements / max(len(activites_actives), 1), 1),
            'moyenne_liens': round(total_liens / max(len(activites_actives), 1), 1)
        }
        
        return render_template('logigramme/liste_logigrammes.html', 
                             activites_actives=activites_actives,
                             activites_archivees=activites_archivees,
                             total_elements=total_elements,
                             total_liens=total_liens,
                             directions=all_directions,
                             services=all_services,
                             stats=stats,
                             now=datetime.now(),
                             current_user=current_user)
                             
    except Exception as e:
        print(f"‚ùå Erreur liste_logigrammes: {e}")
        import traceback
        traceback.print_exc()
        flash(f'Erreur technique: {str(e)}', 'error')
        return redirect(url_for('dashboard'))

# Route de modification AVEC DEBUG
@app.route('/api/logigramme/<int:activite_id>', methods=['PUT'])
@csrf.exempt
@login_required
def api_modifier_logigramme(activite_id):
    """API pour modifier un logigramme - VERSION AVEC DEBUG"""
    try:
        print(f"üîç [DEBUG] D√©but modification logigramme {activite_id}")
        print(f"   Utilisateur: {current_user.username} (ID: {current_user.id}, Client: {current_user.client_id})")
        
        # R√©cup√©rer l'activit√©
        activite = ProcessusActivite.query.get(activite_id)
        if not activite:
            print(f"   ‚ùå Logigramme {activite_id} non trouv√©")
            return jsonify({'success': False, 'error': 'Logigramme non trouv√©'}), 404
        
        print(f"   ‚úÖ Logigramme trouv√©: {activite.nom}")
        print(f"   Client ID logigramme: {activite.client_id}")
        
        # V√©rification d'acc√®s
        if not check_client_access(activite):
            print(f"   ‚ùå Acc√®s refus√© par check_client_access")
            return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
        
        # V√©rifier permission
        if not current_user.has_permission('can_manage_logigram'):
            print(f"   ‚ùå Permission 'can_manage_logigram' refus√©e")
            return jsonify({'success': False, 'error': 'Permission refus√©e'}), 403
        
        data = request.get_json()
        print(f"   üì¶ Donn√©es re√ßues: {data}")
        
        if not data:
            return jsonify({'success': False, 'error': 'Donn√©es manquantes'}), 400
        
        # Mettre √† jour les champs
        modifications = []
        if 'nom' in data:
            activite.nom = data['nom'].strip()
            modifications.append(f"nom: {activite.nom}")
        
        if 'description' in data:
            activite.description = data['description'].strip()
            modifications.append("description mise √† jour")
        
        if 'direction_id' in data:
            ancienne_direction = activite.direction_id
            activite.direction_id = data['direction_id'] if data['direction_id'] else None
            modifications.append(f"direction: {ancienne_direction} ‚Üí {activite.direction_id}")
        
        if 'service_id' in data:
            ancien_service = activite.service_id
            activite.service_id = data['service_id'] if data['service_id'] else None
            modifications.append(f"service: {ancien_service} ‚Üí {activite.service_id}")
        
        activite.updated_at = datetime.utcnow()
        
        print(f"   üîÑ Modifications: {', '.join(modifications)}")
        
        db.session.commit()
        print(f"   ‚úÖ Base de donn√©es mise √† jour")
        
        return jsonify({
            'success': True,
            'message': 'Logigramme modifi√© avec succ√®s',
            'logigramme': {
                'id': activite.id,
                'nom': activite.nom,
                'description': activite.description,
                'direction_id': activite.direction_id,
                'service_id': activite.service_id
            }
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå [DEBUG] Erreur modification: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': f'Erreur technique: {str(e)}'
        }), 500
    
@app.route('/parametrage/listes')
@login_required
def parametrage_listes():
    """Page de param√©trage des listes d√©roulantes"""
    if not current_user.has_permission('can_manage_settings'):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    listes = ConfigurationListeDeroulante.query.order_by('nom_affichage').all()
    liste_form = ConfigurationListeForm()
    
    return render_template('admin/parametrage/parametrage_listes.html',
                         listes=listes,
                         liste_form=liste_form)



@app.route('/parametrage/champs')
@login_required
def parametrage_champs():
    """Page de param√©trage des champs personnalis√©s"""
    if not current_user.has_permission('can_manage_settings'):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    # R√©cup√©rer tous les champs configur√©s
    champs = ConfigurationChampRisque.query.order_by('section', 'ordre_affichage').all()
    
    # Regrouper par section pour l'affichage
    champs_par_section = {
        'general': [],
        'analyse': [],
        'evaluation': [],
        'documentation': [],
        'personnalise': []
    }
    
    for champ in champs:
        if champ.section in champs_par_section:
            champs_par_section[champ.section].append(champ)
        else:
            champs_par_section['personnalise'].append(champ)
    
    # Formulaire pour ajouter un champ
    form = ConfigurationChampForm()
    
    return render_template('admin/parametrage/parametrage_champs.html',
                         champs=champs,
                         champs_par_section=champs_par_section,
                         form=form)


@app.route('/parametrage/fichiers')
@login_required
def parametrage_fichiers():
    """Page de param√©trage des fichiers"""
    if not current_user.has_permission('can_manage_settings'):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    config_fichiers = get_config_fichiers()  # Utilisez la fonction
    
    return render_template('admin/parametrage/parametrage_fichiers.html',
                         config_fichiers=config_fichiers)

@app.route('/api/logigramme/<int:activite_id>/archiver', methods=['POST'])
@csrf.exempt
@login_required
def api_archiver_logigramme(activite_id):
    """API pour archiver un logigramme - VERSION AVEC DEBUG"""
    try:
        print(f"üîç [DEBUG] D√©but archivage logigramme {activite_id}")
        print(f"   Utilisateur: {current_user.username} (ID: {current_user.id}, Client: {current_user.client_id})")
        
        # R√©cup√©rer l'activit√©
        activite = ProcessusActivite.query.get(activite_id)
        if not activite:
            print(f"   ‚ùå Logigramme {activite_id} non trouv√©")
            return jsonify({'success': False, 'error': 'Logigramme non trouv√©'}), 404
        
        print(f"   ‚úÖ Logigramme trouv√©: {activite.nom}")
        print(f"   Client ID: {activite.client_id}")
        print(f"   Actuellement archiv√©: {activite.is_archived}")
        
        # V√©rification d'acc√®s
        if not check_client_access(activite):
            print(f"   ‚ùå Acc√®s refus√© par check_client_access")
            return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
        
        # V√©rifier permission
        if not current_user.has_permission('can_manage_logigram'):
            print(f"   ‚ùå Permission 'can_manage_logigram' refus√©e")
            return jsonify({'success': False, 'error': 'Permission refus√©e'}), 403
        
        # V√©rifier si d√©j√† archiv√©
        if activite.is_archived:
            print(f"   ‚ö†Ô∏è  D√©j√† archiv√©, rien √† faire")
            return jsonify({
                'success': True,
                'message': 'Logigramme d√©j√† archiv√©',
                'already_archived': True
            })
        
        # Archiver
        activite.is_archived = True
        activite.archived_at = datetime.utcnow()
        activite.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        print(f"   ‚úÖ Archivage r√©ussi!")
        print(f"   üìÖ Date archivage: {activite.archived_at}")
        
        return jsonify({
            'success': True,
            'message': 'Logigramme archiv√© avec succ√®s',
            'archived_at': activite.archived_at.isoformat() if activite.archived_at else None
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå [DEBUG] Erreur archivage: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': f'Erreur d√©taill√©e: {str(e)}'
        }), 500

# Route de duplication AVEC DEBUG
@app.route('/api/logigramme/<int:activite_id>/dupliquer', methods=['POST'])
@csrf.exempt
@login_required
def api_dupliquer_logigramme(activite_id):
    """API pour dupliquer un logigramme - VERSION AVEC DEBUG"""
    try:
        print(f"üîç [DEBUG] D√©but duplication logigramme {activite_id}")
        print(f"   Utilisateur: {current_user.username} (ID: {current_user.id}, Client: {current_user.client_id})")
        
        # R√©cup√©rer l'activit√©
        activite = ProcessusActivite.query.get(activite_id)
        if not activite:
            print(f"   ‚ùå Logigramme {activite_id} non trouv√©")
            return jsonify({'success': False, 'error': 'Logigramme non trouv√©'}), 404
        
        print(f"   ‚úÖ Logigramme trouv√©: {activite.nom}")
        print(f"   Client ID original: {activite.client_id}")
        
        # V√©rification d'acc√®s
        if not check_client_access(activite):
            print(f"   ‚ùå Acc√®s refus√© par check_client_access")
            return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
        
        data = request.get_json()
        print(f"   üì¶ Donn√©es re√ßues: {data}")
        
        if not data or 'nom' not in data:
            return jsonify({'success': False, 'error': 'Nom de copie requis'}), 400
        
        nom_copie = data['nom'].strip()
        
        if not nom_copie:
            return jsonify({'success': False, 'error': 'Nom de copie vide'}), 400
        
        print(f"   üìù Nom de copie: {nom_copie}")
        
        # Cr√©er la copie
        nouvelle_activite = ProcessusActivite(
            nom=nom_copie,
            description=activite.description,
            direction_id=activite.direction_id,
            service_id=activite.service_id,
            created_by=current_user.id,
            is_archived=False,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )
        
        # D√©terminer le client_id
        if hasattr(activite, 'client_id') and activite.client_id:
            nouvelle_activite.client_id = activite.client_id
            print(f"   üìã Client ID copi√© depuis original: {activite.client_id}")
        elif hasattr(current_user, 'client_id') and current_user.client_id:
            nouvelle_activite.client_id = current_user.client_id
            print(f"   üìã Client ID depuis utilisateur: {current_user.client_id}")
        else:
            print(f"   ‚ö†Ô∏è  Aucun client_id d√©fini")
        
        db.session.add(nouvelle_activite)
        db.session.flush()  # Pour obtenir l'ID
        
        print(f"   ‚úÖ Nouvelle activit√© cr√©√©e: ID {nouvelle_activite.id}")
        
        # Copier les √©l√©ments
        elements = ElementLogigramme.query.filter_by(activite_id=activite_id).all()
        print(f"   üìä √âl√©ments √† copier: {len(elements)}")
        
        elements_map = {}
        
        for element in elements:
            nouvel_element = ElementLogigramme(
                activite_id=nouvelle_activite.id,
                type_element=element.type_element,
                libelle=element.libelle,
                description=element.description,
                position_x=element.position_x,
                position_y=element.position_y,
                width=getattr(element, 'width', 120),
                height=getattr(element, 'height', 60),
                couleur=getattr(element, 'couleur', '#007bff'),
                style=element.style,
                client_id=nouvelle_activite.client_id,
                created_at=datetime.utcnow()
            )
            db.session.add(nouvel_element)
            db.session.flush()
            elements_map[element.id] = nouvel_element.id
        
        print(f"   ‚úÖ {len(elements)} √©l√©ments copi√©s")
        
        # Copier les liens
        liens = LienLogigramme.query.filter_by(activite_id=activite_id).all()
        print(f"   üìä Liens √† copier: {len(liens)}")
        
        for lien in liens:
            source_id = elements_map.get(lien.element_source_id)
            cible_id = elements_map.get(lien.element_cible_id)
            
            if source_id and cible_id:
                nouveau_lien = LienLogigramme(
                    activite_id=nouvelle_activite.id,
                    element_source_id=source_id,
                    element_cible_id=cible_id,
                    libelle=lien.libelle,
                    type_lien=getattr(lien, 'type_lien', 'sequence'),
                    label=getattr(lien, 'label', ''),
                    points=getattr(lien, 'points'),
                    style=lien.style,
                    client_id=nouvelle_activite.client_id,
                    created_at=datetime.utcnow()
                )
                db.session.add(nouveau_lien)
            else:
                print(f"   ‚ö†Ô∏è  Lien {lien.id} ignor√© (source:{lien.element_source_id}, cible:{lien.element_cible_id})")
        
        db.session.commit()
        
        print(f"   ‚úÖ {len(liens)} liens copi√©s")
        print(f"   üéâ Duplication termin√©e avec succ√®s!")
        
        return jsonify({
            'success': True,
            'message': 'Logigramme dupliqu√© avec succ√®s',
            'id': nouvelle_activite.id,
            'nom': nouvelle_activite.nom,
            'redirect_url': f'/editer_logigramme/{nouvelle_activite.id}'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå [DEBUG] Erreur duplication: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': f'Erreur d√©taill√©e: {str(e)}'
        }), 500

@app.route('/api/logigramme/<int:activite_id>/restaurer', methods=['POST'])
@csrf.exempt  # AJOUTEZ CE D√âCORATEUR
@login_required
def api_restaurer_logigramme(activite_id):
    """API pour restaurer un logigramme archiv√©"""
    try:
        print(f"üîç [DEBUG] D√©but restauration logigramme {activite_id}")
        print(f"   Utilisateur: {current_user.username} (ID: {current_user.id})")
        
        # R√©cup√©rer l'activit√© avec v√©rification d'acc√®s client
        activite = get_client_filter(ProcessusActivite).filter_by(id=activite_id).first()
        if not activite:
            print(f"   ‚ùå Logigramme {activite_id} non trouv√©")
            return jsonify({'success': False, 'error': 'Logigramme non trouv√©'}), 404
        
        print(f"   ‚úÖ Logigramme trouv√©: {activite.nom}")
        print(f"   Actuellement archiv√©: {activite.is_archived}")
        
        # V√©rification d'acc√®s client
        if not check_client_access(activite):
            print(f"   ‚ùå Acc√®s refus√© par check_client_access")
            return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
        
        # V√©rifier la permission
        if not current_user.has_permission('can_manage_logigram'):
            print(f"   ‚ùå Permission 'can_manage_logigram' refus√©e")
            return jsonify({'success': False, 'error': 'Permission refus√©e'}), 403
        
        # V√©rifier qu'il est bien archiv√©
        if not activite.is_archived:
            print(f"   ‚ö†Ô∏è  D√©j√† restaur√©, rien √† faire")
            return jsonify({
                'success': True,
                'message': 'Logigramme d√©j√† actif',
                'already_restored': True
            })
        
        # Restaurer le logigramme
        activite.is_archived = False
        activite.archived_at = None
        activite.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        print(f"   ‚úÖ Restauration r√©ussie!")
        
        return jsonify({
            'success': True,
            'message': 'Logigramme restaur√© avec succ√®s'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå [DEBUG] Erreur restauration: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': f'Erreur d√©taill√©e: {str(e)}'
        }), 500

@app.route('/api/logigramme/<int:activite_id>/supprimer-definitivement', methods=['DELETE'])
@csrf.exempt
@login_required
def api_supprimer_definitivement_logigramme(activite_id):
    """API pour supprimer d√©finitivement un logigramme archiv√©"""
    try:
        print(f"üîç [DEBUG] D√©but suppression d√©finitive logigramme {activite_id}")
        print(f"   Utilisateur: {current_user.username} (ID: {current_user.id})")
        
        # R√©cup√©rer l'activit√© avec v√©rification d'acc√®s client
        activite = get_client_filter(ProcessusActivite).filter_by(id=activite_id).first()
        if not activite:
            print(f"   ‚ùå Logigramme {activite_id} non trouv√©")
            return jsonify({'success': False, 'error': 'Logigramme non trouv√©'}), 404
        
        print(f"   ‚úÖ Logigramme trouv√©: {activite.nom}")
        print(f"   Archiv√©: {activite.is_archived}")
        
        # V√©rification d'acc√®s client
        if not check_client_access(activite):
            print(f"   ‚ùå Acc√®s refus√© par check_client_access")
            return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
        
        # V√©rifier la permission
        if not current_user.has_permission('can_manage_logigram'):
            print(f"   ‚ùå Permission 'can_manage_logigram' refus√©e")
            return jsonify({'success': False, 'error': 'Permission refus√©e'}), 403
        
        # V√©rifier que c'est archiv√©
        if not activite.is_archived:
            return jsonify({
                'success': False, 
                'error': 'Seuls les logigrammes archiv√©s peuvent √™tre supprim√©s d√©finitivement'
            }), 400
        
        # Supprimer les √©l√©ments et liens associ√©s
        ElementLogigramme.query.filter_by(activite_id=activite_id).delete()
        LienLogigramme.query.filter_by(activite_id=activite_id).delete()
        
        # Supprimer l'activit√©
        db.session.delete(activite)
        db.session.commit()
        
        print(f"   ‚úÖ Suppression d√©finitive r√©ussie!")
        
        return jsonify({
            'success': True,
            'message': 'Logigramme supprim√© d√©finitivement'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå [DEBUG] Erreur suppression d√©finitive: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': f'Erreur d√©taill√©e: {str(e)}'
        }), 500

@app.route('/editer_logigramme/<int:id>')
@login_required
def editer_logigramme(id):
    # V√©rifier d'abord la permission
    if not current_user.has_permission('can_manage_logigram'):
        flash('Acc√®s refus√© : permission de g√©rer les logigrammes requise', 'error')
        return redirect(url_for('liste_logigrammes'))
    
    # Obtenir l'activit√©
    activite = ProcessusActivite.query.get(id)
    
    # V√©rifier qu'elle existe
    if not activite:
        flash('Logigramme non trouv√©', 'error')
        return redirect(url_for('liste_logigrammes'))
    
    # V√©rifier l'acc√®s client (isolation multi-tenant)
    if not check_client_access(activite):
        flash('Acc√®s non autoris√© √† ce logigramme', 'error')
        return redirect(url_for('liste_logigrammes'))
    
    # V√©rifier qu'il n'est pas archiv√©
    if activite.is_archived:
        flash('Ce logigramme est archiv√© et ne peut √™tre √©dit√©', 'warning')
        return redirect(url_for('liste_logigrammes'))
    
    return render_template('logigramme/editeur_logigramme.html', activite=activite)

# Dans app.py, modifiez toutes les routes API comme ceci :

@app.route('/api/logigramme/<int:activite_id>/elements', methods=['GET', 'POST'])
@csrf.exempt  # <-- AJOUTER
@login_required
def api_elements_logigramme(activite_id):
    if request.method == 'GET':
        elements = ElementLogigramme.query.filter_by(activite_id=activite_id).all()
        return jsonify([{
            'id': el.id,
            'type': el.type_element,
            'libelle': el.libelle,
            'description': el.description,
            'position_x': el.position_x,
            'position_y': el.position_y,
            'style': el.style or {}
        } for el in elements])
    
    elif request.method == 'POST':
        # V√©rifier le token CSRF pour les requ√™tes POST
        if not validate_csrf():
            return jsonify({'error': 'Token CSRF invalide'}), 400
            
        data = request.get_json()
        nouvel_element = ElementLogigramme(
            activite_id=activite_id,
            type_element=data['type'],
            libelle=data['libelle'],
            description=data.get('description', ''),
            position_x=data['position_x'],
            position_y=data['position_y'],
            style=data.get('style', {})
        )
        db.session.add(nouvel_element)
        db.session.commit()
        return jsonify({'id': nouvel_element.id, 'message': '√âl√©ment cr√©√©'})

def validate_csrf():
    """Valide le token CSRF pour les requ√™tes AJAX"""
    try:
        csrf.protect()
        return True
    except:
        return False

@app.route('/api/element/<int:element_id>', methods=['PUT', 'DELETE'])
@csrf.exempt
@login_required
def api_element_logigramme(element_id):
    element = ElementLogigramme.query.get_or_404(element_id)
    
    if request.method == 'PUT':
        data = request.get_json()
        element.libelle = data.get('libelle', element.libelle)
        element.description = data.get('description', element.description)
        element.position_x = data.get('position_x', element.position_x)
        element.position_y = data.get('position_y', element.position_y)
        element.style = data.get('style', element.style)
        db.session.commit()
        return jsonify({'message': '√âl√©ment mis √† jour'})
    
    elif request.method == 'DELETE':
        db.session.delete(element)
        db.session.commit()
        return jsonify({'message': '√âl√©ment supprim√©'})

@app.route('/api/logigramme/<int:activite_id>/liens', methods=['GET', 'POST'])
@csrf.exempt
@login_required
def api_liens_logigramme(activite_id):
    if request.method == 'GET':
        liens = LienLogigramme.query.filter_by(activite_id=activite_id).all()
        return jsonify([{
            'id': lien.id,
            'source_id': lien.element_source_id,
            'cible_id': lien.element_cible_id,
            'libelle': lien.libelle,
            'style': lien.style or {}
        } for lien in liens])
    
    elif request.method == 'POST':
        data = request.get_json()
        nouveau_lien = LienLogigramme(
            activite_id=activite_id,
            element_source_id=data['source_id'],
            element_cible_id=data['cible_id'],
            libelle=data.get('libelle', ''),
            style=data.get('style', {})
        )
        db.session.add(nouveau_lien)
        db.session.commit()
        return jsonify({'id': nouveau_lien.id, 'message': 'Lien cr√©√©'})

@app.route('/api/lien/<int:lien_id>', methods=['DELETE'])
@csrf.exempt
@login_required
def api_lien_logigramme(lien_id):
    lien = LienLogigramme.query.get_or_404(lien_id)
    db.session.delete(lien)
    db.session.commit()
    return jsonify({'message': 'Lien supprim√©'})




@app.route('/risque/<int:id>/modifier', methods=['GET', 'POST'])
@login_required
def modifier_risque(id):
    """Modifier un risque existant"""
    risque = Risque.query.get_or_404(id)
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_risks') or 
            risque.created_by == current_user.id):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    form = RisqueForm(obj=risque)
    
    # R√©cup√©rer les configurations de listes d√©roulantes
    categories_liste = ConfigurationListeDeroulante.query.filter_by(
        nom_technique='categorie'
    ).first()
    
    types_risque_liste = ConfigurationListeDeroulante.query.filter_by(
        nom_technique='type_risque'
    ).first()
    
    # R√©cup√©rer les champs configur√©s
    champs_configures = ConfigurationChampRisque.query.filter_by(
        est_actif=True
    ).order_by('section', 'ordre_affichage').all()
    
    # R√©cup√©rer les valeurs existantes des champs personnalis√©s
    valeurs_existantes = {}
    for champ in risque.champs_personnalises:
        valeurs_existantes[champ.nom_technique] = champ.get_valeur()
    
    # Configuration fichiers pour le template
    config_fichiers = {
        'extensions': list(app.config.get('ALLOWED_EXTENSIONS', {'pdf', 'doc', 'docx', 'xls', 'xlsx', 'jpg', 'png', 'txt'})),
        'taille_max_mo': app.config.get('MAX_CONTENT_LENGTH', 10 * 1024 * 1024) // (1024 * 1024),
        'categories': ['document', 'image', 'analyse', 'autre']
    }
    
    if form.validate_on_submit():
        # Mettre √† jour les champs de base
        risque.intitule = form.intitule.data
        risque.description = form.description.data
        risque.processus_concerne = form.processus_concerne.data
        
        # Mettre √† jour les listes d√©roulantes
        if categories_liste:
            risque.categorie = request.form.get('categorie', '')
        else:
            risque.categorie = form.categorie.data
            
        if types_risque_liste:
            risque.type_risque = request.form.get('type_risque', '')
        else:
            risque.type_risque = form.type_risque.data
            
        risque.cause_racine = form.cause_racine.data
        risque.consequences = form.consequences.data
        
        # G√©rer les champs personnalis√©s
        for champ in champs_configures:
            field_name = f'champ_{champ.nom_technique}'
            fichier_name = f'fichier_{champ.nom_technique}'
            
            if champ.type_champ == 'fichier':
                # Gestion des fichiers
                if fichier_name in request.files:
                    fichier = request.files[fichier_name]
                    if fichier and fichier.filename:
                        # Supprimer l'ancien fichier si demand√©
                        if request.form.get(f'supprimer_fichier_{champ.nom_technique}') == 'true':
                            ancien_champ = ChampPersonnaliseRisque.query.filter_by(
                                risque_id=risque.id,
                                nom_technique=champ.nom_technique
                            ).first()
                            if ancien_champ and ancien_champ.get_valeur():
                                # Supprimer le fichier physique
                                chemin_fichier = os.path.join(
                                    app.config['UPLOAD_FOLDER'], 
                                    'risques', 
                                    str(risque.id), 
                                    ancien_champ.get_valeur()
                                )
                                if os.path.exists(chemin_fichier):
                                    os.remove(chemin_fichier)
                            
                            # Supprimer l'enregistrement
                            if ancien_champ:
                                db.session.delete(ancien_champ)
                        
                        # Sauvegarder le nouveau fichier
                        nom_fichier = secure_filename(fichier.filename)
                        timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
                        nom_unique = f"{timestamp}_{nom_fichier}"
                        
                        dossier = os.path.join(app.config['UPLOAD_FOLDER'], 'risques', str(risque.id))
                        os.makedirs(dossier, exist_ok=True)
                        chemin = os.path.join(dossier, nom_unique)
                        
                        fichier.save(chemin)
                        
                        # Cr√©er ou mettre √† jour le champ
                        champ_perso = ChampPersonnaliseRisque.query.filter_by(
                            risque_id=risque.id,
                            nom_technique=champ.nom_technique
                        ).first()
                        
                        if not champ_perso:
                            champ_perso = ChampPersonnaliseRisque(
                                risque_id=risque.id,
                                nom_technique=champ.nom_technique
                            )
                        
                        champ_perso.set_valeur(nom_fichier)
                        db.session.add(champ_perso)
            else:
                # Gestion des autres types de champs
                if field_name in request.form:
                    valeur = request.form[field_name]
                    
                    # Pour les checkbox, valeur peut √™tre "true" ou absente
                    if champ.type_champ == 'checkbox':
                        valeur = valeur == 'true'
                    
                    # Pour les multiselect, r√©cup√©rer toutes les valeurs
                    elif champ.type_champ == 'multiselect':
                        valeurs = request.form.getlist(field_name)
                        valeur = valeurs
                    
                    champ_perso = ChampPersonnaliseRisque.query.filter_by(
                        risque_id=risque.id,
                        nom_technique=champ.nom_technique
                    ).first()
                    
                    if not champ_perso and valeur:
                        # Cr√©er un nouveau champ seulement si valeur non vide
                        champ_perso = ChampPersonnaliseRisque(
                            risque_id=risque.id,
                            nom_technique=champ.nom_technique
                        )
                        champ_perso.set_valeur(valeur)
                        db.session.add(champ_perso)
                    elif champ_perso:
                        if valeur or (champ.est_obligatoire and valeur != ''):
                            champ_perso.set_valeur(valeur)
                            db.session.add(champ_perso)
                        else:
                            # Supprimer le champ si vide et non obligatoire
                            db.session.delete(champ_perso)
        
        # G√©rer les fichiers additionnels
        for i in range(10):  # Limite de 10 fichiers additionnels
            fichier_key = f'fichier_additionnel_{i}'
            categorie_key = f'categorie_fichier_{i}'
            description_key = f'description_fichier_{i}'
            
            if fichier_key in request.files:
                fichier = request.files[fichier_key]
                if fichier and fichier.filename:
                    # Sauvegarder le fichier
                    nom_fichier = secure_filename(fichier.filename)
                    timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
                    nom_unique = f"{timestamp}_{nom_fichier}"
                    
                    dossier = os.path.join(app.config['UPLOAD_FOLDER'], 'risques', str(risque.id))
                    os.makedirs(dossier, exist_ok=True)
                    chemin = os.path.join(dossier, nom_unique)
                    
                    fichier.save(chemin)
                    
                    # Enregistrer en base
                    fichier_db = FichierRisque(
                        risque_id=risque.id,
                        nom_fichier=nom_fichier,
                        chemin_fichier=chemin,
                        type_fichier=fichier.content_type,
                        taille=os.path.getsize(chemin),
                        categorie=request.form.get(categorie_key, 'document'),
                        description=request.form.get(description_key, ''),
                        uploaded_by=current_user.id
                    )
                    db.session.add(fichier_db)
        
        db.session.commit()
        
        # üî• SYNCHRONISATION AUTOMATIQUE
        declencher_mise_a_jour_risque(risque.id, 'modification', current_user.id)
        synchroniser_matrices_apres_modification(risque.cartographie_id)
        
        flash('Risque modifi√© avec succ√®s', 'success')
        return redirect(url_for('detail_risque', id=risque.id))
    
    return render_template('cartographie/risque_form.html',
                         form=form,
                         risque=risque,
                         action='modifier',
                         categories_liste=categories_liste,
                         types_risque_liste=types_risque_liste,
                         champs_configures=champs_configures,
                         valeurs_existantes=valeurs_existantes,
                         config_fichiers=config_fichiers)

# Ajouter apr√®s les routes existantes dans app.py

@app.route('/processus/<int:id>/organigramme-avance')
@login_required
def organigramme_avance(id):
    """Page d'organigramme avanc√© avec fonctionnalit√©s √©tendues"""
    processus = Processus.query.get_or_404(id)
    etapes = EtapeProcessus.query.filter_by(processus_id=id).order_by(EtapeProcessus.ordre).all()
    liens = LienProcessus.query.filter_by(processus_id=id).all()
    zones_risque = ZoneRisqueOrganigramme.query.filter_by(processus_id=id).all()
    users = User.query.all()
    
    return render_template('processus/organigramme_avance.html',
                         processus=processus,
                         etapes=etapes,
                         liens=liens,
                         zones_risque=zones_risque,
                         users=users)




@app.route('/risque/<int:id>/nouvelle-evaluation', methods=['POST'])
@login_required
def demarrer_nouvelle_evaluation(id):
    """D√©marrer une nouvelle √©valuation pour un risque"""
    risque = Risque.query.get_or_404(id)
    
    try:
        # V√©rifier s'il y a une √©valuation en cours
        evaluation_en_cours = EvaluationRisque.query.filter_by(
            risque_id=id, 
            statut_validation='en_attente'
        ).first()
        
        if evaluation_en_cours:
            flash('‚ùå Une √©valuation est d√©j√† en cours pour ce risque', 'error')
            return redirect(url_for('detail_risque', id=id))
        
        # Cr√©er une nouvelle √©valuation avec r√©f√©rence unique
        derniere_eval = EvaluationRisque.query.filter_by(risque_id=id).order_by(EvaluationRisque.created_at.desc()).first()
        numero_evaluation = (derniere_eval.id + 1) if derniere_eval else 1
        
        nouvelle_evaluation = EvaluationRisque(
            risque_id=id,
            type_evaluation=f'evaluation_{numero_evaluation}',
            statut_validation='en_attente',
            created_by=current_user.id
        )
        
        db.session.add(nouvelle_evaluation)
        db.session.commit()
        
        # üîÑ SYNCHRONISATION AUTOMATIQUE
        synchroniser_evaluation_triphase(id)
        
        flash('üÜï Nouvelle √©valuation d√©marr√©e avec succ√®s', 'success')
        return redirect(url_for('evaluer_risque_triphase', id=id))
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur lors du d√©marrage: {str(e)}', 'error')
        return redirect(url_for('detail_risque', id=id))



# ============================================================================
# ROUTES POUR L'UPLOAD MULTIPLE DE PREUVES
# ============================================================================

@app.route('/audit/<int:audit_id>/upload-multiple-preuves', methods=['POST'])
@csrf.exempt
@login_required
def upload_multiple_preuves(audit_id):
    """Uploader plusieurs preuves en une seule fois pour un audit"""
    audit = Audit.query.get_or_404(audit_id)
    
    if 'preuves[]' not in request.files:
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(url_for('detail_audit', id=audit_id))
    
    fichiers = request.files.getlist('preuves[]')
    fichiers_uploades = 0
    
    for fichier in fichiers:
        if fichier and fichier.filename:
            if allowed_file(fichier.filename):
                try:
                    # G√©n√©rer un nom de fichier unique
                    filename = secure_filename(fichier.filename)
                    unique_filename = f"{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{filename}"
                    
                    # Cr√©er le dossier s'il n'existe pas
                    upload_folder = 'static/uploads/preuves'
                    os.makedirs(upload_folder, exist_ok=True)
                    
                    # Sauvegarder le fichier
                    filepath = os.path.join(upload_folder, unique_filename)
                    fichier.save(filepath)
                    
                    # Journaliser l'action
                    journaliser_action_audit(
                        audit_id=audit_id,
                        action_type='upload_multiple_preuves',
                        user_id=current_user.id,
                        details={
                            'filename': filename,
                            'unique_filename': unique_filename
                        }
                    )
                    
                    fichiers_uploades += 1
                    
                except Exception as e:
                    flash(f'Erreur lors de l\'upload de {fichier.filename}: {str(e)}', 'error')
            else:
                flash(f'Type de fichier non autoris√©: {fichier.filename}', 'error')
    
    if fichiers_uploades > 0:
        flash(f'{fichiers_uploades} fichier(s) upload√©(s) avec succ√®s', 'success')
    
    return redirect(url_for('detail_audit', id=audit_id))

@app.route('/audit/<int:audit_id>/constatation/<int:constatation_id>/upload-multiple-preuves', methods=['POST'])
@csrf.exempt
@login_required
def upload_multiple_preuves_constatation(audit_id, constatation_id):
    """Uploader plusieurs preuves pour une constatation sp√©cifique"""
    constatation = Constatation.query.get_or_404(constatation_id)
    
    # V√©rifier que la constatation appartient bien √† l'audit
    if constatation.audit_id != audit_id:
        flash('Cette constatation ne fait pas partie de cet audit', 'error')
        return redirect(url_for('detail_audit', id=audit_id))
    
    if 'preuves[]' not in request.files:
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(url_for('detail_audit', id=audit_id))
    
    fichiers = request.files.getlist('preuves[]')
    fichiers_uploades = 0
    preuves_filenames = []
    
    for fichier in fichiers:
        if fichier and fichier.filename:
            if allowed_file(fichier.filename):
                try:
                    # G√©n√©rer un nom de fichier unique
                    filename = secure_filename(fichier.filename)
                    unique_filename = f"preuve_{constatation_id}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{filename}"
                    
                    # Cr√©er le dossier s'il n'existe pas
                    upload_folder = 'static/uploads/preuves'
                    os.makedirs(upload_folder, exist_ok=True)
                    
                    # Sauvegarder le fichier
                    filepath = os.path.join(upload_folder, unique_filename)
                    fichier.save(filepath)
                    
                    preuves_filenames.append(unique_filename)
                    fichiers_uploades += 1
                    
                except Exception as e:
                    flash(f'Erreur lors de l\'upload de {fichier.filename}: {str(e)}', 'error')
            else:
                flash(f'Type de fichier non autoris√©: {fichier.filename}', 'error')
    
    # Mettre √† jour la constatation avec les nouvelles preuves
    if preuves_filenames:
        nouvelles_preuves = ','.join(preuves_filenames)
        if constatation.preuves:
            constatation.preuves = f"{constatation.preuves},{nouvelles_preuves}"
        else:
            constatation.preuves = nouvelles_preuves
        
        constatation.updated_at = datetime.utcnow()
        db.session.commit()
        
        # Journaliser l'action
        journaliser_action_audit(
            audit_id=audit_id,
            action_type='upload_multiple_preuves_constatation',
            user_id=current_user.id,
            details={
                'constatation_id': constatation_id,
                'fichiers_uploades': fichiers_uploades
            }
        )
        
        flash(f'{fichiers_uploades} preuve(s) ajout√©e(s) √† la constatation', 'success')
    
    return redirect(url_for('detail_audit', id=audit_id))

# ============================================================================
# ROUTES POUR LE T√âL√âCHARGEMENT DE TOUTES LES PREUVES D'UN AUDIT
# ============================================================================

@app.route('/audit/<int:audit_id>/download-all-preuves')
@login_required
def download_all_preuves(audit_id):
    """T√©l√©charger toutes les preuves d'un audit sous forme d'archive ZIP"""
    audit = Audit.query.get_or_404(audit_id)
    
    try:
        import zipfile
        import io
        import tempfile
        
        # Cr√©er un fichier ZIP en m√©moire
        zip_buffer = io.BytesIO()
        
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            # R√©cup√©rer toutes les constatations de l'audit
            constatations = Constatation.query.filter_by(audit_id=audit_id).all()
            
            fichiers_ajoutes = 0
            
            for constatation in constatations:
                if constatation.preuves:
                    preuves_list = constatation.get_preuves_list
                    
                    for preuve_filename in preuves_list:
                        # Chemin complet du fichier
                        file_path = os.path.join('static/uploads/preuves', preuve_filename)
                        
                        # V√©rifier si le fichier existe
                        if os.path.exists(file_path):
                            # Ajouter au ZIP avec un chemin organis√©
                            zip_path = f"preuves/{constatation.reference}/{preuve_filename}"
                            zip_file.write(file_path, zip_path)
                            fichiers_ajoutes += 1
        
        if fichiers_ajoutes == 0:
            flash('Aucune preuve √† t√©l√©charger', 'warning')
            return redirect(url_for('detail_audit', id=audit_id))
        
        zip_buffer.seek(0)
        
        # Journaliser l'action
        journaliser_action_audit(
            audit_id=audit_id,
            action_type='download_all_preuves',
            user_id=current_user.id,
            details={'fichiers_ajoutes': fichiers_ajoutes}
        )
        
        # Retourner le fichier ZIP
        return send_file(
            zip_buffer,
            as_attachment=True,
            download_name=f"preuves_audit_{audit.reference}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip",
            mimetype='application/zip'
        )
        
    except Exception as e:
        flash(f'Erreur lors de la cr√©ation de l\'archive: {str(e)}', 'error')
        return redirect(url_for('detail_audit', id=audit_id))

@app.route('/download/preuve/<filename>')
@login_required
def download_preuve(filename):
    """T√©l√©charger une preuve jointe √† une constatation"""
    try:
        # Dossier o√π sont stock√©es les preuves
        upload_folder = 'static/uploads/preuves'
        file_path = os.path.join(upload_folder, filename)
        
        # V√©rifier si le fichier existe
        if not os.path.exists(file_path):
            flash('Fichier non trouv√©', 'error')
            return redirect(request.referrer or url_for('index'))
        
        # Envoyer le fichier
        return send_file(file_path, as_attachment=True)
        
    except Exception as e:
        flash(f'Erreur lors du t√©l√©chargement: {str(e)}', 'error')
        return redirect(request.referrer or url_for('index'))

    
@app.route('/api/processus/<int:processus_id>/liens', methods=['GET', 'POST'])
@login_required
def api_liens_processus(processus_id):
    """API pour g√©rer les liens - CORRIG√âE"""
    if request.method == 'GET':
        try:
            liens = LienProcessus.query.filter_by(processus_id=processus_id).all()
            return jsonify([{
                'id': l.id,
                'source': l.etape_source_id,
                'cible': l.etape_cible_id,
                'type': l.type_lien,
                'label': l.label or '',
                'created_at': l.created_at.isoformat() if l.created_at else None
            } for l in liens])
        except Exception as e:
            print(f"‚ùå Erreur chargement liens: {e}")
            return jsonify({'error': str(e)}), 500
    
    elif request.method == 'POST':
        try:
            data = request.get_json()
            
            # V√©rifier si le lien existe d√©j√†
            lien_existant = LienProcessus.query.filter_by(
                processus_id=processus_id,
                etape_source_id=data['source'],
                etape_cible_id=data['cible']
            ).first()
            
            if lien_existant:
                return jsonify({'success': False, 'error': 'Ce lien existe d√©j√†'})
            
            lien = LienProcessus(
                processus_id=processus_id,
                etape_source_id=data['source'],
                etape_cible_id=data['cible'],
                type_lien=data.get('type', 'sequence'),
                label=data.get('label', '')
            )
            
            db.session.add(lien)
            db.session.commit()
            
            return jsonify({
                'success': True,
                'lien': {
                    'id': lien.id,
                    'source': lien.etape_source_id,
                    'cible': lien.etape_cible_id,
                    'type': lien.type_lien,
                    'label': lien.label
                }
            })
            
        except Exception as e:
            db.session.rollback()
            return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/risque/<int:id>/dupliquer')
@login_required
def dupliquer_risque(id):
    """Dupliquer un risque existant"""
    risque_original = Risque.query.get_or_404(id)
    
    # G√©n√©rer une nouvelle r√©f√©rence
    dernier_risque = Risque.query.order_by(Risque.id.desc()).first()
    nouvelle_ref = f"RISQ-{(dernier_risque.id + 1) if dernier_risque else 1:04d}"
    
    # Cr√©er la copie du risque
    nouveau_risque = Risque(
        reference=nouvelle_ref,
        intitule=f"{risque_original.intitule} (Copie)",
        description=risque_original.description,
        processus_concerne=risque_original.processus_concerne,
        categorie=risque_original.categorie,
        type_risque=risque_original.type_risque,
        cause_racine=risque_original.cause_racine,
        consequences=risque_original.consequences,
        cartographie_id=risque_original.cartographie_id,
        created_by=current_user.id
    )
    
    db.session.add(nouveau_risque)
    db.session.commit()
    
    flash('Risque dupliqu√© avec succ√®s', 'success')
    return redirect(url_for('detail_cartographie', id=risque_original.cartographie_id))

@app.route('/risque/<int:id>/kri/creer-rapide', methods=['POST'])
@login_required
def creer_kri_rapide(id):
    """Cr√©er un KRI rapide pour un risque"""
    risque = Risque.query.get_or_404(id)
    
    # V√©rifier si un KRI existe d√©j√†
    kri_existant = KRI.query.filter_by(risque_id=id).first()
    if kri_existant:
        flash('Un KRI existe d√©j√† pour ce risque', 'error')
        return redirect(url_for('detail_risque', id=id))
    
    nom = request.form.get('nom', f"KRI {risque.reference}")
    unite_mesure = request.form.get('unite_mesure', 'Unit√©')
    seuil_alerte = request.form.get('seuil_alerte')
    seuil_critique = request.form.get('seuil_critique')
    
    kri = KRI(
        risque_id=id,
        nom=nom,
        description=f"KRI automatique pour le risque {risque.reference}",
        unite_mesure=unite_mesure,
        frequence_mesure='mensuel',
        seuil_alerte=float(seuil_alerte) if seuil_alerte else None,
        seuil_critique=float(seuil_critique) if seuil_critique else None,
        responsable_mesure_id=current_user.id
    )
    
    db.session.add(kri)
    db.session.commit()
    
    flash('KRI cr√©√© avec succ√®s', 'success')
    return redirect(url_for('detail_risque', id=id))

@app.route('/api/risque/<int:id>/statut')
@login_required
def api_statut_risque(id):
    """API pour r√©cup√©rer le statut d'un risque"""
    risque = Risque.query.get_or_404(id)
    
    derniere_eval = EvaluationRisque.query.filter_by(
        risque_id=id
    ).order_by(EvaluationRisque.created_at.desc()).first()
    
    kri = KRI.query.filter_by(risque_id=id).first()
    
    return jsonify({
        'reference': risque.reference,
        'intitule': risque.intitule,
        'est_evalue': derniere_eval is not None,
        'niveau_risque': derniere_eval.niveau_risque if derniere_eval else 'Non √©valu√©',
        'score': derniere_eval.score_risque if derniere_eval else 0,
        'a_kri': kri is not None,
        'is_archived': risque.is_archived if hasattr(risque, 'is_archived') else False
    })

@app.route('/cartographie/<int:id>/export/matrice')
@login_required
def export_matrice_cartographie(id):
    """Exporter la matrice de risques d'une cartographie"""
    cartographie = Cartographie.query.get_or_404(id)
    
    # R√©cup√©rer toutes les √©valuations des risques de cette cartographie
    evaluations = []
    for risque in cartographie.risques:
        if hasattr(risque, 'is_archived') and risque.is_archived:
            continue
        if risque.evaluations:
            derniere_evaluation = max(risque.evaluations, key=lambda x: x.created_at)
            evaluations.append(derniere_evaluation)
    
    # G√©n√©rer la matrice
    matrice_image = generer_matrice_risques(evaluations, 'classique')
    
    # Retourner l'image en r√©ponse directe
    from flask import Response
    image_data = base64.b64decode(matrice_image)
    
    response = Response(image_data, mimetype='image/png')
    response.headers['Content-Disposition'] = f'attachment; filename=matrice_{cartographie.nom}_{datetime.now().strftime("%Y%m%d")}.png'
    
    return response

@app.route('/cartographie/<int:id>/risques/non-evalues')
@login_required
def risques_non_evalues(id):
    """Liste des risques non √©valu√©s d'une cartographie"""
    cartographie = Cartographie.query.get_or_404(id)
    
    risques_non_evalues = []
    for risque in cartographie.risques:
        if hasattr(risque, 'is_archived') and risque.is_archived:
            continue
        if not risque.evaluations:
            risques_non_evalues.append(risque)
    
    return render_template('cartographie/risques_non_evalues.html',
                         cartographie=cartographie,
                         risques_non_evalues=risques_non_evalues)

@app.route('/risque/evaluation/multiple', methods=['POST'])
@login_required
def evaluation_multiple_risques():
    """√âvaluation multiple de risques"""
    risque_ids = request.form.getlist('risque_ids')
    impact = int(request.form.get('impact', 0))
    probabilite = int(request.form.get('probabilite', 0))
    commentaire = request.form.get('commentaire', '√âvaluation multiple')
    
    if not risque_ids or impact == 0 or probabilite == 0:
        flash('Veuillez s√©lectionner des risques et des niveaux d\'√©valuation', 'error')
        return redirect(request.referrer or url_for('dashboard'))
    
    risques_evalues = 0
    for risque_id in risque_ids:
        risque = Risque.query.get(int(risque_id))
        if risque:
            # Calculer le score et le niveau
            score_risque = impact * probabilite
            niveau_risque, couleur = calculer_niveau_risque(impact, probabilite)
            
            evaluation = EvaluationRisque(
                risque_id=risque.id,
                type_evaluation='multiple',
                evaluateur_id=current_user.id,
                impact=impact,
                probabilite=probabilite,
                niveau_maitrise=3,
                commentaire=f"{commentaire} - {risque.reference}",
                score_risque=score_risque,
                niveau_risque=niveau_risque,
                statut='valide'
            )
            
            db.session.add(evaluation)
            risques_evalues += 1
    
    db.session.commit()
    flash(f'{risques_evalues} risques √©valu√©s avec succ√®s', 'success')
    return redirect(request.referrer or url_for('dashboard'))

# Routes pour les rapports avanc√©s
@app.route('/rapports/matrices/comparaison')
@login_required
def rapport_comparaison_matrices():
    """Rapport de comparaison entre diff√©rentes matrices"""
    cartographies = Cartographie.query.all()
    
    matrices_data = []
    for cartographie in cartographies:
        evaluations = []
        for risque in cartographie.risques:
            if hasattr(risque, 'is_archived') and risque.is_archived:
                continue
            if risque.evaluations:
                derniere_eval = max(risque.evaluations, key=lambda x: x.created_at)
                evaluations.append(derniere_eval)
        
        if evaluations:
            matrice_classique = generer_matrice_risques(evaluations, 'classique')
            matrices_data.append({
                'cartographie': cartographie,
                'matrice': matrice_classique,
                'nb_risques': len(evaluations)
            })
    
    return render_template('rapports/comparaison_matrices.html',
                         matrices_data=matrices_data)

@app.route('/api/cartographie/<int:id>/stats')
@login_required
def api_stats_cartographie(id):
    """API pour les statistiques d'une cartographie"""
    cartographie = Cartographie.query.get_or_404(id)
    
    stats = {
        'total_risques': 0,
        'risques_evalues': 0,
        'risques_non_evalues': 0,
        'repartition_niveaux': {
            'Critique': 0,
            '√âlev√©': 0,
            'Moyen': 0,
            'Faible': 0
        },
        'moyenne_scores': 0
    }
    
    scores = []
    for risque in cartographie.risques:
        if hasattr(risque, 'is_archived') and risque.is_archived:
            continue
            
        stats['total_risques'] += 1
        
        if risque.evaluations:
            stats['risques_evalues'] += 1
            derniere_eval = max(risque.evaluations, key=lambda x: x.created_at)
            niveau = derniere_eval.niveau_risque
            stats['repartition_niveaux'][niveau] += 1
            scores.append(derniere_eval.score_risque)
        else:
            stats['risques_non_evalues'] += 1
    
    if scores:
        stats['moyenne_scores'] = round(sum(scores) / len(scores), 2)
    
    return jsonify(stats)

# Route pour le tableau de bord des risques
@app.route('/risques/dashboard')
@login_required
def dashboard_risques():
    """Tableau de bord consolid√© des risques"""
    # R√©cup√©rer toutes les cartographies
    cartographies = Cartographie.query.all()
    
    # Statistiques globales - EXCLURE LES RISQUES ARCHIV√âS
    total_risques = Risque.query.filter_by(is_archived=False).count()
    total_risques_evalues = db.session.query(Risque).join(EvaluationRisque).filter(
        Risque.is_archived == False  # ‚Üê EXCLURE LES RISQUES ARCHIV√âS
    ).distinct().count()
    
    # Risques critiques r√©cents (moins de 30 jours) - EXCLURE LES RISQUES ARCHIV√âS
    date_limite = datetime.now() - timedelta(days=30)
    risques_critiques_recents = []
    
    for risque in Risque.query.filter_by(is_archived=False).all():  # ‚Üê FILTRER LES RISQUES NON ARCHIV√âS
        if risque.evaluations:
            derniere_eval = max(risque.evaluations, key=lambda x: x.created_at)
            if derniere_eval.niveau_risque in ['Critique', '√âlev√©'] and derniere_eval.created_at >= date_limite:
                risques_critiques_recents.append({
                    'risque': risque,
                    'evaluation': derniere_eval
                })
    
    # R√©partition par cat√©gorie - EXCLURE LES RISQUES ARCHIV√âS
    repartition_categories = db.session.query(
        Risque.categorie,
        db.func.count(Risque.id)
    ).filter_by(is_archived=False).group_by(Risque.categorie).all()
    
    # Cartographies avec le plus de risques - EXCLURE LES RISQUES ARCHIV√âS
    cartographies_actives = []
    for cartographie in cartographies:
        nb_risques = len([r for r in cartographie.risques if not getattr(r, 'is_archived', False)])
        if nb_risques > 0:
            cartographies_actives.append({
                'cartographie': cartographie,
                'nb_risques': nb_risques
            })
    
    # Trier par nombre de risques d√©croissant
    cartographies_actives.sort(key=lambda x: x['nb_risques'], reverse=True)
    
    return render_template('dashboard_risques.html',
                         total_risques=total_risques,
                         total_risques_evalues=total_risques_evalues,
                         risques_critiques_recents=risques_critiques_recents,
                         repartition_categories=repartition_categories,
                         cartographies_actives=cartographies_actives[:5])


# Route pour la recherche avanc√©e des risques
@app.route('/risques/recherche')
@login_required
def recherche_risques():
    """Recherche avanc√©e dans les risques"""
    query = request.args.get('q', '')
    categorie = request.args.get('categorie', '')
    niveau_risque = request.args.get('niveau_risque', '')
    cartographie_id = request.args.get('cartographie_id', '')
    
    # Construction de la requ√™te de base
    risques_query = Risque.query.filter_by(is_archived=False)
    
    # Filtres
    if query:
        risques_query = risques_query.filter(
            db.or_(
                Risque.reference.ilike(f'%{query}%'),
                Risque.intitule.ilike(f'%{query}%'),
                Risque.description.ilike(f'%{query}%')
            )
        )
    
    if categorie:
        risques_query = risques_query.filter_by(categorie=categorie)
    
    if cartographie_id:
        risques_query = risques_query.filter_by(cartographie_id=cartographie_id)
    
    risques = risques_query.all()
    
    # Filtre par niveau de risque si sp√©cifi√©
    if niveau_risque:
        risques_filtres = []
        for risque in risques:
            if risque.evaluations:
                derniere_eval = max(risque.evaluations, key=lambda x: x.created_at)
                if derniere_eval.niveau_risque == niveau_risque:
                    risques_filtres.append(risque)
        risques = risques_filtres
    
    # Options pour les filtres
    categories = db.session.query(Risque.categorie).filter_by(is_archived=False).distinct().all()
    cartographies = Cartographie.query.all()
    
    return render_template('recherche_risques.html',
                         risques=risques,
                         query=query,
                         categories=categories,
                         cartographies=cartographies,
                         selected_categorie=categorie,
                         selected_niveau=niveau_risque,
                         selected_cartographie=cartographie_id)

# Export des donn√©es
@app.route('/export/risques')
@login_required
def export_risques():
    risques = Risque.query.all()
    data = []
    
    for risque in risques:
        derniere_eval = EvaluationRisque.query.filter_by(
            risque_id=risque.id, 
            statut='valide'
        ).order_by(EvaluationRisque.created_at.desc()).first()
        
        data.append({
            'reference': risque.reference,
            'intitule': risque.intitule,
            'categorie': risque.categorie,
            'impact': derniere_eval.impact if derniere_eval else None,
            'probabilite': derniere_eval.probabilite if derniere_eval else None,
            'niveau_risque': derniere_eval.niveau_risque if derniere_eval else 'Non √©valu√©',
            'cartographie': risque.cartographie.nom
        })
    
    return jsonify(data)


@app.route('/api/guide-evaluation')
@login_required
def api_guide_evaluation():
    """API pour r√©cup√©rer le guide d'√©valuation"""
    try:
        sections = GuideEvaluation.query.filter_by(est_actif=True).order_by('ordre').all()
        
        return jsonify({
            'success': True,
            'sections': [{
                'id': section.id,
                'section': section.section,
                'titre': section.titre,
                'contenu': section.contenu,
                'ordre': section.ordre,
                'est_actif': section.est_actif
            } for section in sections]
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/audit/ajouter', methods=['POST'])
def ajouter_audit():
    nouveau = Audit(
        reference='REF001',
        titre='Audit Qualit√©',
        description='Description de l‚Äôaudit',
        type_audit='interne'
    )
    db.session.add(nouveau)
    db.session.commit()
    return "Audit ajout√© !"



# ============================================================================
# ROUTES MANQUANTES POUR LE MODULE AUDIT
# ============================================================================
@app.route('/audit/plans-action')
@csrf.exempt
@login_required
def liste_plans_action():
    """Liste de tous les plans d'action avec distinction risque/audit/ind√©pendant - VERSION CORRIG√âE"""
    
    print(f"\nüîç ACC√àS PLANS D'ACTION - Utilisateur: {current_user.username}")
    print(f"   R√¥le: {current_user.role}")
    print(f"   Client ID: {current_user.client_id}")
    
    # V√©rifier l'acc√®s au module plans d'action
    if current_user.role != 'super_admin':
        if current_user.client and current_user.client.formule:
            formule = current_user.client.formule
            
            module_names_to_check = ['plans_action', 'audit_interne', 'audit']
            has_access = False
            
            for module_name in module_names_to_check:
                if module_name in formule.modules:
                    if formule.modules[module_name]:
                        has_access = True
                        print(f"   ‚úÖ Module trouv√©: '{module_name}'")
                        break
            
            if not has_access:
                print(f"   ‚ùå Aucun module plans d'action activ√©")
                flash('Le module "Plans d\'action" n\'est pas inclus dans votre formule', 'error')
                return redirect(url_for('dashboard'))
    
    # V√©rifier la permission utilisateur
    if not current_user.has_permission('can_view_action_plans'):
        print(f"   ‚ùå Permission 'can_view_action_plans' manquante")
        
        if current_user.role in ['admin', 'super_admin']:
            print(f"   üîß For√ßage de la permission pour admin")
            if current_user.permissions is None:
                current_user.permissions = {}
            current_user.permissions['can_view_action_plans'] = True
            db.session.commit()
        else:
            flash('Permission "Voir les plans d\'action" requise', 'error')
            return redirect(url_for('dashboard'))
    
    print(f"   üéâ ACC√àS AUTORIS√â")
    
    # R√©cup√©rer le filtre par type
    type_filtre = request.args.get('type', 'tous')
    filtre_statut = request.args.get('statut', 'tous')
    tri = request.args.get('tri', 'date_desc')
    
    # ========================
    # 1. R√âCUP√âRER TOUS LES PLANS POUR LES STATISTIQUES GLOBALES
    # ========================
    tous_plans_query = get_client_filter(PlanAction)
    tous_plans = tous_plans_query.all()
    
    # ========================
    # 2. CALCULER LES STATISTIQUES GLOBALES (ind√©pendamment du filtre)
    # ========================
    stats_globales = {
        'total': len(tous_plans),
        'audit': len([p for p in tous_plans if p.audit_id is not None]),
        'risque': len([p for p in tous_plans if p.risque_id is not None]),
        'independant': len([p for p in tous_plans if p.audit_id is None and p.risque_id is None]),
        'en_attente': len([p for p in tous_plans if p.statut == 'en_attente']),
        'en_cours': len([p for p in tous_plans if p.statut == 'en_cours']),
        'termines': len([p for p in tous_plans if p.statut == 'termine']),
        'suspendus': len([p for p in tous_plans if p.statut == 'suspendu']),
        'annules': len([p for p in tous_plans if p.statut == 'annule']),
        'urgences': 0,
        'en_retard': 0,
        'moyenne_realisation': 0
    }
    
    # ========================
    # 3. APPLIQUER LES FILTRES POUR LA LISTE AFFICH√âE
    # ========================
    query = get_client_filter(PlanAction)
    
    # Appliquer le filtre par type
    if type_filtre == 'audit':
        query = query.filter(PlanAction.audit_id.isnot(None))
        print(f"   üìã Filtre: Plans d'audit uniquement")
    elif type_filtre == 'risque':
        query = query.filter(PlanAction.risque_id.isnot(None))
        print(f"   üìã Filtre: Plans de risque uniquement")
    elif type_filtre == 'independant':
        query = query.filter(
            PlanAction.audit_id.is_(None),
            PlanAction.risque_id.is_(None)
        )
        print(f"   üìã Filtre: Plans ind√©pendants uniquement")
    else:
        print(f"   üìã Filtre: Tous les plans")
    
    # Appliquer le filtre par statut
    if filtre_statut != 'tous':
        query = query.filter(PlanAction.statut == filtre_statut)
        print(f"   üìã Statut: {filtre_statut}")
    
    # R√©cup√©rer les plans filtr√©s
    plans_action = query.all()
    
    # V√©rifier l'acc√®s pour chaque plan et pr√©parer les donn√©es
    accessible_plans = []
    aujourdhui = datetime.now().date()
    total_realisation = 0
    
    for plan in plans_action:
        if check_client_access(plan):
            # Cr√©er un dictionnaire avec les donn√©es du plan
            plan_data = {
                'obj': plan,
                'type_plan': 'audit' if plan.audit_id else 'risque' if plan.risque_id else 'independant',
                'jours_restants': None,
                'etat_delai': 'non_defini',
                'jours_retard': 0,
                'pourcentage_global': 0,
                'source': None
            }
            
            # R√©cup√©rer la source
            if plan.audit_id:
                plan_data['source'] = get_client_filter(Audit).filter_by(id=plan.audit_id).first()
            elif plan.risque_id:
                plan_data['source'] = get_client_filter(Risque).filter_by(id=plan.risque_id).first()
            
            # Calculer les jours restants
            if plan.date_fin_prevue:
                jours_restants = (plan.date_fin_prevue - aujourdhui).days
                plan_data['jours_restants'] = jours_restants
                
                if jours_restants < 0:
                    plan_data['etat_delai'] = 'retarde'
                    plan_data['jours_retard'] = abs(jours_restants)
                    stats_globales['en_retard'] += 1
                elif jours_restants <= 7:
                    plan_data['etat_delai'] = 'urgence'
                    stats_globales['urgences'] += 1
                elif jours_restants <= 30:
                    plan_data['etat_delai'] = 'a_suivre'
                else:
                    plan_data['etat_delai'] = 'ok'
            
            # Calculer la progression
            if hasattr(plan, 'sous_actions') and plan.sous_actions:
                total_sous_actions = len(plan.sous_actions)
                if total_sous_actions > 0:
                    sous_actions_terminees = len([sa for sa in plan.sous_actions 
                                                 if sa.statut == 'termine'])
                    plan_data['pourcentage_global'] = round((sous_actions_terminees / total_sous_actions) * 100)
                else:
                    plan_data['pourcentage_global'] = 0
            else:
                plan_data['pourcentage_global'] = getattr(plan, 'pourcentage_realisation', 0) or 0
            
            total_realisation += plan_data['pourcentage_global']
            accessible_plans.append(plan_data)
    
    # Calculer la moyenne de r√©alisation pour les plans affich√©s
    if accessible_plans:
        stats_globales['moyenne_realisation'] = round(total_realisation / len(accessible_plans))
    
    # Appliquer le tri
    if tri == 'urgence':
        accessible_plans.sort(key=lambda p: (
            0 if p['etat_delai'] == 'retarde' else 
            1 if p['etat_delai'] == 'urgence' else 2,
            p['obj'].date_fin_prevue or datetime.max.date()
        ))
    elif tri == 'realisation_asc':
        accessible_plans.sort(key=lambda p: p['pourcentage_global'])
    elif tri == 'realisation_desc':
        accessible_plans.sort(key=lambda p: p['pourcentage_global'], reverse=True)
    elif tri == 'date_asc':
        accessible_plans.sort(key=lambda p: p['obj'].date_fin_prevue or datetime.min.date())
    elif tri == 'date_desc':
        accessible_plans.sort(key=lambda p: p['obj'].date_fin_prevue or datetime.min.date(), reverse=True)
    
    # ========================
    # DEBUG : Afficher ce qu'on a trouv√©
    # ========================
    print(f"\nüìä R√âSULTATS:")
    print(f"   Total plans: {len(plans_action)}")
    print(f"   Plans audit: {len([p for p in plans_action if p.audit_id])}")
    print(f"   Plans risque: {len([p for p in plans_action if p.risque_id])}")
    print(f"   Plans ind√©pendants: {len([p for p in plans_action if not p.audit_id and not p.risque_id])}")
    
    return render_template('audit/plans_action.html', 
                         plans_action=accessible_plans,
                         stats=stats_globales,  # ‚Üê Maintenant ce sont les stats globales
                         type_filtre=type_filtre,
                         filtre_statut=filtre_statut,
                         tri=tri,
                         aujourdhui=aujourdhui,
                         current_user=current_user)


@app.route('/plan-action-independant/<int:plan_id>/espace-travail', methods=['GET', 'POST'])
@login_required
def espace_travail_plan_action_independant(plan_id):
    """Espace de travail collaboratif pour un plan d'action ind√©pendant"""
    plan = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    # V√©rifier que c'est bien un plan ind√©pendant
    if plan.risque_id or plan.audit_id:
        flash('Ce plan n\'est pas un plan ind√©pendant', 'error')
        return redirect(url_for('liste_plans_action_independants'))
    
    # R√©cup√©rer les sous-actions
    sous_actions = SousAction.query.filter_by(plan_action_id=plan_id).all()
    
    # R√©cup√©rer les commentaires r√©cents
    commentaires = CommentairePlanAction.query\
        .filter_by(plan_action_id=plan_id)\
        .order_by(CommentairePlanAction.created_at.desc())\
        .limit(50)\
        .all()
    
    # R√©cup√©rer les fichiers r√©cents
    fichiers = FichierPlanAction.query\
        .filter_by(plan_action_id=plan_id)\
        .order_by(FichierPlanAction.created_at.desc())\
        .limit(20)\
        .all()
    
    # Formulaire pour ajouter un commentaire
    from flask_wtf import FlaskForm
    from wtforms import TextAreaField, SelectField, BooleanField, StringField
    from wtforms.validators import DataRequired, Optional
    
    class CommentaireForm(FlaskForm):
        contenu = TextAreaField('Commentaire', validators=[DataRequired()])
        type_contenu = SelectField('Type', choices=[
            ('commentaire', 'Commentaire g√©n√©ral'),
            ('note', 'Note importante'),
            ('mise_a_jour', 'Mise √† jour de progression'),
            ('question', 'Question'),
            ('blocage', 'Signalement de blocage'),
            ('reussite', 'Succ√®s accompli')
        ], default='commentaire')
        sous_action_id = SelectField('Lier √† une sous-action', coerce=int, choices=[], validators=[Optional()])
        tags = StringField('Tags', validators=[Optional()])
        est_prive = BooleanField('Priv√©')
    
    form_commentaire = CommentaireForm()
    
    # Pr√©parer les choix pour les sous-actions
    form_commentaire.sous_action_id.choices = [(0, 'Plan g√©n√©ral')] + \
        [(sa.id, f"{sa.reference or f'SA-{sa.id}'}: {sa.description[:50]}...") 
         for sa in sous_actions]
    
    if request.method == 'POST' and form_commentaire.validate_on_submit():
        try:
            # Cr√©er un nouveau commentaire
            commentaire = CommentairePlanAction(
                plan_action_id=plan_id,
                sous_action_id=form_commentaire.sous_action_id.data if form_commentaire.sous_action_id.data != 0 else None,
                utilisateur_id=current_user.id,
                contenu=form_commentaire.contenu.data,
                type_contenu=form_commentaire.type_contenu.data,
                est_prive=form_commentaire.est_prive.data,
                tags=form_commentaire.tags.data.split(',') if form_commentaire.tags.data else [],
                client_id=current_user.client_id
            )
            
            db.session.add(commentaire)
            db.session.commit()
            
            # G√©rer les fichiers upload√©s
            fichiers = request.files.getlist('fichiers')
            for fichier in fichiers:
                if fichier and fichier.filename:
                    save_fichier_plan_action(fichier, plan_id, commentaire.id, current_user.id)
            
            flash('Commentaire ajout√© avec succ√®s', 'success')
            return redirect(url_for('espace_travail_plan_action_independant', plan_id=plan_id))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur: {str(e)}', 'error')
            print(f"Erreur ajout commentaire: {e}")
    
    return render_template('plans_action/espace_travail_independant.html',
                         plan=plan,
                         sous_actions=sous_actions,
                         commentaires=commentaires,
                         fichiers=fichiers,
                         form_commentaire=form_commentaire,
                         current_user=current_user)

@app.route('/plan-action-independant/<int:plan_id>/sous-action/nouveau', methods=['GET', 'POST'])
@login_required
def nouveau_sous_action_independant(plan_id):
    """Ajouter une sous-action √† un plan ind√©pendant"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    if not check_client_access(plan_action):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_plan_action_independant', plan_id=plan_id))
    
    # V√©rifier que c'est bien un plan ind√©pendant
    if plan_action.risque_id or plan_action.audit_id:
        flash('Ce plan n\'est pas un plan ind√©pendant', 'error')
        return redirect(url_for('liste_plans_action_independants'))
    
    # V√©rifier les permissions
    if (current_user.id != plan_action.created_by and 
        not current_user.has_permission('can_manage_plans')):
        flash('Vous n\'√™tes pas autoris√© √† ajouter des sous-actions', 'error')
        return redirect(url_for('detail_plan_action_independant', plan_id=plan_id))
    
    # Cr√©er un formulaire personnalis√© pour la sous-action
    from flask_wtf import FlaskForm
    from wtforms import TextAreaField, SelectField, DateField
    from wtforms.validators import DataRequired, Optional
    
    class SousActionForm(FlaskForm):
        description = TextAreaField('Description', validators=[DataRequired()])
        responsable_id = SelectField('Responsable', coerce=int, choices=[], validators=[Optional()])
        date_debut = DateField('Date de d√©but', format='%Y-%m-%d', validators=[Optional()])
        date_fin_prevue = DateField('Date d\'√©ch√©ance', format='%Y-%m-%d', validators=[Optional()])
    
    form = SousActionForm()
    
    # Pr√©parer les choix
    utilisateurs = get_client_filter(User).filter_by(is_active=True).all()
    form.responsable_id.choices = [(0, 'Non assign√©')] + \
        [(u.id, f"{u.username} - {u.role}") for u in utilisateurs]
    
    if request.method == 'GET':
        form.date_debut.data = datetime.now().date()
        form.date_fin_prevue.data = (datetime.now() + timedelta(days=14)).date()
    
    if form.validate_on_submit():
        # G√©n√©rer une r√©f√©rence
        dernier_sous_action = SousAction.query\
            .filter_by(plan_action_id=plan_id)\
            .order_by(SousAction.id.desc())\
            .first()
        
        reference = f"SA-{plan_action.reference}-{(dernier_sous_action.id + 1) if dernier_sous_action else 1:03d}"
        
        sous_action = SousAction(
            plan_action_id=plan_id,
            reference=reference,
            description=form.description.data,
            date_debut=form.date_debut.data,
            date_fin_prevue=form.date_fin_prevue.data,
            responsable_id=form.responsable_id.data if form.responsable_id.data != 0 else None,
            statut='a_faire',
            pourcentage_realisation=0,
            client_id=current_user.client_id
        )
        
        db.session.add(sous_action)
        db.session.commit()
        
        flash('Sous-action ajout√©e avec succ√®s', 'success')
        return redirect(url_for('detail_plan_action_independant', plan_id=plan_id))
    
    return render_template('plans_action/form_sous_action_independant.html',
                         form=form,
                         plan=plan_action,
                         action='creer')


@app.route('/plan-action-independant/<int:plan_id>/commentaire/<int:commentaire_id>/supprimer', methods=['POST'])
@login_required
def supprimer_commentaire_plan_action_independant(plan_id, commentaire_id):
    """Supprimer un commentaire de l'espace de travail d'un plan ind√©pendant"""
    commentaire = CommentairePlanAction.query.get_or_404(commentaire_id)
    
    if not check_client_access(commentaire):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('espace_travail_plan_action_independant', plan_id=plan_id))
    
    # V√©rifier que l'utilisateur est l'auteur ou admin
    if commentaire.utilisateur_id != current_user.id and not current_user.is_client_admin:
        flash('Vous ne pouvez supprimer que vos propres commentaires', 'error')
        return redirect(url_for('espace_travail_plan_action_independant', plan_id=plan_id))
    
    try:
        # Supprimer les fichiers associ√©s
        for fichier in commentaire.fichiers:
            supprimer_fichier_plan_action(fichier.id)
        
        db.session.delete(commentaire)
        db.session.commit()
        flash('Commentaire supprim√© avec succ√®s', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur: {str(e)}', 'error')
    
    return redirect(url_for('espace_travail_plan_action_independant', plan_id=plan_id))




@app.route('/audit/rapports')
@login_required
def rapports_audit():
    """Page des rapports d'audit - VERSION CORRIG√âE avec multi-tenant"""
    
    # R√©cup√©rer les audits avec filtrage multi-tenant
    audits = get_multi_tenant_filter(Audit).all()
    
    # Cr√©er un dictionnaire des audits pour un acc√®s facile par ID
    audits_dict = {audit.id: audit for audit in audits}
    
    # R√©cup√©rer les fichiers associ√©s aux audits (si vous avez un mod√®le FichierRapport)
    fichiers_par_audit = {}
    
    if audits:
        audit_ids = [audit.id for audit in audits]
        
        # Version 1: Si vous avez un mod√®le FichierRapport qui r√©f√©rence les audits
        # from models import FichierRapport
        # fichiers_query = get_multi_tenant_filter(FichierRapport).filter(FichierRapport.audit_id.in_(audit_ids))
        # for fichier in fichiers_query.all():
        #     if fichier.audit_id not in fichiers_par_audit:
        #         fichiers_par_audit[fichier.audit_id] = []
        #     fichiers_par_audit[fichier.audit_id].append(fichier)
        
        # Version 2: Si vos audits ont une relation directe avec les fichiers
        for audit in audits:
            fichiers_par_audit[audit.id] = []
            # Si votre mod√®le Audit a une relation avec les fichiers :
            # if hasattr(audit, 'fichiers') and audit.fichiers:
            #     fichiers_par_audit[audit.id] = audit.fichiers
    
    # Si aucun audit trouv√© pour le client actuel
    if not audits:
        return render_template('audit/rapports.html',
                             audits=[],
                             audits_dict={},
                             fichiers_par_audit={},
                             constatations_total=0,
                             recommandations_total=0,
                             plans_action_total=0,
                             types_audit={'labels': [], 'data': []},
                             statuts_audit={'labels': [], 'data': []})
    
    # Statistiques pour les rapports (calcul√©es sur les audits filtr√©s)
    constatations_total = sum(len(audit.constatations) for audit in audits)
    recommandations_total = sum(len(audit.recommandations) for audit in audits)
    plans_action_total = sum(len(audit.plans_action) for audit in audits)
    
    # Donn√©es pour les graphiques - avec filtrage multi-tenant
    types_audit_data = {}
    for audit_type in ['interne', 'externe', 'qualite', 'conformite', 'securite', 'financier']:
        types_audit_data[audit_type] = get_multi_tenant_filter(Audit)\
            .filter_by(type_audit=audit_type)\
            .count()
    
    types_audit = {
        'labels': ['Interne', 'Externe', 'Qualit√©', 'Conformit√©', 'S√©curit√©', 'Financier'],
        'data': [
            types_audit_data['interne'],
            types_audit_data['externe'], 
            types_audit_data['qualite'],
            types_audit_data['conformite'],
            types_audit_data['securite'],
            types_audit_data['financier']
        ]
    }
    
    # Statuts des audits - avec filtrage multi-tenant
    statuts_audit = {
        'labels': ['Planifi√©', 'En cours', 'Termin√©', 'Annul√©'],
        'data': [
            get_multi_tenant_filter(Audit).filter_by(statut='planifie').count(),
            get_multi_tenant_filter(Audit).filter_by(statut='en_cours').count(),
            get_multi_tenant_filter(Audit).filter_by(statut='termine').count(),
            get_multi_tenant_filter(Audit).filter_by(statut='annule').count()
        ]
    }
    
    # Autres statistiques utiles
    audits_par_annee = {}
    audits_par_responsable = {}
    audits_par_processus = {}
    
    for audit in audits:
        # Statistiques par ann√©e
        if audit.date_debut_prevue:
            annee = audit.date_debut_prevue.year
            audits_par_annee[annee] = audits_par_annee.get(annee, 0) + 1
        
        # Statistiques par responsable
        if audit.responsable:
            responsable_nom = audit.responsable.username
            audits_par_responsable[responsable_nom] = audits_par_responsable.get(responsable_nom, 0) + 1
        
        # Statistiques par processus
        if audit.processus_concerne:
            audits_par_processus[audit.processus_concerne] = audits_par_processus.get(audit.processus_concerne, 0) + 1
        elif audit.processus and audit.processus.nom:
            audits_par_processus[audit.processus.nom] = audits_par_processus.get(audit.processus.nom, 0) + 1
    
    return render_template('audit/rapports.html',
                         audits=audits,
                         audits_dict=audits_dict,  # ‚Üê AJOUT IMPORTANT
                         fichiers_par_audit=fichiers_par_audit,
                         constatations_total=constatations_total,
                         recommandations_total=recommandations_total,
                         plans_action_total=plans_action_total,
                         types_audit=types_audit,
                         statuts_audit=statuts_audit,
                         audits_par_annee=audits_par_annee,
                         audits_par_responsable=audits_par_responsable,
                         audits_par_processus=audits_par_processus,
                         datetime=datetime)  # ‚Üê N'oubliez pas datetime pour le template




# ============================================================================
# ROUTES API POUR AUDIT
# ============================================================================

@app.route('/api/audit/statistiques-globales')
@login_required
def api_statistiques_audit_globales():
    """API pour les statistiques globales des audits"""
    audits = Audit.query.all()
    
    stats = {
        'total_audits': len(audits),
        'audits_en_cours': len([a for a in audits if a.statut == 'en_cours']),
        'audits_termines': len([a for a in audits if a.statut == 'termine']),
        'total_constatations': sum(len(a.constatations) for a in audits),
        'total_recommandations': sum(len(a.recommandations) for a in audits),
        'total_plans_action': sum(len(a.plans_action) for a in audits),
        'plans_action_en_retard': len([
            p for a in audits for p in a.plans_action 
            if p.date_fin_prevue and p.date_fin_prevue < datetime.now().date() and p.statut != 'termine'
        ])
    }
    
    return jsonify(stats)


# Dans votre app.py, modifiez la route nouvelle_constatation :

@app.route('/audit/<int:audit_id>/constatation/nouvelle', methods=['POST'])
@csrf.exempt
@login_required
def nouvelle_constatation(audit_id):
    """Cr√©er une nouvelle constatation pour un audit"""
    audit = Audit.query.get_or_404(audit_id)
    
    # V√©rifier les permissions
    peut_ajouter = (
        current_user.role == 'admin' or
        current_user.id == audit.created_by or
        current_user.id == audit.responsable_id or
        str(current_user.id) in (audit.equipe_audit_ids or '').split(',')
    )
    
    if not peut_ajouter:
        flash('Non autoris√© √† ajouter des constatations', 'error')
        return redirect(url_for('detail_audit', id=audit_id))
    
    try:
        # G√©n√©rer la r√©f√©rence
        dernier_constat = Constatation.query.filter_by(audit_id=audit_id)\
                                           .order_by(Constatation.id.desc())\
                                           .first()
        nouvelle_ref = f"CON-{audit.reference}-{(dernier_constat.id + 1) if dernier_constat else 1:03d}"
        
        # Cr√©er la constatation
        constatation = Constatation(
            reference=nouvelle_ref,
            description=request.form.get('description', '').strip(),
            type_constatation=request.form.get('type_constatation', 'non_conformite'),
            gravite=request.form.get('gravite', 'moyenne'),
            audit_id=audit_id,
            created_by=current_user.id,
            client_id=audit.client_id if audit.client_id else current_user.client_id
        )
        
        # Journaliser
        journal_entry = JournalAudit(
            audit_id=audit_id,
            action='creation_constatation',
            details={
                'reference': constatation.reference,
                'type': constatation.type_constatation,
                'gravite': constatation.gravite
            },
            utilisateur_id=current_user.id,
            signature=current_user.username,
            client_id=audit.client_id if audit.client_id else current_user.client_id
        )
        
        db.session.add(constatation)
        db.session.add(journal_entry)
        db.session.commit()
        
        flash('Constatation cr√©√©e avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la cr√©ation: {str(e)}', 'error')
    
    return redirect(url_for('detail_audit', id=audit_id))



@app.route('/constatation/<int:constatation_id>/upload-fichier', methods=['POST'])
@csrf.exempt
@login_required
def upload_fichier_constatation(constatation_id):
    """Uploader un fichier pour une constatation"""
    constatation = Constatation.query.get_or_404(constatation_id)
    
    if 'fichier' not in request.files:
        return jsonify({'success': False, 'message': 'Aucun fichier s√©lectionn√©'}), 400
    
    fichier = request.files['fichier']
    
    if fichier.filename == '':
        return jsonify({'success': False, 'message': 'Aucun fichier s√©lectionn√©'}), 400
    
    if fichier and allowed_file(fichier.filename):
        try:
            filename = secure_filename(fichier.filename)
            # Cr√©er un dossier sp√©cifique pour la constatation
            constat_folder = os.path.join(app.config['UPLOAD_FOLDER_RISQUES'], 
                                         f'constatation_{constatation_id}')
            os.makedirs(constat_folder, exist_ok=True)
            
            filepath = os.path.join(constat_folder, filename)
            fichier.save(filepath)
            
            # Mettre √† jour la liste des fichiers
            fichiers_ids = constatation.fichiers_ids or ''
            nouveaux_fichiers = fichiers_ids + f'{filename},' if fichiers_ids else f'{filename},'
            constatation.fichiers_ids = nouveaux_fichiers
            constatation.updated_at = datetime.utcnow()
            
            db.session.commit()
            
            # Journaliser
            journaliser_action_audit(
                audit_id=constatation.audit_id,
                action_type='upload_fichier_constatation',
                user_id=current_user.id,
                details={'fichier': filename, 'constatation': constatation.reference}
            )
            
            return jsonify({
                'success': True,
                'message': 'Fichier upload√© avec succ√®s',
                'filename': filename
            })
            
        except Exception as e:
            db.session.rollback()
            return jsonify({'success': False, 'message': str(e)}), 500
    
    return jsonify({'success': False, 'message': 'Type de fichier non autoris√©'}), 400

@app.route('/plan-action/<int:plan_id>/sous-action/ajouter', methods=['POST'])
@csrf.exempt
@login_required
def ajouter_sous_action(plan_id):
    """Ajouter une sous-action √† un plan d'action"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    try:
        # R√©cup√©rer les donn√©es du formulaire
        description = request.form.get('description', '').strip()
        date_debut = request.form.get('date_debut')
        date_fin_prevue = request.form.get('date_fin_prevue')
        responsable_id = request.form.get('responsable_id')
        pourcentage_realisation = request.form.get('pourcentage_realisation', '0')
        
        # Validation
        if not description:
            flash('La description est requise', 'error')
            return redirect(url_for('detail_plan_action', plan_id=plan_id))
        
        # G√©n√©rer une r√©f√©rence
        dernier_sous_action = SousAction.query.filter_by(plan_action_id=plan_id)\
                                              .order_by(SousAction.id.desc())\
                                              .first()
        reference = f"SA-{plan_id:03d}-{(dernier_sous_action.id + 1) if dernier_sous_action else 1:03d}"
        
        # Cr√©er la sous-action
        sous_action = SousAction(
            plan_action_id=plan_id,
            reference=reference,
            description=description,
            date_debut=datetime.strptime(date_debut, '%Y-%m-%d').date() if date_debut else None,
            date_fin_prevue=datetime.strptime(date_fin_prevue, '%Y-%m-%d').date() if date_fin_prevue else None,
            responsable_id=int(responsable_id) if responsable_id else None,
            pourcentage_realisation=int(pourcentage_realisation),
            statut='a_faire' if int(pourcentage_realisation) == 0 else 'en_cours'
        )
        
        db.session.add(sous_action)
        db.session.commit()
        
        # Mettre √† jour la progression du plan parent
        plan_action.updated_at = datetime.utcnow()
        db.session.commit()
        
        flash('Sous-action ajout√©e avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de l\'ajout: {str(e)}', 'error')
    
    return redirect(url_for('detail_plan_action', plan_id=plan_id))

@app.route('/sous-action/<int:sous_action_id>/modifier', methods=['POST'])
@csrf.exempt
@login_required
def modifier_sous_action(sous_action_id):
    """Modifier une sous-action"""
    sous_action = SousAction.query.get_or_404(sous_action_id)
    
    try:
        # R√©cup√©rer les donn√©es du formulaire
        sous_action.description = request.form.get('description', '').strip()
        
        # Dates
        date_debut = request.form.get('date_debut')
        date_fin_prevue = request.form.get('date_fin_prevue')
        
        if date_debut:
            sous_action.date_debut = datetime.strptime(date_debut, '%Y-%m-%d').date()
        if date_fin_prevue:
            sous_action.date_fin_prevue = datetime.strptime(date_fin_prevue, '%Y-%m-%d').date()
        
        # Responsable
        responsable_id = request.form.get('responsable_id')
        sous_action.responsable_id = int(responsable_id) if responsable_id else None
        
        # Pourcentage et statut
        pourcentage = request.form.get('pourcentage_realisation', '0')
        sous_action.pourcentage_realisation = int(pourcentage)
        
        # Mettre √† jour le statut en fonction du pourcentage
        if int(pourcentage) == 0:
            sous_action.statut = 'a_faire'
        elif int(pourcentage) < 100:
            sous_action.statut = 'en_cours'
        else:
            sous_action.statut = 'termine'
            sous_action.date_fin_reelle = datetime.utcnow().date()
        
        sous_action.updated_at = datetime.utcnow()
        db.session.commit()
        
        flash('Sous-action modifi√©e avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la modification: {str(e)}', 'error')
    
    return redirect(url_for('detail_plan_action', plan_id=sous_action.plan_action_id))


@app.route('/sous-action/<int:sous_action_id>/maj-progression', methods=['POST'])
@csrf.exempt
@login_required
def maj_progression_sous_action(sous_action_id):
    """Mettre √† jour la progression d'une sous-action"""
    sous_action = SousAction.query.get_or_404(sous_action_id)
    plan = sous_action.plan_action
    
    if not current_user.can_edit_plan(plan):
        return jsonify({'success': False, 'message': 'Permission refus√©e'}), 403
    
    try:
        ancienne_progression = sous_action.pourcentage_realisation
        nouvelle_progression = int(request.form.get('progression', 0))
        
        sous_action.pourcentage_realisation = nouvelle_progression
        
        # Mettre √† jour le statut
        if nouvelle_progression == 100:
            sous_action.statut = 'termine'
            sous_action.date_fin_reelle = datetime.utcnow().date()
        elif nouvelle_progression > 0:
            sous_action.statut = 'en_cours'
        else:
            sous_action.statut = 'a_faire'
        
        # Mettre √† jour la progression du plan parent
        plan.pourcentage_realisation = plan.progression_reelle
        
        # Si toutes les sous-actions sont termin√©es, terminer le plan
        if all(s.pourcentage_realisation == 100 for s in plan.sous_actions):
            plan.statut = 'termine'
            plan.date_fin_reelle = datetime.utcnow().date()
            
            # Mettre √† jour la recommandation associ√©e
            if plan.recommandation:
                plan.recommandation.statut = 'termine'
                plan.recommandation.taux_avancement = 100
        
        db.session.commit()
        
        # Journaliser
        journaliser_action_audit(
            audit_id=plan.audit_id,
            action_type='maj_progression_sous_action',
            user_id=current_user.id,
            details={
                'sous_action': sous_action.description[:50],
                'ancien': ancienne_progression,
                'nouveau': nouvelle_progression
            }
        )
        
        return jsonify({
            'success': True,
            'progression_plan': plan.progression_reelle,
            'statut_plan': plan.statut
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/plan-action/<int:plan_id>/gantt')
@login_required
def gantt_plan_action(plan_id):
    """Afficher le diagramme de Gantt du plan d'action"""
    plan = PlanAction.query.get_or_404(plan_id)
    
    # Pr√©parer les donn√©es pour le Gantt
    gantt_data = []
    
    # Ajouter le plan principal
    if plan.date_debut and plan.date_fin_prevue:
        gantt_data.append({
            'id': plan.id,
            'text': plan.nom,
            'start_date': plan.date_debut.isoformat(),
            'end_date': plan.date_fin_prevue.isoformat(),
            'progress': plan.progression_reelle / 100,
            'open': True,
            'type': 'project'
        })
    
    # Ajouter les sous-actions
    for sous_action in plan.sous_actions:
        if sous_action.date_debut and sous_action.date_fin_prevue:
            gantt_data.append({
                'id': f'sa_{sous_action.id}',
                'text': sous_action.description[:50],
                'start_date': sous_action.date_debut.isoformat(),
                'end_date': sous_action.date_fin_prevue.isoformat(),
                'progress': sous_action.pourcentage_realisation / 100,
                'parent': plan.id,
                'type': 'task'
            })
    
    return render_template('audit/gantt.html',
                         plan=plan,
                         gantt_data=gantt_data)



# ============================================================================
# ROUTES POUR LES NOTIFICATIONS
# ============================================================================


@app.route('/notification/<int:notification_id>/marquer-lue', methods=['POST'])
@csrf.exempt
@login_required
def marquer_notification_lue(notification_id):
    """Marquer une notification comme lue"""
    notification = Notification.query.get_or_404(notification_id)
    
    if notification.destinataire_id != current_user.id:
        return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
    
    notification.est_lue = True
    db.session.commit()
    
    return jsonify({'success': True})

@app.route('/notifications/marquer-toutes-lues', methods=['POST'])
@csrf.exempt
@login_required
def marquer_toutes_notifications_lues():
    """Marquer toutes les notifications comme lues"""
    Notification.query.filter_by(destinataire_id=current_user.id, est_lue=False)\
                     .update({'est_lue': True})
    db.session.commit()
    
    return jsonify({'success': True})


# ============================================================================
# FONCTIONS UTILITAIRES
# ============================================================================

def journaliser_action_audit(audit_id, action_type, user_id, details=None):
    """Journaliser les actions sur les audits"""
    try:
        journal = JournalAudit(
            audit_id=audit_id,
            action=action_type,
            details=details or {},
            utilisateur_id=user_id,
            signature=current_user.username  # Signature basique
        )
        
        db.session.add(journal)
        db.session.commit()
        
        # Mettre √† jour la date de modification de l'audit
        audit = Audit.query.get(audit_id)
        if audit:
            audit.updated_at = datetime.utcnow()
            db.session.commit()
        
    except Exception as e:
        print(f"‚ùå Erreur journalisation: {str(e)}")
        db.session.rollback()

def creer_notification(type_notification, titre, message, destinataire_id, entite_type=None, entite_id=None):
    """
    Fonction de compatibilit√© pour l'ancien syst√®me
    Utilise le nouveau syst√®me si disponible
    """
    try:
        from services.notification_service import NotificationService
        
        # Convertir l'ancien type au nouveau format
        type_mapping = {
            'nouvelle_constatation': Notification.TYPE_CONSTATATION,
            'nouveau_plan': Notification.TYPE_PLAN,
            'kri_alerte': Notification.TYPE_KRI_ALERTE,
            'success': Notification.TYPE_SUCCESS,
            'info': Notification.TYPE_INFO,
            'warning': Notification.TYPE_WARNING,
            'error': Notification.TYPE_ERROR
        }
        
        type_notif = type_mapping.get(type_notification, Notification.TYPE_INFO)
        
        notification = NotificationService.create(
            destinataire_id=destinataire_id,
            type_notif=type_notif,
            titre=titre,
            message=message,
            entite_type=entite_type,
            entite_id=entite_id,
            user_id=current_user.id if hasattr(current_user, 'id') else None
        )
        
        return notification
        
    except ImportError:
        # Ancien syst√®me
        from models import Notification
        
        notification = Notification(
            type_notification=type_notification,
            titre=titre,
            message=message,
            destinataire_id=destinataire_id,
            entite_type=entite_type,
            entite_id=entite_id
        )
        
        db.session.add(notification)
        db.session.commit()
        
        print(f"üì¢ Notification cr√©√©e (ancien syst√®me): {titre}")
        return notification

def envoyer_notification_email(notification):
    """Envoyer une notification par email"""
    # √Ä impl√©menter selon votre configuration email
    pass

def verifier_echeances_plans():
    """V√©rifier les √©ch√©ances des plans d'action et cr√©er des alertes"""
    aujourdhui = datetime.utcnow().date()
    
    # Plans dont l'√©ch√©ance est dans 7 jours
    echeance_proche = aujourdhui + timedelta(days=7)
    
    plans_proches = PlanAction.query.filter(
        PlanAction.date_fin_prevue == echeance_proche,
        PlanAction.statut.in_(['en_attente', 'en_cours'])
    ).all()
    
    for plan in plans_proches:
        creer_notification(
            type_notification='echeance_proche',
            titre=f"√âch√©ance proche pour le plan {plan.nom}",
            message=f"Le plan {plan.nom} arrive √† √©ch√©ance dans 7 jours",
            destinataire_id=plan.responsable_id or plan.audit.responsable_id,
            entite_type='plan_action',
            entite_id=plan.id
        )
    
    # Plans en retard
    plans_retard = PlanAction.query.filter(
        PlanAction.date_fin_prevue < aujourdhui,
        PlanAction.statut.in_(['en_attente', 'en_cours']),
        PlanAction.est_en_retard == True
    ).all()
    
    for plan in plans_retard:
        creer_notification(
            type_notification='retard',
            titre=f"Retard sur le plan {plan.nom}",
            message=f"Le plan {plan.nom} est en retard depuis {abs((aujourdhui - plan.date_fin_prevue).days)} jours",
            destinataire_id=plan.responsable_id or plan.audit.responsable_id,
            entite_type='plan_action',
            entite_id=plan.id
        )


# ============================================================================
# ROUTES POUR LA GESTION DES RECOMMANDATIONS AVANC√âES
# ============================================================================

@app.route('/recommandation/<int:recommandation_id>/ajouter-histoire', methods=['POST'])
@csrf.exempt
@login_required
def ajouter_histoire_recommandation(recommandation_id):
    """Ajouter une entr√©e dans l'historique de la recommandation"""
    recommandation = Recommandation.query.get_or_404(recommandation_id)
    
    action = request.form.get('action')
    details = {
        'champ': request.form.get('champ'),
        'ancienne_valeur': request.form.get('ancienne_valeur'),
        'nouvelle_valeur': request.form.get('nouvelle_valeur'),
        'commentaire': request.form.get('commentaire')
    }
    
    historique = HistoriqueRecommandation(
        recommandation_id=recommandation_id,
        action=action,
        details=details,
        utilisateur_id=current_user.id
    )
    
    db.session.add(historique)
    db.session.commit()
    
    return jsonify({'success': True, 'message': 'Historique ajout√©'})


@app.route('/audit/<int:audit_id>/recommandation/nouvelle', methods=['POST'])
@csrf.exempt
@login_required
def nouvelle_recommandation(audit_id):
    """Ajouter une recommandation √† un audit"""
    audit = Audit.query.get_or_404(audit_id)
    
    try:
        # R√©cup√©rer les donn√©es du formulaire
        description = request.form.get('description', '').strip()
        type_recommandation = request.form.get('type_recommandation', '').strip()
        delai_str = request.form.get('delai_mise_en_oeuvre', '').strip()
        
        # VALIDATION
        if not description:
            flash('La description est requise', 'error')
            return redirect(url_for('detail_audit', id=audit_id))
        
        if not type_recommandation:
            flash('Le type de recommandation est requis', 'error')
            return redirect(url_for('detail_audit', id=audit_id))
        
        # G√âN√âRER UNE R√âF√âRENCE
        # Compter les recommandations existantes pour cet audit
        count = Recommandation.query.filter_by(audit_id=audit_id).count()
        
        # Utiliser la r√©f√©rence de l'audit ou cr√©er une r√©f√©rence par d√©faut
        audit_ref = audit.reference if audit.reference else f"AUD{audit_id:04d}"
        audit_ref_clean = audit_ref.replace('AUD-', '').strip()
        
        # G√©n√©rer la r√©f√©rence
        reference = f"REC-{audit_ref_clean}-{(count + 1):03d}"
        
        # Traiter date_echeance
        date_echeance_str = request.form.get('date_echeance')
        date_echeance = None
        
        if date_echeance_str and date_echeance_str.strip():
            try:
                date_echeance = datetime.strptime(date_echeance_str, '%Y-%m-%d').date()
            except ValueError:
                flash('Format de date invalide', 'error')
                return redirect(url_for('detail_audit', id=audit_id))
        
        # Cr√©er la recommandation AVEC LES CHAMPS TEXTUELS
        recommandation = Recommandation(
            reference=reference,  # IMPORTANT: ne pas oublier ce champ !
            description=description,
            type_recommandation=type_recommandation,
            delai_mise_en_oeuvre=delai_str if delai_str else None,  # TEXTE, pas num√©rique
            date_echeance=date_echeance,
            audit_id=audit_id,
            constatation_id=request.form.get('constatation_id') if request.form.get('constatation_id') else None,
            risque_id=request.form.get('risque_id') if request.form.get('risque_id') else None,
            responsable_id=request.form.get('responsable_id') if request.form.get('responsable_id') else None,
            created_by=current_user.id,
            # Ajouter les champs de priorit√© si pr√©sents dans le formulaire
            urgence=int(request.form.get('urgence', 1)),
            impact_operationnel=int(request.form.get('impact_operationnel', 1))
        )
        
        db.session.add(recommandation)
        db.session.commit()
        
        flash(f'Recommandation {reference} ajout√©e avec succ√®s', 'success')
        
    except ValueError as e:
        db.session.rollback()
        flash(f'Erreur de valeur: {str(e)}', 'error')
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur d√©taill√©e: {str(e)}")
        import traceback
        traceback.print_exc()
        flash(f'Erreur lors de l\'ajout: {str(e)}', 'error')
    
    return redirect(url_for('detail_audit', id=audit_id))

@app.route('/audit/<int:audit_id>/plan-action/nouveau', methods=['POST'])
@csrf.exempt
@login_required
def nouveau_plan_action(audit_id):
    """Cr√©er un plan d'action pour un audit"""
    audit = Audit.query.get_or_404(audit_id)
    
    try:
        # 1. VALIDATION
        nom = request.form.get('nom', '').strip()
        if not nom:
            flash('Le nom du plan est requis', 'error')
            return redirect(url_for('detail_audit', id=audit_id))
        
        # 2. G√âN√âRATION DE LA R√âF√âRENCE
        import re
        import time
        
        # Compter les plans d'action existants pour cet audit
        count = PlanAction.query.filter_by(audit_id=audit_id).count()
        
        # Chercher le dernier plan pour trouver le dernier num√©ro
        last_plan = PlanAction.query.filter_by(audit_id=audit_id).order_by(PlanAction.id.desc()).first()
        
        if last_plan and last_plan.reference:
            # Extraire le num√©ro de la derni√®re r√©f√©rence
            match = re.search(r'-(\d{3,})$', last_plan.reference)
            if match:
                last_num = int(match.group(1))
                next_num = last_num + 1
            else:
                next_num = count + 1
        else:
            next_num = 1
        
        # Cr√©er la r√©f√©rence de l'audit
        audit_ref = audit.reference if audit.reference else f"AUD{audit_id:04d}"
        audit_ref_clean = audit_ref.replace('AUD-', '').strip()
        
        # G√©n√©rer la r√©f√©rence finale
        reference = f"PA-{audit_ref_clean}-{next_num:03d}"
        
        # V√âRIFIER QUE LA R√âF√âRENCE N'EXISTE PAS D√âJ√Ä
        while PlanAction.query.filter_by(reference=reference).first():
            next_num += 1
            reference = f"PA-{audit_ref_clean}-{next_num:03d}"
        
        print(f"üìù R√©f√©rence g√©n√©r√©e pour plan d'action: {reference}")
        
        # 3. CR√âATION DU PLAN D'ACTION
        plan_action = PlanAction(
            reference=reference,  # CHAMP OBLIGATOIRE REMPLI
            nom=nom,
            description=request.form.get('description', '').strip(),
            statut='en_attente',
            pourcentage_realisation=0,
            audit_id=audit_id,
            created_by=current_user.id,
            is_archived=False
        )
        
        # 4. TRAITEMENT DES CHAMPS OPTIONNELS
        # Dates
        date_debut_str = request.form.get('date_debut')
        date_fin_prevue_str = request.form.get('date_fin_prevue')
        
        if date_debut_str:
            try:
                plan_action.date_debut = datetime.strptime(date_debut_str, '%Y-%m-%d').date()
            except ValueError:
                pass
        
        if date_fin_prevue_str:
            try:
                plan_action.date_fin_prevue = datetime.strptime(date_fin_prevue_str, '%Y-%m-%d').date()
            except ValueError:
                pass
        
        # IDs optionnels
        for field in ['recommandation_id', 'risque_id', 'responsable_id']:
            value = request.form.get(field)
            if value and value.strip() and value.strip().isdigit():
                setattr(plan_action, field, int(value.strip()))
        
        # Constatations (peut √™tre une liste d'IDs s√©par√©s par des virgules)
        constatations_ids = request.form.get('constatations_ids', '')
        if constatations_ids:
            # Valider que ce sont des nombres
            ids_list = []
            for id_str in constatations_ids.split(','):
                id_str = id_str.strip()
                if id_str.isdigit():
                    ids_list.append(id_str)
            
            if ids_list:
                plan_action.constatations_ids = ','.join(ids_list)
        
        # 5. SAUVEGARDE
        db.session.add(plan_action)
        db.session.commit()
        
        flash(f'Plan d\'action {reference} cr√©√© avec succ√®s', 'success')
        
    except ValueError as e:
        db.session.rollback()
        flash(f'Erreur de valeur: {str(e)}', 'error')
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur d√©taill√©e: {str(e)}")
        import traceback
        traceback.print_exc()
        flash(f'Erreur lors de la cr√©ation: {str(e)}', 'error')
    
    return redirect(url_for('detail_audit', id=audit_id))

@app.route('/plan-action/<int:plan_id>/etape/nouvelle', methods=['POST'])
@csrf.exempt
@login_required
def nouvelle_etape_plan_action(plan_id):
    """Ajouter une √©tape √† un plan d'action"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    try:
        # Trouver le prochain ordre
        derniere_etape = EtapePlanAction.query.filter_by(plan_action_id=plan_id).order_by(EtapePlanAction.ordre.desc()).first()
        nouvel_ordre = (derniere_etape.ordre + 1) if derniere_etape else 1
        
        etape = EtapePlanAction(
            plan_action_id=plan_id,
            ordre=nouvel_ordre,
            description=request.form['description'],
            date_echeance=datetime.strptime(request.form['date_echeance'], '%Y-%m-%d').date() if request.form.get('date_echeance') else None,
            responsable_id=request.form.get('responsable_id') if request.form.get('responsable_id') else None
        )
        
        db.session.add(etape)
        db.session.commit()
        
        flash('√âtape ajout√©e avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de l\'ajout: {str(e)}', 'error')
    
    return redirect(url_for('detail_plan_action', plan_id=plan_id))

@app.route('/plan-action/<int:plan_id>')
@csrf.exempt
@login_required
def detail_plan_action(plan_id):
    """D√©tail d'un plan d'action avec ses √©tapes"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    users = User.query.all()
    
    return render_template('audit/detail_plan_action.html',
                         plan_action=plan_action,
                         users=users)

@app.route('/plan-action/<int:plan_id>/modifier-statut', methods=['POST'])
@csrf.exempt
@login_required
def modifier_statut_plan_action(plan_id):
    """Modifier le statut d'un plan d'action"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    nouveau_statut = request.form.get('statut')
    
    if nouveau_statut in ['en_attente', 'en_cours', 'termine', 'retarde']:
        ancien_statut = plan_action.statut
        plan_action.statut = nouveau_statut
        plan_action.updated_at = datetime.utcnow()
        
        # Si termin√©, mettre √† jour la date de fin r√©elle
        if nouveau_statut == 'termine':
            plan_action.date_fin_reelle = datetime.utcnow().date()
        
        db.session.commit()
        flash(f'Statut modifi√©: {ancien_statut} ‚Üí {nouveau_statut}', 'success')
    else:
        flash('Statut invalide', 'error')
    
    return redirect(url_for('detail_plan_action', plan_id=plan_id))



@app.route('/etape-plan-action/<int:etape_id>/modifier-statut', methods=['POST'])
@csrf.exempt
@login_required
def modifier_statut_etape_plan_action(etape_id):
    """Modifier le statut d'une √©tape de plan d'action"""
    etape = EtapePlanAction.query.get_or_404(etape_id)
    nouveau_statut = request.form.get('statut')
    
    if nouveau_statut in ['a_faire', 'en_cours', 'termine', 'retarde']:
        etape.statut = nouveau_statut
        etape.updated_at = datetime.utcnow()
        
        # Recalculer le pourcentage de r√©alisation du plan
        plan = etape.plan_action
        etapes = plan.etapes
        if etapes:
            etapes_terminees = len([e for e in etapes if e.statut == 'termine'])
            plan.pourcentage_realisation = int((etapes_terminees / len(etapes)) * 100)
        
        db.session.commit()
        flash(f'Statut de l\'√©tape modifi√©', 'success')
    else:
        flash('Statut invalide', 'error')
    
    return redirect(url_for('detail_plan_action', plan_id=etape.plan_action_id))

# ============================================================================
# ROUTES POUR LES RISQUES ET PLANS D'ACTION
# ============================================================================

@app.route('/risque/<int:risque_id>/plans-action')
@csrf.exempt
@login_required
def plans_action_risque(risque_id):
    """Liste des plans d'action li√©s √† un risque"""
    risque = Risque.query.get_or_404(risque_id)
    plans_action = PlanAction.query.filter_by(risque_id=risque_id).all()
    
    return render_template('audit/plans_action_risque.html',
                         risque=risque,
                         plans_action=plans_action)

@app.route('/questionnaire/<int:id>/changer-statut', methods=['POST'])
@csrf.exempt
@login_required
def changer_statut_questionnaire(id):
    """Changer le statut actif/inactif d'un questionnaire"""
    questionnaire = Questionnaire.query.get_or_404(id)
    
    # V√©rifier les permissions
    if not current_user.has_permission('can_manage_questionnaires'):
        flash('Vous n\'avez pas les permissions pour modifier ce questionnaire', 'error')
        return redirect(url_for('liste_questionnaires'))
    
    # Inverser le statut
    questionnaire.est_actif = not questionnaire.est_actif
    db.session.commit()
    
    status = 'activ√©' if questionnaire.est_actif else 'd√©sactiv√©'
    flash(f'Questionnaire {status} avec succ√®s', 'success')
    return redirect(url_for('liste_questionnaires'))

@app.route('/risque/<int:risque_id>/plan-action/nouveau', methods=['GET', 'POST'])
@csrf.exempt
@login_required
def nouveau_plan_action_risque(risque_id):
    """Cr√©er un plan d'action directement li√© √† un risque"""
    risque = Risque.query.get_or_404(risque_id)
    form = PlanActionForm()
    
    # Pr√©parer les choix
    form.responsable_id.choices = [(0, 'S√©lectionnez un responsable')] + [(u.id, u.username) for u in User.query.all()]
    
    if form.validate_on_submit():
        try:
            plan_action = PlanAction(
                nom=form.nom.data,
                description=form.description.data,
                date_debut=form.date_debut.data,
                date_fin_prevue=form.date_fin_prevue.data,
                risque_id=risque_id,
                responsable_id=form.responsable_id.data if form.responsable_id.data and form.responsable_id.data != 0 else None,
                created_by=current_user.id
            )
            
            db.session.add(plan_action)
            db.session.commit()
            
            flash('Plan d\'action cr√©√© avec succ√®s pour le risque', 'success')
            return redirect(url_for('plans_action_risque', risque_id=risque_id))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur lors de la cr√©ation: {str(e)}', 'error')
    
    return render_template('audit/form_plan_action_risque.html', form=form, risque=risque)

# ============================================================================
# ROUTES API POUR LES DONN√âES DYNAMIQUES
# ============================================================================

@app.route('/api/audit/<int:audit_id>/constatations')
@csrf.exempt
@login_required
def api_constatations_audit(audit_id):
    """API pour r√©cup√©rer les constatations d'un audit"""
    audit = Audit.query.get_or_404(audit_id)
    
    constatations = []
    for constat in audit.constatations:
        constatations.append({
            'id': constat.id,
            'reference': constat.reference,
            'description': constat.description,
            'type': constat.type_constatation,
            'gravite': constat.gravite
        })
    
    return jsonify(constatations)

@app.route('/api/risques/actifs')
@login_required
def api_risques_actifs():
    """API pour r√©cup√©rer les risques actifs"""
    risques = Risque.query.filter_by(is_archived=False).all()
    
    risques_data = []
    for risque in risques:
        risques_data.append({
            'id': risque.id,
            'reference': risque.reference,
            'intitule': risque.intitule,
            'categorie': risque.categorie
        })
    
    return jsonify(risques_data)

# ============================================================================
# ROUTES D'EXPORT POUR AUDIT
# ============================================================================

@app.route('/audit/<int:audit_id>/export/rapport-pdf')
@login_required
def export_rapport_audit_pdf(audit_id):
    """Exporter le rapport d'audit en PDF avec liste des fichiers"""
    from reportlab.lib.pagesizes import letter
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch
    from reportlab.lib import colors
    from io import BytesIO
    
    audit = get_client_object_or_404(Audit, audit_id)
    
    # V√©rifier les permissions
    peut_voir = (
        current_user.role == 'super_admin' or
        current_user.id == audit.created_by or
        current_user.id == audit.responsable_id or
        (audit.equipe_audit_ids and str(current_user.id) in audit.equipe_audit_ids.split(','))
    )
    
    if not peut_voir:
        flash('Vous n\'avez pas les permissions pour exporter ce rapport', 'error')
        return redirect(url_for('liste_audits'))
    
    # R√©cup√©rer les fichiers joints
    fichiers_rapport = get_client_filter(FichierRapport)\
        .filter_by(audit_id=audit_id)\
        .order_by(FichierRapport.created_at.desc()).all()
    
    # Cr√©er le PDF en m√©moire
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter)
    story = []
    styles = getSampleStyleSheet()
    
    # Style personnalis√©
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=16,
        spaceAfter=30
    )
    
    # Titre
    story.append(Paragraph(f"Rapport d'Audit - {audit.reference}", title_style))
    story.append(Paragraph(f"Titre: {audit.titre}", styles['Normal']))
    story.append(Spacer(1, 12))
    
    # Informations g√©n√©rales
    story.append(Paragraph("Informations G√©n√©rales", styles['Heading2']))
    
    info_data = [
        ['R√©f√©rence', audit.reference],
        ['Type', audit.type_audit],
        ['Statut', audit.statut],
        ['Responsable', audit.responsable.username if audit.responsable else 'Non d√©fini'],
        ['Dates', f"{audit.date_debut_prevue.strftime('%d/%m/%Y') if audit.date_debut_prevue else 'N/A'} - {audit.date_fin_prevue.strftime('%d/%m/%Y') if audit.date_fin_prevue else 'N/A'}"],
        ['Score global', f"{audit.score_global if hasattr(audit, 'score_global') else 0}/100"],
    ]
    
    info_table = Table(info_data, colWidths=[2*inch, 4*inch])
    info_table.setStyle(TableStyle([
        ('GRID', (0,0), (-1,-1), 1, colors.black),
        ('BACKGROUND', (0,0), (0,-1), colors.lightgrey),
    ]))
    story.append(info_table)
    story.append(Spacer(1, 20))
    
    # Fichiers joints (Nouvelle section)
    if fichiers_rapport:
        story.append(Paragraph("Fichiers joints au rapport", styles['Heading2']))
        
        fichiers_data = [['Nom du fichier', 'Type', 'Taille', 'Description', 'Date']]
        for fichier in fichiers_rapport:
            fichiers_data.append([
                fichier.nom_fichier[:30] + '...' if len(fichier.nom_fichier) > 30 else fichier.nom_fichier,
                fichier.type_fichier or 'N/A',
                fichier.taille_formatee if hasattr(fichier, 'taille_formatee') else 'N/A',
                fichier.description[:30] + '...' if fichier.description and len(fichier.description) > 30 else fichier.description or '',
                fichier.created_at.strftime('%d/%m/%Y') if fichier.created_at else 'N/A'
            ])
        
        fichiers_table = Table(fichiers_data, colWidths=[2*inch, 0.8*inch, 0.8*inch, 1.5*inch, 1*inch])
        fichiers_table.setStyle(TableStyle([
            ('GRID', (0,0), (-1,-1), 1, colors.black),
            ('BACKGROUND', (0,0), (-1,0), colors.lightgrey),
        ]))
        story.append(fichiers_table)
        story.append(Spacer(1, 20))
    
    # Constatations
    story.append(Paragraph("Constatations", styles['Heading2']))
    if audit.constatations:
        constat_data = [['R√©f.', 'Description', 'Type', 'Gravit√©', 'Statut']]
        for constat in audit.constatations:
            constat_data.append([
                constat.reference,
                constat.description[:100] + '...' if len(constat.description) > 100 else constat.description,
                constat.type_constatation,
                constat.gravite,
                constat.statut
            ])
        
        constat_table = Table(constat_data, colWidths=[0.5*inch, 2.5*inch, inch, inch, inch])
        constat_table.setStyle(TableStyle([
            ('GRID', (0,0), (-1,-1), 1, colors.black),
            ('BACKGROUND', (0,0), (-1,0), colors.lightgrey),
        ]))
        story.append(constat_table)
    else:
        story.append(Paragraph("Aucune constatation", styles['Normal']))
    
    story.append(Spacer(1, 20))
    
    # Recommandations
    story.append(Paragraph("Recommandations", styles['Heading2']))
    if audit.recommandations:
        reco_data = [['R√©f.', 'Description', 'Priorit√©', 'Statut', 'Avancement']]
        for reco in audit.recommandations:
            reco_data.append([
                reco.reference,
                reco.description[:80] + '...' if len(reco.description) > 80 else reco.description,
                reco.score_priorite,
                reco.statut,
                f"{reco.taux_avancement}%"
            ])
        
        reco_table = Table(reco_data, colWidths=[0.5*inch, 3*inch, 0.7*inch, inch, inch])
        reco_table.setStyle(TableStyle([
            ('GRID', (0,0), (-1,-1), 1, colors.black),
            ('BACKGROUND', (0,0), (-1,0), colors.lightgrey),
        ]))
        story.append(reco_table)
    
    story.append(Spacer(1, 20))
    
    # Pied de page
    story.append(Paragraph(f"G√©n√©r√© le {datetime.utcnow().strftime('%d/%m/%Y √† %H:%M')} par {current_user.username}", 
                          ParagraphStyle('Footer', parent=styles['Normal'], fontSize=8, alignment=1)))
    
    # G√©n√©rer le PDF
    doc.build(story)
    
    buffer.seek(0)
    return send_file(buffer, 
                    as_attachment=True, 
                    download_name=f"rapport_audit_{audit.reference}.pdf",
                    mimetype='application/pdf')

@app.route('/audit/<int:audit_id>/export-word')
@login_required
def export_rapport_audit_word(audit_id):
    """Exporter le rapport d'audit en Word (.docx)"""
    audit = Audit.query.get_or_404(audit_id)
    
    # V√©rifier les permissions
    peut_voir = (
        current_user.role == 'admin' or
        current_user.id == audit.created_by or
        current_user.id == audit.responsable_id or
        (audit.equipe_audit_ids and str(current_user.id) in audit.equipe_audit_ids.split(','))
    )
    
    if not peut_voir:
        flash('Vous n\'avez pas les permissions pour exporter ce rapport', 'error')
        return redirect(url_for('liste_audits'))
    
    # Initialiser COM pour Windows (si n√©cessaire)
    try:
        pythoncom.CoInitialize()
    except:
        pass
    
    # Cr√©er un nouveau document Word
    doc = Document()
    
    # D√©finir les styles
    styles = doc.styles
    
    # Style pour le titre
    title_style = styles.add_style('CustomTitle', WD_STYLE_TYPE.PARAGRAPH)
    title_style.font.size = Pt(16)
    title_style.font.bold = True
    title_style.font.color.rgb = RGBColor(44, 62, 80)  # #2c3e50
    title_style.paragraph_format.space_after = Pt(12)
    title_style.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER
    
    # Style pour les titres de section
    heading1_style = styles.add_style('CustomHeading1', WD_STYLE_TYPE.PARAGRAPH)
    heading1_style.font.size = Pt(14)
    heading1_style.font.bold = True
    heading1_style.font.color.rgb = RGBColor(52, 73, 94)  # #34495e
    heading1_style.paragraph_format.space_after = Pt(10)
    
    # Style pour les sous-titres
    heading2_style = styles.add_style('CustomHeading2', WD_STYLE_TYPE.PARAGRAPH)
    heading2_style.font.size = Pt(12)
    heading2_style.font.bold = True
    heading2_style.font.color.rgb = RGBColor(44, 62, 80)  # #2c3e50
    heading2_style.paragraph_format.space_after = Pt(8)
    
    # Style normal
    normal_style = styles.add_style('CustomNormal', WD_STYLE_TYPE.PARAGRAPH)
    normal_style.font.size = Pt(10)
    normal_style.font.color.rgb = RGBColor(44, 62, 80)  # #2c3e50
    normal_style.paragraph_format.space_after = Pt(6)
    
    # Titre du document
    title = doc.add_paragraph(f"Rapport d'Audit - {audit.reference}")
    title.style = title_style
    
    subtitle = doc.add_paragraph(audit.titre)
    subtitle.style = heading1_style
    subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
    
    doc.add_paragraph()
    
    # Informations g√©n√©rales
    section_title = doc.add_paragraph("Informations G√©n√©rales")
    section_title.style = heading1_style
    
    # Ajouter les informations dans un tableau
    table = doc.add_table(rows=8, cols=2)
    table.style = 'Light Grid Accent 1'
    
    # Remplir le tableau
    cells = table.rows[0].cells
    cells[0].text = "R√©f√©rence"
    cells[1].text = audit.reference
    
    cells = table.rows[1].cells
    cells[0].text = "Titre"
    cells[1].text = audit.titre
    
    cells = table.rows[2].cells
    cells[0].text = "Type d'audit"
    cells[1].text = audit.type_audit
    
    cells = table.rows[3].cells
    cells[0].text = "Statut"
    cells[1].text = audit.statut
    
    cells = table.rows[4].cells
    cells[0].text = "Responsable"
    cells[1].text = audit.responsable.username if audit.responsable else "Non assign√©"
    
    cells = table.rows[5].cells
    cells[0].text = "Date d√©but pr√©vue"
    cells[1].text = audit.date_debut_prevue.strftime('%d/%m/%Y') if audit.date_debut_prevue else "Non d√©finie"
    
    cells = table.rows[6].cells
    cells[0].text = "Date fin pr√©vue"
    cells[1].text = audit.date_fin_prevue.strftime('%d/%m/%Y') if audit.date_fin_prevue else "Non d√©finie"
    
    cells = table.rows[7].cells
    cells[0].text = "Date de g√©n√©ration"
    cells[1].text = datetime.utcnow().strftime('%d/%m/%Y √† %H:%M')
    
    doc.add_paragraph()
    
    # Description
    if audit.description:
        desc_title = doc.add_paragraph("Description")
        desc_title.style = heading2_style
        doc.add_paragraph(audit.description, style='CustomNormal')
        doc.add_paragraph()
    
    # Objectifs
    if audit.objectifs:
        obj_title = doc.add_paragraph("Objectifs")
        obj_title.style = heading2_style
        doc.add_paragraph(audit.objectifs, style='CustomNormal')
        doc.add_paragraph()
    
    # Constatations
    constatations = Constatation.query.filter_by(audit_id=audit.id, is_archived=False).all()
    if constatations:
        doc.add_page_break()
        const_title = doc.add_paragraph("Constatations de l'Audit")
        const_title.style = heading1_style
        
        for constatation in constatations:
            doc.add_paragraph(f"Constatation {constatation.reference}", style='CustomHeading2')
            
            # Cr√©er un tableau pour cette constatation
            const_table = doc.add_table(rows=9, cols=2)
            const_table.style = 'Light Grid Accent 2'
            
            rows_data = [
                ("Description", constatation.description),
                ("Type", constatation.type_constatation.replace('_', ' ').title() if constatation.type_constatation else ""),
                ("Gravit√©", constatation.gravite.title() if constatation.gravite else ""),
                ("Processus concern√©", constatation.processus_concerne or "Non sp√©cifi√©"),
                ("Statut", constatation.statut.replace('_', ' ').title() if constatation.statut else ""),
                ("Cause racine", constatation.cause_racine or "Non sp√©cifi√©e"),
                ("Conclusion", constatation.conclusion or "Non sp√©cifi√©e"),
                ("Commentaires", constatation.commentaires or "Aucun"),
                ("Recommandations imm√©diates", constatation.recommandations_immediates or "Aucune")
            ]
            
            for i, (label, value) in enumerate(rows_data):
                cells = const_table.rows[i].cells
                cells[0].text = label
                cells[1].text = value
            
            doc.add_paragraph()
    
    # Recommandations
    recommandations = Recommandation.query.filter_by(audit_id=audit.id).all()
    if recommandations:
        doc.add_page_break()
        reco_title = doc.add_paragraph("Recommandations")
        reco_title.style = heading1_style
        
        for recommandation in recommandations:
            doc.add_paragraph(f"Recommandation {recommandation.reference}", style='CustomHeading2')
            
            # Cr√©er un tableau pour cette recommandation
            reco_table = doc.add_table(rows=11, cols=2)
            reco_table.style = 'Light Grid Accent 3'
            
            rows_data = [
                ("Description", recommandation.description),
                ("Type", recommandation.type_recommandation.replace('_', ' ').title() if recommandation.type_recommandation else ""),
                ("Cat√©gorie", recommandation.categorie.replace('_', ' ').title() if recommandation.categorie else ""),
                ("Statut", recommandation.statut.replace('_', ' ').title() if recommandation.statut else ""),
                ("D√©lai", recommandation.delai_mise_en_oeuvre.replace('_', ' ').title() if recommandation.delai_mise_en_oeuvre else ""),
                ("Date √©ch√©ance", recommandation.date_echeance.strftime('%d/%m/%Y') if recommandation.date_echeance else "Non d√©finie"),
                ("Urgence", str(recommandation.urgence) if recommandation.urgence else "Non sp√©cifi√©e"),
                ("Impact", str(recommandation.impact_operationnel) if recommandation.impact_operationnel else "Non sp√©cifi√©"),
                ("Priorit√©", f"{recommandation.score_priorite}/100" if recommandation.score_priorite else "Non calcul√©e"),
                ("Avancement", f"{recommandation.taux_avancement or 0}%"),
                ("Responsable", recommandation.responsable.username if recommandation.responsable else "Non assign√©")
            ]
            
            for i, (label, value) in enumerate(rows_data):
                cells = reco_table.rows[i].cells
                cells[0].text = label
                cells[1].text = value
            
            doc.add_paragraph()
    
    # Synth√®se et conclusions
    doc.add_page_break()
    synth_title = doc.add_paragraph("Synth√®se et Conclusions")
    synth_title.style = heading1_style
    
    # Statistiques
    total_constatations = len(constatations)
    total_recommandations = len(recommandations)
    constatations_critiques = len([c for c in constatations if c.gravite == 'critique'])
    recommandations_terminees = len([r for r in recommandations if r.statut == 'termine'])
    
    stats_table = doc.add_table(rows=5, cols=2)
    stats_table.style = 'Medium Grid 3 Accent 1'
    
    stats_data = [
        ("Total constatations", str(total_constatations)),
        ("Constatations critiques", str(constatations_critiques)),
        ("Total recommandations", str(total_recommandations)),
        ("Recommandations termin√©es", str(recommandations_terminees)),
        ("Taux d'avancement moyen", f"{sum([r.taux_avancement or 0 for r in recommandations]) / total_recommandations if total_recommandations > 0 else 0:.1f}%")
    ]
    
    for i, (label, value) in enumerate(stats_data):
        cells = stats_table.rows[i].cells
        cells[0].text = label
        cells[1].text = value
    
    doc.add_paragraph()
    
    # Recommandations globales
    reco_global_title = doc.add_paragraph("Recommandations Globales")
    reco_global_title.style = heading2_style
    
    recommandations_globales = [
        "Mettre en place un suivi r√©gulier des plans d'action avec des points de contr√¥le mensuels",
        "√âtablir des indicateurs de performance pour mesurer l'efficacit√© des actions correctives",
        "Planifier des audits de suivi dans les 6 mois pour v√©rifier la p√©rennit√© des corrections",
        "Renforcer la formation des √©quipes sur les proc√©dures identifi√©es comme critiques",
        "D√©velopper un syst√®me d'alerte pour les recommandations approchant leur √©ch√©ance"
    ]
    
    for reco in recommandations_globales:
        doc.add_paragraph(f"‚Ä¢ {reco}", style='CustomNormal')
    
    doc.add_paragraph()
    
    # Conclusion g√©n√©rale
    concl_title = doc.add_paragraph("Conclusion G√©n√©rale")
    concl_title.style = heading2_style
    
    conclusion_text = f"""
    L'audit {audit.reference} a permis d'identifier {total_constatations} constatations, 
    dont {constatations_critiques} points critiques. Le syst√®me de gestion a d√©montr√© 
    sa capacit√© √† identifier et traiter les √©carts gr√¢ce aux {total_recommandations} 
    recommandations √©mises.
    
    Le taux d'avancement global des actions est satisfaisant. Il est recommand√© de 
    maintenir la dynamique d'am√©lioration continue et de programmer un audit de suivi 
    dans 6 mois pour v√©rifier l'efficacit√© et la p√©rennit√© des actions mises en ≈ìuvre.
    
    Rapport g√©n√©r√© le {datetime.utcnow().strftime('%d/%m/%Y √† %H:%M')}
    """
    
    doc.add_paragraph(conclusion_text, style='CustomNormal')
    
    # Pied de page
    doc.add_paragraph()
    footer = doc.add_paragraph("Syst√®me de Management Int√©gr√© - Contr√¥le Interne")
    footer.alignment = WD_ALIGN_PARAGRAPH.CENTER
    footer.style.font.size = Pt(9)
    footer.style.font.color.rgb = RGBColor(128, 128, 128)
    
    # Sauvegarder dans un buffer
    buffer = io.BytesIO()
    doc.save(buffer)
    buffer.seek(0)
    
    # Retourner le fichier Word
    filename = f"rapport_audit_{audit.reference}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.docx"
    return send_file(
        buffer,
        as_attachment=True,
        download_name=filename,
        mimetype='application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    )



# ========================
# ROUTES POUR L'ANALYSE IA
# ========================

@app.route('/audit/<int:audit_id>/analyse-ia', methods=['GET', 'POST'])
@csrf.exempt
@login_required
def analyse_ia_audit(audit_id):
    """Lancer une analyse IA sur l'audit"""
    
    # V√©rifier l'acc√®s √† l'audit
    audit = get_client_object_or_404(Audit, audit_id)
    
    if not check_client_access(audit):
        flash('Acc√®s non autoris√© √† cet audit', 'error')
        return redirect(url_for('liste_audits'))
    
    # V√©rifier si le service IA est disponible
    if not SERVICE_IA_IMPORTED or service_ia is None:
        flash('Le service d\'analyse IA n\'est pas disponible', 'error')
        return redirect(url_for('detail_audit', id=audit_id))
    
    if not audit.constatations:
        flash('Aucune constatation √† analyser. Ajoutez d\'abord des constatations.', 'warning')
        return redirect(url_for('detail_audit', id=audit_id))
    
    form = AnalyseIAForm()
    
    if form.validate_on_submit():
        try:
            # Utiliser le service IA avec vos param√®tres
            resultat = service_ia.analyser_audit(
                audit_id=audit_id,
                type_analyse=form.type_analyse.data,
                user_id=current_user.id
            )
            
            # V√©rifier que le r√©sultat est valide
            if not resultat:
                flash('L\'analyse IA n\'a pas retourn√© de r√©sultat', 'error')
                return redirect(url_for('detail_audit', id=audit_id))
            
            # Convertir le r√©sultat si c'est un objet
            if hasattr(resultat, 'to_dict'):
                resultat_dict = resultat.to_dict()
            elif hasattr(resultat, '__dict__'):
                resultat_dict = resultat.__dict__
            elif isinstance(resultat, dict):
                resultat_dict = resultat
            else:
                resultat_dict = {'resultat': str(resultat)}
            
            # Sauvegarder dans la base de donn√©es
            analyse = AnalyseIA(
                audit_id=audit_id,
                type_analyse=form.type_analyse.data,
                resultat=resultat_dict,
                score_confiance=resultat_dict.get('metadata', {}).get('score_confiance', 75.0) if isinstance(resultat_dict, dict) else 75.0,
                created_by=current_user.id,
                client_id=current_user.client_id
            )
            
            db.session.add(analyse)
            db.session.commit()
            
            # Journaliser l'action
            log_activity(current_user.id, 'analyse_ia_audit',
                        f"Analyse IA lanc√©e sur audit {audit.reference}",
                        'audit', audit_id)
            
            # Utiliser le score depuis le r√©sultat
            score = resultat_dict.get('metadata', {}).get('score_confiance', 75.0) if isinstance(resultat_dict, dict) else 75.0
            flash(f'‚úÖ Analyse IA termin√©e avec succ√®s ! Score de confiance: {score:.1f}%', 'success')
            return redirect(url_for('resultat_analyse_ia', audit_id=audit_id, analyse_id=analyse.id))
            
        except Exception as e:
            db.session.rollback()
            flash(f'‚ùå Erreur lors de l\'analyse IA: {str(e)}', 'error')
            print(f"‚ùå Erreur analyse IA: {e}")
            import traceback
            traceback.print_exc()
            return redirect(url_for('detail_audit', id=audit_id))
    
    # Statistiques pour l'affichage
    stats = {
        'nb_constatations': len(audit.constatations) if hasattr(audit, 'constatations') else 0,
        'nb_recommandations': len(audit.recommandations) if hasattr(audit, 'recommandations') else 0,
        'audit_reference': audit.reference if hasattr(audit, 'reference') else f"AUD-{audit_id}"
    }
    
    return render_template('audit/analyse_ia.html', 
                         audit=audit, 
                         form=form,
                         stats=stats)

@app.route('/audit/<int:audit_id>/analyse-ia/resultat/<int:analyse_id>')
@csrf.exempt
@login_required
def resultat_analyse_ia(audit_id, analyse_id):
    """Afficher les r√©sultats de l'analyse IA"""
    try:
        audit = get_client_object_or_404(Audit, audit_id)
        
        # R√©cup√©rer l'analyse depuis la base
        analyse = get_client_object_or_404(AnalyseIA, analyse_id, audit_id=audit_id)
        
        # Convertir le r√©sultat selon son type
        if analyse.resultat:
            if isinstance(analyse.resultat, dict):
                resultat = analyse.resultat
            elif isinstance(analyse.resultat, str):
                try:
                    resultat = json.loads(analyse.resultat)
                except:
                    resultat = {'analyse': analyse.resultat}
            else:
                resultat = {}
        else:
            resultat = {}
        
        # S'assurer que la structure est compl√®te
        if 'statistiques' not in resultat:
            resultat['statistiques'] = {}
        
        # Remplir les valeurs par d√©faut
        stats_defaults = {
            'nb_recommandations_suggerees': len(resultat.get('recommandations_ia', [])),
            'nb_causes_identifiees': len(resultat.get('causes_racines', [])),
            'score_global': analyse.score_confiance if analyse else 75,
            'temps_analyse': '2.3 secondes'
        }
        
        for key, default in stats_defaults.items():
            resultat['statistiques'][key] = resultat['statistiques'].get(key, default)
        
        # S'assurer que les listes existent
        resultat.setdefault('recommandations_ia', [])
        resultat.setdefault('causes_racines', [])
        
        print(f"üìä R√©sultat IA pr√©par√©:")
        print(f"  - Recommandations: {len(resultat['recommandations_ia'])}")
        print(f"  - Causes: {len(resultat['causes_racines'])}")
        print(f"  - Score: {resultat['statistiques']['score_global']}")
        
        return render_template('audit/resultat_analyse_ia.html',
                            audit=audit,
                            analyse=analyse,
                            resultat=resultat)
        
    except Exception as e:
        print(f"‚ùå Erreur resultat_analyse_ia: {e}")
        import traceback
        traceback.print_exc()
        
        flash(f'Erreur lors de l\'affichage des r√©sultats: {str(e)}', 'error')
        return redirect(url_for('detail_audit', id=audit_id))


def _creer_resultat_simulation(self):
    """Cr√©er un r√©sultat de simulation"""
    return {
        'statistiques': {
            'nb_recommandations_suggerees': 3,
            'nb_causes_identifiees': 2,
            'score_global': 75,
            'temps_analyse': '2.3 secondes'
        },
        'recommandations_ia': [
            {
                'titre': 'Am√©lioration des proc√©dures documentaires',
                'description': 'L\'IA sugg√®re de formaliser les proc√©dures manquantes',
                'priorite': 'haute',
                'score_confiance': 85
            }
        ],
        'causes_racines': [
            {
                'cause': 'Absence de proc√©dures formalis√©es',
                'frequence': 3,
                'impact': '√©lev√©'
            }
        ]
    }


@app.route('/api/analyse-ia/<int:analyse_id>/appliquer-recommandation/<int:reco_id>', methods=['POST'])
@csrf.exempt
@login_required
def appliquer_recommandation_ia(analyse_id, reco_id):
    """Transformer une recommandation IA en vraie recommandation"""
    if not MODELS_IMPORTED or not SERVICE_IA_IMPORTED:
        return jsonify({
            'success': False,
            'message': 'Service non disponible'
        }), 503
    
    try:
        # R√©cup√©rer l'analyse
        analyse = get_client_object_or_404(AnalyseIA, analyse_id)
        audit = analyse.audit
        
        # V√©rifier les permissions
        peut_ajouter_recommandation = (
            current_user.role == 'admin' or
            current_user.id == audit.created_by or
            current_user.id == audit.responsable_id or
            (audit.equipe_audit_ids and str(current_user.id) in audit.equipe_audit_ids.split(','))
        )
        
        if not peut_ajouter_recommandation:
            return jsonify({
                'success': False,
                'message': 'Non autoris√©'
            }), 403
        
        # R√©cup√©rer la recommandation IA
        resultat = analyse.resultat
        if isinstance(resultat, str):
            try:
                resultat = json.loads(resultat)
            except:
                resultat = {}
        
        recommandations_ia = resultat.get('recommandations_ia', [])
        
        # Trouver la recommandation IA par ID
        reco_ia = None
        for reco in recommandations_ia:
            if reco.get('id') == reco_id:
                reco_ia = reco
                break
        
        if not reco_ia:
            return jsonify({
                'success': False,
                'message': 'Recommandation IA non trouv√©e'
            }), 404
        
        # Cr√©er une vraie recommandation
        # G√©n√©rer une r√©f√©rence
        count_recos = Recommandation.query.filter_by(audit_id=audit.id).count()
        nouvelle_ref = f"REC-IA-{audit.reference}-{count_recos + 1:03d}"
        
        # Cr√©er la recommandation
        nouvelle_reco = Recommandation(
            reference=nouvelle_ref,
            description=f"[IA] {reco_ia.get('titre', '')}\n\n{reco_ia.get('description', '')}",
            type_recommandation='amelioration',
            categorie='ia_suggested',
            delai_mise_en_oeuvre='court_terme',
            date_echeance=datetime.utcnow().date() + timedelta(days=30),
            urgence=3 if reco_ia.get('priorite') == 'haute' else 2,
            impact_operationnel=3,
            score_priorite=reco_ia.get('score_confiance', 70),
            statut='a_traiter',
            taux_avancement=0,
            audit_id=audit.id,
            created_by=current_user.id,
            client_id=current_user.client_id
        )
        
        db.session.add(nouvelle_reco)
        db.session.commit()
        
        # Journaliser
        log_activity(current_user.id, 'appliquer_recommandation_ia',
                    f"Recommandation IA appliqu√©e: {reco_ia.get('titre')}",
                    'recommandation', nouvelle_reco.id)
        
        return jsonify({
            'success': True,
            'message': 'Recommandation ajout√©e avec succ√®s',
            'recommandation_id': nouvelle_reco.id,
            'reference': nouvelle_reco.reference
        })
            
    except Exception as e:
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500

@app.route('/audit/<int:audit_id>/analyses-ia')
@login_required
def liste_analyses_ia(audit_id):
    """Liste des analyses IA effectu√©es sur un audit"""
    if not MODELS_IMPORTED:
        flash('Syst√®me non disponible', 'error')
        return redirect(url_for('liste_audits'))
    
    try:
        audit = get_client_object_or_404(Audit, audit_id)
        
        # R√©cup√©rer les analyses filtr√©es par client
        analyses = get_client_filter(AnalyseIA)\
            .filter_by(audit_id=audit_id)\
            .order_by(AnalyseIA.date_analyse.desc())\
            .all()
        
        return render_template('audit/liste_analyses_ia.html',
                            audit=audit,
                            analyses=analyses)
        
    except Exception as e:
        flash(f'Erreur: {str(e)}', 'error')
        return redirect(url_for('liste_audits'))

@app.route('/analyse-ia/<int:analyse_id>/export')
@login_required
def export_analyse_ia(analyse_id):
    """Exporter une analyse IA en PDF"""
    if not MODELS_IMPORTED or not REPORTLAB_AVAILABLE:
        flash('Export PDF non disponible', 'error')
        return redirect(url_for('liste_audits'))
    
    try:
        analyse = get_client_object_or_404(AnalyseIA, analyse_id)
        audit = analyse.audit
        
        # S'assurer que resultat est un dict
        resultat = analyse.resultat
        if isinstance(resultat, str):
            try:
                resultat = json.loads(resultat)
            except:
                resultat = {}
        elif not isinstance(resultat, dict):
            resultat = {}
        
        # Cr√©er le PDF
        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=letter)
        story = []
        styles = getSampleStyleSheet()
        
        # Style personnalis√©
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=16,
            spaceAfter=30
        )
        
        # Titre
        story.append(Paragraph(f"Rapport d'Analyse IA - {audit.reference}", title_style))
        story.append(Paragraph(f"Audit: {audit.titre}", styles['Normal']))
        story.append(Paragraph(f"Date d'analyse: {analyse.date_analyse.strftime('%d/%m/%Y %H:%M')}", styles['Normal']))
        story.append(Spacer(1, 20))
        
        # Score de confiance
        story.append(Paragraph(f"Score de confiance: <b>{analyse.score_confiance:.1f}%</b>", styles['Heading2']))
        story.append(Spacer(1, 10))
        
        # Recommandations
        story.append(Paragraph("Recommandations sugg√©r√©es par l'IA", styles['Heading2']))
        
        if resultat and resultat.get('recommandations_ia'):
            reco_data = [['#', 'Titre', 'Priorit√©', 'Confiance', 'D√©lai sugg√©r√©']]
            for i, reco in enumerate(resultat['recommandations_ia'], 1):
                reco_data.append([
                    str(i),
                    reco.get('titre', ''),
                    reco.get('priorite', '').title(),
                    f"{reco.get('score_confiance', 0)}%",
                    reco.get('delai_suggere', 'N/A')
                ])
            
            reco_table = Table(reco_data, colWidths=[1*cm, 8*cm, 3*cm, 3*cm, 3*cm])
            reco_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            story.append(reco_table)
        
        story.append(Spacer(1, 20))
        
        # Causes racines
        if resultat and resultat.get('causes_racines'):
            story.append(Paragraph("Causes racines identifi√©es", styles['Heading2']))
            
            causes_data = [['Cause', 'Fr√©quence', 'Impact']]
            for cause in resultat['causes_racines']:
                causes_data.append([
                    cause.get('cause', ''),
                    str(cause.get('frequence', 0)),
                    cause.get('impact', '').title()
                ])
            
            causes_table = Table(causes_data, colWidths=[10*cm, 3*cm, 3*cm])
            causes_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.lightgrey),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            story.append(causes_table)
        
        story.append(Spacer(1, 20))
        
        # Pied de page
        story.append(Paragraph(
            f"<i>Document g√©n√©r√© le {datetime.utcnow().strftime('%d/%m/%Y √† %H:%M')} par {current_user.username}</i>",
            ParagraphStyle('Footer', fontSize=8, textColor=colors.grey, alignment=1)
        ))
        
        # G√©n√©rer le PDF
        doc.build(story)
        buffer.seek(0)
        
        return send_file(
            buffer,
            as_attachment=True,
            download_name=f"analyse_ia_{audit.reference}_{analyse.date_analyse.strftime('%Y%m%d')}.pdf",
            mimetype='application/pdf'
        )
        
    except Exception as e:
        flash(f'Erreur lors de l\'export: {str(e)}', 'error')
        return redirect(url_for('liste_analyses_ia', audit_id=analyse.audit_id))


# ============================================================================
# ROUTES POUR LES CHECKLISTS D'AUDIT
# ============================================================================

@app.route('/audit/checklist', methods=['GET', 'POST'])
@login_required
def checklist_audit():
    """S√©lectionner et appliquer une checklist d'audit"""
    form = ChecklistAuditForm()
    
    if form.validate_on_submit():
        type_checklist = form.type_checklist.data
        appliquer_template = form.appliquer_template.data
        
        # Appliquer la checklist
        # √Ä impl√©menter selon vos besoins
        
        flash(f'Checklist {type_checklist} appliqu√©e', 'success')
        return redirect(url_for('liste_audits'))
    
    return render_template('audit/checklist.html', form=form)


# ============================================================================
# ROUTES DE DEBUG ET TESTS
# ============================================================================

@app.route('/debug/risques')
@login_required
def debug_risques():
    """Page de debug pour v√©rifier les risques"""
    if current_user.role != 'admin':
        flash('Acc√®s r√©serv√© aux administrateurs', 'error')
        return redirect(url_for('dashboard'))
    
    # Tous les risques
    tous_risques = Risque.query.order_by(Risque.id.desc()).all()
    
    # Risques visibles pour l'utilisateur courant
    risques_visibles = Risque.query.filter_by(is_archived=False).all()
    
    # Statistiques
    stats = {
        'total': len(tous_risques),
        'archives': len([r for r in tous_risques if r.is_archived]),
        'actifs': len([r for r in tous_risques if not r.is_archived]),
        'avec_evaluations': len([r for r in tous_risques if r.evaluations]),
        'sans_evaluations': len([r for r in tous_risques if not r.evaluations]),
        'visibles': len(risques_visibles)
    }
    
    return render_template('debug/risques.html',
                         tous_risques=tous_risques,
                         risques_visibles=risques_visibles,
                         stats=stats,
                         current_user=current_user)

# ============================================================================
# CORRECTION DE LA ROUTE PLANS_ACTION_AUDIT (alias pour compatibilit√©)
# ============================================================================



@app.route('/plans_action', endpoint='plans_action_audit')
@csrf.exempt
@login_required
def plans_action_audit():
    """Route alias pour la compatibilit√© avec les templates existants"""
    return redirect(url_for('liste_plans_action'))


# Routes pour les sous-√©tapes
@app.route('/etape/<int:etape_id>/sous-etape/ajouter', methods=['POST'])
@login_required
def ajouter_sous_etape(etape_id):
    etape = EtapeProcessus.query.get_or_404(etape_id)
    
    # Validation de l'ordre
    ordre = int(request.form['ordre'])
    sous_etape_existante = SousEtapeProcessus.query.filter_by(etape_id=etape_id, ordre=ordre).first()
    if sous_etape_existante:
        flash('Une sous-√©tape avec cet ordre existe d√©j√†', 'error')
        return redirect(url_for('detail_processus', id=etape.processus_id))
    
    sous_etape = SousEtapeProcessus(
        etape_id=etape_id,
        ordre=ordre,
        nom=request.form['nom'],
        description=request.form.get('description'),
        responsable_id=request.form.get('responsable_id') or None,
        duree_estimee=request.form.get('duree_estimee'),
        inputs=request.form.get('inputs'),
        outputs=request.form.get('outputs')
    )
    
    db.session.add(sous_etape)
    db.session.commit()
    
    # Synchronisation automatique
    synchroniser_processus_apres_modification(etape.processus_id, 'ajout_sous_etape', current_user.id)
    
    flash('Sous-√©tape ajout√©e avec succ√®s', 'success')
    return redirect(url_for('detail_processus', id=etape.processus_id))

@app.route('/sous-etape/<int:id>/modifier', methods=['POST'])
@login_required
def modifier_sous_etape(id):
    sous_etape = SousEtapeProcessus.query.get_or_404(id)
    
    # V√©rifier si l'ordre a chang√©
    nouvel_ordre = int(request.form['ordre'])
    if nouvel_ordre != sous_etape.ordre:
        ordre_existant = SousEtapeProcessus.query.filter_by(
            etape_id=sous_etape.etape_id, 
            ordre=nouvel_ordre
        ).first()
        if ordre_existant and ordre_existant.id != sous_etape.id:
            flash('Une sous-√©tape avec cet ordre existe d√©j√†', 'error')
            return redirect(url_for('detail_processus', id=sous_etape.etape.processus_id))
    
    sous_etape.ordre = nouvel_ordre
    sous_etape.nom = request.form['nom']
    sous_etape.description = request.form.get('description')
    sous_etape.responsable_id = request.form.get('responsable_id') or None
    sous_etape.duree_estimee = request.form.get('duree_estimee')
    sous_etape.inputs = request.form.get('inputs')
    sous_etape.outputs = request.form.get('outputs')
    
    db.session.commit()
    
    # Synchronisation automatique
    synchroniser_processus_apres_modification(sous_etape.etape.processus_id, 'modification_sous_etape', current_user.id)
    
    flash('Sous-√©tape modifi√©e avec succ√®s', 'success')
    return redirect(url_for('detail_processus', id=sous_etape.etape.processus_id))

@app.route('/sous-etape/<int:id>/supprimer', methods=['POST'])
@login_required
def supprimer_sous_etape(id):
    sous_etape = SousEtapeProcessus.query.get_or_404(id)
    processus_id = sous_etape.etape.processus_id
    
    db.session.delete(sous_etape)
    db.session.commit()
    
    # Synchronisation automatique
    synchroniser_processus_apres_modification(processus_id, 'suppression_sous_etape', current_user.id)
    
    flash('Sous-√©tape supprim√©e avec succ√®s', 'success')
    return redirect(url_for('detail_processus', id=processus_id))

# ============================================================================
# ROUTES POUR LES MODALS - CORRECTION DES NOMS
# ============================================================================

@app.route('/processus/<int:processus_id>/zone-risque/ajouter', methods=['POST'])
@login_required
def ajouter_zone_risque_processus(processus_id):
    """Ajouter une zone de risque au processus"""
    processus = Processus.query.get_or_404(processus_id)
    
    try:
        zone_risque = ZoneRisqueProcessus(
            processus_id=processus_id,
            nom=request.form['nom'],
            description=request.form.get('description', ''),
            type_risque=request.form.get('type_risque', 'operationnel'),
            niveau_risque=request.form.get('niveau_risque', 'moyen'),
            impact=request.form.get('impact', ''),
            mesures_controle=request.form.get('mesures_controle', ''),
            responsable_id=request.form.get('responsable_id') or None
        )
        
        db.session.add(zone_risque)
        db.session.commit()
        flash('Zone de risque ajout√©e avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de l\'ajout de la zone de risque: {str(e)}', 'error')
    
    return redirect(url_for('detail_processus', id=processus_id))

@app.route('/processus/<int:processus_id>/controle/ajouter', methods=['POST'])
@login_required
def ajouter_controle_processus(processus_id):
    """Ajouter un contr√¥le au processus"""
    processus = Processus.query.get_or_404(processus_id)
    
    try:
        controle = ControleProcessus(
            processus_id=processus_id,
            nom=request.form['nom'],
            description=request.form.get('description', ''),
            type_controle=request.form.get('type_controle', 'preventif'),
            frequence=request.form.get('frequence', 'permanent'),
            etape_id=request.form.get('etape_id') or None,
            responsable_id=request.form.get('responsable_id') or None,
            statut=request.form.get('statut', 'actif')
        )
        
        db.session.add(controle)
        db.session.commit()
        flash('Contr√¥le ajout√© avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de l\'ajout du contr√¥le: {str(e)}', 'error')
    
    return redirect(url_for('detail_processus', id=processus_id))

@app.route('/processus/<int:processus_id>/etape/ajouter', methods=['POST'])
@login_required
def ajouter_etape_processus(processus_id):
    """Ajouter une √©tape au processus AVEC SYNCHRONISATION ORGANIGRAMME"""
    processus = Processus.query.get_or_404(processus_id)
    
    try:
        # Validation de l'ordre
        ordre = int(request.form.get('ordre', 1))
        
        # V√©rifier si l'ordre existe d√©j√†
        etape_existante = EtapeProcessus.query.filter_by(
            processus_id=processus_id, 
            ordre=ordre
        ).first()
        
        if etape_existante:
            flash('Une √©tape avec cet ordre existe d√©j√†', 'error')
            return redirect(url_for('detail_processus', id=processus_id))
        
        # Calculer la position automatique pour l'organigramme
        etapes_existantes = EtapeProcessus.query.filter_by(processus_id=processus_id).count()
        position_x = (etapes_existantes * 250) % 1200
        position_y = 100 + ((etapes_existantes // 5) * 150)
        
        etape = EtapeProcessus(
            processus_id=processus_id,
            ordre=ordre,
            nom=request.form['nom'],
            description=request.form.get('description', ''),
            type_etape=request.form.get('type_etape', 'action'),
            responsable_id=request.form.get('responsable_id') or None,
            duree_estimee=request.form.get('duree_estimee', ''),
            inputs=request.form.get('inputs', ''),
            outputs=request.form.get('outputs', ''),
            # POSITIONS POUR L'ORGANIGRAMME FLUIDE
            position_x=position_x,
            position_y=position_y,
            couleur=request.form.get('couleur', '#007bff')
        )
        
        db.session.add(etape)
        db.session.flush()  # Pour obtenir l'ID
        
        # üî• SYNCHRONISATION AUTOMATIQUE AVEC L'ORGANIGRAMME
        synchroniser_etape_organigramme(etape.id, 'creation_formulaire', current_user.id)
        
        db.session.commit()
        
        flash('√âtape ajout√©e avec succ√®s et synchronis√©e avec l\'organigramme', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de l\'ajout de l\'√©tape: {str(e)}', 'error')
    
    return redirect(url_for('detail_processus', id=processus_id))
# ============================================================================
# ROUTES API CRITIQUES MANQUANTES POUR L'ORGANIGRAMME
# ============================================================================

@app.route('/api/etape/<int:etape_id>', methods=['PUT'])
@login_required
def api_modifier_etape_complete(etape_id):
    """API pour modifier une √©tape - VERSION CORRIG√âE"""
    try:
        print(f"üîÑ Modification √©tape {etape_id}")
        
        # R√©cup√©rer les donn√©es JSON
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'error': 'Donn√©es JSON manquantes'}), 400
        
        # R√©cup√©rer l'√©tape
        etape = EtapeProcessus.query.get_or_404(etape_id)
        
        # Mettre √† jour les champs de base
        if 'nom' in data:
            etape.nom = data['nom']
        if 'description' in data:
            etape.description = data['description']
        if 'type_etape' in data:
            etape.type_etape = data['type_etape']
        if 'couleur' in data:
            etape.couleur = data['couleur']
        
        # Mettre √† jour la position si fournie
        if 'position_x' in data:
            try:
                etape.position_x = int(data['position_x'])
            except (ValueError, TypeError):
                return jsonify({'success': False, 'error': 'Position X invalide'}), 400
                
        if 'position_y' in data:
            try:
                etape.position_y = int(data['position_y'])
            except (ValueError, TypeError):
                return jsonify({'success': False, 'error': 'Position Y invalide'}), 400
        
        # G√©rer le responsable
        if 'responsable_id' in data:
            responsable_id = data['responsable_id']
            if responsable_id and responsable_id != 0:
                etape.responsable_id = int(responsable_id)
            else:
                etape.responsable_id = None
        
        etape.updated_at = datetime.utcnow()
        db.session.commit()
        
        print(f"‚úÖ √âtape {etape_id} modifi√©e avec succ√®s")
        
        # Synchronisation automatique
        synchroniser_organigramme_complet(etape.processus_id)
        
        return jsonify({
            'success': True,
            'etape': {
                'id': etape.id,
                'nom': etape.nom,
                'type_etape': etape.type_etape,
                'position_x': etape.position_x,
                'position_y': etape.position_y,
                'couleur': etape.couleur
            }
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur modification √©tape {etape_id}: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

    
@app.route('/api/lien/<int:lien_id>', methods=['PUT'])
@login_required
def api_modifier_lien(lien_id):
    """Modifier un lien existant - CORRIG√âE"""
    try:
        lien = LienProcessus.query.get_or_404(lien_id)
        data = request.get_json()
        
        print(f"üîó Modification lien {lien_id}:", data)
        
        if 'type' in data:
            lien.type_lien = data['type']
        if 'label' in data:
            lien.label = data['label']
        
        db.session.commit()
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500



# ============================================================================
# FONCTIONS DE SYNCHRONISATION RENFORC√âES
# ============================================================================

def synchroniser_organigramme_complet(processus_id):
    """Synchronise compl√®tement l'organigramme - VERSION RENFORC√âE"""
    try:
        processus = Processus.query.get(processus_id)
        if not processus:
            print(f"‚ùå Processus {processus_id} non trouv√©")
            return False
        
        print(f"üîÑ SYNCHRONISATION COMPL√àTE processus {processus_id}")
        
        # Compter les √©l√©ments
        total_etapes = EtapeProcessus.query.filter_by(processus_id=processus_id).count()
        etapes_avec_position = EtapeProcessus.query.filter_by(
            processus_id=processus_id
        ).filter(
            EtapeProcessus.position_x.isnot(None),
            EtapeProcessus.position_y.isnot(None)
        ).count()
        
        total_liens = LienProcessus.query.filter_by(processus_id=processus_id).count()
        
        # Mettre √† jour les indicateurs
        processus.nb_etapes = total_etapes
        processus.nb_liens = total_liens
        processus.derniere_sync_organigramme = datetime.utcnow()
        processus.a_besoin_sync = False
        processus.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        print(f"‚úÖ SYNCHRONISATION R√âUSSIE: {etapes_avec_position}/{total_etapes} √©tapes positionn√©es, {total_liens} liens")
        return True
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå ERREUR SYNCHRONISATION processus {processus_id}: {str(e)}")
        import traceback
        traceback.print_exc()
        return False

def forcer_synchronisation_organigramme(processus_id):
    """Force la synchronisation de l'organigramme"""
    try:
        processus = Processus.query.get(processus_id)
        if processus:
            # Marquer comme n√©cessitant synchronisation
            processus.a_besoin_sync = True
            processus.updated_at = datetime.utcnow()
            db.session.commit()
            
            # Lancer la synchronisation
            return synchroniser_organigramme_complet(processus_id)
        return False
    except Exception as e:
        print(f"‚ùå Erreur for√ßage synchronisation: {e}")
        return False

@app.route('/zone-risque/<int:id>/modifier', methods=['POST'])
@login_required
def modifier_zone_risque(id):
    zone_risque = ZoneRisqueProcessus.query.get_or_404(id)
    
    zone_risque.nom = request.form['nom']
    zone_risque.description = request.form.get('description')
    zone_risque.type_risque = request.form['type_risque']
    zone_risque.niveau_risque = request.form['niveau_risque']
    zone_risque.impact = request.form.get('impact')
    zone_risque.mesures_controle = request.form.get('mesures_controle')
    zone_risque.responsable_id = request.form.get('responsable_id') or None
    
    db.session.commit()
    
    # Synchronisation automatique
    synchroniser_processus_apres_modification(zone_risque.processus_id, 'modification_zone_risque', current_user.id)
    
    flash('Zone de risque modifi√©e avec succ√®s', 'success')
    return redirect(url_for('detail_processus', id=zone_risque.processus_id))

@app.route('/zone-risque/<int:id>/supprimer', methods=['POST'])
@login_required
def supprimer_zone_risque(id):
    zone_risque = ZoneRisqueProcessus.query.get_or_404(id)
    processus_id = zone_risque.processus_id
    
    db.session.delete(zone_risque)
    db.session.commit()
    
    # Synchronisation automatique
    synchroniser_processus_apres_modification(processus_id, 'suppression_zone_risque', current_user.id)
    
    flash('Zone de risque supprim√©e avec succ√®s', 'success')
    return redirect(url_for('detail_processus', id=processus_id))

# Routes pour les contr√¥les
@app.route('/processus/<int:processus_id>/controle/ajouter', methods=['POST'])
@login_required
def ajouter_controle(processus_id):
    """Ajouter un contr√¥le"""
    processus = Processus.query.get_or_404(processus_id)
    
    controle = ControleProcessus(
        processus_id=processus_id,
        nom=request.form['nom'],
        description=request.form.get('description'),
        type_controle=request.form['type_controle'],
        frequence=request.form.get('frequence'),
        responsable_id=request.form.get('responsable_id') or None,
        statut=request.form.get('statut', 'actif')
    )
    
    db.session.add(controle)
    db.session.commit()
    flash('Contr√¥le ajout√© avec succ√®s', 'success')
    return redirect(url_for('detail_processus', id=processus_id))

@app.route('/controle/<int:id>/modifier', methods=['POST'])
@login_required
def modifier_controle(id):
    controle = ControleProcessus.query.get_or_404(id)
    
    controle.nom = request.form['nom']
    controle.description = request.form.get('description')
    controle.type_controle = request.form['type_controle']
    controle.frequence = request.form.get('frequence')
    controle.etape_id = request.form.get('etape_id') or None
    controle.responsable_id = request.form.get('responsable_id') or None
    controle.statut = request.form.get('statut', 'actif')
    
    db.session.commit()
    
    # Synchronisation automatique
    synchroniser_processus_apres_modification(controle.processus_id, 'modification_controle', current_user.id)
    
    flash('Contr√¥le modifi√© avec succ√®s', 'success')
    return redirect(url_for('detail_processus', id=controle.processus_id))

@app.route('/controle/<int:id>/supprimer', methods=['POST'])
@login_required
def supprimer_controle(id):
    controle = ControleProcessus.query.get_or_404(id)
    processus_id = controle.processus_id
    
    db.session.delete(controle)
    db.session.commit()
    
    # Synchronisation automatique
    synchroniser_processus_apres_modification(processus_id, 'suppression_controle', current_user.id)
    
    flash('Contr√¥le supprim√© avec succ√®s', 'success')
    return redirect(url_for('detail_processus', id=processus_id))

# Fonction de synchronisation automatique
def synchroniser_processus_apres_modification(processus_id, action_type, user_id):
    """Synchronise automatiquement les donn√©es apr√®s modification d'un processus"""
    from utils import synchroniser_donnees_globales
    
    processus = Processus.query.get(processus_id)
    if processus:
        processus.updated_at = datetime.utcnow()
        db.session.commit()
        
        print(f"üîÑ Processus {processus.nom} synchronis√© apr√®s {action_type}")
        
        # Synchronisation globale
        synchroniser_donnees_globales()

# API pour les donn√©es des processus
@app.route('/api/processus/<int:processus_id>/etapes-options')
@login_required
def api_etapes_options(processus_id):
    etapes = EtapeProcessus.query.filter_by(processus_id=processus_id).order_by(EtapeProcessus.ordre).all()
    return jsonify([{'id': e.id, 'nom': f"√âtape {e.ordre}: {e.nom}"} for e in etapes])

@app.route('/api/processus/<int:processus_id>/statistiques')
@login_required
def api_statistiques_processus(processus_id):
    processus = Processus.query.get_or_404(processus_id)
    
    stats = {
        'total_etapes': len(processus.etapes),
        'total_sous_etapes': sum(len(etape.sous_etapes) for etape in processus.etapes),
        'total_zones_risque': len(processus.zones_risque),
        'total_controles': len(processus.controles),
        'zones_risque_par_niveau': {},
        'controles_par_type': {}
    }
    
    # Statistiques des zones de risque par niveau
    for zone in processus.zones_risque:
        niveau = zone.niveau_risque
        if niveau not in stats['zones_risque_par_niveau']:
            stats['zones_risque_par_niveau'][niveau] = 0
        stats['zones_risque_par_niveau'][niveau] += 1
    
    # Statistiques des contr√¥les par type
    for controle in processus.controles:
        type_controle = controle.type_controle
        if type_controle not in stats['controles_par_type']:
            stats['controles_par_type'][type_controle] = 0
        stats['controles_par_type'][type_controle] += 1
    
    return jsonify(stats)



@app.route('/cartographie/<int:id>/synchroniser', methods=['POST'])
@login_required
def synchroniser_cartographie(id):
    """Synchroniser manuellement une cartographie"""
    from utils import synchroniser_cartographie_complete
    
    success = synchroniser_cartographie_complete(id)
    
    if success:
        flash('Cartographie synchronis√©e avec succ√®s', 'success')
    else:
        flash('Erreur lors de la synchronisation', 'error')
    
    return redirect(url_for('detail_cartographie', id=id))

def synchroniser_apres_action(cartographie_id, action_type):
    """Synchronise apr√®s chaque action importante"""
    from utils import synchroniser_cartographie_complete
    
    try:
        success = synchroniser_cartographie_complete(cartographie_id)
        if success:
            print(f"‚úÖ Synchronisation apr√®s {action_type} r√©ussie")
        else:
            print(f"‚ö†Ô∏è Synchronisation apr√®s {action_type} √©chou√©e")
    except Exception as e:
        print(f"‚ùå Erreur synchronisation apr√®s {action_type}: {e}")

@app.route('/cartographie/<int:id>/modifier', methods=['GET', 'POST'])
@login_required
def modifier_cartographie(id):
    """Modifier une cartographie avec synchronisation automatique"""
    from utils import synchroniser_cartographie_complete
    
    cartographie = Cartographie.query.get_or_404(id)
    form = CartographieForm(obj=cartographie)
    
    # Pr√©parer les choix
    directions = [(d.id, d.nom) for d in Direction.query.all()]
    form.direction_id.choices = [(0, 'S√©lectionnez une direction')] + directions
    form.service_id.choices = [(0, 'S√©lectionnez un service')]
    
    if form.validate_on_submit():
        type_cartographie = request.form.get('type_cartographie', 'direction')
        
        # G√©rer les valeurs
        direction_id = form.direction_id.data if form.direction_id.data and form.direction_id.data != 0 else None
        service_id = form.service_id.data if type_cartographie == 'service' and form.service_id.data and form.service_id.data != 0 else None
        
        # Validation
        if not direction_id:
            flash('Veuillez s√©lectionner une direction', 'error')
            return render_template('cartographie/form.html', form=form, action='modifier')
        
        # Mettre √† jour la cartographie
        cartographie.nom = form.nom.data
        cartographie.description = form.description.data
        cartographie.direction_id = direction_id
        cartographie.service_id = service_id
        cartographie.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        # üî• SYNCHRONISATION AUTOMATIQUE
        synchroniser_cartographie_complete(id)
        
        flash('Cartographie modifi√©e et synchronis√©e avec succ√®s', 'success')
        return redirect(url_for('liste_cartographies'))
    
    # Pr√©-remplir les valeurs existantes
    if cartographie.direction_id:
        form.direction_id.data = cartographie.direction_id
    if cartographie.service_id:
        form.service_id.data = cartographie.service_id
        form.type_cartographie.data = 'service'
    else:
        form.type_cartographie.data = 'direction'
    
    return render_template('cartographie/form.html', 
                         form=form, 
                         cartographie=cartographie,
                         action='modifier')

@app.route('/cartographie/<int:id>/supprimer', methods=['POST'])
@login_required
def supprimer_cartographie(id):
    """Supprimer une cartographie avec synchronisation"""
    from models import db, Risque, EvaluationRisque, KRI, MesureKRI
    
    cartographie = Cartographie.query.get_or_404(id)
    
    # V√©rifier les permissions
    if current_user.role != 'admin' and current_user.id != cartographie.created_by:
        flash('Vous n\'√™tes pas autoris√© √† supprimer cette cartographie', 'error')
        return redirect(url_for('liste_cartographies'))
    
    try:
        # R√©cup√©rer tous les risques de cette cartographie
        risques = Risque.query.filter_by(cartographie_id=id).all()
        
        for risque in risques:
            # Supprimer les √©valuations
            EvaluationRisque.query.filter_by(risque_id=risque.id).delete()
            
            # Supprimer les KRI et mesures
            kri = KRI.query.filter_by(risque_id=risque.id).first()
            if kri:
                MesureKRI.query.filter_by(kri_id=kri.id).delete()
                db.session.delete(kri)
            
            # Supprimer le risque
            db.session.delete(risque)
        
        # Supprimer la cartographie
        db.session.delete(cartographie)
        db.session.commit()
        
        # üî• SYNCHRONISATION GLOBALE
        from utils import synchroniser_donnees_globales
        synchroniser_donnees_globales()
        
        flash('Cartographie supprim√©e avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la suppression: {str(e)}', 'error')
    
    return redirect(url_for('liste_cartographies'))

@app.route('/admin/synchroniser-toutes-cartographies', methods=['POST'])
@login_required
def synchroniser_toutes_cartographies():
    """Synchroniser toutes les cartographies (admin seulement)"""
    if current_user.role != 'admin':
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('dashboard'))
    
    from utils import synchroniser_toutes_cartographies as sync_all
    
    results = sync_all()
    success_count = sum(1 for r in results if r['success'])
    
    flash(f'{success_count}/{len(results)} cartographies synchronis√©es', 'success')
    return redirect(url_for('liste_cartographies'))

@app.route('/cartographie/<int:id>/verifier-incoherences')
@login_required
def verifier_incoherences_cartographie(id):
    """V√©rifier les incoh√©rences d'une cartographie"""
    from utils import verifier_incoherences_cartographie as check_incoherences
    
    result = check_incoherences(id)
    
    return render_template('cartographie/verifier_incoherences.html',
                         result=result,
                         cartographie_id=id)
# ============================================================================
# ROUTES CONFIGURATION AUDIT (VERSION SIMPLIFI√âE)
# ============================================================================

@app.route('/audit/configurations')
@login_required
def configurations_audit():
    """Page de configuration des audits - Version simplifi√©e avec isolation"""
    
    # V√©rifier les permissions
    if current_user.role not in ['admin', 'referent', 'super_admin']:
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_audits'))
    
    try:
        # CORRECTION : Utiliser get_client_filter pour toutes les configurations
        configurations = get_client_filter(ConfigurationAudit).all()
        
        # CORRECTION : Filtrer les templates par client
        templates_constatations = get_client_filter(TemplateConstatation)\
            .filter_by(est_actif=True)\
            .all()
        
        templates_recommandations = get_client_filter(TemplateRecommandation)\
            .filter_by(est_actif=True)\
            .all()
            
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur chargement configurations: {e}")
        # Retourner des listes vides si les tables n'existent pas encore
        configurations = []
        templates_constatations = []
        templates_recommandations = []
    
    # V√©rifier l'acc√®s pour chaque configuration
    accessible_configs = []
    for config in configurations:
        if check_client_access(config):
            accessible_configs.append(config)
    
    return render_template('audit/configurations.html',
                         configurations=accessible_configs,
                         templates_constatations=templates_constatations,
                         templates_recommandations=templates_recommandations,
                         current_user=current_user)  # Ajouter current_user au contexte


@app.route('/audit/configuration/nouvelle', methods=['GET', 'POST'])
@login_required
def nouvelle_configuration_audit():
    """Cr√©er une nouvelle configuration d'audit avec isolation"""
    
    # V√©rifier les permissions
    if current_user.role not in ['admin', 'referent', 'super_admin']:
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('configurations_audit'))
    
    form = ConfigurationAuditForm()
    
    if form.validate_on_submit():
        try:
            configuration = ConfigurationAudit(
                nom_config=form.nom_config.data,
                type_audit=form.type_audit.data,
                duree_standard=form.duree_standard.data,
                seuil_gravite_min=form.seuil_gravite_min.data,
                seuil_gravite_max=form.seuil_gravite_max.data,
                categories_audit=['conformite', 'efficacite', 'efficience', 'securite']
            )
            
            # CORRECTION : Ajouter automatiquement le client_id pour les utilisateurs normaux
            if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
                configuration.client_id = current_user.client_id
            
            # Ajouter created_by
            configuration.created_by = current_user.id
            
            db.session.add(configuration)
            db.session.commit()
            
            flash('Configuration d\'audit cr√©√©e avec succ√®s', 'success')
            return redirect(url_for('configurations_audit'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur lors de la cr√©ation: {str(e)}', 'error')
    
    return render_template('audit/form_configuration.html', 
                         form=form,
                         current_user=current_user)


@app.route('/audit/template/constatation/nouveau', methods=['GET', 'POST'])
@login_required
def nouveau_template_constatation():
    """Cr√©er un nouveau template de constatation avec isolation"""
    
    # V√©rifier les permissions
    if current_user.role not in ['admin', 'referent', 'super_admin']:
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('configurations_audit'))
    
    form = TemplateConstatationForm()
    
    if form.validate_on_submit():
        try:
            template = TemplateConstatation(
                reference=form.reference.data,
                titre=form.titre.data,
                description=form.description.data,
                type_constatation=form.type_constatation.data,
                gravite_defaut=form.gravite_defaut.data,
                processus_concerne=form.processus_concerne.data,
                cause_racine_typique=form.cause_racine_typique.data,
                recommandation_standard=form.recommandation_standard.data
            )
            
            # CORRECTION : Ajouter automatiquement le client_id pour les utilisateurs normaux
            if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
                template.client_id = current_user.client_id
            
            # Ajouter created_by
            template.created_by = current_user.id
            
            db.session.add(template)
            db.session.commit()
            
            flash('Template de constatation cr√©√© avec succ√®s', 'success')
            return redirect(url_for('configurations_audit'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur lors de la cr√©ation: {str(e)}', 'error')
    
    return render_template('audit/form_template_constatation.html', 
                         form=form,
                         current_user=current_user)

# ============================================================================
# ROUTES POUR INITIALISATION DES CONFIGURATIONS PAR D√âFAUT
# ============================================================================
@app.route('/audit/init-configurations')
@login_required
def init_configurations_audit():
    """Initialiser les configurations d'audit par d√©faut avec isolation"""
    
    # V√©rifier les permissions
    if current_user.role not in ['admin', 'super_admin']:
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('configurations_audit'))
    
    try:
        # CORRECTION : V√©rifier le client_id pour l'utilisateur
        client_id = current_user.client_id if current_user.role != 'super_admin' else None
        
        # Configurations par d√©faut (par client)
        configurations_defaut = [
            {
                'nom_config': 'Audit Interne Standard',
                'type_audit': 'interne',
                'duree_standard': 30,
                'seuil_gravite_min': 3,
                'seuil_gravite_max': 5
            },
            {
                'nom_config': 'Audit Conformit√©',
                'type_audit': 'conformite', 
                'duree_standard': 45,
                'seuil_gravite_min': 2,
                'seuil_gravite_max': 5
            },
            {
                'nom_config': 'Audit S√©curit√©',
                'type_audit': 'securite',
                'duree_standard': 60,
                'seuil_gravite_min': 3,
                'seuil_gravite_max': 5
            }
        ]
        
        for config_data in configurations_defaut:
            # CORRECTION : V√©rifier si la configuration existe pour ce client
            query = ConfigurationAudit.query.filter_by(nom_config=config_data['nom_config'])
            
            # Ajouter le filtre client_id si c'est un client normal
            if client_id:
                query = query.filter_by(client_id=client_id)
            else:
                # Pour super admin, v√©rifier les configurations globales (sans client_id)
                query = query.filter(ConfigurationAudit.client_id.is_(None))
            
            if not query.first():
                config = ConfigurationAudit(**config_data)
                config.created_by = current_user.id
                
                # CORRECTION : Ajouter client_id seulement pour les clients normaux
                if client_id:
                    config.client_id = client_id
                
                db.session.add(config)
        
        # Templates de constatations par d√©faut (par client)
        templates_constatations_defaut = [
            {
                'reference': 'TEMP-CON-001',
                'titre': 'Documentation manquante',
                'description': 'La documentation requise pour le processus n\'est pas disponible ou incompl√®te.',
                'type_constatation': 'non_conformite',
                'gravite_defaut': 'moyenne',
                'processus_concerne': 'Tous processus',
                'cause_racine_typique': 'Absence de proc√©dure document√©e ou non application des proc√©dures existantes.',
                'recommandation_standard': '√âlaborer et mettre en ≈ìuvre les proc√©dures document√©es manquantes.'
            },
            {
                'reference': 'TEMP-CON-002', 
                'titre': 'Non-respect des d√©lais',
                'description': 'Les d√©lais d√©finis dans les proc√©dures ne sont pas respect√©s.',
                'type_constatation': 'non_conformite',
                'gravite_defaut': 'mineure',
                'processus_concerne': 'Processus op√©rationnels',
                'cause_racine_typique': 'Charge de travail excessive ou mauvaise estimation des d√©lais.',
                'recommandation_standard': 'R√©viser les d√©lais et mettre en place un suivi des √©ch√©ances.'
            }
        ]
        
        for template_data in templates_constatations_defaut:
            # CORRECTION : V√©rifier si le template existe pour ce client
            query = TemplateConstatation.query.filter_by(reference=template_data['reference'])
            
            if client_id:
                query = query.filter_by(client_id=client_id)
            else:
                query = query.filter(TemplateConstatation.client_id.is_(None))
            
            if not query.first():
                template = TemplateConstatation(**template_data)
                template.created_by = current_user.id
                
                if client_id:
                    template.client_id = client_id
                
                db.session.add(template)
        
        db.session.commit()
        flash('Configurations et templates d\'audit initialis√©s avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de l\'initialisation: {str(e)}', 'error')
    
    return redirect(url_for('configurations_audit'))

@app.route('/audits')
@login_required
def liste_audits():
    """Liste de tous les audits avec filtres d'archivage et isolation"""
    
    # V√âRIFICATION FORMULE : v√©rifier si le client a acc√®s au module "audit"
    if current_user.client and current_user.client.formule:
        formule = current_user.client.formule
        
        # V√©rifier si la formule donne acc√®s au module "audit"
        if not formule.can_access_module('audit_interne'):
            # Afficher une page d'upgrade
            try:
                # R√©cup√©rer toutes les formules actives
                all_formules = FormuleAbonnement.query.filter(
                    FormuleAbonnement.is_active == True
                ).all()
                
                # Filtrer celles qui ont le module audit
                upgrade_suggestions = []
                for f in all_formules:
                    if f.modules.get('audit', False):
                        upgrade_suggestions.append(f)
                
                # Trier par prix
                upgrade_suggestions.sort(key=lambda x: x.prix_mensuel or 0)
                
                return render_template('errors/formule_restricted.html', 
                                     module_name='Gestion des Audits',
                                     current_formule=formule,
                                     upgrade_suggestions=upgrade_suggestions[:3])
                
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur recherche formules upgrade: {e}")
                flash('Ce module n\'est pas inclus dans votre formule actuelle', 'error')
                return redirect(url_for('dashboard'))
    
    # V√©rifier la permission de g√©rer les audits
    if not current_user.has_permission('can_manage_audit'):
        flash('Acc√®s refus√© : permission de g√©rer les audits requise', 'error')
        return redirect(url_for('dashboard'))
    
    show_archived = request.args.get('show_archived', 'false').lower() == 'true'
    
    # CORRECTION : Utiliser get_client_filter
    if show_archived:
        audits_query = get_client_filter(Audit).filter_by(is_archived=True)
    else:
        audits_query = get_client_filter(Audit).filter_by(is_archived=False)
    
    audits = audits_query.all()
    
    # V√©rifier l'acc√®s pour chaque audit (s√©curit√© suppl√©mentaire)
    accessible_audits = []
    for audit in audits:
        if check_client_access(audit):
            accessible_audits.append(audit)
    
    # Calcul des statistiques
    stats = {
        'total': len(accessible_audits),
        'planifies': len([a for a in accessible_audits if a.statut == 'planifie']),
        'en_preparation': len([a for a in accessible_audits if a.sous_statut == 'preparation']),
        'en_collecte': len([a for a in accessible_audits if a.sous_statut == 'collecte']),
        'en_analyse': len([a for a in accessible_audits if a.sous_statut == 'analyse']),
        'en_redaction': len([a for a in accessible_audits if a.sous_statut == 'redaction']),
        'en_validation': len([a for a in accessible_audits if a.sous_statut == 'validation']),
        'clos': len([a for a in accessible_audits if a.statut == 'clos']),
        'constatations_total': sum(len(a.constatations) for a in accessible_audits),
        'recommandations_total': sum(len(a.recommandations) for a in accessible_audits),
        'plans_action_total': sum(len(a.plans_action) for a in accessible_audits),
        'archives': get_client_filter(Audit).filter_by(is_archived=True).count()
    }
    
    return render_template('audits.html', 
                         audits=accessible_audits, 
                         stats=stats,
                         show_archived=show_archived,
                           now=datetime.now())

@app.route('/audit/nouveau', methods=['GET', 'POST'])
@login_required
def nouvel_audit():
    """Cr√©er un nouvel audit avec isolation multi-tenant - VERSION CORRIG√âE"""

    # ===== FORMULAIRE COMPLET =====
    from flask_wtf import FlaskForm
    from wtforms import (
        StringField, TextAreaField, SelectField, RadioField,
        DateField, SubmitField, SelectMultipleField
    )
    from wtforms.validators import DataRequired, Optional, Length

    def coerce_int_or_none(value):
        if value in (None, ''):
            return None
        try:
            return int(value)
        except ValueError:
            return None

    class AuditFormComplete(FlaskForm):
        titre = StringField("Titre de l'audit", validators=[DataRequired()])
        description = TextAreaField("Description")

        type_audit = SelectField(
            "Type d'audit",
            choices=[],
            validators=[DataRequired()]
        )

        # ===== PROCESSUS =====
        selection_processus = RadioField(
            "M√©thode de s√©lection du processus",
            choices=[
                ('logigramme', 'S√©lectionner depuis le logigramme'),
                ('manuel', 'Saisie manuelle'),
                ('aucun', 'Aucun processus')
            ],
            default='logigramme',
            validators=[DataRequired()]
        )

        processus_id = SelectField(
            "Processus audit√© (logigramme)",
            coerce=coerce_int_or_none,
            choices=[],
            validators=[Optional()]
        )

        processus_manuel = StringField(
            "Processus (manuel)",
            validators=[Optional(), Length(max=500)]
        )

        # ===== RESPONSABLE =====
        responsable_id = SelectField(
            "Responsable de l'audit",
            coerce=coerce_int_or_none,
            choices=[],
            validators=[Optional()]
        )

        # ===== DATES =====
        date_debut_prevue = DateField(
            "Date de d√©but pr√©vue",
            format='%Y-%m-%d',
            validators=[Optional()]
        )

        date_fin_prevue = DateField(
            "Date de fin pr√©vue",
            format='%Y-%m-%d',
            validators=[Optional()]
        )

        # ===== CONTENU =====
        portee = TextAreaField("Port√©e")
        objectifs = TextAreaField("Objectifs")
        criteres = TextAreaField("Crit√®res")
        parties_prenantes = TextAreaField("Parties prenantes")

        # ===== STATUT =====
        statut = SelectField(
            "Statut",
            choices=[
                ('planifie', 'Planifi√©'),
                ('en_preparation', 'En pr√©paration'),
                ('en_cours', 'En cours'),
                ('en_redaction', 'En r√©daction'),
                ('en_validation', 'En validation'),
                ('clos', 'Clos')
            ],
            default='planifie'
        )

        sous_statut = SelectField(
            "Sous-statut",
            choices=[
                ('planification', 'Planification'),
                ('preparation', 'Pr√©paration'),
                ('collecte', 'Collecte des preuves'),
                ('analyse', 'Analyse'),
                ('redaction', 'R√©daction'),
                ('validation', 'Validation'),
                ('cloture', 'Cl√¥ture')
            ],
            validators=[Optional()]
        )

        # ===== √âQUIPES =====
        equipe_audit_ids = SelectMultipleField(
            "Auditeurs",
            coerce=int,
            choices=[],
            validators=[Optional()]
        )

        participants_ids = SelectMultipleField(
            "Participants",
            coerce=int,
            choices=[],
            validators=[Optional()]
        )

        observateurs_ids = SelectMultipleField(
            "Observateurs",
            coerce=int,
            choices=[],
            validators=[Optional()]
        )

        submit = SubmitField("Cr√©er l'audit")

    form = AuditFormComplete()

    # ===== DONN√âES =====
    # R√©cup√©rer uniquement les utilisateurs du m√™me client
    if current_user.role == 'super_admin':
        all_users = User.query.filter_by(is_active=True).order_by(User.username).all()
    else:
        all_users = get_client_filter(User).filter_by(is_active=True).order_by(User.username).all()

    # Processus actifs de l'utilisateur
    all_processus = get_client_filter(ProcessusActivite)\
        .filter_by(is_archived=False)\
        .order_by(ProcessusActivite.nom).all()

    # ===== CHOIX DYNAMIQUES =====
    form.type_audit.choices = [
        ('', 'S√©lectionnez un type'),
        ('interne', 'Audit Interne'),
        ('externe', 'Audit Externe'),
        ('qualite', 'Audit Qualit√©'),
        ('conformite', 'Audit Conformit√©'),
        ('securite', 'Audit S√©curit√©'),
        ('performance', 'Audit Performance'),
        ('financier', 'Audit Financier'),
        ('operationnel', 'Audit Op√©rationnel'),
        ('systeme', 'Audit Syst√®me')
    ]

    form.processus_id.choices = [('', 'S√©lectionnez un processus')] + [
        (
            p.id,
            f"{p.nom} - {p.direction.nom if p.direction else 'Non sp√©cifi√©'}"
        )
        for p in all_processus
    ]

    form.responsable_id.choices = [('', 'S√©lectionnez un responsable')] + [
        (u.id, f"{u.username} - {u.role}") for u in all_users
    ]

    form.equipe_audit_ids.choices = [(u.id, f"{u.username} - {u.role}") for u in all_users]
    form.participants_ids.choices = [(u.id, f"{u.username} - {u.role}") for u in all_users]
    form.observateurs_ids.choices = [(u.id, f"{u.username} - {u.role}") for u in all_users]

    # ===== SOUMISSION =====
    if form.validate_on_submit():
        try:
            # G√âN√âRATION DE R√âF√âRENCE UNIQUE
            def generer_reference_audit(client_id=None):
                """G√©n√®re une r√©f√©rence unique pour un audit"""
                from sqlalchemy import func
                
                base_ref = "AUD-"
                
                if client_id:
                    dernier = Audit.query.filter_by(client_id=client_id)\
                        .order_by(Audit.id.desc())\
                        .first()
                else:
                    dernier = Audit.query.order_by(Audit.id.desc()).first()
                
                if dernier and dernier.reference:
                    try:
                        if dernier.reference.startswith(base_ref):
                            dernier_num = int(dernier.reference.split('-')[1])
                            nouveau_num = dernier_num + 1
                        else:
                            if client_id:
                                count = Audit.query.filter_by(client_id=client_id).count()
                            else:
                                count = Audit.query.count()
                            nouveau_num = count + 1
                    except (ValueError, IndexError):
                        if client_id:
                            count = Audit.query.filter_by(client_id=client_id).count()
                        else:
                            count = Audit.query.count()
                        nouveau_num = count + 1
                else:
                    nouveau_num = 1
                
                return f"{base_ref}{nouveau_num:04d}"
            
            # D√©terminer le client_id pour la g√©n√©ration de r√©f√©rence
            client_id_for_ref = None
            if current_user.role != 'super_admin' and hasattr(current_user, 'client_id'):
                client_id_for_ref = current_user.client_id
            elif current_user.role == 'super_admin' and session.get('viewing_client_id'):
                client_id_for_ref = session.get('viewing_client_id')
            
            # G√©n√©rer la r√©f√©rence
            reference = generer_reference_audit(client_id_for_ref)
            
            # V√©rifier que la r√©f√©rence n'existe pas d√©j√†
            existing_audit = Audit.query.filter_by(reference=reference).first()
            if existing_audit:
                base_num = int(reference.split('-')[1])
                for i in range(1, 1000):
                    new_ref = f"AUD-{(base_num + i):04d}"
                    if not Audit.query.filter_by(reference=new_ref).first():
                        reference = new_ref
                        break
            
            audit = Audit(
                reference=reference,
                titre=form.titre.data,
                description=form.description.data,
                type_audit=form.type_audit.data,
                date_debut_prevue=form.date_debut_prevue.data,
                date_fin_prevue=form.date_fin_prevue.data,
                portee=form.portee.data,
                objectifs=form.objectifs.data,
                criteres=form.criteres.data,
                parties_prenantes=form.parties_prenantes.data,
                statut=form.statut.data,
                sous_statut=form.sous_statut.data or 'planification',
                created_by=current_user.id,
                # CORRECTION : TOUJOURS D√âFINIR client_id √Ä LA CR√âATION
                client_id=current_user.client_id  # IMPORTANT !
            )

            # CORRECTION : UNIQUEMENT pour super_admin en mode client
            if current_user.role == 'super_admin' and session.get('viewing_client_id'):
                audit.client_id = session.get('viewing_client_id')

            # ===== PROCESSUS =====
            if form.selection_processus.data == 'logigramme' and form.processus_id.data:
                processus = ProcessusActivite.query.get(form.processus_id.data)
                if processus and check_client_access(processus):
                    audit.processus_id = form.processus_id.data
                    audit.processus_concerne = None
                else:
                    flash('Acc√®s non autoris√© √† ce processus', 'error')
                    return render_template('audit/form_audit.html', form=form, all_users=all_users, all_processus=all_processus, title="Nouvel Audit")

            elif form.selection_processus.data == 'manuel' and form.processus_manuel.data:
                audit.processus_concerne = form.processus_manuel.data.strip()
                audit.processus_id = None

            else:
                audit.processus_id = None
                audit.processus_concerne = None

            # ===== RESPONSABLE =====
            if form.responsable_id.data:
                responsable = db.session.get(User, form.responsable_id.data)
                if responsable:
                    # V√©rifier que le responsable appartient au m√™me client
                    if current_user.role != 'super_admin':
                        if responsable.client_id != current_user.client_id:
                            flash('Le responsable s√©lectionn√© ne fait pas partie de votre client', 'error')
                            return render_template('audit/form_audit.html', form=form, all_users=all_users, all_processus=all_processus, title="Nouvel Audit")
                    
                    audit.responsable_id = form.responsable_id.data
                else:
                    flash('Responsable non trouv√©', 'error')
                    return render_template('audit/form_audit.html', form=form, all_users=all_users, all_processus=all_processus, title="Nouvel Audit")

            # ===== √âQUIPES =====
            equipe_ids = form.equipe_audit_ids.data or []
            participants_ids = form.participants_ids.data or []
            observateurs_ids = form.observateurs_ids.data or []
            
            # V√©rifier que tous les utilisateurs s√©lectionn√©s appartiennent au m√™me client
            if current_user.role != 'super_admin' and (equipe_ids or participants_ids or observateurs_ids):
                all_selected_ids = set(equipe_ids + participants_ids + observateurs_ids)
                users = User.query.filter(User.id.in_(all_selected_ids)).all()
                for user in users:
                    if user.client_id != current_user.client_id:
                        flash(f"L'utilisateur {user.username} ne fait pas partie de votre client", 'error')
                        return render_template('audit/form_audit.html', form=form, all_users=all_users, all_processus=all_processus, title="Nouvel Audit")

            audit.equipe_audit_ids = ','.join(map(str, equipe_ids)) if equipe_ids else None
            audit.participants_ids = ','.join(map(str, participants_ids)) if participants_ids else None
            audit.observateurs_ids = ','.join(map(str, observateurs_ids)) if observateurs_ids else None

            db.session.add(audit)
            db.session.flush()
            
            # ==================== NOTIFICATIONS ====================
            notifications_crees = []
            
            # 1. Notification pour le cr√©ateur
            notification_createur = Notification(
                destinataire_id=current_user.id,
                type_notification=Notification.TYPE_AUDIT_DEMARRE,
                titre=f"Audit cr√©√©: {audit.reference}",
                message=f"L'audit '{audit.titre}' a √©t√© cr√©√© avec succ√®s.",
                urgence=Notification.URGENCE_NORMAL,
                entite_type='audit',
                entite_id=audit.id,
                donnees_supplementaires={
                    'type_audit': audit.type_audit,
                    'statut': audit.statut,
                    'equipe_size': len(equipe_ids)
                },
                client_id=audit.client_id  # CORRECTION : Ajouter client_id
            )
            db.session.add(notification_createur)
            notifications_crees.append(current_user.id)
            
            # 2. Notification pour le responsable (si diff√©rent du cr√©ateur)
            if audit.responsable_id and audit.responsable_id != current_user.id:
                notification_responsable = Notification(
                    destinataire_id=audit.responsable_id,
                    type_notification=Notification.TYPE_AUDIT_DEMARRE,
                    titre=f"Vous √™tes responsable de l'audit: {audit.reference}",
                    message=f"Vous avez √©t√© d√©sign√© comme responsable de l'audit '{audit.titre}'.",
                    urgence=Notification.URGENCE_IMPORTANT,
                    entite_type='audit',
                    entite_id=audit.id,
                    donnees_supplementaires={
                        'type_audit': audit.type_audit,
                        'createur': current_user.username,
                        'date_debut': audit.date_debut_prevue.isoformat() if audit.date_debut_prevue else None
                    },
                    client_id=audit.client_id  # CORRECTION : Ajouter client_id
                )
                db.session.add(notification_responsable)
                notifications_crees.append(audit.responsable_id)
            
            # 3. Notifications pour l'√©quipe d'audit
            for user_id in equipe_ids:
                if user_id not in notifications_crees:
                    notification_equipe = Notification(
                        destinataire_id=user_id,
                        type_notification=Notification.TYPE_AUDIT_DEMARRE,
                        titre=f"Vous √™tes dans l'√©quipe d'audit: {audit.reference}",
                        message=f"Vous avez √©t√© ajout√© √† l'√©quipe de l'audit '{audit.titre}'.",
                        urgence=Notification.URGENCE_NORMAL,
                        entite_type='audit',
                        entite_id=audit.id,
                        donnees_supplementaires={
                            'role': 'auditeur',
                            'responsable': audit.responsable.username if audit.responsable else None
                        },
                        client_id=audit.client_id  # CORRECTION : Ajouter client_id
                    )
                    db.session.add(notification_equipe)
                    notifications_crees.append(user_id)
            
            db.session.commit()

            # Journaliser l'action
            log_activity(current_user.id, 'creation_audit',
                        f"Cr√©ation audit {audit.reference}: {audit.titre}",
                        'audit', audit.id)

            flash(f'‚úÖ Audit "{audit.titre}" cr√©√© avec succ√®s ({audit.reference})', 'success')
            return redirect(url_for('detail_audit', id=audit.id))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Erreur cr√©ation audit: {str(e)}", exc_info=True)
            flash(f"‚ùå Erreur lors de la cr√©ation de l'audit: {str(e)}", "danger")

    return render_template(
        'audit/form_audit.html',
        form=form,
        all_users=all_users,
        all_processus=all_processus,
        title="Nouvel Audit"
    )


@app.route('/audit/<int:id>/edit', methods=['GET', 'POST'])
@login_required
def edit_audit(id):
    """Modifier un audit existant avec isolation multi-tenant"""
    
    # CORRECTION : R√©cup√©rer avec v√©rification d'acc√®s
    audit = Audit.query.get_or_404(id)
    
    # V√©rifier l'acc√®s
    if not check_client_access(audit):
        flash('Acc√®s non autoris√© √† cet audit', 'error')
        return redirect(url_for('liste_audits'))
    
    # Cr√©er un formulaire de modification
    from flask_wtf import FlaskForm
    from wtforms import StringField, TextAreaField, SelectField, RadioField, DateField, SubmitField, SelectMultipleField
    from wtforms.validators import DataRequired, Optional, Length
    
    def coerce_int_or_none(value):
        if value == '' or value is None:
            return None
        try:
            return int(value)
        except ValueError:
            return None
    
    class EditAuditForm(FlaskForm):
        # Informations de base
        titre = StringField("Titre de l'audit", validators=[DataRequired()])
        description = TextAreaField("Description")
        
        type_audit = SelectField(
            "Type d'audit",
            choices=[],  # Sera rempli
            validators=[DataRequired()]
        )
        
        # S√âLECTION DE PROCESSUS
        selection_processus = RadioField(
            "M√©thode de s√©lection du processus",
            choices=[
                ('logigramme', 'S√©lectionner depuis le logigramme'),
                ('manuel', '√âcrire manuellement'),
                ('aucun', 'Aucun processus sp√©cifique')
            ],
            default='logigramme',
            validators=[DataRequired()]
        )
        
        processus_id = SelectField(
            "Processus audit√© (logigramme)", 
            coerce=coerce_int_or_none,
            choices=[],  # Sera rempli
            validators=[Optional()]
        )
        
        processus_manuel = StringField(
            "Nom du processus (manuel)",
            validators=[Optional(), Length(max=500)]
        )
        
        # Responsable
        responsable_id = SelectField(
            "Responsable", 
            coerce=coerce_int_or_none,
            choices=[],  # Sera rempli
            validators=[Optional()]
        )
        
        # Dates
        date_debut_prevue = DateField(
            "Date de d√©but pr√©vue", 
            format='%Y-%m-%d', 
            validators=[Optional()]
        )
        
        date_fin_prevue = DateField(
            "Date de fin pr√©vue", 
            format='%Y-%m-%d', 
            validators=[Optional()]
        )
        
        date_debut_reelle = DateField(
            "Date de d√©but r√©elle", 
            format='%Y-%m-%d', 
            validators=[Optional()]
        )
        
        date_fin_reelle = DateField(
            "Date de fin r√©elle", 
            format='%Y-%m-%d', 
            validators=[Optional()]
        )
        
        # Informations techniques
        portee = TextAreaField("Port√©e de l'audit")
        objectifs = TextAreaField("Objectifs")
        criteres = TextAreaField("Crit√®res d'audit")
        parties_prenantes = TextAreaField("Parties prenantes suppl√©mentaires")
        
        # Statuts
        statut = SelectField(
            "Statut",
            choices=[
                ('planifie', 'Planifi√©'),
                ('en_preparation', 'En pr√©paration'),
                ('en_cours', 'En cours'),
                ('en_redaction', 'En r√©daction'),
                ('en_validation', 'En validation'),
                ('clos', 'Clos'),
                ('suspendu', 'Suspendu'),
                ('annule', 'Annul√©')
            ]
        )
        
        sous_statut = SelectField(
            "Sous-statut",
            choices=[
                ('planification', 'Planification'),
                ('preparation', 'Pr√©paration'),
                ('collecte', 'Collecte des preuves'),
                ('analyse', 'Analyse'),
                ('redaction', 'R√©daction du rapport'),
                ('validation', 'Validation'),
                ('cloture', 'Cl√¥ture'),
                ('archive', 'Archiv√©')
            ],
            validators=[Optional()]
        )
        
        # √âquipes
        equipe_audit_ids = SelectMultipleField(
            "Auditeurs participants",
            coerce=int,
            choices=[],  # Sera rempli
            validators=[Optional()]
        )
        
        participants_ids = SelectMultipleField(
            "Participants interview√©s",
            coerce=int,
            choices=[],  # Sera rempli
            validators=[Optional()]
        )
        
        observateurs_ids = SelectMultipleField(
            "Observateurs",
            coerce=int,
            choices=[],  # Sera rempli
            validators=[Optional()]
        )
        
        commentaires = TextAreaField("Commentaires g√©n√©raux")
        
        submit = SubmitField("Mettre √† jour l'audit")
    
    # Cr√©er le formulaire avec les donn√©es actuelles
    form = EditAuditForm(obj=audit)
    
    # CORRECTION : R√©cup√©rer les donn√©es avec filtrage client
    all_processus = get_client_filter(ProcessusActivite).order_by(ProcessusActivite.nom).all()
    
    # CORRECTION : R√©cup√©rer uniquement les utilisateurs du m√™me client
    if current_user.role == 'super_admin':
        all_users = User.query.filter_by(is_active=True).order_by(User.username).all()
    else:
        all_users = get_client_filter(User).filter_by(is_active=True).order_by(User.username).all()
    
    # Initialiser les choix
    form.type_audit.choices = [
        ('', 'S√©lectionnez un type'),
        ('interne', 'Audit Interne'),
        ('externe', 'Audit Externe'),
        ('qualite', 'Audit Qualit√©'),
        ('conformite', 'Audit Conformit√©'),
        ('securite', 'Audit S√©curit√©'),
        ('performance', 'Audit Performance'),
        ('financier', 'Audit Financier'),
        ('operationnel', 'Audit Op√©rationnel'),
        ('systeme', 'Audit Syst√®me')
    ]
    
    form.processus_id.choices = [('', 'S√©lectionnez un processus')] + [
        (p.id, f"{p.nom} - {p.direction.nom if p.direction else 'Non sp√©cifi√©'}") 
        for p in all_processus
    ]
    
    form.responsable_id.choices = [('', 'S√©lectionnez un responsable')] + [
        (u.id, f"{u.username} - {u.role}") for u in all_users
    ]
    
    form.equipe_audit_ids.choices = [(u.id, f"{u.username} - {u.role}") for u in all_users]
    form.participants_ids.choices = [(u.id, f"{u.username} - {u.role}") for u in all_users]
    form.observateurs_ids.choices = [(u.id, f"{u.username} - {u.role}") for u in all_users]
    
    # D√©terminer la m√©thode de s√©lection actuelle
    if audit.processus_id:
        form.selection_processus.data = 'logigramme'
        form.processus_id.data = audit.processus_id
    elif hasattr(audit, 'processus_concerne') and audit.processus_concerne:
        form.selection_processus.data = 'manuel'
        form.processus_manuel.data = audit.processus_concerne
    else:
        form.selection_processus.data = 'aucun'
    
    # Pr√©-remplir les listes d'√©quipe
    if audit.equipe_audit_ids:
        try:
            form.equipe_audit_ids.data = [int(id.strip()) for id in audit.equipe_audit_ids.split(',') if id.strip()]
        except (ValueError, AttributeError):
            form.equipe_audit_ids.data = []
    
    if audit.participants_ids:
        try:
            form.participants_ids.data = [int(id.strip()) for id in audit.participants_ids.split(',') if id.strip()]
        except (ValueError, AttributeError):
            form.participants_ids.data = []
    
    if audit.observateurs_ids:
        try:
            form.observateurs_ids.data = [int(id.strip()) for id in audit.observateurs_ids.split(',') if id.strip()]
        except (ValueError, AttributeError):
            form.observateurs_ids.data = []
    
    if form.validate_on_submit():
        try:
            # Enregistrer l'ancien √©tat
            ancien_etat = {
                'titre': audit.titre,
                'type_audit': audit.type_audit,
                'statut': audit.statut,
                'sous_statut': audit.sous_statut,
                'processus_id': audit.processus_id,
                'processus_concerne': getattr(audit, 'processus_concerne', None),
                'responsable_id': audit.responsable_id
            }
            
            # Mettre √† jour les champs de base
            audit.titre = form.titre.data
            audit.description = form.description.data
            audit.type_audit = form.type_audit.data
            audit.statut = form.statut.data
            audit.sous_statut = form.sous_statut.data if form.sous_statut.data else audit.sous_statut
            
            # Dates
            audit.date_debut_prevue = form.date_debut_prevue.data
            audit.date_fin_prevue = form.date_fin_prevue.data
            audit.date_debut_reelle = form.date_debut_reelle.data if form.date_debut_reelle.data else None
            audit.date_fin_reelle = form.date_fin_reelle.data if form.date_fin_reelle.data else None
            
            # Informations techniques
            audit.portee = form.portee.data if form.portee.data else None
            audit.objectifs = form.objectifs.data if form.objectifs.data else None
            audit.criteres = form.criteres.data if form.criteres.data else None
            audit.parties_prenantes = form.parties_prenantes.data if form.parties_prenantes.data else None
            audit.commentaires = form.commentaires.data if form.commentaires.data else None
            
            # Gestion du processus selon la m√©thode choisie
            selection_method = form.selection_processus.data
            
            if selection_method == 'logigramme':
                # Processus depuis le logigramme
                if form.processus_id.data:
                    processus_id = int(form.processus_id.data)
                    # V√©rifier que le processus appartient au m√™me client
                    processus = ProcessusActivite.query.get(processus_id)
                    if processus and not check_client_access(processus):
                        flash('Le processus s√©lectionn√© ne fait pas partie de votre client', 'error')
                        return render_template('audit/form_audit.html', form=form, audit=audit, all_users=all_users, all_processus=all_processus, title=f"Modifier l'audit {audit.reference}")
                    
                    audit.processus_id = processus_id
                    # Effacer le champ manuel si existe
                    if hasattr(audit, 'processus_concerne'):
                        audit.processus_concerne = None
                else:
                    audit.processus_id = None
                    if hasattr(audit, 'processus_concerne'):
                        audit.processus_concerne = None
                        
            elif selection_method == 'manuel':
                # Processus saisi manuellement
                if form.processus_manuel.data:
                    if hasattr(audit, 'processus_concerne'):
                        audit.processus_concerne = form.processus_manuel.data.strip()
                    audit.processus_id = None
                else:
                    if hasattr(audit, 'processus_concerne'):
                        audit.processus_concerne = None
                    audit.processus_id = None
                    
            elif selection_method == 'aucun':
                # Aucun processus sp√©cifique
                audit.processus_id = None
                if hasattr(audit, 'processus_concerne'):
                    audit.processus_concerne = None
            
            # Responsable
            if form.responsable_id.data:
                responsable_id = int(form.responsable_id.data)
                # V√©rifier que le responsable appartient au m√™me client
                responsable = User.query.get(responsable_id)
                if responsable and not check_client_access(responsable):
                    flash('Le responsable s√©lectionn√© ne fait pas partie de votre client', 'error')
                    return render_template('audit/form_audit.html', form=form, audit=audit, all_users=all_users, all_processus=all_processus, title=f"Modifier l'audit {audit.reference}")
                
                audit.responsable_id = responsable_id
            else:
                audit.responsable_id = None
            
            # Gestion des listes d'√©quipe
            equipe_ids = form.equipe_audit_ids.data or []
            participants_ids = form.participants_ids.data or []
            observateurs_ids = form.observateurs_ids.data or []
            
            # V√©rifier que tous les utilisateurs s√©lectionn√©s appartiennent au m√™me client
            if current_user.role != 'super_admin':
                all_selected_ids = set(equipe_ids + participants_ids + observateurs_ids)
                if all_selected_ids:
                    users = User.query.filter(User.id.in_(all_selected_ids)).all()
                    for user in users:
                        if not check_client_access(user):
                            flash(f"L'utilisateur {user.username} ne fait pas partie de votre client", 'error')
                            return render_template('audit/form_audit.html', form=form, audit=audit, all_users=all_users, all_processus=all_processus, title=f"Modifier l'audit {audit.reference}")
            
            audit.equipe_audit_ids = ','.join(map(str, equipe_ids)) if equipe_ids else None
            audit.participants_ids = ','.join(map(str, participants_ids)) if participants_ids else None
            audit.observateurs_ids = ','.join(map(str, observateurs_ids)) if observateurs_ids else None
            
            audit.updated_at = datetime.utcnow()
            db.session.commit()
            
            # Journaliser
            if 'journaliser_action_audit' in globals():
                journaliser_action_audit(
                    audit_id=audit.id,
                    action_type='modification_audit',
                    user_id=current_user.id,
                    details={
                        'ancien_etat': ancien_etat,
                        'nouvel_etat': {
                            'titre': audit.titre,
                            'type_audit': audit.type_audit,
                            'statut': audit.statut,
                            'processus_id': audit.processus_id,
                            'processus_concerne': getattr(audit, 'processus_concerne', None),
                            'responsable_id': audit.responsable_id
                        }
                    }
                )
            
            flash('Audit modifi√© avec succ√®s', 'success')
            return redirect(url_for('detail_audit', id=audit.id))
            
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Erreur lors de la modification de l'audit {id}: {str(e)}", exc_info=True)
            flash(f'Erreur lors de la modification: {str(e)}', 'error')
    
    return render_template('audit/form_audit.html', 
                         form=form, 
                         audit=audit,
                         all_users=all_users,
                         all_processus=all_processus,
                         title=f"Modifier l'audit {audit.reference}")
@app.route('/audit/<int:id>/archive', methods=['POST'])
@csrf.exempt
@login_required
def archive_audit(id):
    """Archiver un audit avec isolation multi-tenant - VERSION ULTIME"""
    
    print(f"üîç [ARCHIVE] D√©but pour audit {id}")
    print(f"üîç [ARCHIVE] User: {current_user.username} (client_id={current_user.client_id}, role={current_user.role})")
    
    # 1. R√©cup√©rer l'audit
    audit = Audit.query.get(id)
    
    if not audit:
        flash('Audit non trouv√©', 'error')
        return redirect(url_for('liste_audits'))
    
    print(f"üîç [ARCHIVE] Audit: {audit.reference} (client_id={audit.client_id}, created_by={audit.created_by})")
    
    # 2. CORRECTION CRITIQUE : Si l'audit appartient √† un autre client mais que l'utilisateur est le cr√©ateur
    if audit.client_id and audit.client_id != current_user.client_id:
        print(f"‚ö†Ô∏è [ARCHIVE] Audit client_id={audit.client_id} diff√©rent de user client_id={current_user.client_id}")
        
        # V√©rifier si l'utilisateur est le cr√©ateur
        if audit.created_by == current_user.id:
            print(f"‚úÖ [ARCHIVE] Utilisateur est le cr√©ateur - autorisation sp√©ciale")
            # On autorise car c'est le cr√©ateur
        else:
            print(f"‚ùå [ARCHIVE] Acc√®s refus√©: pas le m√™me client et pas le cr√©ateur")
            flash('Acc√®s non autoris√© √† cet audit', 'error')
            return redirect(url_for('liste_audits'))
    
    # 3. V√©rifier permissions simplifi√©e
    can_archive = False
    
    # Super admin peut tout faire
    if current_user.role == 'super_admin':
        can_archive = True
    # Admin client peut archiver les audits de son client
    elif current_user.is_client_admin and audit.client_id == current_user.client_id:
        can_archive = True
    # Cr√©ateur peut archiver son audit
    elif audit.created_by == current_user.id:
        can_archive = True
    # Responsable peut archiver
    elif audit.responsable_id == current_user.id:
        can_archive = True
    # Permission can_manage_audit
    elif current_user.has_permission('can_manage_audit'):
        can_archive = True
    
    print(f"üîç [ARCHIVE] can_archive: {can_archive}")
    
    if not can_archive:
        flash('Vous n\'avez pas les permissions n√©cessaires', 'error')
        return redirect(url_for('detail_audit', id=id))
    
    # 4. ARCHIVAGE
    try:
        print(f"üîÑ [ARCHIVE] D√©but archivage...")
        
        # Si audit n'a pas de client_id, lui attribuer
        if audit.client_id is None:
            print(f"‚ö†Ô∏è [ARCHIVE] Attribution client_id={current_user.client_id}")
            audit.client_id = current_user.client_id
        
        # Mettre √† jour l'audit
        audit.is_archived = True
        audit.archived_at = datetime.utcnow()
        audit.archived_by = current_user.id
        audit.statut = 'archive'
        audit.sous_statut = 'archive'
        
        print(f"üîç [ARCHIVE] Audit mis √† jour: is_archived={audit.is_archived}")
        
        db.session.commit()
        print(f"‚úÖ [ARCHIVE] Commit r√©ussi!")
        
        flash(f'‚úÖ Audit "{audit.titre}" archiv√© avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå [ARCHIVE] Erreur: {str(e)}")
        import traceback
        traceback.print_exc()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
    
    return redirect(url_for('liste_audits'))

@app.route('/audit/<int:id>/restaurer', methods=['POST'])
@csrf.exempt
@login_required
def restaurer_audit(id):
    """Restaurer un audit archiv√© - VERSION SIMPLIFI√âE"""
    
    print(f"üîç [RESTAURER] D√©but pour audit {id}")
    
    # R√©cup√©rer l'audit archiv√©
    audit = Audit.query.filter_by(id=id, is_archived=True).first()
    
    if not audit:
        flash('Audit archiv√© non trouv√©', 'error')
        return redirect(url_for('liste_audits', show_archived=True))
    
    print(f"üîç [RESTAURER] Audit: {audit.reference} (client_id={audit.client_id}, created_by={audit.created_by})")
    
    # V√©rification simplifi√©e d'acc√®s
    if audit.client_id and audit.client_id != current_user.client_id:
        if audit.created_by != current_user.id:
            flash('Acc√®s non autoris√©', 'error')
            return redirect(url_for('liste_audits', show_archived=True))
    
    # V√©rification simplifi√©e de permission
    can_restore = False
    
    if current_user.role == 'super_admin':
        can_restore = True
    elif current_user.is_client_admin and audit.client_id == current_user.client_id:
        can_restore = True
    elif audit.created_by == current_user.id:
        can_restore = True
    elif audit.responsable_id == current_user.id:
        can_restore = True
    elif current_user.has_permission('can_manage_audit'):
        can_restore = True
    
    if not can_restore:
        flash('Permission refus√©e', 'error')
        return redirect(url_for('liste_audits', show_archived=True))
    
    try:
        # Restaurer
        audit.is_archived = False
        audit.archived_at = None
        audit.archived_by = None
        audit.statut = 'planifie'
        
        db.session.commit()
        flash('‚úÖ Audit restaur√© avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
    
    return redirect(url_for('liste_audits', show_archived=True))

@app.route('/debug_audit_access/<int:id>')
@login_required
def debug_audit_access(id):
    """Debug l'acc√®s √† un audit sp√©cifique"""
    
    import json
    from flask import jsonify
    
    print(f"üîç [DEBUG_ACCESS] D√©but pour audit {id}")
    print(f"üîç [DEBUG_ACCESS] User: {current_user.username} (id={current_user.id}, client_id={current_user.client_id})")
    
    audit = Audit.query.get(id)
    
    if not audit:
        return "‚ùå Audit non trouv√©"
    
    print(f"üîç [DEBUG_ACCESS] Audit trouv√©: {audit.reference}")
    
    # Test check_client_access
    try:
        access_result = check_client_access(audit)
        print(f"‚úÖ check_client_access r√©sultat: {access_result}")
    except Exception as e:
        print(f"‚ùå Erreur check_client_access: {str(e)}")
        access_result = f"Erreur: {str(e)}"
    
    # Test can_archive_audit
    try:
        can_archive = current_user.can_archive_audit(audit)
        print(f"‚úÖ can_archive_audit r√©sultat: {can_archive}")
    except Exception as e:
        print(f"‚ùå Erreur can_archive_audit: {str(e)}")
        can_archive = f"Erreur: {str(e)}"
    
    # Collecte des informations
    debug_info = {
        'audit': {
            'id': audit.id,
            'reference': audit.reference,
            'titre': audit.titre,
            'client_id': audit.client_id,
            'created_by': audit.created_by,
            'responsable_id': audit.responsable_id,
            'is_archived': audit.is_archived,
            'statut': audit.statut,
            'equipe_audit_ids': audit.equipe_audit_ids,
        },
        'user': {
            'id': current_user.id,
            'username': current_user.username,
            'client_id': current_user.client_id,
            'role': current_user.role,
            'is_client_admin': current_user.is_client_admin,
            'can_manage_users': current_user.can_manage_users,
        },
        'access': {
            'check_client_access': access_result,
            'can_archive_audit': can_archive,
            'has_permission_can_manage_audit': current_user.has_permission('can_manage_audit'),
            'is_creator': current_user.id == audit.created_by,
            'is_responsable': current_user.id == audit.responsable_id,
            'client_id_match': current_user.client_id == audit.client_id,
        },
        'permissions_debug': {
            'user_permissions': current_user.permissions if hasattr(current_user, 'permissions') else None,
            'has_permission_result': current_user.has_permission('can_manage_audit') if hasattr(current_user, 'has_permission') else 'M√©thode non trouv√©e',
        }
    }
    
    # HTML de debug
    html = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>Debug Audit {audit.reference}</title>
        <style>
            body {{ font-family: Arial, sans-serif; margin: 20px; }}
            .section {{ margin: 20px 0; padding: 15px; border: 1px solid #ddd; }}
            .success {{ background: #d4edda; border-color: #c3e6cb; }}
            .error {{ background: #f8d7da; border-color: #f5c6cb; }}
            .warning {{ background: #fff3cd; border-color: #ffeaa7; }}
            .info {{ background: #d1ecf1; border-color: #bee5eb; }}
            pre {{ background: #f8f9fa; padding: 10px; border: 1px solid #e9ecef; }}
            .btn {{ 
                display: inline-block; 
                padding: 10px 20px; 
                margin: 5px; 
                border: none; 
                border-radius: 4px; 
                cursor: pointer; 
                text-decoration: none;
                color: white;
            }}
            .btn-archive {{ background: #f0ad4e; }}
            .btn-restore {{ background: #5bc0de; }}
            .btn-delete {{ background: #d9534f; }}
            .btn-test {{ background: #0275d8; }}
        </style>
    </head>
    <body>
        <h1>üîç Debug Audit: {audit.reference}</h1>
        
        <div class="section info">
            <h2>Audit Info</h2>
            <pre>{json.dumps(debug_info['audit'], indent=2, default=str)}</pre>
        </div>
        
        <div class="section info">
            <h2>User Info</h2>
            <pre>{json.dumps(debug_info['user'], indent=2)}</pre>
        </div>
        
        <div class="section {'success' if debug_info['access']['check_client_access'] else 'error'}">
            <h2>Acc√®s & Permissions</h2>
            <pre>{json.dumps(debug_info['access'], indent=2)}</pre>
        </div>
        
        <div class="section warning">
            <h2>Permissions Debug</h2>
            <pre>{json.dumps(debug_info['permissions_debug'], indent=2, default=str)}</pre>
        </div>
        
        <div class="section">
            <h2>Actions de Test</h2>
            
            <h3>Test d'Archivage</h3>
            <form action="/test_archive_simple/{id}" method="POST" style="display: inline;">
                <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
                <button type="submit" class="btn btn-archive">üîß TEST ARCHIVER (Simple)</button>
            </form>
            
            <form action="/audit/{id}/archive" method="POST" style="display: inline;">
                <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
                <button type="submit" class="btn btn-archive">üì¶ ARCHIVER (Route normale)</button>
            </form>
            
            <h3>Autres Actions</h3>
            <a href="/test_archive_debug/{id}" class="btn btn-test">üß™ Test Debug Complet</a>
            <a href="/audits" class="btn btn-test">üìã Liste des Audits</a>
            <a href="/detail_audit/{id}" class="btn btn-test">üëÅÔ∏è D√©tail Audit</a>
        </div>
        
        <div class="section">
            <h2>Analyse</h2>
            <ul>
                <li><strong>Client ID Match:</strong> {'‚úÖ OUI' if debug_info['access']['client_id_match'] else '‚ùå NON'}</li>
                <li><strong>Cr√©ateur:</strong> {'‚úÖ OUI' if debug_info['access']['is_creator'] else '‚ùå NON'}</li>
                <li><strong>Permission can_manage_audit:</strong> {'‚úÖ OUI' if debug_info['access']['has_permission_can_manage_audit'] else '‚ùå NON'}</li>
                <li><strong>check_client_access:</strong> {'‚úÖ SUCC√àS' if debug_info['access']['check_client_access'] == True else '‚ùå √âCHEC'}</li>
                <li><strong>can_archive_audit:</strong> {'‚úÖ AUTORIS√â' if debug_info['access']['can_archive_audit'] == True else '‚ùå REFUS√â'}</li>
            </ul>
        </div>
        
        <div class="section">
            <h2>R√©solution de Probl√®mes</h2>
            <p>Si <strong>check_client_access</strong> √©choue :</p>
            <ol>
                <li>V√©rifiez que user.client_id ({current_user.client_id}) == audit.client_id ({audit.client_id})</li>
                <li>Si diff√©rent, v√©rifiez si vous √™tes le cr√©ateur (user.id={current_user.id} == audit.created_by={audit.created_by})</li>
                <li>Ex√©cutez <a href="/fix_all_audits_client">/fix_all_audits_client</a> pour corriger les client_id</li>
            </ol>
            
            <p>Si <strong>can_archive_audit</strong> √©choue :</p>
            <ol>
                <li>V√©rifiez votre r√¥le: {current_user.role}</li>
                <li>V√©rifiez is_client_admin: {current_user.is_client_admin}</li>
                <li>V√©rifiez la permission can_manage_audit</li>
            </ol>
        </div>
        
        <script>
            console.log("Debug info:", {json.dumps(debug_info, default=str)});
        </script>
    </body>
    </html>
    """
    
    return html

@app.route('/fix_all_audits_client', methods=['GET'])
@login_required
def fix_all_audits_client():
    """Migre TOUS les audits vers le client_id de leur cr√©ateur"""
    
    if current_user.role != 'super_admin' and not current_user.is_client_admin:
        flash('Permission refus√©e', 'error')
        return redirect(url_for('dashboard'))
    
    try:
        # R√©cup√©rer tous les audits
        all_audits = Audit.query.all()
        fixed_count = 0
        errors = []
        
        for audit in all_audits:
            try:
                # Si l'audit n'a pas de client_id
                if audit.client_id is None:
                    # Trouver le cr√©ateur
                    creator = User.query.get(audit.created_by)
                    if creator and creator.client_id:
                        audit.client_id = creator.client_id
                        fixed_count += 1
                        print(f"‚úÖ Audit {audit.id} -> client_id={creator.client_id}")
                    
                # Si l'audit a un client_id diff√©rent de son cr√©ateur
                elif hasattr(audit, 'created_by') and audit.created_by:
                    creator = User.query.get(audit.created_by)
                    if creator and creator.client_id and audit.client_id != creator.client_id:
                        print(f"‚ö†Ô∏è Audit {audit.id}: client_id={audit.client_id} mais cr√©ateur a client_id={creator.client_id}")
                        # Optionnel: corriger aussi
                        # audit.client_id = creator.client_id
                        # fixed_count += 1
                        
            except Exception as e:
                errors.append(f"Audit {audit.id}: {str(e)}")
        
        db.session.commit()
        
        return f"""
        <h1>Migration termin√©e</h1>
        <p>{fixed_count} audits corrig√©s</p>
        <p>{len(errors)} erreurs</p>
        <p><a href="/audits">Retour aux audits</a></p>
        """
        
    except Exception as e:
        db.session.rollback()
        return f"Erreur: {str(e)}"@app.route('/fix_all_audits_client', methods=['GET'])
@login_required
def fix_all_audits_client():
    """Migre TOUS les audits vers le client_id de leur cr√©ateur"""
    
    if current_user.role != 'super_admin' and not current_user.is_client_admin:
        flash('Permission refus√©e', 'error')
        return redirect(url_for('dashboard'))
    
    try:
        # R√©cup√©rer tous les audits
        all_audits = Audit.query.all()
        fixed_count = 0
        errors = []
        
        for audit in all_audits:
            try:
                # Si l'audit n'a pas de client_id
                if audit.client_id is None:
                    # Trouver le cr√©ateur
                    creator = User.query.get(audit.created_by)
                    if creator and creator.client_id:
                        audit.client_id = creator.client_id
                        fixed_count += 1
                        print(f"‚úÖ Audit {audit.id} -> client_id={creator.client_id}")
                    
                # Si l'audit a un client_id diff√©rent de son cr√©ateur
                elif hasattr(audit, 'created_by') and audit.created_by:
                    creator = User.query.get(audit.created_by)
                    if creator and creator.client_id and audit.client_id != creator.client_id:
                        print(f"‚ö†Ô∏è Audit {audit.id}: client_id={audit.client_id} mais cr√©ateur a client_id={creator.client_id}")
                        # Optionnel: corriger aussi
                        # audit.client_id = creator.client_id
                        # fixed_count += 1
                        
            except Exception as e:
                errors.append(f"Audit {audit.id}: {str(e)}")
        
        db.session.commit()
        
        return f"""
        <h1>Migration termin√©e</h1>
        <p>{fixed_count} audits corrig√©s</p>
        <p>{len(errors)} erreurs</p>
        <p><a href="/audits">Retour aux audits</a></p>
        """
        
    except Exception as e:
        db.session.rollback()
        return f"Erreur: {str(e)}"
    

@app.route('/audit/<int:id>/supprimer', methods=['POST'])
@login_required
def supprimer_audit(id):
    """Supprimer d√©finitivement un audit - VERSION SIMPLIFI√âE"""
    
    print(f"üîç [SUPPRIMER] D√©but pour audit {id}")
    
    # R√©cup√©rer l'audit archiv√©
    audit = Audit.query.filter_by(id=id, is_archived=True).first()
    
    if not audit:
        flash('Audit archiv√© non trouv√©', 'error')
        return redirect(url_for('liste_audits', show_archived=True))
    
    print(f"üîç [SUPPRIMER] Audit: {audit.reference} (client_id={audit.client_id})")
    
    # Seuls super_admin et admin client peuvent supprimer
    if current_user.role != 'super_admin' and not current_user.is_client_admin:
        flash('Permission refus√©e', 'error')
        return redirect(url_for('liste_audits', show_archived=True))
    
    # V√©rifier client_id
    if audit.client_id and audit.client_id != current_user.client_id:
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_audits', show_archived=True))
    
    try:
        # Supprimer
        db.session.delete(audit)
        db.session.commit()
        flash('‚úÖ Audit supprim√© d√©finitivement', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur: {str(e)}', 'error')
    
    return redirect(url_for('liste_audits', show_archived=True))



@app.route('/audit/<int:audit_id>/changer-statut', methods=['POST'])
@csrf.exempt
@login_required
def changer_statut_audit(audit_id):
    """Changer le statut d'un audit avec isolation multi-tenant"""
    
    # CORRECTION : R√©cup√©rer avec v√©rification d'acc√®s
    audit = Audit.query.get_or_404(audit_id)
    
    # V√©rifier l'acc√®s
    if not check_client_access(audit):
        return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
    
    if not current_user.can_edit_audit(audit):
        return jsonify({'success': False, 'message': 'Permission refus√©e'}), 403
    
    nouveau_statut = request.form.get('statut')
    sous_statut = request.form.get('sous_statut')
    
    ancien_statut = audit.statut
    ancien_sous_statut = audit.sous_statut
    
    try:
        if nouveau_statut:
            audit.statut = nouveau_statut
        
        if sous_statut:
            audit.sous_statut = sous_statut
        
        audit.updated_at = datetime.utcnow()
        db.session.commit()
        
        # Journaliser le changement
        if 'journaliser_action_audit' in globals():
            journaliser_action_audit(
                audit_id=audit.id,
                action_type='changement_statut',
                user_id=current_user.id,
                details={
                    'ancien_statut': ancien_statut,
                    'nouveau_statut': nouveau_statut,
                    'ancien_sous_statut': ancien_sous_statut,
                    'nouveau_sous_statut': sous_statut
                }
            )
        
        return jsonify({
            'success': True,
            'message': 'Statut mis √† jour',
            'statut': audit.statut,
            'sous_statut': audit.sous_statut
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': str(e)}), 500



@app.route('/audit/<int:audit_id>/dashboard')
@login_required
def dashboard_audit(audit_id):
    """Dashboard avanc√© d'un audit avec isolation"""
    
    # CORRECTION : R√©cup√©rer l'audit avec v√©rification d'acc√®s
    audit = Audit.query.get_or_404(audit_id)
    
    # V√©rifier l'acc√®s √† l'audit
    if not check_client_access(audit):
        flash('Acc√®s non autoris√© √† cet audit', 'error')
        return redirect(url_for('liste_audits'))
    
    # CORRECTION : Filtrer les donn√©es associ√©es par client
    
    # Constatations du m√™me client
    constatations_client = []
    for constatation in audit.constatations:
        if check_client_access(constatation):
            constatations_client.append(constatation)
    
    # Recommandations du m√™me client
    recommandations_client = []
    for recommandation in audit.recommandations:
        if check_client_access(recommandation):
            recommandations_client.append(recommandation)
    
    # Plans d'action du m√™me client
    plans_client = []
    for plan in audit.plans_action:
        if check_client_access(plan):
            plans_client.append(plan)
    
    # Calcul des statistiques d√©taill√©es avec donn√©es filtr√©es
    stats = {
        'progression_globale': audit.progression_globale,
        'taux_realisation_recommandations': audit.taux_realisation_recommandations,
        'taux_realisation_plans': audit.taux_realisation_plans,
        'score_global': audit.score_global,
        'couleur_progression': audit.couleur_progression,
        'constatations_par_type': {},
        'recommandations_par_statut': {},
        'plans_action_par_statut': {},
        'risques_associes': 0,
        'totals': {
            'constatations': len(constatations_client),
            'recommandations': len(recommandations_client),
            'plans_action': len(plans_client)
        }
    }
    
    # Constatations par type (seulement celles accessibles)
    for constatation in constatations_client:
        if constatation.type_constatation:
            if constatation.type_constatation not in stats['constatations_par_type']:
                stats['constatations_par_type'][constatation.type_constatation] = 0
            stats['constatations_par_type'][constatation.type_constatation] += 1
    
    # Recommandations par statut (seulement celles accessibles)
    for recommandation in recommandations_client:
        if recommandation.statut:
            if recommandation.statut not in stats['recommandations_par_statut']:
                stats['recommandations_par_statut'][recommandation.statut] = 0
            stats['recommandations_par_statut'][recommandation.statut] += 1
    
    # Plans d'action par statut (seulement ceux accessibles)
    for plan in plans_client:
        if plan.statut:
            if plan.statut not in stats['plans_action_par_statut']:
                stats['plans_action_par_statut'][plan.statut] = 0
            stats['plans_action_par_statut'][plan.statut] += 1
    
    # R√©cup√©rer les risques associ√©s (seulement ceux accessibles)
    risques_associes = []
    risques_ids_vus = set()
    
    # Risques via les recommandations
    for recommandation in recommandations_client:
        if recommandation.risque_id and recommandation.risque_id not in risques_ids_vus:
            risque = Risque.query.get(recommandation.risque_id)
            if risque and check_client_access(risque):
                risques_associes.append({
                    'risque': risque,
                    'types_association': ['recommandation']
                })
                risques_ids_vus.add(recommandation.risque_id)
    
    # Risques via les plans d'action
    for plan in plans_client:
        if plan.risque_id and plan.risque_id not in risques_ids_vus:
            risque = Risque.query.get(plan.risque_id)
            if risque and check_client_access(risque):
                # V√©rifier si le risque est d√©j√† dans la liste
                risque_existant = None
                for r in risques_associes:
                    if r['risque'].id == plan.risque_id:
                        risque_existant = r
                        break
                
                if risque_existant:
                    if 'plan_action' not in risque_existant['types_association']:
                        risque_existant['types_association'].append('plan_action')
                else:
                    risques_associes.append({
                        'risque': risque,
                        'types_association': ['plan_action']
                    })
                risques_ids_vus.add(plan.risque_id)
    
    # Mettre √† jour le nombre de risques associ√©s
    stats['risques_associes'] = len(risques_associes)
    
    # Statistiques de progression par domaine (si disponible)
    stats['progression_par_domaine'] = {}
    if hasattr(audit, 'domaines'):
        for domaine in audit.domaines:
            if hasattr(domaine, 'progression'):
                stats['progression_par_domaine'][domaine.nom] = domaine.progression
    
    # R√©cup√©rer les analyses IA associ√©es (si disponibles)
    analyses_ia = []
    try:
        if MODELS_IMPORTED:
            analyses_ia = get_client_filter(AnalyseIA)\
                .filter_by(audit_id=audit_id)\
                .order_by(AnalyseIA.date_analyse.desc())\
                .limit(3)\
                .all()
    except:
        pass
    
    # Derni√®res activit√©s
    dernieres_activites = []
    try:
        # Journal d'audit sp√©cifique
        if MODELS_IMPORTED and hasattr(db, 'session'):
            dernieres_activites = JournalAudit.query\
                .filter_by(audit_id=audit_id)\
                .order_by(JournalAudit.created_at.desc())\
                .limit(10)\
                .all()
    except:
        pass
    
    # √âch√©ances √† venir (7 prochains jours)
    echeances_a_venir = []
    aujourdhui = datetime.utcnow().date()
    sept_jours = aujourdhui + timedelta(days=7)
    
    for recommandation in recommandations_client:
        if recommandation.date_echeance and recommandation.statut not in ['termine', 'annule']:
            if aujourdhui <= recommandation.date_echeance <= sept_jours:
                echeances_a_venir.append({
                    'type': 'recommandation',
                    'objet': recommandation,
                    'jours_restants': (recommandation.date_echeance - aujourdhui).days
                })
    
    for plan in plans_client:
        if plan.date_fin_prevue and plan.statut not in ['termine', 'suspendu']:
            if aujourdhui <= plan.date_fin_prevue <= sept_jours:
                echeances_a_venir.append({
                    'type': 'plan_action',
                    'objet': plan,
                    'jours_restants': (plan.date_fin_prevue - aujourdhui).days
                })
    
    # Trier les √©ch√©ances par date
    echeances_a_venir.sort(key=lambda x: x['jours_restants'])
    
    # R√©sum√© des alertes
    alertes = {
        'echeances_proches': len(echeances_a_venir),
        'recommandations_retardees': len([r for r in recommandations_client if r.statut == 'retarde']),
        'plans_retardes': len([p for p in plans_client if p.statut == 'retarde']),
        'constatations_critiques': len([c for c in constatations_client if c.gravite == 'critique'])
    }
    
    return render_template('audit/dashboard.html', 
                         audit=audit, 
                         stats=stats,
                         risques_associes=risques_associes,
                         analyses_ia=analyses_ia,
                         dernieres_activites=dernieres_activites,
                         echeances_a_venir=echeances_a_venir,
                         alertes=alertes,
                         datetime=datetime,
                         current_user=current_user)




# ==================== ROUTES PROGRAMME AUDIT ====================
# ==================== ROUTES PROGRAMME AUDIT ====================

@app.route('/programme-audit')
@login_required
def liste_programmes_audit():
    """Liste des programmes d'audit"""
    # V√©rification formule
    if current_user.client and current_user.client.formule:
        formule = current_user.client.formule
        if not formule.can_access_module('audit_interne'):
            return render_formule_restricted('Programme d\'Audit', formule)
    
    # V√©rification permission
    if not current_user.has_permission('can_manage_audit'):
        flash('Permission requise', 'error')
        return redirect(url_for('dashboard'))
    
    # R√©cup√©ration avec isolation
    programmes = get_client_filter(ProgrammeAudit)\
        .filter_by(is_archived=False)\
        .order_by(ProgrammeAudit.annee_debut.desc())\
        .all()
    
    # Statistiques
    stats = {
        'total': len(programmes),
        'actifs': len([p for p in programmes if p.statut == 'actif']),
        'en_elaboration': len([p for p in programmes if p.statut == 'en_elaboration']),
        'missions_total': sum(p.nb_missions for p in programmes),
        'missions_terminees': sum(p.nb_missions_realisees for p in programmes)
    }
    
    return render_template('programme_audit/liste.html',
                         programmes=programmes,
                         stats=stats)


@app.route('/programme-audit/nouveau', methods=['GET', 'POST'])
@csrf.exempt
@login_required
def nouveau_programme_audit():
    """Cr√©er un nouveau programme d'audit"""
    
    if not current_user.has_permission('can_manage_audit'):
        flash('Permission requise', 'error')
        return redirect(url_for('liste_programmes_audit'))
    
    from flask_wtf import FlaskForm
    from wtforms import StringField, TextAreaField, SelectField, BooleanField, IntegerField, SubmitField
    from wtforms.validators import DataRequired, Optional, NumberRange
    
    class ProgrammeAuditForm(FlaskForm):
        nom = StringField('Nom du programme', validators=[DataRequired()])
        description = TextAreaField('Description')
        periode = SelectField('P√©riode', choices=[
            ('annuel', 'Annuel'),
            ('triennal', 'Triennal (3 ans)')
        ], validators=[DataRequired()])
        annee_debut = SelectField('Ann√©e de d√©but', choices=[], validators=[DataRequired()])
        annee_fin = SelectField('Ann√©e de fin', choices=[], validators=[DataRequired()])
        
        methode_generation = SelectField('M√©thode de g√©n√©ration', choices=[
            ('manuel', 'Manuel - Je cr√©erai les missions moi-m√™me'),
            ('auto_risques', 'Automatique - Bas√© sur la cartographie des risques'),
            ('hybride', 'Hybride - Automatique avec ajustements manuels')
        ], validators=[DataRequired()])
        
        seuil_critique = BooleanField('Inclure les risques Critiques', default=True)
        seuil_eleve = BooleanField('Inclure les risques √âlev√©s', default=True)
        inclure_risques_moyens = BooleanField('Inclure les risques Moyens', default=False)
        frequence_audit_risque = SelectField('Fr√©quence d\'audit par niveau', choices=[
            ('annuelle_critique', 'Annuelle pour risques critiques'),
            ('semestrielle_critique', 'Semestrielle pour risques critiques'),
            ('triennal_tous', 'Tous les 3 ans pour tous les risques')
        ])
        prioriser_processus_critiques = BooleanField('Prioriser les processus critiques', default=True)
        
        frequence_audit = SelectField('Fr√©quence g√©n√©rale d\'audit', choices=[
            ('annuelle', 'Annuelle'),
            ('semestrielle', 'Semestrielle'),
            ('trimestrielle', 'Trimestrielle')
        ])
        duree_moyenne_mission = IntegerField('Dur√©e moyenne d\'une mission (jours)', 
                                             default=5, validators=[NumberRange(min=1, max=30)])
        ressources_disponibles = IntegerField('Ressources disponibles (jours/homme par an)', 
                                             default=100, validators=[NumberRange(min=10, max=1000)])
        
        submit = SubmitField('Cr√©er le programme')
    
    form = ProgrammeAuditForm()
    
    # Initialisation des ann√©es
    annee_courante = datetime.now().year
    form.annee_debut.choices = [(str(y), str(y)) for y in range(annee_courante, annee_courante + 6)]
    form.annee_fin.choices = [(str(y), str(y)) for y in range(annee_courante, annee_courante + 11)]
    
    if form.validate_on_submit():
        try:
            # G√©n√©rer r√©f√©rence
            def generer_reference_programme(client_id=None):
                base_ref = "PROGAUD-"
                
                if client_id:
                    dernier = ProgrammeAudit.query.filter_by(client_id=client_id)\
                        .order_by(ProgrammeAudit.id.desc()).first()
                else:
                    dernier = ProgrammeAudit.query.order_by(ProgrammeAudit.id.desc()).first()
                
                if dernier and dernier.reference:
                    try:
                        if dernier.reference.startswith(base_ref):
                            dernier_num = int(dernier.reference.split('-')[1])
                            nouveau_num = dernier_num + 1
                        else:
                            count = ProgrammeAudit.query.filter_by(client_id=client_id).count() if client_id else ProgrammeAudit.query.count()
                            nouveau_num = count + 1
                    except:
                        count = ProgrammeAudit.query.filter_by(client_id=client_id).count() if client_id else ProgrammeAudit.query.count()
                        nouveau_num = count + 1
                else:
                    nouveau_num = 1
                
                return f"{base_ref}{nouveau_num:04d}"
            
            reference = generer_reference_programme(current_user.client_id)
            
            programme = ProgrammeAudit(
                reference=reference,
                nom=form.nom.data,
                description=form.description.data,
                periode=form.periode.data,
                annee_debut=int(form.annee_debut.data),
                annee_fin=int(form.annee_fin.data),
                methode_generation=form.methode_generation.data,
                statut='en_elaboration',
                client_id=current_user.client_id,
                created_by=current_user.id,
                frequence_audit=form.frequence_audit.data,
                duree_moyenne_mission=form.duree_moyenne_mission.data,
                ressources_disponibles=form.ressources_disponibles.data
            )
            
            # Crit√®res de g√©n√©ration automatis√©e
            if form.methode_generation.data in ['auto_risques', 'hybride']:
                programme.criteres_generation = {
                    'seuil_critique': form.seuil_critique.data,
                    'seuil_eleve': form.seuil_eleve.data,
                    'inclure_risques_moyens': form.inclure_risques_moyens.data,
                    'frequence_audit_risque': form.frequence_audit_risque.data,
                    'prioriser_processus_critiques': form.prioriser_processus_critiques.data
                }
            
            db.session.add(programme)
            db.session.commit()
            
            # G√©n√©rer les missions si m√©thode automatis√©e
            if form.methode_generation.data in ['auto_risques', 'hybride']:
                missions_crees = generer_missions_auto(programme.id, current_user.id)
                flash(f'Programme cr√©√© avec {missions_crees} missions g√©n√©r√©es automatiquement', 'success')
            else:
                flash('Programme cr√©√© - Ajoutez maintenant les missions manuellement', 'info')
            
            return redirect(url_for('detail_programme_audit', id=programme.id))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur: {str(e)}', 'error')
    
    return render_template('programme_audit/form.html', form=form, title="Nouveau Programme")

@app.route('/programme-audit/<int:id>')
@login_required
def detail_programme_audit(id):
    """D√©tail d'un programme d'audit"""
    
    programme = ProgrammeAudit.query.get_or_404(id)
    
    if not check_client_access(programme):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_programmes_audit'))
    
    # R√©cup√©rer les risques disponibles pour ce client
    risques_disponibles = get_client_filter(Risque)\
        .filter_by(is_archived=False)\
        .order_by(Risque.reference.asc())\
        .all()
    
    # R√©cup√©rer les utilisateurs disponibles
    if current_user.role == 'super_admin':
        utilisateurs = User.query.filter_by(is_active=True).order_by(User.username).all()
    else:
        utilisateurs = get_client_filter(User).filter_by(is_active=True).order_by(User.username).all()
    
    # ===== CORRECTION : FILTRER LES MISSIONS NON ARCHIV√âES =====
    missions_non_archivees = programme.missions.filter_by(is_archived=False).all()
    
    # Convertir les missions en dictionnaires pour le template
    missions_data = []
    for mission in missions_non_archivees:  # ‚Üê UTILISER LES MISSIONS FILTR√âES
        # R√©cup√©rer l'audit associ√© si existe
        audit_info = None
        if mission.audit_id:
            audit = Audit.query.get(mission.audit_id)
            if audit:
                audit_info = {
                    'id': audit.id,
                    'reference': audit.reference or '',
                    'titre': audit.titre or ''
                }
        
        mission_dict = {
            'id': mission.id,
            'reference': mission.reference,
            'titre': mission.titre,
            'description': mission.description or '',
            'priorite': mission.priorite or '',
            'niveau_risque_associe': mission.niveau_risque_associe or '',
            'annee_prevue': mission.annee_prevue,
            'trimestre_prevue': mission.trimestre_prevue,
            'duree_estimee': mission.duree_estimee or 0,
            'duree_reelle': mission.duree_reelle or 0,
            'statut': mission.statut or 'planifie',
            'date_debut_prevue': mission.date_debut_prevue.strftime('%Y-%m-%d') if mission.date_debut_prevue else None,
            'date_fin_prevue': mission.date_fin_prevue.strftime('%Y-%m-%d') if mission.date_fin_prevue else None,
            'date_debut_reelle': mission.date_debut_reelle.strftime('%Y-%m-%d') if mission.date_debut_reelle else None,
            'date_fin_reelle': mission.date_fin_reelle.strftime('%Y-%m-%d') if mission.date_fin_reelle else None,
            'audit_id': mission.audit_id,
            'audit': audit_info,
            'risque_id': mission.risque_id,
            'responsable_id': mission.responsable_id,
            'jours_restants': mission.jours_restants if hasattr(mission, 'jours_restants') else 0,
            'est_en_retard': mission.est_en_retard if hasattr(mission, 'est_en_retard') else False
        }
        
        if mission.risque:
            mission_dict['risque'] = {
                'id': mission.risque.id,
                'reference': mission.risque.reference or '',
                'intitule': mission.risque.intitule or '',
                'description': mission.risque.description or '',
                'categorie': mission.risque.categorie or ''
            }
        
        if mission.responsable:
            mission_dict['responsable'] = {
                'id': mission.responsable.id,
                'username': mission.responsable.username or '',
                'role': mission.responsable.role or ''
            }
        
        missions_data.append(mission_dict)
    
    return render_template('programme_audit/detail.html',
                         programme=programme,
                         missions_data=missions_data,  # ‚Üê MAINTENANT SANS ARCHIV√âES
                         risques_disponibles=risques_disponibles,
                         utilisateurs=utilisateurs)


# ============================================================================
# ROUTES POUR LA MANIPULATION MANUELLE DU CHRONOGRAMME
# ============================================================================

@app.route('/programme-audit/<int:id>/chronogramme')
@login_required
def chronogramme_programme(id):
    """Chronogramme interactif avec manipulation manuelle"""
    
    programme = ProgrammeAudit.query.get_or_404(id)
    
    if not check_client_access(programme):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_programmes_audit'))
    
    # ‚úÖ CORRECTION : Utiliser .all() pour obtenir une liste
    missions = programme.missions.filter_by(is_archived=False).all()
    
    # Organisation des missions
    missions_par_annee = {}
    ressources_par_periode = {}
    
    for mission in missions:  # ‚úÖ Maintenant c'est une LISTE
        annee = mission.annee_prevue
        trimestre = mission.trimestre_prevue or 1
        
        if annee not in missions_par_annee:
            missions_par_annee[annee] = {1: [], 2: [], 3: [], 4: []}
        if trimestre not in missions_par_annee[annee]:
            missions_par_annee[annee][trimestre] = []
        
        missions_par_annee[annee][trimestre].append(mission)
        
        if annee not in ressources_par_periode:
            ressources_par_periode[annee] = {1: 0, 2: 0, 3: 0, 4: 0}
        ressources_par_periode[annee][trimestre] += mission.duree_estimee or 0
    
    # ‚úÖ CORRECTION : ICI LE FAMEUX len() qui plantait
    stats = {
        'total_charge': programme.jours_audit_planifies,
        'charge_moyenne': programme.jours_audit_planifies / max(1, len(missions)),  # ‚úÖ missions est une LISTE
        'missions_par_priorite': {
            'critique': len([m for m in missions if m.priorite == 'critique']),
            'elevee': len([m for m in missions if m.priorite == 'elevee']),
            'moyenne': len([m for m in missions if m.priorite == 'moyenne']),
            'faible': len([m for m in missions if m.priorite == 'faible'])
        }
    }
    
    return render_template('programme_audit/chronogramme.html',
                         programme=programme,
                         missions_par_annee=missions_par_annee,
                         ressources_par_periode=ressources_par_periode,
                         missions=missions,  # ‚úÖ Passer la liste au template
                         stats=stats,
                         now=datetime.now)








# ============================================================================
# ROUTES API POUR LE CHRONOGRAMME INTERACTIF
# ============================================================================



@app.route('/api/chronogramme/programme/<int:programme_id>/repartition-auto', methods=['POST'])
@login_required
def repartition_auto_chronogramme(programme_id):
    """R√©partir automatiquement les missions pour √©quilibrer la charge"""
    programme = ProgrammeAudit.query.get_or_404(programme_id)
    
    if not check_client_access(programme):
        return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
    
    try:
        # R√©cup√©rer les missions planifi√©es
        missions = programme.missions.filter_by(
            statut='planifie',
            is_archived=False
        ).all()
        
        if not missions:
            return jsonify({'success': True, 'message': 'Aucune mission √† r√©partir'})
        
        # R√©partition par priorit√©
        missions_critique = [m for m in missions if m.priorite == 'critique']
        missions_elevee = [m for m in missions if m.priorite == 'elevee']
        missions_moyenne = [m for m in missions if m.priorite == 'moyenne']
        missions_faible = [m for m in missions if m.priorite == 'faible']
        
        # R√©partition sur les ann√©es
        annees = list(range(programme.annee_debut, programme.annee_fin + 1))
        modifications = 0
        
        # Ann√©e 1 : missions critiques
        if annees:
            for i, mission in enumerate(missions_critique):
                mission.annee_prevue = annees[0]
                mission.trimestre_prevue = (i % 4) + 1
                modifications += 1
        
        # Ann√©e 2 : missions √©lev√©es
        if len(annees) > 1:
            for i, mission in enumerate(missions_elevee):
                mission.annee_prevue = annees[1]
                mission.trimestre_prevue = (i % 4) + 1
                modifications += 1
        else:
            for i, mission in enumerate(missions_elevee):
                mission.annee_prevue = annees[0]
                mission.trimestre_prevue = (i % 4) + 1
                modifications += 1
        
        # Ann√©e 3 : missions moyennes
        if len(annees) > 2:
            for i, mission in enumerate(missions_moyenne):
                mission.annee_prevue = annees[2]
                mission.trimestre_prevue = (i % 4) + 1
                modifications += 1
        else:
            for i, mission in enumerate(missions_moyenne):
                mission.annee_prevue = annees[-1]
                mission.trimestre_prevue = (i % 4) + 1
                modifications += 1
        
        # R√©partition des missions faibles sur les ann√©es restantes
        for i, mission in enumerate(missions_faible):
            annee_index = i % len(annees)
            mission.annee_prevue = annees[annee_index]
            mission.trimestre_prevue = (i % 4) + 1
            modifications += 1
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'{modifications} missions r√©parties automatiquement'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/mission-audit/<int:mission_id>/modifier', methods=['GET', 'POST'])
@csrf.exempt
@login_required
def modifier_mission_audit(mission_id):
    """Modifier une mission d'audit"""
    mission = MissionAudit.query.get_or_404(mission_id)
    programme = mission.programme
    
    if not check_client_access(mission):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('detail_programme_audit', id=programme.id))
    
    if request.method == 'POST':
        try:
            # Mise √† jour des champs
            mission.titre = request.form.get('titre', mission.titre)
            mission.description = request.form.get('description', mission.description)
            mission.priorite = request.form.get('priorite', mission.priorite)
            
            annee_prevue = request.form.get('annee_prevue')
            if annee_prevue:
                mission.annee_prevue = int(annee_prevue)
            
            trimestre_prevue = request.form.get('trimestre_prevue')
            if trimestre_prevue:
                mission.trimestre_prevue = int(trimestre_prevue)
            else:
                mission.trimestre_prevue = None
            
            duree_estimee = request.form.get('duree_estimee')
            if duree_estimee:
                mission.duree_estimee = int(duree_estimee)
            
            date_debut_prevue = request.form.get('date_debut_prevue')
            if date_debut_prevue:
                mission.date_debut_prevue = datetime.strptime(date_debut_prevue, '%Y-%m-%d').date()
            
            date_fin_prevue = request.form.get('date_fin_prevue')
            if date_fin_prevue:
                mission.date_fin_prevue = datetime.strptime(date_fin_prevue, '%Y-%m-%d').date()
            
            risque_id = request.form.get('risque_id')
            if risque_id:
                mission.risque_id = int(risque_id) if risque_id else None
            
            responsable_id = request.form.get('responsable_id')
            if responsable_id:
                mission.responsable_id = int(responsable_id) if responsable_id else None
            
            statut = request.form.get('statut')
            if statut:
                mission.statut = statut
            
            progression = request.form.get('progression')
            if progression:
                mission.progression = int(progression)
            
            mission.commentaire_repli = request.form.get('commentaire_repli', mission.commentaire_repli)
            mission.updated_at = datetime.now()
            
            db.session.commit()
            flash('Mission modifi√©e avec succ√®s', 'success')
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur: {str(e)}', 'error')
        
        return redirect(url_for('detail_programme_audit', id=programme.id))
    
    # GET - Afficher le formulaire
    risques_disponibles = get_client_filter(Risque).filter_by(is_archived=False).all()
    
    if current_user.role == 'super_admin':
        utilisateurs = User.query.filter_by(is_active=True).all()
    else:
        utilisateurs = get_client_filter(User).filter_by(is_active=True).all()
    
    return render_template('programme_audit/edit_mission.html',
                         mission=mission,
                         programme=programme,
                         risques_disponibles=risques_disponibles,
                         utilisateurs=utilisateurs)



@app.route('/programme-audit/<int:id>/generer-auto')
@login_required
def generer_missions_auto_programme(id):  # Garder id pour la coh√©rence
    """G√©n√©rer automatiquement les missions bas√©es sur les risques"""
    programme = ProgrammeAudit.query.get_or_404(id)
    
    if not check_client_access(programme):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_programmes_audit'))
    
    try:
        missions_crees = generer_missions_auto(programme.id, current_user.id)
        flash(f'{missions_crees} missions g√©n√©r√©es automatiquement', 'success')
        
    except Exception as e:
        flash(f'Erreur lors de la g√©n√©ration: {str(e)}', 'error')
    
    return redirect(url_for('detail_programme_audit', id=id))


def generer_missions_auto(programme_id, user_id):
    """G√©n√®re automatiquement les missions avec r√©partition intelligente"""
    
    programme = ProgrammeAudit.query.get(programme_id)
    if not programme:
        return 0
    
    # R√©cup√©rer les crit√®res
    criteres = programme.criteres_generation or {}
    
    # ===== 1. FILTRAGE DES RISQUES =====
    query = get_client_filter(Risque).filter_by(is_archived=False)
    
    # Filtrer par niveau de risque
    niveaux = []
    if criteres.get('seuil_critique', True):
        niveaux.append('Critique')
    if criteres.get('seuil_eleve', True):
        niveaux.append('√âlev√©')
    if criteres.get('inclure_risques_moyens', False):
        niveaux.append('Moyen')
    
    if niveaux:
        # Sous-query pour la derni√®re √©valuation
        subquery = db.session.query(
            EvaluationRisque.risque_id,
            db.func.max(EvaluationRisque.created_at).label('max_date')
        ).group_by(EvaluationRisque.risque_id).subquery()
        
        query = query.join(subquery, Risque.id == subquery.c.risque_id)\
                    .join(EvaluationRisque, 
                         db.and_(
                             EvaluationRisque.risque_id == Risque.id,
                             EvaluationRisque.created_at == subquery.c.max_date
                         ))\
                    .filter(EvaluationRisque.niveau_risque.in_(niveaux))
    
    # Filtrer par score minimum
    score_min = criteres.get('score_minimum', 0)
    if score_min > 0:
        query = query.filter(EvaluationRisque.score_risque >= score_min)
    
    risques = query.all()
    
    # ===== 2. R√âPARTITION STRAT√âGIQUE =====
    missions_crees = 0
    annees_programme = list(range(programme.annee_debut, programme.annee_fin + 1))
    
    # Initialiser le compteur de charge par trimestre pour chaque ann√©e
    charge_par_trimestre = {}
    for annee in annees_programme:
        charge_par_trimestre[annee] = {1: 0, 2: 0, 3: 0, 4: 0}
        
        # Ajouter les missions existantes
        for mission in programme.missions:
            if mission.annee_prevue == annee and mission.trimestre_prevue:
                charge_par_trimestre[annee][mission.trimestre_prevue] += mission.duree_estimee or 0
    
    # Compter les missions par priorit√© pour la r√©partition
    missions_critique = []
    missions_elevee = []
    missions_moyenne = []
    missions_faible = []
    
    for risque in risques:
        if not risque.evaluations:
            continue
            
        derniere_eval = sorted(
            risque.evaluations, 
            key=lambda x: x.created_at, 
            reverse=True
        )[0]
        
        if derniere_eval.niveau_risque == 'Critique':
            missions_critique.append(risque)
        elif derniere_eval.niveau_risque == '√âlev√©':
            missions_elevee.append(risque)
        elif derniere_eval.niveau_risque == 'Moyen':
            missions_moyenne.append(risque)
        else:
            missions_faible.append(risque)
    
    # ===== 3. R√âPARTITION DES MISSIONS CRITIQUES =====
    # R√©partir sur TOUS les trimestres de l'ann√©e 1
    if annees_programme:
        annee_critique = annees_programme[0]
        for i, risque in enumerate(missions_critique):
            # Choisir le trimestre le moins charg√©
            trimestre = min(charge_par_trimestre[annee_critique], 
                           key=charge_par_trimestre[annee_critique].get)
            
            # Cr√©er la mission
            mission = creer_mission_depuis_risque(risque, programme, annee_critique, trimestre, user_id, criteres)
            db.session.add(mission)
            missions_crees += 1
            
            # Mettre √† jour la charge
            duree = criteres.get('duree_par_priorite', {}).get('critique', programme.duree_moyenne_mission * 1.5 or 10)
            charge_par_trimestre[annee_critique][trimestre] += duree
    
    # ===== 4. R√âPARTITION DES MISSIONS √âLEV√âES =====
    # R√©partir sur TOUS les trimestres de l'ann√©e 2 (ou ann√©e 1 si pas assez d'ann√©es)
    if len(annees_programme) > 1:
        annee_elevee = annees_programme[1]
    else:
        annee_elevee = annees_programme[0]
    
    for i, risque in enumerate(missions_elevee):
        trimestre = min(charge_par_trimestre[annee_elevee], 
                       key=charge_par_trimestre[annee_elevee].get)
        
        mission = creer_mission_depuis_risque(risque, programme, annee_elevee, trimestre, user_id, criteres)
        db.session.add(mission)
        missions_crees += 1
        
        duree = criteres.get('duree_par_priorite', {}).get('elevee', programme.duree_moyenne_mission * 1.2 or 7)
        charge_par_trimestre[annee_elevee][trimestre] += duree
    
    # ===== 5. R√âPARTITION DES MISSIONS MOYENNES =====
    # R√©partir sur TOUS les trimestres de l'ann√©e 3 (ou derni√®re ann√©e)
    if len(annees_programme) > 2:
        annee_moyenne = annees_programme[2]
    else:
        annee_moyenne = annees_programme[-1]
    
    for i, risque in enumerate(missions_moyenne):
        trimestre = min(charge_par_trimestre[annee_moyenne], 
                       key=charge_par_trimestre[annee_moyenne].get)
        
        mission = creer_mission_depuis_risque(risque, programme, annee_moyenne, trimestre, user_id, criteres)
        db.session.add(mission)
        missions_crees += 1
        
        duree = criteres.get('duree_par_priorite', {}).get('moyenne', programme.duree_moyenne_mission or 5)
        charge_par_trimestre[annee_moyenne][trimestre] += duree
    
    # ===== 6. R√âPARTITION DES MISSIONS FAIBLES =====
    # R√©partir sur toutes les ann√©es et tous les trimestres
    for i, risque in enumerate(missions_faible):
        annee_index = i % len(annees_programme)
        annee_faible = annees_programme[annee_index]
        
        trimestre = min(charge_par_trimestre[annee_faible], 
                       key=charge_par_trimestre[annee_faible].get)
        
        mission = creer_mission_depuis_risque(risque, programme, annee_faible, trimestre, user_id, criteres)
        db.session.add(mission)
        missions_crees += 1
        
        duree = criteres.get('duree_par_priorite', {}).get('faible', programme.duree_moyenne_mission * 0.8 or 3)
        charge_par_trimestre[annee_faible][trimestre] += duree
    
    db.session.commit()
    
    return missions_crees


def creer_mission_depuis_risque(risque, programme, annee, trimestre, user_id, criteres):
    """Fonction utilitaire pour cr√©er une mission"""
    from datetime import datetime
    
    # R√©cup√©rer la derni√®re √©valuation
    derniere_eval = sorted(risque.evaluations, key=lambda x: x.created_at, reverse=True)[0]
    
    # D√©terminer la priorit√© et la dur√©e
    if derniere_eval.niveau_risque == 'Critique':
        priorite = 'critique'
        duree = criteres.get('duree_par_priorite', {}).get('critique', programme.duree_moyenne_mission * 1.5 or 10)
    elif derniere_eval.niveau_risque == '√âlev√©':
        priorite = 'elevee'
        duree = criteres.get('duree_par_priorite', {}).get('elevee', programme.duree_moyenne_mission * 1.2 or 7)
    elif derniere_eval.niveau_risque == 'Moyen':
        priorite = 'moyenne'
        duree = criteres.get('duree_par_priorite', {}).get('moyenne', programme.duree_moyenne_mission or 5)
    else:
        priorite = 'faible'
        duree = criteres.get('duree_par_priorite', {}).get('faible', programme.duree_moyenne_mission * 0.8 or 3)
    
    # G√©n√©rer r√©f√©rence
    ref_count = programme.missions.filter_by(is_archived=False).count() + 1
    reference = f"MIS-{programme.reference}-{ref_count:03d}"
    
    # Titre
    if risque.processus_concerne:
        titre = f"Audit {risque.reference} - {risque.intitule[:50]} ({risque.processus_concerne})"
    else:
        titre = f"Audit {risque.reference} - {risque.intitule[:50]}"
    
    return MissionAudit(
        reference=reference,
        titre=titre.strip(),
        description=f"Audit du risque {risque.reference}: {risque.intitule}",
        risque_id=risque.id,
        cartographie_id=risque.cartographie_id,
        priorite=priorite,
        niveau_risque_associe=derniere_eval.niveau_risque,
        score_risque=derniere_eval.score_risque,
        programme_id=programme.id,
        annee_prevue=annee,
        trimestre_prevue=trimestre,
        duree_estimee=int(duree),
        statut='planifie',
        created_by=user_id,
        client_id=programme.client_id
    )


# ============================================================================
# ROUTES POUR LES PLANS DE REPLI (PLAN PLUIE) - CORRIG√âES
# ============================================================================

@app.route('/programme-audit/<int:programme_id>/plan-pluie')
@login_required
def plan_pluie_programme(programme_id):
    """Gestion du plan de repli (plan pluie)"""
    
    programme = ProgrammeAudit.query.get_or_404(programme_id)
    
    if not check_client_access(programme):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_programmes_audit'))
    
    # ========== MISSIONS REPORTABLES ==========
    missions_reportables = []
    for mission in programme.missions:
        # Une mission peut √™tre report√©e si :
        # - Elle est planifi√©e ou en cours
        # - Elle n'est pas archiv√©e
        # - Elle n'a pas d√©j√† un plan de repli actif
        if (mission.statut in ['planifie', 'en_cours'] and 
            not mission.is_archived):
            
            # V√©rifier si elle a d√©j√† un plan de repli
            plan_existant = PlanPluieAudit.query.filter_by(
                mission_principale_id=mission.id,
                statut='actif',
                is_archived=False
            ).first()
            
            if not plan_existant:
                missions_reportables.append(mission)
    
    # ========== MISSIONS DE REMPLACEMENT ==========
    missions_remplacement = []
    annee_courante = datetime.now().year
    trimestre_actuel = (datetime.now().month - 1) // 3 + 1
    
    for mission in programme.missions:
        # Une mission peut servir de remplacement si :
        # - Elle est planifi√©e (pas en cours, pas termin√©e)
        # - Elle n'est pas archiv√©e
        # - Elle n'est pas d√©j√† utilis√©e comme mission principale d'un plan actif
        # - Elle est dans le futur (ann√©e > ann√©e courante OU m√™me ann√©e mais trimestre futur)
        
        if (mission.statut == 'planifie' and 
            not mission.is_archived):
            
            # Exclure les missions qui sont d√©j√† des missions principales
            est_mission_principale = PlanPluieAudit.query.filter_by(
                mission_principale_id=mission.id,
                statut='actif',
                is_archived=False
            ).first() is not None
            
            if not est_mission_principale:
                # V√©rifier si c'est une mission future
                if mission.annee_prevue > annee_courante:
                    missions_remplacement.append(mission)
                elif mission.annee_prevue == annee_courante:
                    if mission.trimestre_prevue and mission.trimestre_prevue > trimestre_actuel:
                        missions_remplacement.append(mission)
                    elif not mission.trimestre_prevue:
                        # Si pas de trimestre, on l'inclut quand m√™me
                        missions_remplacement.append(mission)
    
    # ========== PLANS DE REPLI EXISTANTS ==========
    plans_pluie = PlanPluieAudit.query.filter(
        PlanPluieAudit.mission_principale_id.in_([m.id for m in programme.missions])
    ).filter_by(is_archived=False).all()
    
    return render_template('programme_audit/plan_pluie.html',
                         programme=programme,
                         missions_reportables=missions_reportables,
                         missions_remplacement=missions_remplacement,
                         plans_pluie=plans_pluie,
                         datetime=datetime,
                         now=datetime.now(),
                         annee_courante=annee_courante,
                         trimestre_actuel=trimestre_actuel)

@app.route('/programme-audit/<int:programme_id>/plan-pluie/creer', methods=['POST'])
@csrf.exempt 
@login_required
def creer_plan_pluie(programme_id):  # Param√®tre: programme_id
    """Cr√©er un plan de repli"""
    programme = ProgrammeAudit.query.get_or_404(programme_id)
    
    if not check_client_access(programme):
        return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
    
    try:
        # Validation des donn√©es
        nom = request.form.get('nom', '').strip()
        if not nom:
            return jsonify({'success': False, 'message': 'Le nom du plan est requis'}), 400
        
        mission_principale_id = request.form.get('mission_principale_id')
        mission_remplacement_id = request.form.get('mission_remplacement_id')
        
        if not mission_principale_id or not mission_remplacement_id:
            return jsonify({'success': False, 'message': 'Les missions principale et de remplacement sont requises'}), 400
        
        # V√©rifier que les missions existent et appartiennent au programme
        mission_principale = MissionAudit.query.get_or_404(mission_principale_id)
        mission_remplacement = MissionAudit.query.get_or_404(mission_remplacement_id)
        
        if mission_principale.programme_id != programme.id or mission_remplacement.programme_id != programme.id:
            return jsonify({'success': False, 'message': 'Les missions doivent appartenir au m√™me programme'}), 400
        
        if mission_principale_id == mission_remplacement_id:
            return jsonify({'success': False, 'message': 'La mission de remplacement doit √™tre diff√©rente de la mission principale'}), 400
        
        # V√©rifier qu'un plan n'existe pas d√©j√†
        plan_existant = PlanPluieAudit.query.filter_by(
            mission_principale_id=mission_principale_id,
            is_archived=False
        ).first()
        
        if plan_existant:
            return jsonify({'success': False, 'message': 'Un plan de repli existe d√©j√† pour cette mission'}), 400
        
        # Cr√©er le plan
        plan = PlanPluieAudit(
            nom=nom,
            description=request.form.get('description', '').strip(),
            mission_principale_id=int(mission_principale_id),
            mission_remplacement_id=int(mission_remplacement_id),
            condition_type=request.form.get('condition_type', 'retard'),
            condition_seuil=int(request.form.get('condition_seuil', 15)) if request.form.get('condition_seuil') else None,
            condition_description=request.form.get('condition_description', '').strip(),
            statut='actif',
            created_by=current_user.id,
            client_id=programme.client_id
        )
        
        db.session.add(plan)
        db.session.commit()
        
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'success': True, 'message': 'Plan de repli cr√©√© avec succ√®s', 'plan_id': plan.id})
        else:
            flash('Plan de repli cr√©√© avec succ√®s', 'success')
            return redirect(url_for('plan_pluie_programme', programme_id=programme_id))
        
    except Exception as e:
        db.session.rollback()
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'success': False, 'message': str(e)}), 500
        else:
            flash(f'Erreur: {str(e)}', 'error')
            return redirect(url_for('plan_pluie_programme', programme_id=programme_id))


@app.route('/plan-pluie/<int:plan_id>/modifier', methods=['POST'])
@csrf.exempt 
@login_required
def modifier_plan_pluie(plan_id):
    """Modifier un plan de repli existant"""
    plan = PlanPluieAudit.query.get_or_404(plan_id)
    
    if not check_client_access(plan):
        return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
    
    try:
        programme_id = plan.mission_principale.programme_id
        
        # Mise √† jour des champs
        if request.form.get('nom'):
            plan.nom = request.form.get('nom').strip()
        if request.form.get('description') is not None:
            plan.description = request.form.get('description').strip()
        if request.form.get('condition_type'):
            plan.condition_type = request.form.get('condition_type')
        if request.form.get('condition_seuil'):
            plan.condition_seuil = int(request.form.get('condition_seuil'))
        if request.form.get('condition_description') is not None:
            plan.condition_description = request.form.get('condition_description').strip()
        if request.form.get('statut') and current_user.has_permission('can_manage_audit'):
            plan.statut = request.form.get('statut')
        
        plan.updated_at = datetime.now()
        
        # Mise √† jour des missions si fournies
        if request.form.get('mission_remplacement_id'):
            mission_remplacement_id = int(request.form.get('mission_remplacement_id'))
            if mission_remplacement_id != plan.mission_principale_id:
                plan.mission_remplacement_id = mission_remplacement_id
        
        db.session.commit()
        
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'success': True, 'message': 'Plan de repli modifi√© avec succ√®s'})
        else:
            flash('Plan de repli modifi√© avec succ√®s', 'success')
            return redirect(url_for('plan_pluie_programme', programme_id=programme_id))
        
    except Exception as e:
        db.session.rollback()
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'success': False, 'message': str(e)}), 500
        else:
            flash(f'Erreur: {str(e)}', 'error')
            return redirect(url_for('plan_pluie_programme', programme_id=programme_id))


@app.route('/plan-pluie/<int:plan_id>/activer', methods=['POST'])
@csrf.exempt 
@login_required
def activer_plan_pluie(plan_id):
    """Activer un plan de repli"""
    plan = PlanPluieAudit.query.get_or_404(plan_id)
    
    if not check_client_access(plan):
        return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
    
    if plan.statut != 'actif':
        return jsonify({'success': False, 'message': 'Seuls les plans actifs peuvent √™tre activ√©s'}), 400
    
    try:
        programme_id = plan.mission_principale.programme_id
        mission_principale = plan.mission_principale
        mission_remplacement = plan.mission_remplacement
        
        if mission_principale.statut not in ['planifie', 'en_cours']:
            return jsonify({'success': False, 'message': 'La mission principale n\'est pas dans un √©tat permettant le repli'}), 400
        
        if mission_remplacement.statut != 'planifie':
            return jsonify({'success': False, 'message': 'La mission de remplacement doit √™tre planifi√©e'}), 400
        
        raison = request.form.get('raison', 'activation_manuelle')
        commentaires = request.form.get('commentaires', '')
        
        # Reporter la mission principale
        date_originale = mission_principale.annee_prevue
        mission_principale.statut = 'reporte'
        mission_principale.commentaire_repli = f"Mission report√©e suite √† l'activation du plan {plan.nom}"
        mission_principale.date_report = datetime.now().date()
        
        # Avancer la mission de remplacement
        mission_remplacement.annee_prevue = mission_principale.annee_prevue
        mission_remplacement.trimestre_prevue = mission_principale.trimestre_prevue
        mission_remplacement.date_debut_prevue = mission_principale.date_debut_prevue
        mission_remplacement.date_fin_prevue = mission_principale.date_fin_prevue
        mission_remplacement.commentaire_repli = f"Mission avanc√©e depuis {date_originale} suite √† l'activation du plan {plan.nom}"
        
        # Marquer le plan comme d√©clench√©
        plan.statut = 'declenche'
        plan.date_declenchement = datetime.now()
        plan.raison_declenchement = raison
        plan.commentaires_declenchement = commentaires
        
        db.session.commit()
        
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'success': True, 'message': 'Plan de repli activ√© avec succ√®s'})
        else:
            flash('Plan de repli activ√© avec succ√®s', 'success')
            return redirect(url_for('plan_pluie_programme', programme_id=programme_id))
        
    except Exception as e:
        db.session.rollback()
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'success': False, 'message': str(e)}), 500
        else:
            flash(f'Erreur: {str(e)}', 'error')
            return redirect(url_for('plan_pluie_programme', programme_id=programme_id))


@app.route('/plan-pluie/<int:plan_id>/reprogrammer', methods=['POST'])
@csrf.exempt 
@login_required
def reprogrammer_plan_pluie(plan_id):
    """Reprogrammer un plan de repli"""
    plan = PlanPluieAudit.query.get_or_404(plan_id)
    
    if not check_client_access(plan):
        return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
    
    try:
        programme_id = plan.mission_principale.programme_id
        mission_principale = plan.mission_principale
        mission_remplacement = plan.mission_remplacement
        
        nouvelle_annee_principale = request.form.get('nouvelle_annee_principale')
        nouveau_trimestre_principal = request.form.get('nouveau_trimestre_principal')
        nouvelle_annee_remplacement = request.form.get('nouvelle_annee_remplacement')
        nouveau_trimestre_remplacement = request.form.get('nouveau_trimestre_remplacement')
        
        if nouvelle_annee_principale:
            mission_principale.annee_prevue = int(nouvelle_annee_principale)
        if nouveau_trimestre_principal:
            mission_principale.trimestre_prevue = int(nouveau_trimestre_principal)
        
        if nouvelle_annee_remplacement:
            mission_remplacement.annee_prevue = int(nouvelle_annee_remplacement)
        if nouveau_trimestre_remplacement:
            mission_remplacement.trimestre_prevue = int(nouveau_trimestre_remplacement)
        
        if mission_principale.statut == 'reporte':
            mission_principale.statut = 'planifie'
        
        plan.updated_at = datetime.now()
        
        db.session.commit()
        
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'success': True, 'message': 'Plan de repli reprogramm√© avec succ√®s'})
        else:
            flash('Plan de repli reprogramm√© avec succ√®s', 'success')
            return redirect(url_for('plan_pluie_programme', programme_id=programme_id))
        
    except Exception as e:
        db.session.rollback()
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'success': False, 'message': str(e)}), 500
        else:
            flash(f'Erreur: {str(e)}', 'error')
            return redirect(url_for('plan_pluie_programme', programme_id=programme_id))


@app.route('/plan-pluie/<int:plan_id>/supprimer', methods=['POST'])
@csrf.exempt 
@login_required
def supprimer_plan_pluie(plan_id):
    """Supprimer (archiver) un plan de repli"""
    plan = PlanPluieAudit.query.get_or_404(plan_id)
    
    if not check_client_access(plan):
        return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
    
    try:
        programme_id = plan.mission_principale.programme_id
        
        plan.is_archived = True
        plan.statut = 'archive'
        plan.archived_at = datetime.now()
        plan.archived_by = current_user.id
        plan.archive_reason = request.form.get('raison', 'Suppression manuelle')
        
        db.session.commit()
        
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'success': True, 'message': 'Plan de repli supprim√© avec succ√®s'})
        else:
            flash('Plan de repli supprim√© avec succ√®s', 'success')
            return redirect(url_for('plan_pluie_programme', programme_id=programme_id))
        
    except Exception as e:
        db.session.rollback()
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'success': False, 'message': str(e)}), 500
        else:
            flash(f'Erreur: {str(e)}', 'error')
            return redirect(url_for('plan_pluie_programme', programme_id=programme_id))

@app.route('/programme-audit/<int:programme_id>/simuler-retard', methods=['POST'])
@login_required
@csrf.exempt  # ‚Üê SOLUTION LA PLUS SIMPLE
def simuler_retard(programme_id):
    """Simuler un retard pour tester les plans de repli"""
    try:
        programme = ProgrammeAudit.query.get_or_404(programme_id)
        
        if not check_client_access(programme):
            return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
        
        # DEBUG - Afficher ce qui est re√ßu
        print(f"=== SIMULATION RETARD ===")
        print(f"Programme ID: {programme_id}")
        print(f"Form data: {dict(request.form)}")
        print(f"Headers: {dict(request.headers)}")
        
        # R√©cup√©rer le param√®tre 'jours'
        jours_str = request.form.get('jours', '15')
        print(f"Jours re√ßus: '{jours_str}'")
        
        try:
            jours_retard = int(jours_str)
        except ValueError:
            return jsonify({'success': False, 'message': f'Le param√®tre jours doit √™tre un nombre valide, re√ßu: {jours_str}'}), 400
        
        if jours_retard <= 0 or jours_retard > 365:
            return jsonify({'success': False, 'message': 'Le nombre de jours doit √™tre entre 1 et 365'}), 400
        
        date_limite = datetime.now().date() - timedelta(days=jours_retard)
        
        alertes_generes = 0
        missions_retard = []
        plans_declenchables = []
        
        for mission in programme.missions:
            if (mission.date_fin_prevue and 
                mission.date_fin_prevue < date_limite and 
                mission.statut == 'planifie'):
                
                missions_retard.append({
                    'id': mission.id,
                    'reference': mission.reference,
                    'titre': mission.titre,
                    'retard_jours': (date_limite - mission.date_fin_prevue).days if mission.date_fin_prevue else jours_retard
                })
                
                plan = PlanPluieAudit.query.filter_by(
                    mission_principale_id=mission.id,
                    statut='actif',
                    is_archived=False
                ).first()
                
                if plan:
                    alertes_generes += 1
                    plans_declenchables.append({
                        'id': plan.id,
                        'nom': plan.nom,
                        'mission_remplacement': plan.mission_remplacement.reference if plan.mission_remplacement else 'N/A'
                    })
        
        message = f"Simulation de {jours_retard} jours de retard : {len(missions_retard)} mission(s) concern√©e(s), {alertes_generes} plan(s) de repli d√©clenchable(s)"
        
        return jsonify({
            'success': True,
            'alertes': alertes_generes,
            'missions_retard': len(missions_retard),
            'missions_liste': missions_retard[:5],
            'plans_declenchables': plans_declenchables[:5],
            'message': message,
            'debug': {
                'programme_id': programme_id,
                'jours': jours_retard,
                'date_limite': date_limite.isoformat()
            }
        })
        
    except Exception as e:
        print(f"Erreur dans simuler_retard: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'message': str(e)}), 500


# ============================================================================
# ROUTES POUR LES MISSIONS D'AUDIT
# ============================================================================




@app.route('/mission-audit/<int:mission_id>/reprogrammer', methods=['POST'])
@csrf.exempt
@login_required
def reprogrammer_mission_audit(mission_id):
    """Reprogrammer une mission d'audit (changer les dates)"""
    mission = MissionAudit.query.get_or_404(mission_id)
    programme = mission.programme
    
    if not check_client_access(mission):
        return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
    
    try:
        # R√©cup√©rer les nouvelles dates
        nouvelle_annee = request.form.get('nouvelle_annee')
        nouveau_trimestre = request.form.get('nouveau_trimestre')
        nouvelle_date_debut = request.form.get('nouvelle_date_debut')
        nouvelle_date_fin = request.form.get('nouvelle_date_fin')
        raison = request.form.get('raison', '')
        
        # Mettre √† jour la mission
        if nouvelle_annee:
            mission.annee_prevue = int(nouvelle_annee)
        if nouveau_trimestre:
            mission.trimestre_prevue = int(nouveau_trimestre)
        if nouvelle_date_debut:
            mission.date_debut_prevue = datetime.strptime(nouvelle_date_debut, '%Y-%m-%d').date()
        if nouvelle_date_fin:
            mission.date_fin_prevue = datetime.strptime(nouvelle_date_fin, '%Y-%m-%d').date()
        
        # Si la mission √©tait report√©e, la remettre en planifi√©
        if mission.statut == 'reporte':
            mission.statut = 'planifie'
        
        mission.updated_at = datetime.now()
        
        # Ajouter un commentaire sur la reprogrammation
        if raison:
            if mission.commentaire_repli:
                mission.commentaire_repli += f"\n[{datetime.now().strftime('%d/%m/%Y')}] Reprogrammation: {raison}"
            else:
                mission.commentaire_repli = f"[{datetime.now().strftime('%d/%m/%Y')}] Reprogrammation: {raison}"
        
        db.session.commit()
        
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'success': True, 'message': 'Mission reprogramm√©e avec succ√®s'})
        else:
            flash('Mission reprogramm√©e avec succ√®s', 'success')
            return redirect(url_for('detail_programme_audit', id=programme.id))
        
    except Exception as e:
        db.session.rollback()
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'success': False, 'message': str(e)}), 500
        else:
            flash(f'Erreur: {str(e)}', 'error')
            return redirect(url_for('detail_programme_audit', id=programme.id))
# ============================================================================
# ===== ROUTES API CHRONOGRAMME V2 - VERSION FINALE 100% FONCTIONNELLE =====
# ===== √Ä COLLER √Ä LA FIN DE app.py, AVANT if __name__ == '__main__' =====
# ============================================================================

@app.route('/api/chronogramme/v2/mission/<int:mid>/deplacer', methods=['POST'])
@csrf.exempt 
@login_required
def chrono_deplacer(mid):
    """D√©placer une mission - VERSION FINALE"""
    print(f"\n{'='*50}")
    print(f"üöÄ API DEPLACER V2 - Mission {mid}")
    print(f"{'='*50}")
    
    try:
        # 1. R√©cup√©rer la mission
        mission = MissionAudit.query.get_or_404(mid)
        if not check_client_access(mission):
            return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
        
        # 2. Parser le JSON
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'message': 'Donn√©es JSON requises'}), 400
        
        print(f"üì¶ Donn√©es re√ßues: {data}")
        
        # 3. Valider l'ann√©e
        annee = data.get('annee')
        if annee is None:
            return jsonify({'success': False, 'message': 'Ann√©e requise'}), 400
        
        try:
            annee = int(annee)
        except (ValueError, TypeError):
            return jsonify({'success': False, 'message': 'Ann√©e invalide'}), 400
        
        programme = mission.programme
        if annee < programme.annee_debut or annee > programme.annee_fin:
            return jsonify({
                'success': False, 
                'message': f'Ann√©e hors programme ({programme.annee_debut}-{programme.annee_fin})'
            }), 400
        
        # 4. Valider le trimestre (optionnel)
        trimestre = data.get('trimestre')
        if trimestre is not None:
            try:
                trimestre = int(trimestre)
                if 1 <= trimestre <= 4:
                    mission.trimestre_prevue = trimestre
                else:
                    print(f"‚ö†Ô∏è Trimestre {trimestre} hors limites, ignor√©")
            except (ValueError, TypeError):
                print(f"‚ö†Ô∏è Trimestre invalide: {trimestre}, ignor√©")
        
        # 5. Mettre √† jour
        mission.annee_prevue = annee
        mission.updated_at = datetime.now()
        db.session.commit()
        
        print(f"‚úÖ Mission {mid} d√©plac√©e vers {annee}-T{mission.trimestre_prevue}")
        return jsonify({
            'success': True, 
            'message': f'Mission d√©plac√©e en {annee}',
            'mission': {
                'id': mission.id,
                'annee': mission.annee_prevue,
                'trimestre': mission.trimestre_prevue
            }
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur: {str(e)}")
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/chronogramme/v2/mission/<int:mid>/duree', methods=['POST'])
@csrf.exempt 
@login_required
def chrono_duree(mid):
    """Modifier la dur√©e - VERSION FINALE"""
    print(f"\n{'='*50}")
    print(f"üöÄ API DUREE V2 - Mission {mid}")
    print(f"{'='*50}")
    
    try:
        mission = MissionAudit.query.get_or_404(mid)
        if not check_client_access(mission):
            return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
        
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'message': 'Donn√©es JSON requises'}), 400
        
        print(f"üì¶ Donn√©es re√ßues: {data}")
        
        duree = data.get('duree')
        if duree is None:
            return jsonify({'success': False, 'message': 'Dur√©e requise'}), 400
        
        try:
            duree = int(duree)
            if duree < 1:
                return jsonify({'success': False, 'message': 'La dur√©e doit √™tre > 0'}), 400
            if duree > 365:
                return jsonify({'success': False, 'message': 'La dur√©e ne peut pas d√©passer 365 jours'}), 400
        except (ValueError, TypeError):
            return jsonify({'success': False, 'message': 'Dur√©e invalide'}), 400
        
        mission.duree_estimee = duree
        mission.updated_at = datetime.now()
        db.session.commit()
        
        print(f"‚úÖ Mission {mid} dur√©e modifi√©e: {duree}j")
        return jsonify({'success': True, 'message': f'Dur√©e modifi√©e √† {duree} jours'})
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur: {str(e)}")
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/chronogramme/v2/mission/<int:mid>/statut', methods=['POST'])
@csrf.exempt 
@login_required
def chrono_statut(mid):
    """Changer le statut - VERSION FINALE"""
    print(f"\n{'='*50}")
    print(f"üöÄ API STATUT V2 - Mission {mid}")
    print(f"{'='*50}")
    
    try:
        mission = MissionAudit.query.get_or_404(mid)
        if not check_client_access(mission):
            return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
        
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'message': 'Donn√©es JSON requises'}), 400
        
        print(f"üì¶ Donn√©es re√ßues: {data}")
        
        statut = data.get('statut')
        statuts_valides = ['planifie', 'en_cours', 'termine', 'reporte', 'annule']
        
        if not statut or statut not in statuts_valides:
            return jsonify({'success': False, 'message': 'Statut invalide'}), 400
        
        ancien_statut = mission.statut
        mission.statut = statut
        
        # Gestion automatique des dates
        aujourdhui = datetime.now().date()
        
        if statut == 'termine':
            mission.progression = 100
            if not mission.date_fin_reelle:
                mission.date_fin_reelle = aujourdhui
        elif statut == 'en_cours':
            if not mission.date_debut_reelle:
                mission.date_debut_reelle = aujourdhui
            mission.progression = max(mission.progression or 0, 25)
        elif statut == 'planifie':
            mission.progression = 0
        
        mission.updated_at = datetime.now()
        db.session.commit()
        
        print(f"‚úÖ Mission {mid}: {ancien_statut} ‚Üí {statut}")
        return jsonify({'success': True, 'message': f'Statut chang√© en {statut}'})
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur: {str(e)}")
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/chronogramme/v2/mission/<int:mid>/assigner', methods=['POST'])
@csrf.exempt 
@login_required
def chrono_assigner(mid):
    """Assigner un responsable - VERSION FINALE"""
    print(f"\n{'='*50}")
    print(f"üöÄ API ASSIGNER V2 - Mission {mid}")
    print(f"{'='*50}")
    
    try:
        mission = MissionAudit.query.get_or_404(mid)
        if not check_client_access(mission):
            return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
        
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'message': 'Donn√©es JSON requises'}), 400
        
        print(f"üì¶ Donn√©es re√ßues: {data}")
        
        responsable_id = data.get('responsable_id')
        
        if responsable_id is None or responsable_id == 0:
            mission.responsable_id = None
            message = "Responsable retir√©"
            print(f"‚úÖ Responsable retir√©")
        else:
            try:
                responsable_id = int(responsable_id)
                user = User.query.get(responsable_id)
                if not user:
                    return jsonify({'success': False, 'message': 'Utilisateur non trouv√©'}), 404
                
                if not check_client_access(user):
                    return jsonify({'success': False, 'message': 'Acc√®s non autoris√© √† cet utilisateur'}), 403
                
                mission.responsable_id = responsable_id
                message = f"Responsable: {user.username}"
                print(f"‚úÖ {message}")
                
            except (ValueError, TypeError):
                return jsonify({'success': False, 'message': 'ID responsable invalide'}), 400
        
        mission.updated_at = datetime.now()
        db.session.commit()
        
        return jsonify({'success': True, 'message': message})
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur: {str(e)}")
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/chronogramme/v2/programme/<int:pid>/repartition-auto', methods=['POST'])
@csrf.exempt 
@login_required
def chrono_repartition(pid):
    """R√©partition automatique - VERSION FINALE"""
    print(f"\n{'='*50}")
    print(f"üöÄ API REPARTITION V2 - Programme {pid}")
    print(f"{'='*50}")
    
    try:
        programme = ProgrammeAudit.query.get_or_404(pid)
        if not check_client_access(programme):
            return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
        
        missions = programme.missions.filter_by(
            statut='planifie', 
            is_archived=False
        ).all()
        
        if not missions:
            return jsonify({'success': True, 'message': 'Aucune mission √† r√©partir'})
        
        modifications = 0
        annees = list(range(programme.annee_debut, programme.annee_fin + 1))
        
        if not annees:
            return jsonify({'success': False, 'message': 'Programme sans ann√©e'}), 400
        
        for i, mission in enumerate(missions):
            # R√©partition par priorit√©
            if mission.priorite == 'critique' and annees:
                mission.annee_prevue = annees[0]
            elif mission.priorite == 'elevee' and len(annees) > 1:
                mission.annee_prevue = annees[1]
            elif mission.priorite == 'moyenne' and len(annees) > 2:
                mission.annee_prevue = annees[2]
            else:
                mission.annee_prevue = annees[i % len(annees)]
            
            # R√©partition trimestrielle √©quilibr√©e
            mission.trimestre_prevue = (i % 4) + 1
            modifications += 1
        
        db.session.commit()
        
        print(f"‚úÖ {modifications} missions r√©parties")
        return jsonify({
            'success': True, 
            'message': f'{modifications} missions r√©parties automatiquement'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur: {str(e)}")
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/chronogramme/v2/utilisateurs', methods=['GET'])
@login_required
def api_chronogramme_utilisateurs():
    """API pour r√©cup√©rer la liste des utilisateurs √©ligibles comme responsables"""
    print(f"\nüîµ API UTILISATEURS - Chargement de la liste")
    
    try:
        # R√©cup√©rer les utilisateurs en fonction des permissions
        if current_user.role == 'super_admin':
            utilisateurs = User.query.filter_by(is_active=True, is_blocked=False).all()
        else:
            utilisateurs = get_client_filter(User).filter_by(
                is_active=True, 
                is_blocked=False
            ).all()
        
        # Formater les donn√©es
        data = []
        for user in utilisateurs:
            # D√©terminer le nom d'affichage
            display_name = user.username
            if hasattr(user, 'prenom') and user.prenom and hasattr(user, 'nom') and user.nom:
                display_name = f"{user.prenom} {user.nom}"
            elif hasattr(user, 'full_name') and user.full_name:
                display_name = user.full_name
            
            data.append({
                'id': user.id,
                'username': user.username,
                'display_name': display_name,
                'email': user.email,
                'role': user.role,
                'role_display': user.get_role_display_name() if hasattr(user, 'get_role_display_name') else user.role,
                'department': user.department or '',
                'is_client_admin': user.is_client_admin
            })
        
        # Trier par nom d'affichage
        data.sort(key=lambda x: x['display_name'].lower())
        
        return jsonify({
            'success': True,
            'utilisateurs': data,
            'total': len(data)
        })
        
    except Exception as e:
        print(f"‚ùå Erreur: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/chronogramme/v2/test')
def chrono_test_v2():
    """Test des routes API V2"""
    routes = []
    for rule in app.url_map.iter_rules():
        if '/api/chronogramme/v2' in str(rule):
            routes.append({
                'route': str(rule),
                'methods': list(rule.methods)
            })
    
    # Supprimer les doublons
    routes_uniques = {}
    for route in routes:
        routes_uniques[route['route']] = route
    
    return jsonify({
        'status': '‚úÖ API CHRONOGRAMME V2 ACTIVE',
        'routes': sorted(list(routes_uniques.keys())),
        'count': len(routes_uniques),
        'debug': True
    })


@app.route('/api/chronogramme/v2/programme/<int:pid>/stats')
@login_required
def chrono_stats(pid):
    """Statistiques pour le chronogramme"""
    try:
        programme = ProgrammeAudit.query.get_or_404(pid)
        if not check_client_access(programme):
            return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
        
        missions = programme.missions.filter_by(is_archived=False).all()
        
        stats = {
            'total_missions': len(missions),
            'missions_terminees': len([m for m in missions if m.statut == 'termine']),
            'progression': programme.progression,
            'charge_totale': programme.jours_audit_planifies,
            'charge_realisee': programme.jours_audit_realises,
            'par_priorite': {
                'critique': len([m for m in missions if m.priorite == 'critique']),
                'elevee': len([m for m in missions if m.priorite == 'elevee']),
                'moyenne': len([m for m in missions if m.priorite == 'moyenne']),
                'faible': len([m for m in missions if m.priorite == 'faible'])
            },
            'par_statut': {
                'planifie': len([m for m in missions if m.statut == 'planifie']),
                'en_cours': len([m for m in missions if m.statut == 'en_cours']),
                'termine': len([m for m in missions if m.statut == 'termine']),
                'reporte': len([m for m in missions if m.statut == 'reporte'])
            }
        }
        
        return jsonify({'success': True, 'stats': stats})
        
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


# ============================================================================
# ===== CORRECTION ROUTE AJOUTER MISSION (SINGULIER) =====
# ============================================================================

@app.route('/programme-audit/<int:programme_id>/mission/ajouter', methods=['GET', 'POST'])
@csrf.exempt
@login_required
def ajouter_mission_programme(programme_id):
    """Ajouter une mission manuellement au programme (SINGULIER)"""
    programme = ProgrammeAudit.query.get_or_404(programme_id)
    
    if not check_client_access(programme):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_programmes_audit'))
    
    # GET - Afficher le formulaire d'ajout rapide
    if request.method == 'GET':
        annee = request.args.get('annee', programme.annee_debut, type=int)
        trimestre = request.args.get('trimestre', None, type=int)
        
        risques_disponibles = get_client_filter(Risque).filter_by(is_archived=False).all()
        
        if current_user.role == 'super_admin':
            utilisateurs = User.query.filter_by(is_active=True).all()
        else:
            utilisateurs = get_client_filter(User).filter_by(is_active=True).all()
        
        return render_template('programme_audit/ajouter_mission_rapide.html',
                             programme=programme,
                             annee=annee,
                             trimestre=trimestre,
                             risques_disponibles=risques_disponibles,
                             utilisateurs=utilisateurs)
    
    # POST - Cr√©er la mission
    try:
        # G√©n√©rer r√©f√©rence
        ref_count = programme.missions.filter_by(is_archived=False).count() + 1
        reference = f"MIS-{programme.reference}-{ref_count:03d}"
        
        mission = MissionAudit(
            reference=reference,
            titre=request.form.get('titre'),
            description=request.form.get('description'),
            priorite=request.form.get('priorite'),
            annee_prevue=int(request.form.get('annee_prevue', programme.annee_debut)),
            trimestre_prevue=int(request.form.get('trimestre_prevue')) if request.form.get('trimestre_prevue') else None,
            duree_estimee=int(request.form.get('duree_estimee', programme.duree_moyenne_mission or 5)),
            risque_id=int(request.form.get('risque_id')) if request.form.get('risque_id') else None,
            responsable_id=int(request.form.get('responsable_id')) if request.form.get('responsable_id') else None,
            programme_id=programme.id,
            statut='planifie',
            created_by=current_user.id,
            client_id=programme.client_id
        )
        
        db.session.add(mission)
        db.session.commit()
        
        flash(f'Mission {reference} ajout√©e avec succ√®s', 'success')
        
        # Rediriger vers le chronogramme si demand√©
        if request.args.get('redirect') == 'chronogramme':
            return redirect(url_for('chronogramme_programme', id=programme.id))
        
        return redirect(url_for('detail_programme_audit', id=programme.id))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur: {str(e)}', 'error')
        return redirect(url_for('detail_programme_audit', id=programme.id))


# ============================================================================
# ===== SUPPRIMER L'ANCIENNE ROUTE PLURIELLE POUR √âVITER LES CONFLITS =====
# ============================================================================


@app.route('/programme-audit/<int:programme_id>/missions/supprimer-bloc', methods=['POST'])
@csrf.exempt
@login_required
def supprimer_missions_bloc(programme_id):
    """Supprimer plusieurs missions en une fois"""
    programme = ProgrammeAudit.query.get_or_404(programme_id)
    
    if not check_client_access(programme):
        return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
    
    try:
        data = request.get_json()
        mission_ids = data.get('mission_ids', [])
        raison = data.get('raison', 'Suppression en bloc')
        
        if not mission_ids:
            return jsonify({'success': False, 'message': 'Aucune mission s√©lectionn√©e'}), 400
        
        missions = MissionAudit.query.filter(MissionAudit.id.in_(mission_ids)).all()
        count = 0
        erreurs = []
        
        for mission in missions:
            # V√©rifier que la mission appartient au programme
            if mission.programme_id != programme_id:
                continue
            
            # V√©rifier que la mission n'est pas en cours
            if mission.statut in ['en_cours', 'termine']:
                erreurs.append(f"{mission.reference}: mission en cours")
                continue
            
            # V√©rifier qu'aucun plan de repli n'est actif
            plan_actif = PlanPluieAudit.query.filter_by(
                mission_principale_id=mission.id,
                statut='actif',
                is_archived=False
            ).first()
            
            if plan_actif:
                erreurs.append(f"{mission.reference}: plan de repli actif")
                continue
            
            # Archiver la mission
            mission.is_archived = True
            mission.statut = 'archive'
            mission.archived_at = datetime.now()
            mission.archived_by = current_user.id
            mission.archive_reason = raison
            count += 1
        
        db.session.commit()
        
        message = f'{count} mission(s) supprim√©e(s) avec succ√®s'
        if erreurs:
            message += f' ({len(erreurs)} ignor√©e(s): {", ".join(erreurs[:3])})'
        
        return jsonify({
            'success': True, 
            'message': message
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': str(e)}), 500
    
@app.route('/mission-audit/<int:mission_id>/supprimer', methods=['POST'])
@csrf.exempt
@login_required
def supprimer_mission_audit(mission_id):
    """Supprimer (archiver) une mission d'audit"""
    mission = MissionAudit.query.get_or_404(mission_id)
    programme = mission.programme
    
    if not check_client_access(mission):
        return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
    
    try:
        # V√©rifier que la mission n'est pas en cours
        if mission.statut in ['en_cours', 'termine']:
            return jsonify({'success': False, 'message': 'Impossible de supprimer une mission en cours ou termin√©e'}), 400
        
        # V√©rifier qu'aucun plan de repli n'est actif
        plan_actif = PlanPluieAudit.query.filter_by(
            mission_principale_id=mission.id,
            statut='actif',
            is_archived=False
        ).first()
        
        if plan_actif:
            return jsonify({'success': False, 'message': 'Supprimez d\'abord le plan de repli associ√©'}), 400
        
        # R√©cup√©rer la raison de suppression (JSON ou form-data)
        raison = 'Suppression manuelle'
        
        # Si c'est du JSON
        if request.is_json:
            data = request.get_json()
            raison = data.get('raison', 'Suppression manuelle')
        else:
            # Si c'est du form-data
            raison = request.form.get('raison', 'Suppression manuelle')
        
        # Archiver la mission
        mission.is_archived = True
        mission.statut = 'archive'
        mission.archived_at = datetime.now()
        mission.archived_by = current_user.id
        mission.archive_reason = raison
        mission.updated_at = datetime.now()
        
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Mission supprim√©e avec succ√®s'})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/mission-audit/<int:mission_id>/restaurer', methods=['POST'])
@login_required
def restaurer_mission_audit(mission_id):
    """Restaurer une mission archiv√©e"""
    mission = MissionAudit.query.get_or_404(mission_id)
    programme = mission.programme
    
    if not check_client_access(mission):
        return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
    
    try:
        mission.is_archived = False
        mission.statut = 'planifie'
        mission.archived_at = None
        mission.archived_by = None
        mission.archive_reason = None
        mission.updated_at = datetime.now()
        
        db.session.commit()
        
        flash('Mission restaur√©e avec succ√®s', 'success')
        return redirect(url_for('detail_programme_audit', id=programme.id))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur: {str(e)}', 'error')
        return redirect(url_for('detail_programme_audit', id=programme.id))


@app.route('/mission-audit/<int:mission_id>/dupliquer', methods=['POST'])
@login_required
def dupliquer_mission_audit(mission_id):
    """Dupliquer une mission d'audit"""
    mission_originale = MissionAudit.query.get_or_404(mission_id)
    programme = mission_originale.programme
    
    if not check_client_access(mission_originale):
        return jsonify({'success': False, 'message': 'Acc√®s non autoris√©'}), 403
    
    try:
        # G√©n√©rer une nouvelle r√©f√©rence
        ref_count = len(programme.missions) + 1
        nouvelle_reference = f"MIS-{programme.reference}-{ref_count:03d}"
        
        # Cr√©er la nouvelle mission
        nouvelle_mission = MissionAudit(
            reference=nouvelle_reference,
            titre=f"COPIE - {mission_originale.titre}",
            description=mission_originale.description,
            priorite=mission_originale.priorite,
            niveau_risque_associe=mission_originale.niveau_risque_associe,
            annee_prevue=mission_originale.annee_prevue + 1,  # Ann√©e suivante
            trimestre_prevue=mission_originale.trimestre_prevue,
            duree_estimee=mission_originale.duree_estimee,
            risque_id=mission_originale.risque_id,
            programme_id=programme.id,
            statut='planifie',
            created_by=current_user.id,
            client_id=programme.client_id
        )
        
        db.session.add(nouvelle_mission)
        db.session.commit()
        
        flash(f'Mission dupliqu√©e avec succ√®s - {nouvelle_reference}', 'success')
        return redirect(url_for('detail_programme_audit', id=programme.id))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur: {str(e)}', 'error')
        return redirect(url_for('detail_programme_audit', id=programme.id))
    





# Route pour convertir une mission en audit
@app.route('/mission-audit/<int:id>/convertir-audit')
@login_required
def convertir_mission_audit(id):
    """Convertir une mission d'audit planifi√©e en audit effectif"""
    mission = MissionAudit.query.get_or_404(id)
    
    if not check_client_access(mission):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_programmes_audit'))
    
    try:
        # R√©cup√©rer les informations du processus si disponible
        processus_id = None
        if mission.risque and mission.risque.cartographie:
            processus_id = mission.risque.cartographie.processus_id
        
        # Cr√©er l'audit √† partir de la mission
        audit = Audit(
            reference=f"AUD-{mission.reference}",
            titre=mission.titre,
            description=mission.description,
            type_audit='interne',
            date_debut_prevue=mission.date_debut_prevue or datetime.now().date(),
            date_fin_prevue=mission.date_fin_prevue,
            statut='planifie',
            sous_statut='planification',
            processus_id=processus_id,
            responsable_id=mission.responsable_id,
            equipe_audit_ids=mission.equipe_ids,
            created_by=current_user.id,
            client_id=mission.client_id
        )
        
        db.session.add(audit)
        db.session.flush()
        
        # Lier l'audit √† la mission
        mission.audit_id = audit.id
        mission.statut = 'en_cours'
        mission.date_debut_reelle = datetime.now().date()
        
        # Lier l'audit au risque
        if mission.risque_id:
            audit_risque = AuditRisque(
                audit_id=audit.id,
                risque_id=mission.risque_id,
                impact_audit='a_evaluer',
                commentaire=f"Audit g√©n√©r√© √† partir de la mission {mission.reference}"
            )
            db.session.add(audit_risque)
        
        db.session.commit()
        
        flash(f'Audit {audit.reference} cr√©√© √† partir de la mission', 'success')
        return redirect(url_for('detail_audit', id=audit.id))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur: {str(e)}', 'error')
        return redirect(url_for('detail_programme_audit', id=mission.programme_id))



@app.route('/programme-audit/<int:id>/exporter')
@login_required
def exporter_programme(id):
    """Exporter le programme en Excel, CSV ou PDF"""
    programme = ProgrammeAudit.query.get_or_404(id)
    
    if not check_client_access(programme):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_programmes_audit'))
    
    format_export = request.args.get('format', 'excel')
    
    try:
        # ========== EXPORT EXCEL ==========
        if format_export == 'excel':
            return exporter_programme_excel(programme)
        
        # ========== EXPORT CSV ==========
        elif format_export == 'csv':
            return exporter_programme_csv(programme)
        
        # ========== EXPORT PDF ==========
        elif format_export == 'pdf':
            return exporter_programme_pdf(programme)
        
        else:
            flash('Format d\'export non support√©', 'error')
            return redirect(url_for('detail_programme_audit', id=id))
            
    except Exception as e:
        flash(f'Erreur lors de l\'export: {str(e)}', 'error')
        return redirect(url_for('detail_programme_audit', id=id))


def exporter_programme_excel(programme):
    """Export du programme au format Excel sans pandas"""
    try:
        wb = Workbook()
        
        # ========== SHEET 1 : MISSIONS ==========
        ws1 = wb.active
        ws1.title = "Missions"
        
        # Style des en-t√™tes
        header_font = Font(bold=True, color="FFFFFF")
        header_fill = PatternFill(start_color="0D6EFD", end_color="0D6EFD", fill_type="solid")
        header_alignment = Alignment(horizontal="center", vertical="center")
        border = Border(
            left=Side(style='thin'), 
            right=Side(style='thin'),
            top=Side(style='thin'), 
            bottom=Side(style='thin')
        )
        
        # En-t√™tes de colonnes
        headers = [
            'R√©f√©rence', 'Titre', 'Description', 'Priorit√©', 'Niveau Risque',
            'Ann√©e', 'Trimestre', 'Date d√©but', 'Date fin', 'Dur√©e (j)',
            'Statut', 'Progression %', 'Responsable', 'Risque associ√©', 'Audit li√©'
        ]
        
        for col, header in enumerate(headers, 1):
            cell = ws1.cell(row=1, column=col, value=header)
            cell.font = header_font
            cell.fill = header_fill
            cell.alignment = header_alignment
            cell.border = border
        
        # Donn√©es des missions
        row = 2
        for mission in programme.missions:
            ws1.cell(row, 1, mission.reference)
            ws1.cell(row, 2, mission.titre)
            ws1.cell(row, 3, mission.description or '')
            ws1.cell(row, 4, mission.priorite.capitalize() if mission.priorite else '')
            ws1.cell(row, 5, mission.niveau_risque_associe or '')
            ws1.cell(row, 6, mission.annee_prevue)
            ws1.cell(row, 7, f"T{mission.trimestre_prevue}" if mission.trimestre_prevue else '')
            ws1.cell(row, 8, mission.date_debut_prevue.strftime('%d/%m/%Y') if mission.date_debut_prevue else '')
            ws1.cell(row, 9, mission.date_fin_prevue.strftime('%d/%m/%Y') if mission.date_fin_prevue else '')
            ws1.cell(row, 10, mission.duree_estimee or 0)
            ws1.cell(row, 11, mission.statut.replace('_', ' ').title() if mission.statut else '')
            ws1.cell(row, 12, mission.progression or 0)
            ws1.cell(row, 13, mission.responsable.username if mission.responsable else 'Non assign√©')
            ws1.cell(row, 14, mission.risque.reference if mission.risque else '')
            ws1.cell(row, 15, mission.audit.reference if mission.audit else '')
            
            # Colorer la ligne selon la priorit√©
            if mission.priorite == 'critique':
                for col in range(1, 16):
                    ws1.cell(row, col).fill = PatternFill(start_color="FFE5E5", end_color="FFE5E5", fill_type="solid")
            elif mission.priorite == 'elevee':
                for col in range(1, 16):
                    ws1.cell(row, col).fill = PatternFill(start_color="FFF3CD", end_color="FFF3CD", fill_type="solid")
            
            row += 1
        
        # Ajuster la largeur des colonnes
        for col in range(1, 16):
            ws1.column_dimensions[openpyxl.utils.get_column_letter(col)].width = 18
        
        # ========== SHEET 2 : R√âSUM√â ==========
        ws2 = wb.create_sheet("R√©sum√©")
        
        resume_data = [
            ('Programme', programme.nom),
            ('R√©f√©rence', programme.reference),
            ('Description', programme.description or ''),
            ('P√©riode', f"{programme.annee_debut} - {programme.annee_fin} ({programme.periode})"),
            ('Statut', programme.statut.replace('_', ' ').title()),
            ('M√©thode de g√©n√©ration', programme.methode_generation.replace('_', ' ').title()),
            ('Fr√©quence d\'audit', programme.frequence_audit.capitalize() if programme.frequence_audit else 'Non sp√©cifi√©e'),
            ('Dur√©e moyenne mission', f"{programme.duree_moyenne_mission or 0} jours"),
            ('Ressources disponibles', f"{programme.ressources_disponibles or 0} jours/homme/an"),
            ('Total missions', programme.nb_missions),
            ('Missions termin√©es', programme.nb_missions_realisees),
            ('Progression', f"{programme.progression}%"),
            ('Jours audit planifi√©s', programme.jours_audit_planifies),
            ('Jours audit r√©alis√©s', programme.jours_audit_realises),
            ('Cr√©√© par', programme.createur.username if programme.createur else 'N/A'),
            ('Date cr√©ation', programme.created_at.strftime('%d/%m/%Y') if programme.created_at else ''),
        ]
        
        if programme.date_approbation:
            resume_data.append(('Date approbation', programme.date_approbation.strftime('%d/%m/%Y')))
        
        for row, (label, value) in enumerate(resume_data, 1):
            cell_label = ws2.cell(row, 1, label)
            cell_label.font = Font(bold=True)
            cell_label.border = border
            cell_value = ws2.cell(row, 2, str(value))
            cell_value.border = border
        
        ws2.column_dimensions['A'].width = 25
        ws2.column_dimensions['B'].width = 40
        
        # ========== SHEET 3 : STATISTIQUES ==========
        ws3 = wb.create_sheet("Statistiques")
        
        # Statistiques par priorit√©
        ws3.cell(1, 1, "R√âPARTITION PAR PRIORIT√â").font = Font(bold=True, size=14)
        
        stats_headers = ['Priorit√©', 'Nombre', 'Pourcentage']
        for col, header in enumerate(stats_headers, 1):
            cell = ws3.cell(3, col, header)
            cell.font = Font(bold=True)
            cell.fill = PatternFill(start_color="0D6EFD", end_color="0D6EFD", fill_type="solid")
            cell.font = Font(bold=True, color="FFFFFF")
        
        # Compter les missions par priorit√©
        priorites = {
            'critique': {'nom': 'Critique', 'count': 0, 'color': 'FFE5E5'},
            'elevee': {'nom': '√âlev√©e', 'count': 0, 'color': 'FFF3CD'},
            'moyenne': {'nom': 'Moyenne', 'count': 0, 'color': 'E5F6FF'},
            'faible': {'nom': 'Faible', 'count': 0, 'color': 'F0F0F0'}
        }
        
        for mission in programme.missions:
            if mission.priorite in priorites:
                priorites[mission.priorite]['count'] += 1
        
        row = 4
        total = programme.nb_missions or 1
        for p_key, p_data in priorites.items():
            if p_data['count'] > 0:
                ws3.cell(row, 1, p_data['nom'])
                ws3.cell(row, 2, p_data['count'])
                pourcentage = (p_data['count'] / total * 100)
                ws3.cell(row, 3, f"{pourcentage:.1f}%")
                
                # Colorer la ligne
                for col in range(1, 4):
                    ws3.cell(row, col).fill = PatternFill(start_color=p_data['color'], end_color=p_data['color'], fill_type="solid")
                row += 1
        
        # Statistiques par statut
        row += 2
        ws3.cell(row, 1, "R√âPARTITION PAR STATUT").font = Font(bold=True, size=14)
        row += 1
        
        statuts = {}
        for mission in programme.missions:
            statut = mission.statut or 'non_defini'
            statuts[statut] = statuts.get(statut, 0) + 1
        
        row += 1
        for statut, count in statuts.items():
            ws3.cell(row, 1, statut.replace('_', ' ').title())
            ws3.cell(row, 2, count)
            row += 1
        
        # ========== SAUVEGARDE ==========
        output = BytesIO()
        wb.save(output)
        output.seek(0)
        
        return send_file(
            output,
            mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            as_attachment=True,
            download_name=f'programme_audit_{programme.reference}_{datetime.now().strftime("%Y%m%d_%H%M")}.xlsx'
        )
        
    except Exception as e:
        flash(f'Erreur export Excel: {str(e)}', 'error')
        return redirect(url_for('detail_programme_audit', id=programme.id))


def exporter_programme_csv(programme):
    """Export du programme au format CSV"""
    try:
        output = StringIO()
        writer = csv.writer(output, delimiter=';', quoting=csv.QUOTE_ALL)
        
        # En-t√™te
        writer.writerow([
            'R√©f√©rence', 'Titre', 'Priorit√©', 'Ann√©e', 'Trimestre', 
            'Date d√©but', 'Date fin', 'Dur√©e (j)', 'Statut', 'Responsable',
            'Niveau Risque', 'Progression %'
        ])
        
        # Donn√©es
        for mission in programme.missions:
            writer.writerow([
                mission.reference,
                mission.titre,
                mission.priorite.capitalize() if mission.priorite else '',
                mission.annee_prevue,
                mission.trimestre_prevue or '',
                mission.date_debut_prevue.strftime('%d/%m/%Y') if mission.date_debut_prevue else '',
                mission.date_fin_prevue.strftime('%d/%m/%Y') if mission.date_fin_prevue else '',
                mission.duree_estimee or 0,
                mission.statut.replace('_', ' ').title() if mission.statut else '',
                mission.responsable.username if mission.responsable else '',
                mission.niveau_risque_associe or '',
                mission.progression or 0
            ])
        
        output.seek(0)
        
        return send_file(
            BytesIO(output.getvalue().encode('utf-8-sig')),
            mimetype='text/csv; charset=utf-8',
            as_attachment=True,
            download_name=f'programme_audit_{programme.reference}_{datetime.now().strftime("%Y%m%d_%H%M")}.csv'
        )
        
    except Exception as e:
        flash(f'Erreur export CSV: {str(e)}', 'error')
        return redirect(url_for('detail_programme_audit', id=programme.id))


def exporter_programme_pdf(programme):
    """Export du programme au format PDF"""
    try:
        from reportlab.lib.pagesizes import letter, landscape
        from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib.units import inch
        from reportlab.lib import colors
        
        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=landscape(letter))
        story = []
        styles = getSampleStyleSheet()
        
        # Style personnalis√©
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=18,
            spaceAfter=20,
            textColor=colors.HexColor('#0d6efd')
        )
        
        # Titre
        story.append(Paragraph(f"Programme d'Audit : {programme.nom}", title_style))
        story.append(Paragraph(f"R√©f√©rence: {programme.reference}", styles['Normal']))
        story.append(Spacer(1, 20))
        
        # Informations g√©n√©rales
        story.append(Paragraph("Informations G√©n√©rales", styles['Heading2']))
        
        info_data = [
            ['P√©riode', f"{programme.annee_debut} - {programme.annee_fin} ({programme.periode})"],
            ['Statut', programme.statut.replace('_', ' ').title()],
            ['M√©thode', programme.methode_generation.replace('_', ' ').title()],
            ['Progression', f"{programme.progression}%"],
            ['Missions', f"{programme.nb_missions_realisees}/{programme.nb_missions}"],
            ['Jours audit', f"{programme.jours_audit_realises}/{programme.jours_audit_planifies}j"],
            ['Cr√©√© par', programme.createur.username if programme.createur else 'N/A'],
            ['Date cr√©ation', programme.created_at.strftime('%d/%m/%Y') if programme.created_at else '']
        ]
        
        info_table = Table(info_data, colWidths=[2*inch, 4*inch])
        info_table.setStyle(TableStyle([
            ('GRID', (0,0), (-1,-1), 0.5, colors.grey),
            ('BACKGROUND', (0,0), (0,-1), colors.lightgrey),
            ('VALIGN', (0,0), (-1,-1), 'MIDDLE'),
        ]))
        story.append(info_table)
        story.append(Spacer(1, 20))
        
        # Missions
        story.append(Paragraph("Missions d'Audit", styles['Heading2']))
        
        if programme.missions:
            mission_data = [['R√©f.', 'Titre', 'Priorit√©', 'Ann√©e', 'Dur√©e', 'Statut']]
            
            for mission in programme.missions[:20]:  # Limiter √† 20 missions pour le PDF
                mission_data.append([
                    mission.reference,
                    mission.titre[:30] + '...' if len(mission.titre) > 30 else mission.titre,
                    mission.priorite.capitalize() if mission.priorite else '',
                    str(mission.annee_prevue),
                    f"{mission.duree_estimee or 0}j",
                    mission.statut.replace('_', ' ').title() if mission.statut else ''
                ])
            
            mission_table = Table(mission_data, colWidths=[0.8*inch, 2.5*inch, 0.6*inch, 0.5*inch, 0.4*inch, 0.8*inch])
            mission_table.setStyle(TableStyle([
                ('GRID', (0,0), (-1,-1), 0.5, colors.grey),
                ('BACKGROUND', (0,0), (-1,0), colors.HexColor('#0d6efd')),
                ('TEXTCOLOR', (0,0), (-1,0), colors.white),
                ('ALIGN', (0,0), (-1,-1), 'CENTER'),
                ('VALIGN', (0,0), (-1,-1), 'MIDDLE'),
                ('FONTSIZE', (0,0), (-1,-1), 8),
            ]))
            story.append(mission_table)
        
        # Pied de page
        story.append(Spacer(1, 30))
        story.append(Paragraph(
            f"G√©n√©r√© le {datetime.now().strftime('%d/%m/%Y √† %H:%M')} - Egalyx Audit",
            ParagraphStyle('Footer', parent=styles['Normal'], fontSize=8, alignment=1, textColor=colors.grey)
        ))
        
        doc.build(story)
        buffer.seek(0)
        
        return send_file(
            buffer,
            mimetype='application/pdf',
            as_attachment=True,
            download_name=f'programme_audit_{programme.reference}_{datetime.now().strftime("%Y%m%d_%H%M")}.pdf'
        )
        
    except ImportError:
        flash('Export PDF n√©cessite ReportLab: pip install reportlab', 'error')
        return redirect(url_for('detail_programme_audit', id=programme.id))
    except Exception as e:
        flash(f'Erreur export PDF: {str(e)}', 'error')
        return redirect(url_for('detail_programme_audit', id=programme.id))


@app.route('/api/programme-audit/<int:id>/statistiques')
@login_required
def api_statistiques_programme(id):
    """API pour les statistiques du programme"""
    programme = ProgrammeAudit.query.get_or_404(id)
    
    if not check_client_access(programme):
        return jsonify({'error': 'Acc√®s non autoris√©'}), 403
    
    # Statistiques par priorit√©
    stats_priorite = {
        'critique': 0,
        'elevee': 0,
        'moyenne': 0,
        'faible': 0
    }
    
    for mission in programme.missions:
        if mission.priorite in stats_priorite:
            stats_priorite[mission.priorite] += 1
    
    # Statistiques par statut
    stats_statut = {
        'planifie': 0,
        'en_cours': 0,
        'termine': 0,
        'suspendu': 0,
        'annule': 0
    }
    
    for mission in programme.missions:
        if mission.statut in stats_statut:
            stats_statut[mission.statut] += 1
    
    # Charge par ann√©e
    charge_annee = {}
    for mission in programme.missions:
        if mission.annee_prevue not in charge_annee:
            charge_annee[mission.annee_prevue] = 0
        charge_annee[mission.annee_prevue] += mission.duree_estimee or 0
    
    return jsonify({
        'priorite': stats_priorite,
        'statut': stats_statut,
        'charge_annee': charge_annee,
        'progression': programme.progression,
        'jours_planifies': programme.jours_audit_planifies,
        'jours_realises': programme.jours_audit_realises
    })


@app.route('/api/programme-audit/<int:programme_id>/stats-plans')
@login_required
def api_stats_plans_pluie(programme_id):
    """API pour obtenir les statistiques des plans de repli"""
    programme = ProgrammeAudit.query.get_or_404(programme_id)
    
    if not check_client_access(programme):
        return jsonify({'error': 'Acc√®s non autoris√©'}), 403
    
    mission_ids = [m.id for m in programme.missions]
    plans = PlanPluieAudit.query.filter(
        PlanPluieAudit.mission_principale_id.in_(mission_ids)
    ).filter_by(is_archived=False).all()
    
    stats = {
        'total': len(plans),
        'actifs': len([p for p in plans if p.statut == 'actif']),
        'declenches': len([p for p in plans if p.statut == 'declenche']),
        'par_type': {
            'retard': len([p for p in plans if p.condition_type == 'retard']),
            'indisponibilite': len([p for p in plans if p.condition_type == 'indisponibilite']),
            'urgence': len([p for p in plans if p.condition_type == 'urgence'])
        }
    }
    
    return jsonify(stats)


# ============================================================================
# ROUTES POUR LA MODIFICATION DES PROGRAMMES
# ============================================================================

@app.route('/programme-audit/<int:id>/modifier', methods=['POST'])
@csrf.exempt 
@login_required
def modifier_programme_audit(id):
    """Modifier un programme d'audit"""
    programme = ProgrammeAudit.query.get_or_404(id)
    
    if not check_client_access(programme):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_programmes_audit'))
    
    try:
        ancienne_annee_debut = programme.annee_debut
        ancienne_annee_fin = programme.annee_fin
        
        # Mise √† jour des champs
        programme.nom = request.form.get('nom', programme.nom)
        programme.description = request.form.get('description', programme.description)
        programme.periode = request.form.get('periode', programme.periode)
        programme.annee_debut = int(request.form.get('annee_debut', programme.annee_debut))
        programme.annee_fin = int(request.form.get('annee_fin', programme.annee_fin))
        programme.methode_generation = request.form.get('methode_generation', programme.methode_generation)
        programme.frequence_audit = request.form.get('frequence_audit') or None
        programme.duree_moyenne_mission = int(request.form.get('duree_moyenne_mission')) if request.form.get('duree_moyenne_mission') else None
        programme.ressources_disponibles = int(request.form.get('ressources_disponibles')) if request.form.get('ressources_disponibles') else None
        programme.updated_at = datetime.now()
        
        # ========== GESTION DES MISSIONS APR√àS CHANGEMENT DE P√âRIODE ==========
        if ancienne_annee_debut != programme.annee_debut or ancienne_annee_fin != programme.annee_fin:
            # Ajuster les missions qui sont hors de la nouvelle p√©riode
            for mission in programme.missions:
                if mission.annee_prevue < programme.annee_debut:
                    mission.annee_prevue = programme.annee_debut
                    mission.commentaire_repli = f"Mission ajust√©e automatiquement (ann√©e d√©but programme modifi√©e)"
                elif mission.annee_prevue > programme.annee_fin:
                    mission.annee_prevue = programme.annee_fin
                    mission.commentaire_repli = f"Mission ajust√©e automatiquement (ann√©e fin programme modifi√©e)"
        
        db.session.commit()
        
        flash('Programme modifi√© avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur: {str(e)}', 'error')
    
    return redirect(url_for('detail_programme_audit', id=programme.id))


@app.route('/programme-audit/<int:id>/desapprouver', methods=['POST'])
@csrf.exempt 
@login_required
def desapprouver_programme_audit(id):
    """D√©sapprouver un programme d'audit (remettre en √©laboration)"""
    programme = ProgrammeAudit.query.get_or_404(id)
    
    if not check_client_access(programme):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_programmes_audit'))
    
    try:
        raison = request.form.get('raison', 'D√©sapprobation manuelle')
        
        programme.statut = 'en_elaboration'
        programme.date_approbation = None
        programme.date_mise_en_oeuvre = None
        programme.updated_at = datetime.now()
        programme.archive_reason = raison  # R√©utiliser pour la raison de d√©sapprobation
        
        db.session.commit()
        
        flash(f'Programme {programme.reference} d√©sapprouv√© avec succ√®s', 'warning')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur: {str(e)}', 'error')
    
    return redirect(url_for('detail_programme_audit', id=programme.id))


@app.route('/programme-audit/<int:id>/dupliquer', methods=['POST'])
@login_required
def dupliquer_programme_audit(id):
    """Dupliquer un programme d'audit"""
    programme_original = ProgrammeAudit.query.get_or_404(id)
    
    if not check_client_access(programme_original):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_programmes_audit'))
    
    try:
        # G√©n√©rer nouvelle r√©f√©rence
        def generer_reference_programme(client_id=None):
            base_ref = "PROGAUD-"
            dernier = ProgrammeAudit.query.filter_by(client_id=client_id)\
                .order_by(ProgrammeAudit.id.desc()).first()
            
            if dernier and dernier.reference:
                try:
                    dernier_num = int(dernier.reference.split('-')[1])
                    nouveau_num = dernier_num + 1
                except:
                    count = ProgrammeAudit.query.filter_by(client_id=client_id).count()
                    nouveau_num = count + 1
            else:
                nouveau_num = 1
            
            return f"{base_ref}{nouveau_num:04d}"
        
        # Cr√©er nouveau programme
        nouveau_programme = ProgrammeAudit(
            reference=generer_reference_programme(programme_original.client_id),
            nom=f"COPIE - {programme_original.nom}",
            description=programme_original.description,
            periode=programme_original.periode,
            annee_debut=programme_original.annee_debut + 1,
            annee_fin=programme_original.annee_fin + 1,
            methode_generation=programme_original.methode_generation,
            criteres_generation=programme_original.criteres_generation,
            frequence_audit=programme_original.frequence_audit,
            duree_moyenne_mission=programme_original.duree_moyenne_mission,
            ressources_disponibles=programme_original.ressources_disponibles,
            statut='en_elaboration',
            client_id=programme_original.client_id,
            created_by=current_user.id
        )
        
        db.session.add(nouveau_programme)
        db.session.commit()
        
        flash(f'Programme dupliqu√© avec succ√®s - {nouveau_programme.reference}', 'success')
        return redirect(url_for('detail_programme_audit', id=nouveau_programme.id))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur: {str(e)}', 'error')
        return redirect(url_for('detail_programme_audit', id=programme_original.id))
# ============================================================================
# ROUTES POUR L'ARCHIVAGE DES PROGRAMMES D'AUDIT
# ============================================================================

@app.route('/programme-audit/<int:id>/archiver', methods=['POST'])
@csrf.exempt
@login_required
def archiver_programme_audit(id):
    """Archiver un programme d'audit"""
    programme = ProgrammeAudit.query.get_or_404(id)
    
    if not check_client_access(programme):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_programmes_audit'))
    
    if request.method == 'POST':
        try:
            raison = request.form.get('raison', 'Archivage manuel')
            commentaire = request.form.get('commentaire', '')
            
            programme.is_archived = True
            programme.statut = 'archive'
            programme.archived_at = datetime.now()
            programme.archived_by = current_user.id
            programme.archive_reason = f"{raison} - {commentaire}" if commentaire else raison
            
            db.session.commit()
            
            flash(f'Programme {programme.reference} archiv√© avec succ√®s', 'success')
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur lors de l\'archivage: {str(e)}', 'error')
    
    return redirect(url_for('programmes_archives'))


@app.route('/programme-audit/<int:id>/restaurer', methods=['POST'])
@csrf.exempt 
@login_required
def restaurer_programme_audit(id):
    """Restaurer un programme d'audit archiv√©"""
    programme = ProgrammeAudit.query.get_or_404(id)
    
    if not check_client_access(programme):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('programmes_archives'))
    
    try:
        programme.is_archived = False
        programme.statut = 'en_elaboration'  # Remettre en √©laboration
        programme.archived_at = None
        programme.archived_by = None
        programme.archive_reason = None
        
        db.session.commit()
        
        flash(f'Programme {programme.reference} restaur√© avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la restauration: {str(e)}', 'error')
    
    return redirect(url_for('programmes_archives'))


@app.route('/programme-audit/<int:id>/supprimer-definitivement', methods=['POST'])
@login_required
def supprimer_programme_audit_definitif(id):
    """Supprimer d√©finitivement un programme archiv√©"""
    programme = ProgrammeAudit.query.get_or_404(id)
    
    if not check_client_access(programme):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('programmes_archives'))
    
    # V√©rifier que le programme est bien archiv√©
    if not programme.is_archived:
        flash('Seuls les programmes archiv√©s peuvent √™tre supprim√©s d√©finitivement', 'error')
        return redirect(url_for('liste_programmes_audit'))
    
    try:
        confirmation = request.form.get('confirmation', '')
        
        if confirmation != programme.reference:
            flash('La confirmation ne correspond pas √† la r√©f√©rence du programme', 'error')
            return redirect(url_for('programmes_archives'))
        
        # Supprimer les missions associ√©es
        for mission in programme.missions:
            # Supprimer les plans de repli associ√©s
            PlanPluieAudit.query.filter(
                (PlanPluieAudit.mission_principale_id == mission.id) |
                (PlanPluieAudit.mission_remplacement_id == mission.id)
            ).delete()
            
            db.session.delete(mission)
        
        # Supprimer le programme
        db.session.delete(programme)
        db.session.commit()
        
        flash(f'Programme {programme.reference} supprim√© d√©finitivement', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la suppression: {str(e)}', 'error')
    
    return redirect(url_for('programmes_archives'))


@app.route('/programmes-archives')
@csrf.exempt
@login_required
def programmes_archives():
    """Liste des programmes d'audit archiv√©s"""
    
    # V√©rification permission
    if not current_user.has_permission('can_manage_audit'):
        flash('Permission requise', 'error')
        return redirect(url_for('dashboard'))
    
    # R√©cup√©ration des programmes archiv√©s
    programmes = get_client_filter(ProgrammeAudit)\
        .filter_by(is_archived=True)\
        .order_by(ProgrammeAudit.archived_at.desc())\
        .all()
    
    return render_template('programme_audit/archives.html',
                         programmes=programmes)

@app.route('/programme-audit/<int:id>/approuver', methods=['POST'])
@csrf.exempt
@login_required
def approuver_programme_audit(id):
    """Approuver un programme d'audit"""
    programme = ProgrammeAudit.query.get_or_404(id)
    
    if not check_client_access(programme):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_programmes_audit'))
    
    try:
        programme.statut = 'actif'
        programme.date_approbation = datetime.strptime(
            request.form.get('date_approbation', datetime.now().strftime('%Y-%m-%d')), 
            '%Y-%m-%d'
        ).date()
        programme.date_mise_en_oeuvre = datetime.now().date()
        programme.updated_at = datetime.now()
        
        db.session.commit()
        
        flash(f'Programme {programme.reference} approuv√© avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de l\'approbation: {str(e)}', 'error')
    
    return redirect(url_for('detail_programme_audit', id=id))


@app.route('/audit/<int:audit_id>/matrice-maturite', methods=['GET', 'POST'])
@login_required
def matrice_maturite_audit(audit_id):
    """Afficher et g√©rer la matrice de maturit√©/conformit√©"""
    audit = Audit.query.get_or_404(audit_id)
    
    # Charger les matrices existantes
    matrices = MatriceMaturite.query.filter_by(audit_id=audit_id).all()
    
    # G√©rer le formulaire si c'est une requ√™te POST
    if request.method == 'POST':
        try:
            # R√©cup√©rer les donn√©es du formulaire
            exigence = request.form.get('exigence', '').strip()
            niveau_conformite = request.form.get('niveau_conformite', '')
            commentaire = request.form.get('commentaire', '').strip()
            risques_associes = request.form.get('risques_associes', '').strip()
            
            # Validation basique
            if not exigence or not niveau_conformite:
                flash('L\'exigence et le niveau de conformit√© sont requis', 'error')
                return redirect(url_for('matrice_maturite_audit', audit_id=audit_id))
            
            # Cr√©er une nouvelle matrice SANS created_by
            matrice = MatriceMaturite(
                audit_id=audit_id,
                exigence=exigence,
                niveau_conformite=niveau_conformite,
                commentaire=commentaire if commentaire else None,
                risques_associes=risques_associes if risques_associes else None
            )
            
            db.session.add(matrice)
            db.session.commit()
            
            flash('Exigence ajout√©e √† la matrice avec succ√®s', 'success')
            return redirect(url_for('matrice_maturite_audit', audit_id=audit_id))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur lors de l\'ajout: {str(e)}', 'error')
    
    return render_template('audit/matrice_maturite.html',
                         audit=audit,
                         matrices=matrices)


@app.route('/api/audit/<int:audit_id>/statistiques-temps-reel')
@login_required
def api_statistiques_temps_reel(audit_id):
    """API pour les statistiques en temps r√©el"""
    audit = Audit.query.get_or_404(audit_id)
    
    data = {
        'progression_globale': audit.progression_globale,
        'taux_realisation_recommandations': audit.taux_realisation_recommandations,
        'score_global': audit.score_global,
        'couleur_progression': audit.get_couleur_progression(),
        'constatations_total': len(audit.constatations),
        'constatations_closes': len([c for c in audit.constatations if c.statut == 'clos']),
        'recommandations_total': len(audit.recommandations),
        'recommandations_terminees': len([r for r in audit.recommandations if r.statut == 'termine']),
        'plans_action_total': len(audit.plans_action),
        'plans_action_termines': len([p for p in audit.plans_action if p.statut == 'termine']),
        'plans_en_retard': len([p for p in audit.plans_action if p.est_en_retard]),
        'derniere_maj': audit.updated_at.isoformat() if audit.updated_at else None
    }
    
    return jsonify(data)


@app.route('/audit/<int:audit_id>/export/rapport-complet', methods=['GET'])
@login_required
def export_rapport_audit_complet(audit_id):
    """Exporter le rapport d'audit complet en PDF"""
    from reportlab.lib.pagesizes import letter
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch
    from reportlab.lib import colors
    from io import BytesIO
    
    audit = Audit.query.get_or_404(audit_id)
    
    # Cr√©er le PDF en m√©moire
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter)
    story = []
    styles = getSampleStyleSheet()
    
    # Style personnalis√©
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=16,
        spaceAfter=30
    )
    
    # Titre
    story.append(Paragraph(f"Rapport d'Audit - {audit.reference}", title_style))
    story.append(Paragraph(f"Titre: {audit.titre}", styles['Normal']))
    story.append(Spacer(1, 12))
    
    # Informations g√©n√©rales
    story.append(Paragraph("Informations G√©n√©rales", styles['Heading2']))
    
    info_data = [
        ['R√©f√©rence', audit.reference],
        ['Type', audit.type_audit],
        ['Statut', audit.statut],
        ['Responsable', audit.responsable.username if audit.responsable else 'Non d√©fini'],
        ['Dates', f"{audit.date_debut_prevue.strftime('%d/%m/%Y') if audit.date_debut_prevue else 'N/A'} - {audit.date_fin_prevue.strftime('%d/%m/%Y') if audit.date_fin_prevue else 'N/A'}"],
        ['Score global', f"{audit.score_global}/100"],
    ]
    
    info_table = Table(info_data, colWidths=[2*inch, 4*inch])
    info_table.setStyle(TableStyle([
        ('GRID', (0,0), (-1,-1), 1, colors.black),
        ('BACKGROUND', (0,0), (0,-1), colors.lightgrey),
    ]))
    story.append(info_table)
    story.append(Spacer(1, 20))
    
    # Constatations
    story.append(Paragraph("Constatations", styles['Heading2']))
    if audit.constatations:
        constat_data = [['R√©f.', 'Description', 'Type', 'Gravit√©', 'Statut']]
        for constat in audit.constatations:
            constat_data.append([
                constat.reference,
                constat.description[:100] + '...' if len(constat.description) > 100 else constat.description,
                constat.type_constatation,
                constat.gravite,
                constat.statut
            ])
        
        constat_table = Table(constat_data, colWidths=[0.5*inch, 2.5*inch, inch, inch, inch])
        constat_table.setStyle(TableStyle([
            ('GRID', (0,0), (-1,-1), 1, colors.black),
            ('BACKGROUND', (0,0), (-1,0), colors.lightgrey),
        ]))
        story.append(constat_table)
    else:
        story.append(Paragraph("Aucune constatation", styles['Normal']))
    
    story.append(Spacer(1, 20))
    
    # Recommandations
    story.append(Paragraph("Recommandations", styles['Heading2']))
    if audit.recommandations:
        reco_data = [['R√©f.', 'Description', 'Priorit√©', 'Statut', 'Avancement']]
        for reco in audit.recommandations:
            reco_data.append([
                reco.reference,
                reco.description[:80] + '...' if len(reco.description) > 80 else reco.description,
                reco.score_priorite,
                reco.statut,
                f"{reco.taux_avancement}%"
            ])
        
        reco_table = Table(reco_data, colWidths=[0.5*inch, 3*inch, 0.7*inch, inch, inch])
        reco_table.setStyle(TableStyle([
            ('GRID', (0,0), (-1,-1), 1, colors.black),
            ('BACKGROUND', (0,0), (-1,0), colors.lightgrey),
        ]))
        story.append(reco_table)
    
    story.append(Spacer(1, 20))
    
    # Pied de page
    story.append(Paragraph(f"G√©n√©r√© le {datetime.utcnow().strftime('%d/%m/%Y √† %H:%M')} par {current_user.username}", 
                          ParagraphStyle('Footer', parent=styles['Normal'], fontSize=8, alignment=1)))
    
    # G√©n√©rer le PDF
    doc.build(story)
    
    buffer.seek(0)
    return send_file(buffer, 
                    as_attachment=True, 
                    download_name=f"rapport_audit_{audit.reference}.pdf",
                    mimetype='application/pdf')

@app.route('/audit/<int:audit_id>/export/synthese-word', methods=['GET'])
@login_required
def export_synthese_word(audit_id):
    """Exporter la synth√®se en format Word"""
    from docx import Document
    from docx.shared import Inches, Pt, RGBColor
    from docx.enum.text import WD_ALIGN_PARAGRAPH
    from io import BytesIO
    
    audit = Audit.query.get_or_404(audit_id)
    
    # Cr√©er le document Word
    doc = Document()
    
    # Titre
    title = doc.add_heading(f'Rapport d\'Audit - {audit.reference}', 0)
    title.alignment = WD_ALIGN_PARAGRAPH.CENTER
    
    # Informations g√©n√©rales
    doc.add_heading('Informations G√©n√©rales', level=1)
    
    info_table = doc.add_table(rows=6, cols=2)
    info_table.style = 'Light Shading Accent 1'
    
    data = [
        ('R√©f√©rence', audit.reference),
        ('Titre', audit.titre),
        ('Type', audit.type_audit),
        ('Statut', audit.statut),
        ('Responsable', audit.responsable.username if audit.responsable else 'Non d√©fini'),
        ('Dates', f"{audit.date_debut_prevue.strftime('%d/%m/%Y') if audit.date_debut_prevue else 'N/A'} - {audit.date_fin_prevue.strftime('%d/%m/%Y') if audit.date_fin_prevue else 'N/A'}"),
    ]
    
    for i, (label, value) in enumerate(data):
        row = info_table.rows[i]
        row.cells[0].text = label
        row.cells[1].text = str(value)
    
    # Statistiques
    doc.add_heading('Statistiques', level=1)
    
    stats_data = [
        ('Score global', f'{audit.score_global}/100'),
        ('Constatations', f'{len(audit.constatations)}'),
        ('Recommandations', f'{len(audit.recommandations)}'),
        ('Plans d\'action', f'{len(audit.plans_action)}'),
    ]
    
    stats_table = doc.add_table(rows=4, cols=2)
    stats_table.style = 'Light Grid Accent 1'
    
    for i, (label, value) in enumerate(stats_data):
        row = stats_table.rows[i]
        row.cells[0].text = label
        row.cells[1].text = value
    
    # Sauvegarder dans un buffer
    buffer = BytesIO()
    doc.save(buffer)
    buffer.seek(0)
    
    return send_file(buffer, 
                    as_attachment=True, 
                    download_name=f"synthese_audit_{audit.reference}.docx",
                    mimetype='application/vnd.openxmlformats-officedocument.wordprocessingml.document')

@app.route('/audit/<int:audit_id>/journal')
@login_required
def journal_audit(audit_id):
    """Afficher le journal d'audit complet"""
    audit = Audit.query.get_or_404(audit_id)
    
    # R√©cup√©rer les entr√©es du journal tri√©es par date d√©croissante
    journal_entries = JournalAudit.query.filter_by(audit_id=audit_id)\
                                       .order_by(JournalAudit.created_at.desc())\
                                       .all()
    
    return render_template('audit/journal.html',
                         audit=audit,
                         journal_entries=journal_entries,
                         datetime=datetime,  # ‚Üê IMPORTANT : passer datetime au template
                         now=datetime.utcnow)  # ‚Üê passer la fonction maintenant

# ============================================================================
# ROUTES DE SUPPRESSION POUR AUDIT
# ============================================================================



@app.route('/audit/<int:audit_id>/journal/export')
@login_required
def export_journal_audit(audit_id):
    """Exporter le journal d'audit en format CSV ou PDF"""
    from flask import Response
    from io import StringIO
    import csv
    
    audit = Audit.query.get_or_404(audit_id)
    
    # R√©cup√©rer les entr√©es du journal
    journal_entries = JournalAudit.query.filter_by(audit_id=audit_id)\
                                       .order_by(JournalAudit.created_at.desc())\
                                       .all()
    
    format_type = request.args.get('format', 'csv')
    
    if format_type == 'csv':
        # G√©n√©rer un CSV
        output = StringIO()
        writer = csv.writer(output, delimiter=';', quoting=csv.QUOTE_ALL)
        
        # En-t√™te
        writer.writerow(['Date', 'Utilisateur', 'Action', 'D√©tails', 'Signature'])
        
        # Donn√©es
        for entry in journal_entries:
            writer.writerow([
                entry.created_at.strftime('%d/%m/%Y %H:%M'),
                entry.utilisateur.username if entry.utilisateur else 'Syst√®me',
                entry.action,
                str(entry.details)[:500],  # Limiter la taille
                entry.signature or ''
            ])
        
        output.seek(0)
        
        response = Response(
            output.getvalue(),
            mimetype='text/csv; charset=utf-8',
            headers={
                'Content-Disposition': f'attachment; filename=journal_audit_{audit.reference}_{datetime.now().strftime("%Y%m%d")}.csv'
            }
        )
        return response
    
    elif format_type == 'pdf':
        try:
            from reportlab.lib.pagesizes import letter
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib.units import inch
            from reportlab.lib import colors
            from io import BytesIO
            
            buffer = BytesIO()
            doc = SimpleDocTemplate(buffer, pagesize=letter)
            story = []
            styles = getSampleStyleSheet()
            
            # Style personnalis√©
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=16,
                spaceAfter=30
            )
            
            # Titre
            story.append(Paragraph(f"Journal d'Audit - {audit.reference}", title_style))
            story.append(Paragraph(f"Audit: {audit.titre}", styles['Normal']))
            story.append(Spacer(1, 12))
            
            # Table des donn√©es
            data = [['Date', 'Utilisateur', 'Action', 'D√©tails']]
            
            for entry in journal_entries:
                data.append([
                    entry.created_at.strftime('%d/%m/%Y %H:%M'),
                    entry.utilisateur.username if entry.utilisateur else 'Syst√®me',
                    entry.action,
                    str(entry.details)[:200] + '...' if len(str(entry.details)) > 200 else str(entry.details)
                ])
            
            table = Table(data, colWidths=[1.5*inch, 1*inch, 1.5*inch, 3*inch])
            table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 10),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            
            story.append(table)
            story.append(Spacer(1, 20))
            story.append(Paragraph(f"G√©n√©r√© le {datetime.now().strftime('%d/%m/%Y √† %H:%M')}", 
                                  ParagraphStyle('Footer', parent=styles['Normal'], fontSize=8)))
            
            doc.build(story)
            buffer.seek(0)
            
            response = Response(
                buffer.getvalue(),
                mimetype='application/pdf',
                headers={
                    'Content-Disposition': f'attachment; filename=journal_audit_{audit.reference}_{datetime.now().strftime("%Y%m%d")}.pdf'
                }
            )
            return response
            
        except ImportError:
            flash('Export PDF non disponible. Le module ReportLab n\'est pas install√©.', 'error')
            return redirect(url_for('journal_audit', audit_id=audit_id))
    
    else:
        flash('Format d\'export non support√©', 'error')
        return redirect(url_for('journal_audit', audit_id=audit_id))

    

@app.route('/audit/<int:audit_id>/plan-action/<int:plan_id>/supprimer', methods=['POST'])
@csrf.exempt
@login_required
def supprimer_plan_action_audit(audit_id, plan_id):
    """Supprimer un plan d'action d'audit"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    # V√©rifier que le plan d'action appartient bien √† l'audit
    if plan_action.audit_id != audit_id:
        flash('Ce plan d\'action ne fait pas partie de cet audit', 'error')
        return redirect(url_for('detail_audit', id=audit_id))
    
    try:
        # Supprimer les √©tapes du plan d'action
        EtapePlanAction.query.filter_by(plan_action_id=plan_id).delete()
        
        # Supprimer le plan d'action
        db.session.delete(plan_action)
        db.session.commit()
        
        flash('Plan d\'action supprim√© avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la suppression: {str(e)}', 'error')
    
    return redirect(url_for('detail_audit', id=audit_id))

@app.route('/audit/<int:audit_id>/dissocier-risque/<int:risque_id>', methods=['POST'])
@login_required
def dissocier_risque_audit(audit_id, risque_id):
    """Dissocier un risque de toutes les constatations et recommandations d'un audit"""
    audit = Audit.query.get_or_404(audit_id)
    
    # V√©rifier les permissions
    peut_modifier = (
        current_user.role == 'admin' or
        current_user.id == audit.created_by or
        current_user.id == audit.responsable_id or
        str(current_user.id) in (audit.equipe_audit_ids or '').split(',')
    )
    
    if not peut_modifier:
        flash('Non autoris√©', 'error')
        return redirect(url_for('detail_audit', id=audit_id))
    
    try:
        # Dissocier le risque des constatations
        constatations = Constatation.query.filter_by(
            audit_id=audit_id,
            risque_id=risque_id
        ).all()
        
        for constatation in constatations:
            constatation.risque_id = None
            constatation.updated_at = datetime.utcnow()
        
        # Dissocier le risque des recommandations
        recommandations = Recommandation.query.filter_by(
            audit_id=audit_id,
            risque_id=risque_id
        ).all()
        
        for recommandation in recommandations:
            recommandation.risque_id = None
            recommandation.updated_at = datetime.utcnow()
        
        # Dissocier le risque des plans d'action
        plans_action = PlanAction.query.filter_by(
            audit_id=audit_id,
            risque_id=risque_id
        ).all()
        
        for plan in plans_action:
            plan.risque_id = None
            plan.updated_at = datetime.utcnow()
        
        db.session.commit()
        flash(f'Risque dissoci√© avec succ√®s de l\'audit', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la dissociation du risque: {str(e)}', 'error')
    
    return redirect(url_for('detail_audit', id=audit_id))

# ============================================================================
# ROUTES POUR LA GESTION AVANC√âE DES RISQUES DANS LES AUDITS
# ============================================================================

@app.route('/api/risques/cartographie/<int:cartographie_id>')
@login_required
def api_risques_par_cartographie(cartographie_id):
    """API pour r√©cup√©rer les risques d'une cartographie sp√©cifique"""
    cartographie = Cartographie.query.get_or_404(cartographie_id)
    risques = Risque.query.filter_by(cartographie_id=cartographie_id, is_archived=False).all()
    
    risques_data = []
    for risque in risques:
        derniere_eval = EvaluationRisque.query.filter_by(risque_id=risque.id).order_by(EvaluationRisque.created_at.desc()).first()
        
        risque_info = {
            'id': risque.id,
            'reference': risque.reference,
            'intitule': risque.intitule,
            'categorie': risque.categorie,
            'cartographie_nom': cartographie.nom,
            'evaluation': {
                'niveau_risque': derniere_eval.niveau_risque if derniere_eval else 'Non √©valu√©',
                'score': derniere_eval.score_risque if derniere_eval else 0,
                'impact': derniere_eval.impact if derniere_eval else None,
                'probabilite': derniere_eval.probabilite if derniere_eval else None
            } if derniere_eval else None
        }
        risques_data.append(risque_info)
    
    return jsonify(risques_data)

@app.route('/audit/<int:audit_id>/recommandation/<int:recommandation_id>/associer-risques', methods=['POST'])
@csrf.exempt
@login_required
def associer_risques_recommandation(audit_id, recommandation_id):
    """Associer plusieurs risques √† une recommandation"""
    recommandation = Recommandation.query.get_or_404(recommandation_id)
    risque_ids = request.form.getlist('risque_ids')
    
    try:
        for risque_id in risque_ids:
            if risque_id:  # V√©rifier que l'ID n'est pas vide
                # V√©rifier si l'association existe d√©j√†
                existing = Recommandation.query.filter_by(
                    id=recommandation_id, 
                    risque_id=risque_id
                ).first()
                
                if not existing:
                    # Cr√©er une nouvelle recommandation pour chaque risque
                    nouvelle_recommandation = Recommandation(
                        description=recommandation.description,
                        type_recommandation=recommandation.type_recommandation,
                        delai_mise_en_oeuvre=recommandation.delai_mise_en_oeuvre,
                        date_echeance=recommandation.date_echeance,
                        audit_id=audit_id,
                        constatation_id=recommandation.constatation_id,
                        risque_id=int(risque_id),
                        responsable_id=recommandation.responsable_id,
                        statut=recommandation.statut,
                        created_by=current_user.id
                    )
                    db.session.add(nouvelle_recommandation)
        
        db.session.commit()
        flash(f'{len(risque_ids)} risque(s) associ√©(s) √† la recommandation', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de l\'association: {str(e)}', 'error')
    
    return redirect(url_for('detail_audit', id=audit_id))




@app.route('/audit/<int:audit_id>/plan-action/<int:plan_id>/associer-risques', methods=['POST'])
@csrf.exempt
@login_required
def associer_risques_plan_action(audit_id, plan_id):
    """Associer plusieurs risques √† un plan d'action"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    risque_ids = request.form.getlist('risque_ids')
    
    try:
        for risque_id in risque_ids:
            if risque_id:  # V√©rifier que l'ID n'est pas vide
                # V√©rifier si l'association existe d√©j√†
                existing = PlanAction.query.filter_by(
                    id=plan_id, 
                    risque_id=risque_id
                ).first()
                
                if not existing:
                    # Cr√©er un nouveau plan d'action pour chaque risque
                    nouveau_plan = PlanAction(
                        nom=f"{plan_action.nom} - {risque_id}",
                        description=plan_action.description,
                        date_debut=plan_action.date_debut,
                        date_fin_prevue=plan_action.date_fin_prevue,
                        audit_id=audit_id,
                        recommandation_id=plan_action.recommandation_id,
                        risque_id=int(risque_id),
                        responsable_id=plan_action.responsable_id,
                        statut=plan_action.statut,
                        created_by=current_user.id
                    )
                    db.session.add(nouveau_plan)
        
        db.session.commit()
        flash(f'{len(risque_ids)} risque(s) associ√©(s) au plan d\'action', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de l\'association: {str(e)}', 'error')
    
    return redirect(url_for('detail_audit', id=audit_id))

@app.route('/recommandation/<int:recommandation_id>/maj-statut', methods=['POST'])
@csrf.exempt
@login_required
def maj_statut_recommandation(recommandation_id):
    """Mettre √† jour le statut d'une recommandation"""
    recommandation = Recommandation.query.get_or_404(recommandation_id)
    nouveau_statut = request.form.get('statut')
    taux_avancement = request.form.get('taux_avancement')
    
    if nouveau_statut in ['a_traiter', 'en_cours', 'termine', 'retarde']:
        recommandation.statut = nouveau_statut
        
        if taux_avancement:
            recommandation.taux_avancement = int(taux_avancement)
        
        recommandation.updated_at = datetime.utcnow()
        db.session.commit()
        flash('Statut de la recommandation mis √† jour', 'success')
    else:
        flash('Statut invalide', 'error')
    
    return redirect(url_for('detail_audit', id=recommandation.audit_id))

@app.route('/audit/<int:id>')
@login_required
def detail_audit(id):
    """D√©tail complet d'un audit"""
    from datetime import datetime
    
    audit = Audit.query.get_or_404(id)
    
    # R√©cup√©rer les donn√©es n√©cessaires
    constatations = Constatation.query.filter_by(
        audit_id=audit.id, 
        is_archived=False
    ).order_by(Constatation.created_at.desc()).all()
    
    users = User.query.all()
    processus_list = Processus.query.all()
    risques_list = Risque.query.filter_by(is_archived=False).all()
    cartographies_list = Cartographie.query.all()
    
    # R√©cup√©rer les recommandations de l'audit
    recommandations = Recommandation.query.filter_by(
        audit_id=audit.id
    ).order_by(Recommandation.created_at.desc()).all()
    
    # R√©cup√©rer les plans d'action de l'audit
    plans_action = PlanAction.query.filter_by(
        audit_id=audit.id
    ).order_by(PlanAction.created_at.desc()).all()
    
    # Calculer le total des preuves
    total_preuves = 0
    total_fichiers = 0
    for constatation in constatations:
        if hasattr(constatation, 'get_preuves_list'):
            preuves_list = constatation.get_preuves_list
            total_preuves += len(preuves_list) if preuves_list else 0
        
        if hasattr(constatation, 'get_fichiers_list'):
            fichiers_list = constatation.get_fichiers_list()
            total_fichiers += len(fichiers_list) if fichiers_list else 0
    
    # R√©cup√©rer TOUS les risques associ√©s (via recommandations, plans ET constatations)
    risques_associes = []
    risques_ids_vus = set()
    
    # 1. Risques via les constatations
    for constatation in audit.constatations:
        if constatation.risque_id and constatation.risque_id not in risques_ids_vus:
            risque = Risque.query.get(constatation.risque_id)
            if risque:
                # R√©cup√©rer la derni√®re √©valuation
                derniere_eval = None
                if risque.evaluations:
                    derniere_eval = sorted(risque.evaluations, key=lambda x: x.created_at, reverse=True)[0]
                
                risques_associes.append({
                    'risque': risque,
                    'types_association': ['constatation'],
                    'constatation_ref': constatation.reference,
                    'derniere_evaluation': derniere_eval
                })
                risques_ids_vus.add(constatation.risque_id)
    
    # 2. Risques via les recommandations
    for recommandation in audit.recommandations:
        if recommandation.risque_id and recommandation.risque_id not in risques_ids_vus:
            risque = Risque.query.get(recommandation.risque_id)
            if risque:
                # R√©cup√©rer la derni√®re √©valuation
                derniere_eval = None
                if risque.evaluations:
                    derniere_eval = sorted(risque.evaluations, key=lambda x: x.created_at, reverse=True)[0]
                
                # V√©rifier si d√©j√† dans la liste
                risque_existant = None
                for r in risques_associes:
                    if r['risque'].id == recommandation.risque_id:
                        risque_existant = r
                        break
                
                if risque_existant:
                    if 'recommandation' not in risque_existant['types_association']:
                        risque_existant['types_association'].append('recommandation')
                else:
                    risques_associes.append({
                        'risque': risque,
                        'types_association': ['recommandation'],
                        'derniere_evaluation': derniere_eval
                    })
                risques_ids_vus.add(recommandation.risque_id)
    
    # 3. Risques via les plans d'action
    for plan in audit.plans_action:
        if plan.risque_id and plan.risque_id not in risques_ids_vus:
            risque = Risque.query.get(plan.risque_id)
            if risque:
                # R√©cup√©rer la derni√®re √©valuation
                derniere_eval = None
                if risque.evaluations:
                    derniere_eval = sorted(risque.evaluations, key=lambda x: x.created_at, reverse=True)[0]
                
                # V√©rifier si d√©j√† dans la liste
                risque_existant = None
                for r in risques_associes:
                    if r['risque'].id == plan.risque_id:
                        risque_existant = r
                        break
                
                if risque_existant:
                    if 'plan_action' not in risque_existant['types_association']:
                        risque_existant['types_association'].append('plan_action')
                else:
                    risques_associes.append({
                        'risque': risque,
                        'types_association': ['plan_action'],
                        'derniere_evaluation': derniere_eval
                    })
                risques_ids_vus.add(plan.risque_id)
    
    # V√âRIFICATIONS DE PERMISSIONS SIMPLIFI√âES
    def user_in_ids_list(ids_string):
        """V√©rifie si l'utilisateur est dans une liste d'IDs"""
        if not ids_string:
            return False
        try:
            ids = [id_str.strip() for id_str in ids_string.split(',')]
            return str(current_user.id) in ids
        except:
            return False
    
    # Permissions basiques
    peut_modifier = (
        current_user.role == 'admin' or
        current_user.id == audit.created_by or
        current_user.id == audit.responsable_id or
        user_in_ids_list(audit.equipe_audit_ids)
    )
    
    peut_ajouter_constatation = (
        current_user.role == 'admin' or
        current_user.id == audit.created_by or
        current_user.id == audit.responsable_id or
        user_in_ids_list(audit.equipe_audit_ids)
    )
    
    peut_ajouter_recommandation = (
        current_user.role == 'admin' or
        current_user.id == audit.created_by or
        current_user.id == audit.responsable_id or
        user_in_ids_list(audit.equipe_audit_ids)
    )
    
    peut_generer_rapport = (
        current_user.role == 'admin' or
        current_user.id == audit.created_by or
        current_user.id == audit.responsable_id or
        user_in_ids_list(audit.equipe_audit_ids) or
        user_in_ids_list(audit.observateurs_ids)
    )
    
    # Obtenir la date et heure actuelles
    current_datetime = datetime.utcnow()
    
    # R√©cup√©rer les processus logigramme pour le formulaire
    all_processus_logigramme = ProcessusActivite.query.filter_by(
        is_archived=False,
        created_by=current_user.id
    ).order_by(ProcessusActivite.nom).all()
    
    # D√âFINIR LA FONCTION get_fichier_metadata
    def get_fichier_metadata(constatation_id, filename):
        """R√©cup√®re les m√©tadonn√©es d'un fichier"""
        try:
            from models import FichierMetadata
            metadata = FichierMetadata.query.filter_by(
                nom_fichier=filename,
                entite_type='constatation',
                entite_id=constatation_id
            ).first()
            
            if metadata:
                return {
                    'commentaire': metadata.commentaire or '',
                    'responsable': metadata.responsable.username if metadata.responsable else 'Non d√©fini',
                    'date_upload': metadata.created_at.strftime('%d/%m/%Y') if metadata.created_at else '',
                    'taille': f"{metadata.taille / 1024:.1f} KB" if metadata.taille else 'N/A'
                }
        except Exception as e:
            print(f"Erreur m√©tadonn√©es: {e}")
        
        return {
            'commentaire': '',
            'responsable': 'Non d√©fini',
            'date_upload': '',
            'taille': 'N/A'
        }
    
    # R√©cup√©rer les m√©tadonn√©es des fichiers pour afficher commentaires et responsables
    try:
        from models import FichierMetadata
        fichiers_metadata = FichierMetadata.query.filter(
            FichierMetadata.entite_type == 'constatation',
            FichierMetadata.entite_id.in_([c.id for c in constatations])
        ).all()
        
        # Cr√©er un dictionnaire pour acc√®s rapide
        metadata_dict = {}
        for meta in fichiers_metadata:
            if meta.entite_id not in metadata_dict:
                metadata_dict[meta.entite_id] = []
            metadata_dict[meta.entite_id].append({
                'nom_fichier': meta.nom_fichier,
                'commentaire': meta.commentaire,
                'responsable': meta.responsable.username if meta.responsable else None,
                'date_upload': meta.created_at
            })
    except:
        metadata_dict = {}
        print("Table FichierMetadata non disponible")
    
    return render_template(
        'audit/detail_audit.html', 
        audit=audit,
        constatations=constatations,
        recommandations=recommandations,
        plans_action=plans_action,
        users=users,
        processus_list=processus_list,
        all_processus_logigramme=all_processus_logigramme,  # Pour le formulaire
        risques_list=risques_list,
        cartographies_list=cartographies_list,
        total_preuves=total_preuves,
        total_fichiers=total_fichiers,
        peut_modifier=peut_modifier,
        peut_ajouter_constatation=peut_ajouter_constatation,
        peut_ajouter_recommandation=peut_ajouter_recommandation,
        peut_generer_rapport=peut_generer_rapport,
        datetime=datetime,  # Le module datetime pour les fonctions
        now=current_datetime,  # L'objet datetime actuel
        get_now=lambda: datetime.utcnow(),  # Fonction pour obtenir la date/heure actuelle si besoin
        risques_associes=risques_associes,  # Ajout√© pour afficher dans l'onglet risques
        fichiers_metadata=metadata_dict,  # Pour afficher commentaires et responsables
        get_fichier_metadata=get_fichier_metadata  # AJOUT√â : fonction pour r√©cup√©rer les m√©tadonn√©es
    )

# ============================================================================
# FONCTIONS UTILITAIRES POUR AUDIT
# ============================================================================

def historiser_action_audit(audit_id, action_type, user_id, donnees=None):
    """Historiser les actions sur les audits"""
    from models import HistoriqueModification
    
    try:
        historique = HistoriqueModification(
            entite_type='audit',
            entite_id=audit_id,
            utilisateur_id=user_id,
            modifications={
                'action': action_type,
                'donnees': donnees or {},
                'timestamp': datetime.utcnow().isoformat()
            },
            date_modification=datetime.utcnow()
        )
        
        db.session.add(historique)
        db.session.commit()
        print(f"üìù Action audit historis√©e: {action_type} pour audit {audit_id}")
        
    except Exception as e:
        print(f"‚ùå Erreur historisation action audit: {str(e)}")
        db.session.rollback()

def generer_rapport_audit_complet(audit_id):
    """G√©n√©rer un rapport d'audit complet avec toutes les s√©curit√©s"""
    from datetime import datetime
    
    audit = Audit.query.get_or_404(audit_id)
    
    # Fonction pour r√©cup√©rer un attribut en toute s√©curit√©
    def safe_getattr(obj, attr, default=None):
        try:
            return getattr(obj, attr, default)
        except (AttributeError, TypeError):
            return default
    
    # Fonction pour formater une date
    def format_date(date_obj):
        if date_obj and hasattr(date_obj, 'isoformat'):
            return date_obj.isoformat()
        return None
    
    # R√©cup√©rer les donn√©es en toute s√©curit√©
    date_debut_prevue = safe_getattr(audit, 'date_debut_prevue')
    date_fin_prevue = safe_getattr(audit, 'date_fin_prevue')
    date_debut_reelle = safe_getattr(audit, 'date_debut_reelle')
    date_fin_reelle = safe_getattr(audit, 'date_fin_reelle')
    
    # R√©cup√©rer couleur_progression (propri√©t√© ou m√©thode)
    try:
        couleur_progression = audit.couleur_progression
    except AttributeError:
        try:
            couleur_progression = audit.get_couleur_progression()
        except (AttributeError, TypeError):
            couleur_progression = 'secondary'
    
    rapport = {
        'audit': {
            'reference': audit.reference,
            'titre': audit.titre,
            'type': audit.type_audit,
            'statut': audit.statut,
            'sous_statut': audit.sous_statut,
            'dates': {
                'debut_prevue': format_date(date_debut_prevue),
                'fin_prevue': format_date(date_fin_prevue),
                'debut_reelle': format_date(date_debut_reelle),
                'fin_reelle': format_date(date_fin_reelle)
            },
            'score_global': safe_getattr(audit, 'score_global', 0),
            'couleur_progression': couleur_progression
        },
        'constatations': [],
        'recommandations': [],
        'plans_action': [],
        'statistiques': {
            'total_constatations': len(audit.constatations),
            'constatations_par_type': {},
            'recommandations_par_statut': {},
            'plans_action_actifs': len([p for p in audit.plans_action if p.statut != 'termine']),
            'progression_globale': safe_getattr(audit, 'progression_globale', 0),
            'taux_realisation_recommandations': safe_getattr(audit, 'taux_realisation_recommandations', 0)
        }
    }
    
    # Compiler les constatations
    for constat in audit.constatations:
        constat_data = {
            'reference': constat.reference,
            'description': constat.description,
            'type': constat.type_constatation,
            'gravite': safe_getattr(constat, 'gravite'),
            'criticite': safe_getattr(constat, 'criticite'),
            'processus_concerne': safe_getattr(constat, 'processus_concerne'),
            'statut': safe_getattr(constat, 'statut')
        }
        rapport['constatations'].append(constat_data)
        
        # Statistiques par type
        type_constatation = constat.type_constatation or 'non_defini'
        if type_constatation not in rapport['statistiques']['constatations_par_type']:
            rapport['statistiques']['constatations_par_type'][type_constatation] = 0
        rapport['statistiques']['constatations_par_type'][type_constatation] += 1
    
    # Compiler les recommandations
    for recommandation in audit.recommandations:
        reco_data = {
            'description': recommandation.description,
            'type': recommandation.type_recommandation,
            'categorie': safe_getattr(recommandation, 'categorie'),
            'statut': safe_getattr(recommandation, 'statut'),
            'score_priorite': safe_getattr(recommandation, 'score_priorite', 0),
            'taux_avancement': safe_getattr(recommandation, 'taux_avancement', 0)
        }
        
        # Date d'√©ch√©ance
        date_echeance = safe_getattr(recommandation, 'date_echeance')
        if date_echeance and hasattr(date_echeance, 'strftime'):
            reco_data['date_echeance'] = date_echeance.strftime('%d/%m/%Y')
        else:
            reco_data['date_echeance'] = None
            
        rapport['recommandations'].append(reco_data)
        
        # Statistiques par statut
        statut = safe_getattr(recommandation, 'statut', 'non_defini')
        if statut not in rapport['statistiques']['recommandations_par_statut']:
            rapport['statistiques']['recommandations_par_statut'][statut] = 0
        rapport['statistiques']['recommandations_par_statut'][statut] += 1
    
    # Compiler les plans d'action
    for plan in audit.plans_action:
        plan_data = {
            'nom': plan.nom,
            'description': plan.description,
            'statut': safe_getattr(plan, 'statut'),
            'pourcentage_realisation': safe_getattr(plan, 'pourcentage_realisation', 0),
            'progression_reelle': safe_getattr(plan, 'progression_reelle', 0),
            'efficacite': safe_getattr(plan, 'efficacite'),
            'score_efficacite': safe_getattr(plan, 'score_efficacite', 0)
        }
        
        # Dates
        plan_data['dates'] = {}
        for date_field in ['date_debut', 'date_fin_prevue', 'date_fin_reelle']:
            date_value = safe_getattr(plan, date_field)
            if date_value and hasattr(date_value, 'strftime'):
                plan_data['dates'][date_field] = date_value.strftime('%d/%m/%Y')
            else:
                plan_data['dates'][date_field] = None
                
        rapport['plans_action'].append(plan_data)
    
    return rapport

@app.route('/sous-action/<int:sous_action_id>/modifier-statut', methods=['POST'])
@csrf.exempt
@login_required
def modifier_statut_sous_action(sous_action_id):
    """Modifier le statut d'une sous-action"""
    sous_action = SousAction.query.get_or_404(sous_action_id)
    nouveau_statut = request.form.get('statut')
    
    if nouveau_statut in ['a_faire', 'en_cours', 'termine']:
        ancien_statut = sous_action.statut
        sous_action.statut = nouveau_statut
        sous_action.updated_at = datetime.utcnow()
        
        # Si termin√©, mettre √† jour la date de fin et le pourcentage
        if nouveau_statut == 'termine':
            sous_action.pourcentage_realisation = 100
            sous_action.date_fin_reelle = datetime.utcnow().date()
        
        db.session.commit()
        flash(f'Statut de la sous-action modifi√©: {ancien_statut} ‚Üí {nouveau_statut}', 'success')
    else:
        flash('Statut invalide', 'error')
    
    return redirect(url_for('detail_plan_action', plan_id=sous_action.plan_action_id))
from datetime import datetime
from flask import render_template, request, flash, redirect, url_for
from flask_login import login_required, current_user

@app.route('/audit/<int:audit_id>/gerer-equipe', methods=['POST'])
@login_required
def gerer_equipe_audit(audit_id):
    """G√©rer l'√©quipe d'audit - Version corrig√©e avec multi-tenant"""
    from models import Audit, db  # ‚úÖ Correction: models au lieu de app.models
    from datetime import datetime
    
    # V√©rifier les permissions
    if not current_user.is_authenticated:
        flash('Vous devez √™tre connect√©', 'danger')
        return redirect(url_for('login'))
    
    # V√âRIFICATION FORMULE : v√©rifier si le client a acc√®s au module "audit"
    if current_user.client and current_user.client.formule:
        formule = current_user.client.formule
        
        # V√©rifier si la formule donne acc√®s au module "audit"
        if not formule.can_access_module('audit_interne'):
            # Afficher une page d'upgrade
            try:
                # R√©cup√©rer toutes les formules actives
                all_formules = FormuleAbonnement.query.filter(
                    FormuleAbonnement.is_active == True
                ).all()
                
                # Filtrer celles qui ont le module audit
                upgrade_suggestions = []
                for f in all_formules:
                    if f.modules.get('audit', False):
                        upgrade_suggestions.append(f)
                
                # Trier par prix
                upgrade_suggestions.sort(key=lambda x: x.prix_mensuel or 0)
                
                return render_template('errors/formule_restricted.html', 
                                     module_name='Gestion des √âquipes d\'Audit',
                                     current_formule=formule,
                                     upgrade_suggestions=upgrade_suggestions[:3])
                
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur recherche formules upgrade: {e}")
                flash('Ce module n\'est pas inclus dans votre formule actuelle', 'error')
                return redirect(url_for('dashboard'))
    
    # V√©rifier la permission de g√©rer les audits
    if not current_user.has_permission('can_manage_audit'):
        flash('Acc√®s refus√© : permission de g√©rer les audits requise', 'error')
        return redirect(url_for('dashboard'))
    
    # CORRECTION MULTI-TENANT : Utiliser get_client_filter
    audit = get_client_filter(Audit).filter_by(id=audit_id).first_or_404()
    
    # V√©rification suppl√©mentaire d'acc√®s
    if not check_client_access(audit):
        flash('Acc√®s non autoris√© √† cet audit', 'danger')
        return redirect(url_for('liste_audits'))
    
    # V√©rifier que l'utilisateur a le droit de modifier cet audit
    if current_user.role not in ['admin', 'manager', 'auditeur'] and current_user.id != audit.created_by:
        flash('Vous n\'avez pas les permissions n√©cessaires', 'danger')
        return redirect(url_for('detail_audit', id=audit_id))
    
    # 1. G√©rer les utilisateurs existants
    utilisateurs_existants = request.form.getlist('utilisateurs_existants[]')
    
    # Convertir en cha√Æne CSV
    if utilisateurs_existants:
        # V√©rifier que les IDs sont valides ET appartiennent au m√™me client
        ids_valides = []
        for user_id in utilisateurs_existants:
            try:
                user_id_int = int(user_id)
                
                # CORRECTION MULTI-TENANT : V√©rifier que l'utilisateur appartient au m√™me client
                from models import User
                user = get_client_filter(User).filter_by(id=user_id_int).first()
                if user and check_client_access(user):
                    ids_valides.append(str(user_id_int))
                else:
                    print(f"‚ö†Ô∏è Tentative d'ajout d'un utilisateur d'un autre client: {user_id}")
                    
            except ValueError:
                continue
        
        audit.equipe_audit_ids = ','.join(ids_valides) if ids_valides else ''
    else:
        audit.equipe_audit_ids = ''
    
    # 2. G√©rer les membres externes
    membres_externes = []
    i = 0
    
    # Parcourir tous les membres externes du formulaire
    while True:
        nom_key = f'membres_externes[{i}][nom]'
        if nom_key not in request.form:
            break
        
        prenom = request.form.get(f'membres_externes[{i}][prenom]', '').strip()
        nom = request.form.get(nom_key, '').strip()
        email = request.form.get(f'membres_externes[{i}][email]', '').strip()
        fonction = request.form.get(f'membres_externes[{i}][fonction]', '').strip()
        organisation = request.form.get(f'membres_externes[{i}][organisation]', '').strip()
        
        # Validation
        if nom and prenom and email and '@' in email:
            membre = {
                'nom': nom,
                'prenom': prenom,
                'email': email,
                'fonction': fonction,
                'organisation': organisation,
                # CORRECTION MULTI-TENANT : Ajouter l'ID du client pour tra√ßabilit√©
                'client_id': current_user.client_id
            }
            membres_externes.append(membre)
        
        i += 1
    
    # Mettre √† jour l'audit
    audit.membres_externes = membres_externes
    audit.updated_at = datetime.utcnow()
    
    # CORRECTION MULTI-TENANT : Ajouter un journal de l'action
    try:
        from models import JournalActivite
        
        # Cr√©er un journal de l'action
        journal = JournalActivite(
            user_id=current_user.id,
            action='update',
            entite_type='audit_equipe',
            entite_id=audit.id,
            details=f"Mise √† jour de l'√©quipe d'audit: {len(ids_valides)} membres internes, {len(membres_externes)} membres externes",
            client_id=current_user.client_id
        )
        db.session.add(journal)
        
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur cr√©ation journal: {e}")
    
    try:
        db.session.commit()
        flash('√âquipe d\'audit mise √† jour avec succ√®s', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la mise √† jour: {str(e)}', 'danger')
    
    return redirect(url_for('detail_audit', id=audit_id))

@app.route('/audit/<int:audit_id>/supprimer-membre-externe', methods=['POST'])
@login_required
def supprimer_membre_externe_audit(audit_id):
    """Supprimer un membre externe"""
    from models import Audit, db  # ‚úÖ Correction: models au lieu de app.models
    
    audit = Audit.query.get_or_404(audit_id)
    
    # V√©rifier les permissions
    if current_user.role not in ['admin', 'manager', 'auditeur'] and current_user.id != audit.created_by:
        flash('Vous n\'avez pas les permissions n√©cessaires', 'danger')
        return redirect(url_for('detail_audit', id=audit_id))
    
    membre_index = request.form.get('membre_index', type=int)
    
    if membre_index is None:
        flash('Index du membre manquant', 'danger')
        return redirect(url_for('detail_audit', id=audit_id))
    
    if not audit.membres_externes:
        flash('Aucun membre externe √† supprimer', 'warning')
        return redirect(url_for('detail_audit', id=audit_id))
    
    if 0 <= membre_index < len(audit.membres_externes):
        membre_supprime = audit.membres_externes.pop(membre_index)
        db.session.commit()
        flash(f'Membre {membre_supprime.get("nom", "")} {membre_supprime.get("prenom", "")} supprim√©', 'success')
    else:
        flash('Index du membre invalide', 'danger')
    
    return redirect(url_for('detail_audit', id=audit_id))

@app.route('/audit/<int:audit_id>/supprimer-utilisateur-equipe', methods=['POST'])
@login_required
def supprimer_utilisateur_equipe(audit_id):
    """Supprimer un utilisateur de l'√©quipe"""
    from models import Audit, User, db  # ‚úÖ Correction: models au lieu de app.models
    
    audit = Audit.query.get_or_404(audit_id)
    
    # V√©rifier les permissions
    if current_user.role not in ['admin', 'manager', 'auditeur'] and current_user.id != audit.created_by:
        flash('Vous n\'avez pas les permissions n√©cessaires', 'danger')
        return redirect(url_for('detail_audit', id=audit_id))
    
    user_id = request.form.get('user_id', type=int)
    
    if user_id is None:
        flash('ID utilisateur manquant', 'danger')
        return redirect(url_for('detail_audit', id=audit_id))
    
    if not audit.equipe_audit_ids:
        flash('√âquipe vide', 'warning')
        return redirect(url_for('detail_audit', id=audit_id))
    
    try:
        # Convertir la cha√Æne en liste
        ids = [id.strip() for id in audit.equipe_audit_ids.split(',') if id.strip()]
        user_id_str = str(user_id)
        
        if user_id_str in ids:
            ids.remove(user_id_str)
            
            # Mettre √† jour
            if ids:
                audit.equipe_audit_ids = ','.join(ids)
            else:
                audit.equipe_audit_ids = ''
            
            db.session.commit()
            
            # R√©cup√©rer le nom de l'utilisateur
            user = User.query.get(user_id)
            if user:
                nom = f"{user.prenom or ''} {user.nom or user.username}".strip()
                flash(f'Utilisateur {nom} supprim√© de l\'√©quipe', 'success')
            else:
                flash(f'Utilisateur ID {user_id} supprim√© de l\'√©quipe', 'success')
        else:
            flash('Utilisateur non trouv√© dans l\'√©quipe', 'warning')
            
    except Exception as e:
        flash(f'Erreur lors de la suppression: {str(e)}', 'danger')
    
    return redirect(url_for('detail_audit', id=audit_id))

@app.route('/audit/<int:audit_id>/plan-action/nouveau', methods=['POST'])
@csrf.exempt
@login_required
def nouvel_plan_action(audit_id):
    """Cr√©er un nouveau plan d'action pour un audit"""
    audit = Audit.query.get_or_404(audit_id)
    
    try:
        # R√©cup√©rer les donn√©es du formulaire
        nom = request.form.get('nom', '').strip()
        description = request.form.get('description', '').strip()
        date_debut = request.form.get('date_debut')
        date_fin_prevue = request.form.get('date_fin_prevue')
        responsable_id = request.form.get('responsable_id')
        
        # Validation
        if not nom:
            flash('Le nom du plan est requis', 'error')
            return redirect(url_for('detail_audit', id=audit_id))
        
        # G√©n√©rer une r√©f√©rence
        dernier_plan = PlanAction.query.filter_by(audit_id=audit_id)\
                                       .order_by(PlanAction.id.desc())\
                                       .first()
        reference = f"PA-{audit.reference}-{(dernier_plan.id + 1) if dernier_plan else 1:03d}"
        
        # Cr√©er le plan d'action
        plan_action = PlanAction(
            reference=reference,
            nom=nom,
            description=description,
            audit_id=audit_id,
            date_debut=datetime.strptime(date_debut, '%Y-%m-%d').date() if date_debut else None,
            date_fin_prevue=datetime.strptime(date_fin_prevue, '%Y-%m-%d').date() if date_fin_prevue else None,
            responsable_id=int(responsable_id) if responsable_id else None,
            statut='en_attente',
            created_by=current_user.id
        )
        
        db.session.add(plan_action)
        db.session.commit()
        
        flash('Plan d\'action cr√©√© avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la cr√©ation: {str(e)}', 'error')
    
    return redirect(url_for('detail_audit', id=audit_id))

@app.route('/sous-action/<int:sous_action_id>/supprimer', methods=['POST'])
@csrf.exempt
@login_required
def supprimer_sous_action(sous_action_id):
    """Supprimer une sous-action"""
    sous_action = SousAction.query.get_or_404(sous_action_id)
    plan_id = sous_action.plan_action_id
    
    try:
        db.session.delete(sous_action)
        db.session.commit()
        flash('Sous-action supprim√©e avec succ√®s', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la suppression: {str(e)}', 'error')
    
    return redirect(url_for('detail_plan_action', plan_id=plan_id))

from datetime import datetime  # Ajoutez ceci en haut du fichier app.py

@app.route('/audit/<int:audit_id>/rapport-complet')
@login_required
def rapport_audit_complet(audit_id):
    """G√©n√©rer un rapport complet de l'audit avec gestion des fichiers - VERSION CORRIG√âE"""
    
    # R√©cup√©rer l'audit avec v√©rification d'acc√®s client
    audit = get_client_object_or_404(Audit, audit_id)
    
    # V√©rifier les permissions
    peut_voir = (
        current_user.role == 'super_admin' or
        current_user.id == audit.created_by or
        current_user.id == audit.responsable_id or
        (audit.equipe_audit_ids and str(current_user.id) in audit.equipe_audit_ids.split(',')) or
        (audit.observateurs_ids and str(current_user.id) in audit.observateurs_ids.split(','))
    )
    
    if not peut_voir:
        flash('Vous n\'avez pas les permissions pour voir ce rapport', 'error')
        return redirect(url_for('liste_audits'))
    
    print(f"\nüìä G√âN√âRATION RAPPORT AUDIT {audit.reference}")
    
    # R√©cup√©rer toutes les donn√©es de l'audit
    constatations = get_client_filter(Constatation)\
        .filter_by(audit_id=audit.id, is_archived=False)\
        .order_by(Constatation.created_at.desc()).all()
    
    recommandations = get_client_filter(Recommandation)\
        .filter_by(audit_id=audit.id)\
        .order_by(Recommandation.created_at.desc()).all()
    
    plans_action = get_client_filter(PlanAction)\
        .filter_by(audit_id=audit.id)\
        .order_by(PlanAction.created_at.desc()).all()
    
    # R√©cup√©rer les utilisateurs pour les relations
    createur_audit = User.query.get(audit.created_by) if audit.created_by else None
    
    # R√©cup√©rer les fichiers joints √† l'audit
    fichiers_rapport = get_client_filter(FichierRapport)\
        .filter_by(audit_id=audit_id)\
        .order_by(FichierRapport.created_at.desc()).all()
    
    # Calculer les statistiques des fichiers
    stats_fichiers = {
        'total': len(fichiers_rapport),
        'total_taille': sum(f.taille or 0 for f in fichiers_rapport),
        'par_type': {}
    }
    
    for fichier in fichiers_rapport:
        type_key = fichier.type_fichier or 'autre'
        if type_key not in stats_fichiers['par_type']:
            stats_fichiers['par_type'][type_key] = {
                'count': 0,
                'total_taille': 0
            }
        stats_fichiers['par_type'][type_key]['count'] += 1
        stats_fichiers['par_type'][type_key]['total_taille'] += fichier.taille or 0
    
    # Formater les tailles
    def format_taille(taille_bytes):
        if not taille_bytes:
            return "0 B"
        for unit in ['B', 'KB', 'MB', 'GB']:
            if taille_bytes < 1024.0:
                return f"{taille_bytes:.1f} {unit}"
            taille_bytes /= 1024.0
        return f"{taille_bytes:.1f} GB"
    
    stats_fichiers['total_taille_formatee'] = format_taille(stats_fichiers['total_taille'])
    for type_key in stats_fichiers['par_type']:
        stats_fichiers['par_type'][type_key]['total_taille_formatee'] = format_taille(
            stats_fichiers['par_type'][type_key]['total_taille']
        )
    
    # V√©rifier les permissions pour les actions
    peut_modifier = (
        current_user.role == 'super_admin' or
        current_user.id == audit.created_by or
        current_user.id == audit.responsable_id or
        (audit.equipe_audit_ids and str(current_user.id) in audit.equipe_audit_ids.split(','))
    )
    
    peut_uploader = peut_modifier or (
        audit.observateurs_ids and str(current_user.id) in audit.observateurs_ids.split(',')
    )
    
    # R√©cup√©rer les recommandations globales dynamiques
    recommandations_globales = []
    try:
        from models import RecommandationGlobale
        recommandations_globales = RecommandationGlobale.query.filter_by(est_actif=True).all()
        
        if recommandations_globales and audit.type_audit:
            recommandations_filtrees = [r for r in recommandations_globales 
                                       if r.type_audit is None or r.type_audit == audit.type_audit]
            if recommandations_filtrees:
                recommandations_globales = recommandations_filtrees
        
        recommandations_globales = sorted(recommandations_globales, 
                                         key=lambda x: (x.priorite or 1), 
                                         reverse=True)
        
        recommandations_globales = [r.texte for r in recommandations_globales[:10]]
    except ImportError:
        recommandations_globales = [
            "Mettre en place un suivi r√©gulier des plans d'action avec des points de contr√¥le mensuels",
            "√âtablir des indicateurs de performance pour mesurer l'efficacit√© des actions correctives",
            "Planifier des audits de suivi dans les 6 mois pour v√©rifier la p√©rennit√© des corrections",
            "Renforcer la formation des √©quipes sur les proc√©dures identifi√©es comme critiques",
            "D√©velopper un syst√®me d'alerte pour les recommandations approchant leur √©ch√©ance"
        ]
    
    # R√©cup√©rer les m√©tadonn√©es des fichiers pour les constatations
    metadata_dict = {}
    try:
        from models import FichierMetadata
        fichiers_metadata = FichierMetadata.query.filter(
            FichierMetadata.entite_type == 'constatation',
            FichierMetadata.entite_id.in_([c.id for c in constatations])
        ).all()
        
        for meta in fichiers_metadata:
            if meta.entite_id not in metadata_dict:
                metadata_dict[meta.entite_id] = []
            metadata_dict[meta.entite_id].append({
                'nom_fichier': meta.nom_fichier,
                'commentaire': meta.commentaire,
                'responsable': meta.responsable.username if meta.responsable else None,
                'date_upload': meta.created_at
            })
    except:
        metadata_dict = {}
        print("Table FichierMetadata non disponible")
    
    # CORRECTION : D√©finir processus_audite_display de mani√®re s√©curis√©e
    processus_audite_display = None
    try:
        if hasattr(audit, 'processus_audite_display'):
            # Si c'est une propri√©t√© (pas une m√©thode)
            processus_audite_display = audit.processus_audite_display
        elif hasattr(audit, 'get_processus_audite_display'):
            # Si c'est une m√©thode
            processus_audite_display = audit.get_processus_audite_display()
        else:
            # Fallback
            if audit.processus:
                processus_audite_display = audit.processus.nom
            elif hasattr(audit, 'processus_concerne') and audit.processus_concerne:
                processus_audite_display = audit.processus_concerne
            else:
                processus_audite_display = "Non sp√©cifi√©"
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur r√©cup√©ration processus_audite_display: {e}")
        processus_audite_display = "Non sp√©cifi√©"
    
    # Pr√©parer les donn√©es pour le rapport
    rapport_data = {
        'audit': {
            'reference': audit.reference,
            'titre': audit.titre,
            'type_audit': audit.type_audit,
            'statut': audit.statut,
            'description': audit.description,
            'objectifs': audit.objectifs,
            'portee': audit.portee,
            'criteres': audit.criteres,
            'date_debut_prevue': audit.date_debut_prevue,
            'date_fin_prevue': audit.date_fin_prevue,
            'date_debut_reelle': audit.date_debut_reelle,
            'date_fin_reelle': audit.date_fin_reelle,
            'responsable': audit.responsable.username if audit.responsable else None,
            'responsable_obj': audit.responsable,
            'processus': audit.processus.nom if audit.processus else None,
            # CORRECTION ICI : Utiliser la variable d√©j√† d√©finie
            'processus_audite_display': processus_audite_display,
            'created_at': audit.created_at,
            'created_by': createur_audit.username if createur_audit else None,
            'createur': createur_audit,
            # CORRECTION : Utiliser getattr sans parenth√®ses inutiles
            'score_global': getattr(audit, 'score_global', 0),
            'progression_globale': getattr(audit, 'progression_globale', 0),
            'taux_realisation_recommandations': getattr(audit, 'taux_realisation_recommandations', 0),
            'taux_realisation_plans': getattr(audit, 'taux_realisation_plans', 0),
            'couleur_progression': getattr(audit, 'couleur_progression', 'secondary')
        },
        'constatations': [],
        'recommandations': [],
        'plans_action': [],
        'fichiers_rapport': fichiers_rapport,
        'stats_fichiers': stats_fichiers,
        'recommandations_globales': recommandations_globales,
        'statistiques': {
            'total_constatations': len(constatations),
            'constatations_par_type': {},
            'constatations_par_gravite': {},
            'constatations_par_statut': {},
            'total_recommandations': len(recommandations),
            'recommandations_par_type': {},
            'recommandations_par_statut': {},
            'total_plans_action': len(plans_action),
            'plans_action_par_statut': {},
            'plans_action_actifs': len([p for p in plans_action if p.statut in ['en_cours', 'a_demarrer', 'planifie']]),
            'taux_avancement_moyen': 0,
            'progression_globale': getattr(audit, 'progression_globale', 0),
            'score_global': getattr(audit, 'score_global', 0),
            'taux_realisation_recommandations': getattr(audit, 'taux_realisation_recommandations', 0),
            'taux_realisation_plans': getattr(audit, 'taux_realisation_plans', 0)
        }
    }
    
    # Traiter les constatations
    for constatation in constatations:
        createur_constatation = User.query.get(constatation.created_by) if constatation.created_by else None
        
        constatation_data = {
            'id': constatation.id,
            'reference': constatation.reference,
            'description': constatation.description,
            'type': constatation.type_constatation,
            'type_display': constatation.type_constatation.replace('_', ' ').title() if constatation.type_constatation else '',
            'gravite': constatation.gravite,
            'gravite_display': constatation.gravite.title() if constatation.gravite else '',
            'statut': constatation.statut,
            'statut_display': constatation.statut.replace('_', ' ').title() if constatation.statut else '',
            'processus_concerne': getattr(constatation, 'processus_concerne', None),
            'cause_racine': getattr(constatation, 'cause_racine', None),
            'conclusion': getattr(constatation, 'conclusion', ''),
            'commentaires': getattr(constatation, 'commentaires', ''),
            'recommandations_immediates': getattr(constatation, 'recommandations_immediates', ''),
            'documents_justificatifs': getattr(constatation, 'documents_justificatifs', ''),
            'created_at': constatation.created_at,
            'updated_at': constatation.updated_at,
            'createur': createur_constatation.username if createur_constatation else None,
            'createur_obj': createur_constatation,
            'risque': None,
            'preuves': [],
            'recommandations_liees': []
        }
        
        # Ajouter le risque associ√©
        if constatation.risque_id:
            risque = Risque.query.get(constatation.risque_id)
            if risque and check_client_access(risque):
                derniere_eval = risque.evaluations[-1] if risque.evaluations else None
                constatation_data['risque'] = {
                    'reference': risque.reference,
                    'intitule': risque.intitule,
                    'categorie': risque.categorie,
                    'niveau': derniere_eval.niveau_risque if derniere_eval else 'Non √©valu√©',
                    'score': derniere_eval.score_risque if derniere_eval else 0
                }
        
        # Ajouter les preuves
        preuves_list = []
        try:
            if hasattr(constatation, 'get_preuves_list'):
                preuves_list = constatation.get_preuves_list
            elif hasattr(constatation, 'preuves') and constatation.preuves:
                # Fallback si les preuves sont stock√©es en cha√Æne s√©par√©e par virgules
                preuves_list = [p.strip() for p in constatation.preuves.split(',') if p.strip()]
        except:
            preuves_list = []
        
        for preuve in preuves_list:
            try:
                metadata_info = {
                    'nom': preuve,
                    'commentaire': '',
                    'responsable': '',
                    'date_upload': '',
                    'taille': 'N/A'
                }
                
                if constatation.id in metadata_dict:
                    for meta in metadata_dict[constatation.id]:
                        if meta['nom_fichier'] == preuve:
                            metadata_info['commentaire'] = meta['commentaire'] or ''
                            metadata_info['responsable'] = meta['responsable'] or 'Non d√©fini'
                            metadata_info['date_upload'] = meta['date_upload']
                            metadata_info['date_upload_str'] = meta['date_upload'].strftime('%d/%m/%Y') if meta['date_upload'] else ''
                            break
                
                constatation_data['preuves'].append(metadata_info)
            except:
                constatation_data['preuves'].append({
                    'nom': preuve,
                    'commentaire': 'Fichier joint',
                    'responsable': 'Non sp√©cifi√©',
                    'date_upload': None,
                    'date_upload_str': 'Date inconnue',
                    'taille': 'N/A'
                })
        
        # Ajouter les recommandations li√©es
        try:
            for reco in getattr(constatation, 'recommandations', []):
                responsable_reco = User.query.get(reco.responsable_id) if reco.responsable_id else None
                constatation_data['recommandations_liees'].append({
                    'id': reco.id,
                    'reference': reco.reference,
                    'description': reco.description[:100] + '...' if len(reco.description) > 100 else reco.description,
                    'statut': reco.statut,
                    'statut_display': reco.statut.replace('_', ' ').title() if reco.statut else '',
                    'responsable': responsable_reco.username if responsable_reco else None
                })
        except:
            pass
        
        rapport_data['constatations'].append(constatation_data)
        
        # Mettre √† jour les statistiques
        if constatation.type_constatation:
            rapport_data['statistiques']['constatations_par_type'][constatation.type_constatation] = \
                rapport_data['statistiques']['constatations_par_type'].get(constatation.type_constatation, 0) + 1
        if constatation.gravite:
            rapport_data['statistiques']['constatations_par_gravite'][constatation.gravite] = \
                rapport_data['statistiques']['constatations_par_gravite'].get(constatation.gravite, 0) + 1
        if constatation.statut:
            rapport_data['statistiques']['constatations_par_statut'][constatation.statut] = \
                rapport_data['statistiques']['constatations_par_statut'].get(constatation.statut, 0) + 1
    
    # Traiter les recommandations
    for recommandation in recommandations:
        createur_recommandation = User.query.get(recommandation.created_by) if recommandation.created_by else None
        
        # V√©rifier si la recommandation est en retard
        est_en_retard = False
        if recommandation.date_echeance and recommandation.statut != 'termine':
            est_en_retard = datetime.utcnow().date() > recommandation.date_echeance
        
        recommandation_data = {
            'id': recommandation.id,
            'reference': recommandation.reference,
            'description': recommandation.description,
            'type': recommandation.type_recommandation,
            'type_display': recommandation.type_recommandation.replace('_', ' ').title() if recommandation.type_recommandation else '',
            'categorie': recommandation.categorie,
            'categorie_display': recommandation.categorie.replace('_', ' ').title() if recommandation.categorie else '',
            'statut': recommandation.statut,
            'statut_display': recommandation.statut.replace('_', ' ').title() if recommandation.statut else '',
            'delai_mise_en_oeuvre': recommandation.delai_mise_en_oeuvre,
            'delai_display': recommandation.delai_mise_en_oeuvre.replace('_', ' ').title() if recommandation.delai_mise_en_oeuvre else '',
            'date_echeance': recommandation.date_echeance,
            'date_echeance_str': recommandation.date_echeance.strftime('%d/%m/%Y') if recommandation.date_echeance else '',
            'urgence': recommandation.urgence,
            'impact_operationnel': recommandation.impact_operationnel,
            'score_priorite': recommandation.score_priorite,
            'taux_avancement': recommandation.taux_avancement or 0,
            'est_en_retard': est_en_retard,
            'created_at': recommandation.created_at,
            'responsable': recommandation.responsable.username if recommandation.responsable else None,
            'responsable_obj': recommandation.responsable,
            'createur': createur_recommandation.username if createur_recommandation else None,
            'createur_obj': createur_recommandation,
            'constatation': None,
            'risque': None,
            'plan_action': None
        }
        
        # Ajouter la constatation li√©e
        if recommandation.constatation_id:
            constatation = Constatation.query.get(recommandation.constatation_id)
            if constatation:
                recommandation_data['constatation'] = {
                    'reference': constatation.reference,
                    'description': constatation.description[:100] + '...' if len(constatation.description) > 100 else constatation.description,
                    'id': constatation.id
                }
        
        # Ajouter le risque associ√©
        if recommandation.risque_id:
            risque = Risque.query.get(recommandation.risque_id)
            if risque and check_client_access(risque):
                derniere_eval = risque.evaluations[-1] if risque.evaluations else None
                recommandation_data['risque'] = {
                    'reference': risque.reference,
                    'intitule': risque.intitule,
                    'categorie': risque.categorie,
                    'niveau': derniere_eval.niveau_risque if derniere_eval else 'Non √©valu√©',
                    'score': derniere_eval.score_risque if derniere_eval else 0,
                    'id': risque.id
                }
        
        # Ajouter le plan d'action li√©
        if getattr(recommandation, 'plan_action', None):
            responsable_plan = User.query.get(recommandation.plan_action.responsable_id) if recommandation.plan_action.responsable_id else None
            recommandation_data['plan_action'] = {
                'nom': recommandation.plan_action.nom,
                'statut': recommandation.plan_action.statut,
                'statut_display': recommandation.plan_action.statut.replace('_', ' ').title() if recommandation.plan_action.statut else '',
                'pourcentage_realisation': recommandation.plan_action.pourcentage_realisation,
                'responsable': responsable_plan.username if responsable_plan else None,
                'id': recommandation.plan_action.id
            }
        
        rapport_data['recommandations'].append(recommandation_data)
        
        # Mettre √† jour les statistiques
        if recommandation.type_recommandation:
            rapport_data['statistiques']['recommandations_par_type'][recommandation.type_recommandation] = \
                rapport_data['statistiques']['recommandations_par_type'].get(recommandation.type_recommandation, 0) + 1
        if recommandation.statut:
            rapport_data['statistiques']['recommandations_par_statut'][recommandation.statut] = \
                rapport_data['statistiques']['recommandations_par_statut'].get(recommandation.statut, 0) + 1
    
    # Traiter les plans d'action
    taux_avancement_total = 0
    plans_traites = 0
    
    for plan in plans_action:
        createur_plan = User.query.get(plan.created_by) if plan.created_by else None
        
        plan_data = {
            'id': plan.id,
            'reference': plan.reference,
            'nom': plan.nom,
            'description': plan.description,
            'statut': plan.statut,
            'statut_display': plan.statut.replace('_', ' ').title() if plan.statut else '',
            'date_debut': plan.date_debut,
            'date_debut_str': plan.date_debut.strftime('%d/%m/%Y') if plan.date_debut else '',
            'date_fin_prevue': plan.date_fin_prevue,
            'date_fin_prevue_str': plan.date_fin_prevue.strftime('%d/%m/%Y') if plan.date_fin_prevue else '',
            'date_fin_reelle': plan.date_fin_reelle,
            'date_fin_reelle_str': plan.date_fin_reelle.strftime('%d/%m/%Y') if plan.date_fin_reelle else '',
            'pourcentage_realisation': plan.pourcentage_realisation or 0,
            'responsable': plan.responsable.username if plan.responsable else None,
            'responsable_obj': plan.responsable,
            'created_at': plan.created_at,
            'createur': createur_plan.username if createur_plan else None,
            'createur_obj': createur_plan,
            'recommandation': None,
            'risque': None,
            'taches': [],
            'sous_actions': []  # Renomm√© pour correspondre au mod√®le
        }
        
        # Ajouter la recommandation li√©e
        if getattr(plan, 'recommandation', None):
            plan_data['recommandation'] = {
                'reference': plan.recommandation.reference,
                'description': plan.recommandation.description[:100] + '...' if len(plan.recommandation.description) > 100 else plan.recommandation.description,
                'id': plan.recommandation.id
            }
        
        # Ajouter le risque associ√©
        if plan.risque_id:
            risque = Risque.query.get(plan.risque_id)
            if risque and check_client_access(risque):
                derniere_eval = risque.evaluations[-1] if risque.evaluations else None
                plan_data['risque'] = {
                    'reference': risque.reference,
                    'intitule': risque.intitule,
                    'niveau': derniere_eval.niveau_risque if derniere_eval else 'Non √©valu√©',
                    'id': risque.id
                }
        
        # Ajouter les sous-actions (anciennement taches)
        for sous_action in getattr(plan, 'sous_actions', []):
            responsable_sous_action = User.query.get(sous_action.responsable_id) if sous_action.responsable_id else None
            
            # V√©rifier si la sous-action est en retard
            est_en_retard_sa = False
            if sous_action.date_fin_prevue and sous_action.statut != 'termine':
                est_en_retard_sa = datetime.utcnow().date() > sous_action.date_fin_prevue
            
            plan_data['sous_actions'].append({
                'id': sous_action.id,
                'reference': sous_action.reference or f"SA-{sous_action.id}",
                'description': sous_action.description,
                'statut': sous_action.statut,
                'statut_display': sous_action.statut.replace('_', ' ').title() if sous_action.statut else '',
                'date_debut': sous_action.date_debut,
                'date_debut_str': sous_action.date_debut.strftime('%d/%m/%Y') if sous_action.date_debut else '',
                'date_fin_prevue': sous_action.date_fin_prevue,
                'date_fin_prevue_str': sous_action.date_fin_prevue.strftime('%d/%m/%Y') if sous_action.date_fin_prevue else '',
                'date_fin_reelle': sous_action.date_fin_reelle,
                'date_fin_reelle_str': sous_action.date_fin_reelle.strftime('%d/%m/%Y') if sous_action.date_fin_reelle else '',
                'pourcentage_realisation': sous_action.pourcentage_realisation or 0,
                'responsable': responsable_sous_action.username if responsable_sous_action else None,
                'responsable_obj': responsable_sous_action,
                'est_en_retard': est_en_retard_sa,
                'created_at': sous_action.created_at
            })
        
        # Ajouter les √©tapes (si elles existent)
        if hasattr(plan, 'etapes'):
            plan_data['etapes'] = []
            for etape in plan.etapes:
                responsable_etape = User.query.get(etape.responsable_id) if etape.responsable_id else None
                plan_data['etapes'].append({
                    'id': etape.id,
                    'ordre': etape.ordre,
                    'description': etape.description,
                    'statut': etape.statut,
                    'statut_display': etape.statut.replace('_', ' ').title() if etape.statut else '',
                    'date_echeance': etape.date_echeance,
                    'date_echeance_str': etape.date_echeance.strftime('%d/%m/%Y') if etape.date_echeance else '',
                    'responsable': responsable_etape.username if responsable_etape else None,
                    'responsable_obj': responsable_etape,
                    'created_at': etape.created_at
                })
        
        rapport_data['plans_action'].append(plan_data)
        
        # Mettre √† jour les statistiques
        if plan.statut:
            rapport_data['statistiques']['plans_action_par_statut'][plan.statut] = \
                rapport_data['statistiques']['plans_action_par_statut'].get(plan.statut, 0) + 1
        
        # Calculer le taux d'avancement
        if hasattr(plan, 'sous_actions') and plan.sous_actions:
            taux_avancement_sous_actions = sum([sa.pourcentage_realisation or 0 for sa in plan.sous_actions])
            taux_plan = taux_avancement_sous_actions / len(plan.sous_actions) if plan.sous_actions else plan.pourcentage_realisation or 0
        else:
            taux_plan = plan.pourcentage_realisation or 0
        
        taux_avancement_total += taux_plan
        plans_traites += 1
    
    # Calculer le taux d'avancement moyen global
    if plans_traites > 0:
        rapport_data['statistiques']['taux_avancement_moyen'] = round(taux_avancement_total / plans_traites, 2)
    
    # R√©cup√©rer l'historique de l'audit
    historique_audit = []
    try:
        historique_audit = JournalAudit.query.filter_by(audit_id=audit_id)\
            .order_by(JournalAudit.created_at.desc())\
            .limit(20)\
            .all()
    except:
        pass
    
    # R√©cup√©rer les analyses IA associ√©es
    analyses_ia = []
    try:
        from models import AnalyseIA
        analyses_ia = get_client_filter(AnalyseIA)\
            .filter_by(audit_id=audit_id)\
            .order_by(AnalyseIA.date_analyse.desc())\
            .limit(5)\
            .all()
    except:
        pass
    
    # R√©cup√©rer les matrices de maturit√©
    matrices_maturite = []
    try:
        from models import MatriceMaturite
        matrices_maturite = get_client_filter(MatriceMaturite)\
            .filter_by(audit_id=audit_id)\
            .order_by(MatriceMaturite.created_at.desc())\
            .all()
    except:
        pass
    
    # R√©cup√©rer les √©ch√©ances √† venir
    echeances_a_venir = []
    aujourdhui = datetime.utcnow().date()
    sept_jours = aujourdhui + timedelta(days=7)
    
    for recommandation in recommandations:
        if recommandation.date_echeance and recommandation.statut not in ['termine', 'annule']:
            if aujourdhui <= recommandation.date_echeance <= sept_jours:
                echeances_a_venir.append({
                    'type': 'recommandation',
                    'objet': recommandation,
                    'jours_restants': (recommandation.date_echeance - aujourdhui).days
                })
    
    for plan in plans_action:
        if plan.date_fin_prevue and plan.statut not in ['termine', 'suspendu']:
            if aujourdhui <= plan.date_fin_prevue <= sept_jours:
                echeances_a_venir.append({
                    'type': 'plan_action',
                    'objet': plan,
                    'jours_restants': (plan.date_fin_prevue - aujourdhui).days
                })
    
    echeances_a_venir.sort(key=lambda x: x['jours_restants'])
    
    return render_template(
        'audit/rapport_complet.html',
        rapport=rapport_data,
        audit=audit,
        createur_audit=createur_audit,
        fichiers_rapport=fichiers_rapport,
        stats_fichiers=stats_fichiers,
        peut_modifier=peut_modifier,
        peut_uploader=peut_uploader,
        historique_audit=historique_audit,
        analyses_ia=analyses_ia,
        matrices_maturite=matrices_maturite,
        echeances_a_venir=echeances_a_venir,
        current_datetime=datetime.utcnow(),
        get_fichier_metadata=lambda x, y: {},
        current_user=current_user,
        format_taille=format_taille
    )


@app.route('/admin/recommandations-globales')
@login_required
@csrf.exempt
@admin_required
def admin_recommandations_globales():
    """Interface d'administration des recommandations globales"""
    recommandations = RecommandationGlobale.query.order_by(RecommandationGlobale.priorite.desc(), 
                                                          RecommandationGlobale.categorie).all()
    categories = db.session.query(RecommandationGlobale.categorie).distinct().all()
    categories = [c[0] for c in categories if c[0]]
    
    return render_template('admin/recommandations_globales.html',
                         recommandations=recommandations,
                         categories=categories)

@app.route('/admin/recommandations-globales/ajouter', methods=['POST'])
@login_required
@csrf.exempt
@admin_required
def ajouter_recommandation_globale():
    """Ajouter une nouvelle recommandation globale"""
    texte = request.form.get('texte')
    categorie = request.form.get('categorie')
    type_audit = request.form.get('type_audit')
    priorite = request.form.get('priorite', 1, type=int)
    
    if not texte:
        flash('Le texte de la recommandation est obligatoire', 'error')
        return redirect(url_for('admin_recommandations_globales'))
    
    recommandation = RecommandationGlobale(
        texte=texte,
        categorie=categorie,
        type_audit=type_audit if type_audit else None,
        priorite=priorite,
        created_by=current_user.id
    )
    
    db.session.add(recommandation)
    db.session.commit()
    
    flash('Recommandation globale ajout√©e avec succ√®s', 'success')
    return redirect(url_for('admin_recommandations_globales'))

@app.route('/admin/recommandations-globales/<int:id>/modifier', methods=['GET', 'POST'])
@login_required
@csrf.exempt
@admin_required
def modifier_recommandation_globale(id):
    """Modifier une recommandation globale"""
    recommandation = RecommandationGlobale.query.get_or_404(id)
    
    if request.method == 'POST':
        recommandation.texte = request.form.get('texte')
        recommandation.categorie = request.form.get('categorie')
        recommandation.type_audit = request.form.get('type_audit')
        recommandation.priorite = request.form.get('priorite', 1, type=int)
        recommandation.est_actif = 'est_actif' in request.form
        recommandation.updated_at = datetime.utcnow()
        
        db.session.commit()
        flash('Recommandation globale modifi√©e avec succ√®s', 'success')
        return redirect(url_for('admin_recommandations_globales'))
    
    return render_template('admin/modifier_recommandation_globale.html',
                         recommandation=recommandation)

@app.route('/admin/recommandations-globales/<int:id>/supprimer', methods=['POST'])
@login_required
@csrf.exempt
@admin_required
def supprimer_recommandation_globale(id):
    """Supprimer une recommandation globale"""
    recommandation = RecommandationGlobale.query.get_or_404(id)
    
    db.session.delete(recommandation)
    db.session.commit()
    
    flash('Recommandation globale supprim√©e avec succ√®s', 'success')
    return redirect(url_for('admin_recommandations_globales'))


# ============================
# ROUTES POUR L'EXPORT
# ============================

    
@app.route('/matrice-maturite/<int:matrice_id>/modifier', methods=['POST'])
@csrf.exempt
@login_required
def modifier_matrice_maturite(matrice_id):
    """Modifier une matrice de maturit√©"""
    matrice = MatriceMaturite.query.get_or_404(matrice_id)
    
    try:
        # R√©cup√©rer les donn√©es du formulaire
        matrice.exigence = request.form.get('exigence', '').strip()
        matrice.niveau_conformite = request.form.get('niveau_conformite', '')
        matrice.commentaire = request.form.get('commentaire', '').strip()
        
        # Validation basique
        if not matrice.exigence or not matrice.niveau_conformite:
            flash('L\'exigence et le niveau de conformit√© sont requis', 'error')
            return redirect(url_for('matrice_maturite_audit', audit_id=matrice.audit_id))
        
        db.session.commit()
        flash('Exigence modifi√©e avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la modification: {str(e)}', 'error')
    
    return redirect(url_for('matrice_maturite_audit', audit_id=matrice.audit_id))

@app.route('/matrice-maturite/<int:matrice_id>/supprimer', methods=['POST'])
@csrf.exempt
@login_required
def supprimer_matrice_maturite(matrice_id):
    """Supprimer une matrice de maturit√©"""
    matrice = MatriceMaturite.query.get_or_404(matrice_id)
    audit_id = matrice.audit_id
    
    try:
        db.session.delete(matrice)
        db.session.commit()
        flash('Exigence supprim√©e de la matrice avec succ√®s', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la suppression: {str(e)}', 'error')
    
    return redirect(url_for('matrice_maturite_audit', audit_id=audit_id))


# ============================
# ROUTES POUR CONSTATATIONS
# ============================
@app.route('/audit/<int:audit_id>/recommandation/ajouter', methods=['POST'])
@csrf.exempt
@login_required
def ajouter_recommandation(audit_id):
    """Ajouter une recommandation √† un audit"""
    audit = Audit.query.get_or_404(audit_id)
    
    try:
        # DEBUG: Afficher les donn√©es re√ßues
        print(f"üîç Donn√©es POST re√ßues: {dict(request.form)}")
        
        # 1. G√©n√©rer une r√©f√©rence UNIQUE
        # Compter le nombre de recommandations pour cet audit
        count_recos = Recommandation.query.filter_by(audit_id=audit_id).count()
        print(f"üìä Nombre de recommandations existantes: {count_recos}")
        
        # Extraire la partie num√©rique de la r√©f√©rence d'audit
        import re
        
        # Obtenir la r√©f√©rence de l'audit
        audit_ref = audit.reference if audit.reference else f"AUD-{audit_id:04d}"
        print(f"üìù R√©f√©rence audit: {audit_ref}")
        
        # Trouver le prochain num√©ro de recommandation
        # Chercher la derni√®re recommandation pour cet audit
        derniere_reco = Recommandation.query.filter_by(audit_id=audit_id).order_by(Recommandation.id.desc()).first()
        
        if derniere_reco and derniere_reco.reference:
            # Essayer d'extraire le num√©ro de la derni√®re r√©f√©rence
            match = re.search(r'REC-.*-(\d+)', derniere_reco.reference)
            if match:
                last_num = int(match.group(1))
                next_num = last_num + 1
            else:
                next_num = count_recos + 1
        else:
            next_num = 1
        
        # Cr√©er la nouvelle r√©f√©rence
        nouvelle_ref = f"REC-{audit_ref}-{next_num:03d}"
        print(f"‚úÖ Nouvelle r√©f√©rence g√©n√©r√©e: {nouvelle_ref}")
        
        # 2. Valider les donn√©es requises
        description = request.form.get('description', '').strip()
        if not description:
            flash('La description est requise', 'error')
            return redirect(url_for('detail_audit', id=audit_id))
        
        # 3. Traiter les champs optionnels
        constatation_id = request.form.get('constatation_id')
        risque_id = request.form.get('risque_id')
        responsable_id = request.form.get('responsable_id')
        
        # Convertir en int si possible
        constatation_id = int(constatation_id) if constatation_id and constatation_id.isdigit() else None
        risque_id = int(risque_id) if risque_id and risque_id.isdigit() else None
        responsable_id = int(responsable_id) if responsable_id and responsable_id.isdigit() else None
        
        # 4. Traiter la date d'√©ch√©ance
        date_echeance = None
        date_echeance_str = request.form.get('date_echeance')
        if date_echeance_str:
            try:
                date_echeance = datetime.strptime(date_echeance_str, '%Y-%m-%d').date()
            except ValueError:
                flash('Format de date invalide', 'warning')
                # Date par d√©faut: 30 jours √† partir d'aujourd'hui
                date_echeance = datetime.utcnow().date() + timedelta(days=30)
        
        # 5. Cr√©er la recommandation avec TOUS les champs requis
        recommandation = Recommandation(
            reference=nouvelle_ref,  # CHAMP OBLIGATOIRE
            description=description,
            type_recommandation=request.form.get('type_recommandation', 'corrective'),
            categorie=request.form.get('categorie', ''),
            delai_mise_en_oeuvre=request.form.get('delai_mise_en_oeuvre', ''),
            date_echeance=date_echeance,
            urgence=int(request.form.get('urgence', 3)),
            impact_operationnel=int(request.form.get('impact_operationnel', 3)),
            statut='a_traiter',
            audit_id=audit_id,
            constatation_id=constatation_id,
            risque_id=risque_id,
            responsable_id=responsable_id,
            created_by=current_user.id,
            taux_avancement=0  # Valeur par d√©faut
        )
        
        # 6. Calculer le score de priorit√©
        recommandation.score_priorite = recommandation.calculer_score_priorite()
        
        print(f"üíæ Sauvegarde recommandation: {recommandation.reference}")
        
        # 7. Sauvegarder
        db.session.add(recommandation)
        db.session.commit()
        
        flash(f'Recommandation {recommandation.reference} ajout√©e avec succ√®s', 'success')
        
    except ValueError as e:
        db.session.rollback()
        print(f"‚ùå Erreur ValueError: {str(e)}")
        flash(f'Erreur de conversion: {str(e)}', 'error')
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur inattendue: {str(e)}")
        import traceback
        traceback.print_exc()  # Pour le d√©bogage complet
        flash(f'Erreur lors de l\'ajout: {str(e)}', 'error')
    
    return redirect(url_for('detail_audit', id=audit_id))

@app.route('/recommandation/<int:recommandation_id>/modifier', methods=['POST'])
@csrf.exempt
@login_required
def modifier_recommandation(recommandation_id):
    """Modifier une recommandation compl√®tement"""
    recommandation = Recommandation.query.get_or_404(recommandation_id)
    
    try:
        # Mettre √† jour tous les champs
        recommandation.description = request.form.get('description', '').strip()
        recommandation.type_recommandation = request.form.get('type_recommandation', 'corrective')
        recommandation.categorie = request.form.get('categorie', '')
        recommandation.delai_mise_en_oeuvre = request.form.get('delai_mise_en_oeuvre', '')
        
        # Date d'√©ch√©ance
        date_echeance = request.form.get('date_echeance')
        recommandation.date_echeance = datetime.strptime(date_echeance, '%Y-%m-%d').date() if date_echeance else None
        
        # Urgence et impact
        recommandation.urgence = int(request.form.get('urgence', 3))
        recommandation.impact_operationnel = int(request.form.get('impact_operationnel', 3))
        
        # Statut et taux d'avancement - IMPORTANT: lier les deux
        nouveau_statut = request.form.get('statut', 'a_traiter')
        recommandation.statut = nouveau_statut
        
        # Taux d'avancement
        taux_avancement_str = request.form.get('taux_avancement')
        if taux_avancement_str and taux_avancement_str.isdigit():
            nouveau_taux = int(taux_avancement_str)
            recommandation.taux_avancement = nouveau_taux
            
            # Si le statut est "termine", forcer 100%
            if nouveau_statut == 'termine':
                recommandation.taux_avancement = 100
            # Si 100% et pas encore termin√©, marquer comme termin√©
            elif nouveau_taux == 100 and nouveau_statut != 'termine':
                recommandation.statut = 'termine'
        
        # Responsable
        responsable_id = request.form.get('responsable_id')
        recommandation.responsable_id = int(responsable_id) if responsable_id and responsable_id.isdigit() else None
        
        # Risque associ√©
        risque_id = request.form.get('risque_id')
        recommandation.risque_id = int(risque_id) if risque_id and risque_id.isdigit() else None
        
        # Recalculer le score de priorit√©
        recommandation.score_priorite = recommandation.calculer_score_priorite()
        
        # Mettre √† jour la date de modification
        recommandation.updated_at = datetime.utcnow()
        
        db.session.commit()
        flash('Recommandation modifi√©e avec succ√®s', 'success')
        
    except ValueError as e:
        db.session.rollback()
        flash(f'Erreur de valeur: {str(e)}', 'error')
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la modification: {str(e)}', 'error')
    
    return redirect(url_for('detail_audit', id=recommandation.audit_id))

@app.route('/recommandation/<int:recommandation_id>/changer-statut', methods=['POST'])
@csrf.exempt
@login_required
def changer_statut_recommandation(recommandation_id):
    """Changer le statut et le taux d'avancement d'une recommandation"""
    recommandation = Recommandation.query.get_or_404(recommandation_id)
    nouveau_statut = request.form.get('statut')
    
    if nouveau_statut in ['a_traiter', 'en_cours', 'termine', 'retarde']:
        ancien_statut = recommandation.statut
        recommandation.statut = nouveau_statut
        
        # G√©rer le taux d'avancement en fonction du statut
        taux_avancement = request.form.get('taux_avancement')
        if taux_avancement and taux_avancement.isdigit():
            recommandation.taux_avancement = int(taux_avancement)
        
        # Si termin√©, forcer 100%
        if nouveau_statut == 'termine':
            recommandation.taux_avancement = 100
        # Si 100% et pas encore termin√©, marquer comme termin√©
        elif recommandation.taux_avancement == 100 and nouveau_statut != 'termine':
            recommandation.statut = 'termine'
        
        recommandation.updated_at = datetime.utcnow()
        
        db.session.commit()
        flash(f'Statut modifi√©: {ancien_statut} ‚Üí {nouveau_statut}', 'success')
    else:
        flash('Statut invalide', 'error')
    
    return redirect(url_for('detail_audit', id=recommandation.audit_id))

@app.route('/constatation/<int:constatation_id>/changer-statut', methods=['POST'])
@csrf.exempt
@login_required
def changer_statut_constatation(constatation_id):
    """Changer le statut d'une constatation"""
    constatation = Constatation.query.get_or_404(constatation_id)
    nouveau_statut = request.form.get('statut')
    
    if nouveau_statut in ['a_analyser', 'a_valider', 'en_action', 'clos']:
        ancien_statut = constatation.statut
        constatation.statut = nouveau_statut
        constatation.updated_at = datetime.utcnow()
        
        db.session.commit()
        flash(f'Statut modifi√©: {ancien_statut} ‚Üí {nouveau_statut}', 'success')
    else:
        flash('Statut invalide', 'error')
    
    return redirect(url_for('detail_audit', id=constatation.audit_id))


@app.route('/audit/<int:audit_id>/upload-fichier', methods=['POST'])
@login_required
def upload_fichier_audit(audit_id):
    """Uploader un fichier pour un audit"""
    audit = Audit.query.get_or_404(audit_id)
    
    if 'fichier' not in request.files:
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(url_for('detail_audit', id=audit_id))
    
    fichier = request.files['fichier']
    
    if fichier.filename == '':
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(url_for('detail_audit', id=audit_id))
    
    if fichier and allowed_file(fichier.filename):
        # Cr√©er le dossier s'il n'existe pas
        os.makedirs(UPLOAD_FOLDER, exist_ok=True)
        
        # G√©n√©rer un nom de fichier unique
        filename = secure_filename(fichier.filename)
        unique_filename = f"{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{filename}"
        filepath = os.path.join(UPLOAD_FOLDER, unique_filename)
        
        # Sauvegarder le fichier
        fichier.save(filepath)
        
        # Cr√©er une entr√©e dans le journal
        journaliser_action_audit(
            audit_id=audit.id,
            action_type='upload_fichier',
            user_id=current_user.id,
            details={
                'filename': filename,
                'unique_filename': unique_filename,
                'filepath': filepath
            }
        )
        
        flash(f'Fichier "{filename}" upload√© avec succ√®s', 'success')
    else:
        flash('Type de fichier non autoris√©', 'error')
    
    return redirect(url_for('detail_audit', id=audit_id))

@app.route('/constatation/<int:constatation_id>/upload-preuve', methods=['POST'])
@login_required
def upload_preuve_constatation(constatation_id):
    """Uploader une preuve pour une constatation avec m√©tadonn√©es"""
    constatation = Constatation.query.get_or_404(constatation_id)
    
    if 'preuve' not in request.files:
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(url_for('detail_audit', id=constatation.audit_id))
    
    preuve = request.files['preuve']
    commentaire = request.form.get('commentaire', '').strip()
    
    if preuve and allowed_file(preuve.filename):
        # Cr√©er le dossier
        os.makedirs('static/uploads/preuves', exist_ok=True)
        
        # Sauvegarder le fichier
        filename = secure_filename(preuve.filename)
        unique_filename = f"preuve_{constatation_id}_{filename}"
        filepath = os.path.join('static/uploads/preuves', unique_filename)
        preuve.save(filepath)
        
        # Enregistrer les m√©tadonn√©es
        try:
            fichier_metadata = FichierMetadata(
                nom_fichier=unique_filename,
                chemin=filepath,
                type_fichier=filename.split('.')[-1].lower() if '.' in filename else 'unknown',
                taille=os.path.getsize(filepath),
                commentaire=commentaire,
                responsable_id=current_user.id,  # Responsable automatique
                entite_type='constatation',
                entite_id=constatation_id,
                created_by=current_user.id
            )
            
            db.session.add(fichier_metadata)
        except Exception as e:
            print(f"Erreur lors de l'enregistrement des m√©tadonn√©es: {e}")
            # Continuer m√™me sans m√©tadonn√©es
        
        # Mettre √† jour la constatation
        if constatation.preuves:
            constatation.preuves += f",{unique_filename}"
        else:
            constatation.preuves = unique_filename
        
        constatation.updated_at = datetime.utcnow()
        db.session.commit()
        
        flash(f'Fichier "{filename}" upload√© avec succ√®s', 'success')
        if commentaire:
            flash(f'Commentaire enregistr√© : {commentaire}', 'info')
    
    return redirect(url_for('detail_audit', id=constatation.audit_id))



# ============================
# ROUTES API POUR LES R√âSUM√âS
# ============================
@app.route('/api/constatation/<int:constatation_id>/resume')
@login_required
def api_resume_constatation(constatation_id):
    """API pour r√©cup√©rer le r√©sum√© d'une constatation"""
    constatation = Constatation.query.get_or_404(constatation_id)
    
    # V√©rifier que l'utilisateur a acc√®s √† cet audit
    audit = constatation.audit
    
    # V√©rifier les permissions
    user_in_equipe = False
    if audit.equipe_audit_ids:
        equipe_ids = [id_str.strip() for id_str in audit.equipe_audit_ids.split(',') if id_str.strip()]
        user_in_equipe = str(current_user.id) in equipe_ids
    
    peut_voir = (
        current_user.role == 'admin' or
        current_user.id == audit.created_by or
        current_user.id == audit.responsable_id or
        user_in_equipe
    )
    
    if not peut_voir:
        return jsonify({'error': 'Non autoris√©'}), 403
    
    # R√©cup√©rer les m√©tadonn√©es des fichiers si disponibles
    preuves_avec_metadata = []
    if constatation.preuves:
        preuves_list = constatation.get_preuves_list
        for preuve in preuves_list:
            metadata_info = {
                'nom': preuve,
                'commentaire': '',
                'responsable': '',
                'date_upload': '',
                'taille': 'N/A'
            }
            
            # Essayer de r√©cup√©rer les m√©tadonn√©es
            try:
                from models import FichierMetadata
                metadata = FichierMetadata.query.filter_by(
                    nom_fichier=preuve,
                    entite_type='constatation',
                    entite_id=constatation_id
                ).first()
                
                if metadata:
                    metadata_info['commentaire'] = metadata.commentaire or ''
                    metadata_info['responsable'] = metadata.responsable.username if metadata.responsable else 'Non d√©fini'
                    metadata_info['date_upload'] = metadata.created_at.strftime('%d/%m/%Y') if metadata.created_at else ''
                    if metadata.taille:
                        taille_kb = metadata.taille / 1024
                        metadata_info['taille'] = f"{taille_kb:.1f} KB"
            except Exception as e:
                print(f"Erreur lors de la r√©cup√©ration des m√©tadonn√©es: {e}")
            
            preuves_avec_metadata.append(metadata_info)
    
    # R√©cup√©rer les recommandations li√©es
    recommandations_data = []
    for recommandation in constatation.recommandations:
        recommandations_data.append({
            'id': recommandation.id,
            'reference': recommandation.reference,
            'description': recommandation.description[:80] + '...' if len(recommandation.description) > 80 else recommandation.description,
            'statut': recommandation.statut,
            'statut_display': recommandation.statut.replace('_', ' ').title() if recommandation.statut else '',
            'couleur_statut': recommandation.couleur_statut
        })
    
    # Informations sur le risque
    risque_data = None
    if constatation.risque_id:
        risque = Risque.query.get(constatation.risque_id)
        if risque:
            derniere_eval = risque.evaluations[-1] if risque.evaluations else None
            risque_data = {
                'id': risque.id,
                'reference': risque.reference,
                'intitule': risque.intitule,
                'categorie': risque.categorie,
                'niveau': derniere_eval.niveau_risque if derniere_eval else 'Non √©valu√©',
                'score': derniere_eval.score_risque if derniere_eval else 0
            }
    
    # V√âRIFIER ET INCLURE TOUS LES CHAMPS
    conclusion = getattr(constatation, 'conclusion', '')
    commentaires = getattr(constatation, 'commentaires', '')
    recommandations_immediates = getattr(constatation, 'recommandations_immediates', '')
    
    # Formater les donn√©es
    data = {
        'id': constatation.id,
        'reference': constatation.reference,
        'description': constatation.description,
        'type_constatation': constatation.type_constatation,
        'type_constatation_display': constatation.type_constatation.replace('_', ' ').title() if constatation.type_constatation else '',
        'gravite': constatation.gravite,
        'gravite_display': constatation.gravite.title() if constatation.gravite else '',
        'statut': constatation.statut,
        'statut_display': constatation.statut.replace('_', ' ').title() if constatation.statut else '',
        'processus': constatation.processus_concerne or '',
        'cause_racine': constatation.cause_racine or '',
        'conclusion': conclusion,  # CORRIG√â
        'commentaires': commentaires,  # CORRIG√â
        'recommandations_immediates': recommandations_immediates,  # CORRIG√â
        'date_creation': constatation.created_at.strftime('%d/%m/%Y √† %H:%M') if constatation.created_at else '',
        'date_modification': constatation.updated_at.strftime('%d/%m/%Y √† %H:%M') if constatation.updated_at else '',
        'createur': constatation.createur.username if constatation.createur else 'Syst√®me',
        'couleur_type': {
            'non_conformite': 'danger',
            'observation': 'warning',
            'conformite': 'success',
            'amelioration': 'info',
            'recommandation': 'primary'
        }.get(constatation.type_constatation, 'secondary'),
        'couleur_gravite': {
            'critique': 'danger',
            'majeure': 'warning',
            'moyenne': 'info',
            'mineure': 'success'
        }.get(constatation.gravite, 'secondary'),
        'couleur_statut': {
            'a_analyser': 'secondary',
            'a_valider': 'warning',
            'en_action': 'info',
            'clos': 'success'
        }.get(constatation.statut, 'light'),
        'preuves': preuves_avec_metadata,
        'recommandations': recommandations_data,
        'risque': risque_data
    }
    
    return jsonify(data)

@app.route('/api/recommandation/<int:recommandation_id>/resume')
@login_required
def api_resume_recommandation(recommandation_id):
    """API pour r√©cup√©rer le r√©sum√© d'une recommandation"""
    recommandation = Recommandation.query.get_or_404(recommandation_id)
    
    # V√©rifier que l'utilisateur a acc√®s √† cet audit
    audit = recommandation.audit
    
    # V√©rifier les permissions
    user_in_equipe = False
    if audit.equipe_audit_ids:
        equipe_ids = [id_str.strip() for id_str in audit.equipe_audit_ids.split(',') if id_str.strip()]
        user_in_equipe = str(current_user.id) in equipe_ids
    
    peut_voir = (
        current_user.role == 'admin' or
        current_user.id == audit.created_by or
        current_user.id == audit.responsable_id or
        user_in_equipe
    )
    
    if not peut_voir:
        return jsonify({'error': 'Non autoris√©'}), 403
    
    # Informations sur la constatation li√©e
    constatation_data = None
    if recommandation.constatation_id:
        constatation = Constatation.query.get(recommandation.constatation_id)
        if constatation:
            constatation_data = {
                'id': constatation.id,
                'reference': constatation.reference,
                'description': constatation.description[:80] + '...' if len(constatation.description) > 80 else constatation.description
            }
    
    # Informations sur le risque
    risque_data = None
    if recommandation.risque_id:
        risque = Risque.query.get(recommandation.risque_id)
        if risque:
            derniere_eval = risque.evaluations[-1] if risque.evaluations else None
            risque_data = {
                'id': risque.id,
                'reference': risque.reference,
                'intitule': risque.intitule,
                'categorie': risque.categorie,
                'niveau': derniere_eval.niveau_risque if derniere_eval else 'Non √©valu√©',
                'score': derniere_eval.score_risque if derniere_eval else 0
            }
    
    # Informations sur le plan d'action
    plan_action_data = None
    if recommandation.plan_action:
        plan_action_data = {
            'id': recommandation.plan_action.id,
            'nom': recommandation.plan_action.nom,
            'statut': recommandation.plan_action.statut,
            'statut_display': recommandation.plan_action.statut.replace('_', ' ').title() if recommandation.plan_action.statut else '',
            'couleur_statut': recommandation.plan_action.couleur_statut,
            'pourcentage_realisation': recommandation.plan_action.pourcentage_realisation or 0
        }
    
    # Formater les donn√©es
    data = {
        'id': recommandation.id,
        'reference': recommandation.reference,
        'description': recommandation.description,
        'type_recommandation': recommandation.type_recommandation,
        'type_display': recommandation.type_recommandation.replace('_', ' ').title() if recommandation.type_recommandation else '',
        'categorie': recommandation.categorie,
        'categorie_display': recommandation.categorie.replace('_', ' ').title() if recommandation.categorie else '',
        'delai_mise_en_oeuvre': recommandation.delai_mise_en_oeuvre,
        'delai_display': recommandation.delai_mise_en_oeuvre.replace('_', ' ').title() if recommandation.delai_mise_en_oeuvre else '',
        'date_echeance': recommandation.date_echeance.strftime('%d/%m/%Y') if recommandation.date_echeance else '',
        'urgence': recommandation.urgence,
        'urgence_display': f"Niveau {recommandation.urgence}/5" if recommandation.urgence else '',
        'urgence_percent': (recommandation.urgence or 0) * 20,
        'impact_operationnel': recommandation.impact_operationnel,
        'impact_display': f"Niveau {recommandation.impact_operationnel}/5" if recommandation.impact_operationnel else '',
        'impact_percent': (recommandation.impact_operationnel or 0) * 20,
        'score_priorite': recommandation.score_priorite or 0,
        'statut': recommandation.statut,
        'statut_display': recommandation.statut.replace('_', ' ').title() if recommandation.statut else '',
        'taux_avancement': recommandation.taux_avancement or 0,
        'est_en_retard': recommandation.est_en_retard,
        'date_creation': recommandation.created_at.strftime('%d/%m/%Y √† %H:%M') if recommandation.created_at else '',
        'responsable': recommandation.responsable.username if recommandation.responsable else '',
        'commentaires': '',
        'couleur_type': {
            'corrective': 'danger',
            'preventive': 'warning',
            'amelioration': 'success',
            'optimisation': 'info'
        }.get(recommandation.type_recommandation, 'secondary'),
        'couleur_statut': recommandation.couleur_statut,
        'couleur_priorite': 'danger' if (recommandation.score_priorite or 0) >= 80 else 'warning' if (recommandation.score_priorite or 0) >= 60 else 'success',
        'couleur_avancement': 'danger' if (recommandation.taux_avancement or 0) < 25 else 'warning' if (recommandation.taux_avancement or 0) < 75 else 'success',
        'constatation': constatation_data,
        'risque': risque_data,
        'plan_action': plan_action_data
    }
    
    return jsonify(data)

@app.route('/audit/constatation/<int:constatation_id>/preuve/delete', methods=['POST'])
@login_required
def delete_preuve_constatation(constatation_id):
    """Supprimer une preuve d'une constatation"""
    constatation = Constatation.query.get_or_404(constatation_id)
    
    # V√©rifier les permissions
    audit = constatation.audit
    peut_modifier = (
        current_user.role == 'admin' or
        current_user.id == audit.created_by or
        current_user.id == audit.responsable_id or
        str(current_user.id) in (audit.equipe_audit_ids or '').split(',')
    )
    
    if not peut_modifier:
        return jsonify({'success': False, 'message': 'Non autoris√©'}), 403
    
    data = request.get_json()
    filename = data.get('filename')
    
    if not filename:
        return jsonify({'success': False, 'message': 'Nom de fichier manquant'}), 400
    
    try:
        # Supprimer le fichier physique
        filepath = os.path.join('static/uploads/preuves', filename)
        if os.path.exists(filepath):
            os.remove(filepath)
        
        # Supprimer les m√©tadonn√©es
        try:
            from models import FichierMetadata
            FichierMetadata.query.filter_by(
                nom_fichier=filename,
                entite_type='constatation',
                entite_id=constatation_id
            ).delete()
        except:
            pass
        
        # Mettre √† jour la constatation
        if constatation.preuves:
            preuves_list = constatation.get_preuves_list
            if filename in preuves_list:
                preuves_list.remove(filename)
                constatation.preuves = ','.join(preuves_list) if preuves_list else None
        
        constatation.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Preuve supprim√©e avec succ√®s'})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': f'Erreur lors de la suppression: {str(e)}'}), 500
    
@app.route('/constatation/<int:constatation_id>/modifier', methods=['POST'])
@login_required
def modifier_constatation(constatation_id):
    """Modifier une constatation existante"""
    constatation = Constatation.query.get_or_404(constatation_id)
    audit = constatation.audit
    
    # V√©rifier les permissions
    peut_modifier = (
        current_user.role == 'admin' or
        current_user.id == audit.created_by or
        current_user.id == audit.responsable_id or
        str(current_user.id) in (audit.equipe_audit_ids or '').split(',')
    )
    
    if not peut_modifier:
        flash('Non autoris√©', 'error')
        return redirect(url_for('detail_audit', id=audit.id))
    
    try:
        # Mettre √† jour tous les champs
        constatation.description = request.form.get('description', '').strip()
        constatation.type_constatation = request.form.get('type_constatation', '')
        constatation.gravite = request.form.get('gravite', '')
        constatation.processus_concerne = request.form.get('processus_concerne', '').strip()
        constatation.cause_racine = request.form.get('cause_racine', '').strip()
        
        # NOUVEAUX CHAMPS - IMPORTANT
        constatation.conclusion = request.form.get('conclusion', '').strip()
        constatation.commentaires = request.form.get('commentaires', '').strip()
        constatation.recommandations_immediates = request.form.get('recommandations_immediates', '').strip()
        constatation.documents_justificatifs = request.form.get('documents_justificatifs', '').strip()
        
        # Risque associ√©
        risque_id = request.form.get('risque_id', '')
        constatation.risque_id = int(risque_id) if risque_id and risque_id.isdigit() else None
        
        # Statut
        constatation.statut = request.form.get('statut', 'a_analyser')
        
        constatation.updated_at = datetime.utcnow()
        
        db.session.commit()
        flash('Constatation modifi√©e avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la modification: {str(e)}', 'error')
    
    return redirect(url_for('detail_audit', id=audit.id))

@app.route('/audit/<int:audit_id>/constatation/ajouter', methods=['POST'])
@csrf.exempt
@login_required
def ajouter_constatation(audit_id):
    """Ajouter une constatation √† un audit"""
    audit = Audit.query.get_or_404(audit_id)

    try:
        # ===== G√âN√âRATION DE LA R√âF√âRENCE =====
        dernier_constat = (
            Constatation.query
            .filter_by(audit_id=audit_id)
            .order_by(Constatation.id.desc())
            .first()
        )

        nouvelle_ref = f"CON-{audit.reference}-{(dernier_constat.id + 1) if dernier_constat else 1:03d}"

        # ===== CR√âATION DE LA CONSTATATION =====
        constatation = Constatation(
            reference=nouvelle_ref,
            description=request.form.get('description', '').strip(),
            type_constatation=request.form.get('type_constatation', 'observation'),
            gravite=request.form.get('gravite', 'moyenne'),
            criticite=request.form.get('criticite', 'mineure'),
            processus_concerne=request.form.get('processus_concerne', '').strip(),
            cause_racine=request.form.get('cause_racine', '').strip(),

            # üîπ NOUVEAUX CHAMPS AJOUT√âS
            conclusion=request.form.get('conclusion', '').strip(),
            commentaires=request.form.get('commentaires', '').strip(),
            recommandations_immediates=request.form.get('recommandations_immediates', '').strip(),

            statut='a_analyser',
            audit_id=audit_id,
            created_by=current_user.id,

            # üîπ RISQUE ASSOCI√â (s√©curis√©)
            risque_id=int(request.form.get('risque_id'))
            if request.form.get('risque_id') else None
        )

        db.session.add(constatation)
        db.session.commit()

        flash('Constatation ajout√©e avec succ√®s', 'success')

    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Erreur lors de l'ajout de la constatation : {e}",
            exc_info=True
        )
        flash("Erreur lors de l'ajout de la constatation", 'error')

    return redirect(url_for('detail_audit', id=audit_id))


# ========================
# ROUTES DE SUPPRESSION IA
# ========================

@app.route('/analyse-ia/<int:analyse_id>/supprimer', methods=['POST'])
@csrf.exempt
@login_required
def supprimer_analyse_ia(analyse_id):
    """Supprimer une analyse IA"""
    try:
        analyse = get_client_object_or_404(AnalyseIA, analyse_id)
        audit_id = analyse.audit_id
        
        # V√©rifier les permissions
        peut_supprimer = (
            current_user.role == 'admin' or
            current_user.id == analyse.created_by or
            current_user.id == analyse.audit.created_by
        )
        
        if not peut_supprimer:
            flash('Vous n\'avez pas les permissions pour supprimer cette analyse', 'error')
            return redirect(url_for('liste_analyses_ia', audit_id=audit_id))
        
        # Supprimer l'analyse
        db.session.delete(analyse)
        db.session.commit()
        
        # Journaliser
        log_activity(current_user.id, 'suppression_analyse_ia',
                    f"Analyse IA {analyse_id} supprim√©e",
                    'analyse_ia', analyse_id)
        
        flash('Analyse IA supprim√©e avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la suppression: {str(e)}', 'error')
    
    return redirect(url_for('liste_analyses_ia', audit_id=audit_id))

@app.route('/audit/<int:audit_id>/analyses-ia/supprimer-toutes', methods=['POST'])
@csrf.exempt
@login_required
def supprimer_toutes_analyses_ia(audit_id):
    """Supprimer toutes les analyses IA d'un audit"""
    try:
        audit = get_client_object_or_404(Audit, audit_id)
        
        # V√©rifier les permissions
        peut_supprimer = (
            current_user.role == 'admin' or
            current_user.id == audit.created_by or
            current_user.id == audit.responsable_id
        )
        
        if not peut_supprimer:
            flash('Vous n\'avez pas les permissions pour cette action', 'error')
            return redirect(url_for('liste_analyses_ia', audit_id=audit_id))
        
        # R√©cup√©rer et supprimer toutes les analyses
        analyses = get_client_filter(AnalyseIA).filter_by(audit_id=audit_id).all()
        count = len(analyses)
        
        for analyse in analyses:
            db.session.delete(analyse)
        
        db.session.commit()
        
        # Journaliser
        log_activity(current_user.id, 'suppression_toutes_analyses_ia',
                    f"{count} analyses IA supprim√©es pour l'audit {audit.reference}",
                    'audit', audit_id)
        
        flash(f'{count} analyses IA supprim√©es avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la suppression: {str(e)}', 'error')
    
    return redirect(url_for('detail_audit', id=audit_id))

@app.route('/recommandation/<int:recommandation_id>/supprimer', methods=['POST'])
@csrf.exempt
@login_required
def supprimer_recommandation(recommandation_id):
    """Supprimer une recommandation (inclut les recommandations IA)"""
    try:
        recommandation = get_client_object_or_404(Recommandation, recommandation_id)
        audit_id = recommandation.audit_id
        
        # V√©rifier les permissions
        peut_supprimer = (
            current_user.role == 'admin' or
            current_user.id == recommandation.created_by or
            current_user.id == recommandation.audit.created_by
        )
        
        if not peut_supprimer:
            flash('Vous n\'avez pas les permissions pour supprimer cette recommandation', 'error')
            return redirect(url_for('detail_audit', id=audit_id))
        
        # V√©rifier si c'est une recommandation IA
        is_ia_recommendation = recommandation.categorie == 'ia_suggested'
        
        # Supprimer la recommandation
        db.session.delete(recommandation)
        db.session.commit()
        
        # Journaliser
        action = 'suppression_recommandation_ia' if is_ia_recommendation else 'suppression_recommandation'
        log_activity(current_user.id, action,
                    f"Recommandation {recommandation.reference} supprim√©e",
                    'recommandation', recommandation_id)
        
        flash('Recommandation supprim√©e avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la suppression: {str(e)}', 'error')
    
    return redirect(url_for('detail_audit', id=audit_id))

@app.route('/constatation/<int:constatation_id>/supprimer', methods=['POST'])
@csrf.exempt
@login_required
def supprimer_constatation(constatation_id):
    """Supprimer une constatation"""
    try:
        constatation = get_client_object_or_404(Constatation, constatation_id)
        audit_id = constatation.audit_id
        
        # V√©rifier les permissions
        peut_supprimer = (
            current_user.role == 'admin' or
            current_user.id == constatation.created_by or
            current_user.id == constatation.audit.created_by
        )
        
        if not peut_supprimer:
            flash('Vous n\'avez pas les permissions pour supprimer cette constatation', 'error')
            return redirect(url_for('detail_audit', id=audit_id))
        
        # Supprimer les fichiers associ√©s
        if constatation.preuves:
            preuves_list = constatation.get_preuves_list
            for preuve in preuves_list:
                filepath = os.path.join('static/uploads/preuves', preuve)
                if os.path.exists(filepath):
                    os.remove(filepath)
        
        # Supprimer la constatation
        db.session.delete(constatation)
        db.session.commit()
        
        # Journaliser
        log_activity(current_user.id, 'suppression_constatation',
                    f"Constatation {constatation.reference} supprim√©e",
                    'constatation', constatation_id)
        
        flash('Constatation supprim√©e avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la suppression: {str(e)}', 'error')
    
    return redirect(url_for('detail_audit', id=audit_id))
@app.route('/admin/analyses-ia')
@login_required
@admin_required
def admin_analyses_ia():
    """Dashboard d'administration des analyses IA"""
    
    # Statistiques globales
    stats = {
        'total': AnalyseIA.query.count(),
        'today': AnalyseIA.query.filter(
            db.func.date(AnalyseIA.date_analyse) == datetime.utcnow().date()
        ).count(),
        'avg_score': db.session.query(db.func.avg(AnalyseIA.score_confiance)).scalar() or 0,
        'by_type': {},
        'top_audits': []
    }
    
    # Analyses par type
    types = db.session.query(
        AnalyseIA.type_analyse,
        db.func.count(AnalyseIA.id).label('count')
    ).group_by(AnalyseIA.type_analyse).all()
    
    for type_name, count in types:
        stats['by_type'][type_name] = count
    
    # Top audits
    top = db.session.query(
        Audit.reference,
        Audit.titre,
        db.func.count(AnalyseIA.id).label('analysis_count')
    ).join(AnalyseIA).group_by(Audit.id).order_by(
        db.desc('analysis_count')
    ).limit(10).all()
    
    stats['top_audits'] = top
    
    # Analyses r√©centes
    recent = AnalyseIA.query.order_by(
        AnalyseIA.date_analyse.desc()
    ).limit(20).all()
    
    return render_template('admin/analyses_ia.html',
                         stats=stats,
                         recent_analyses=recent)

@app.route('/plan-action/<int:plan_id>/modifier', methods=['POST'])
@csrf.exempt
@login_required
def modifier_plan_action(plan_id):
    """Modifier les informations d'un plan d'action"""
    plan_action = PlanAction.query.get_or_404(plan_id)
    
    try:
        # R√©cup√©rer les donn√©es du formulaire
        plan_action.nom = request.form.get('nom', '').strip()
        plan_action.description = request.form.get('description', '').strip()
        
        # Dates
        date_debut = request.form.get('date_debut')
        date_fin_prevue = request.form.get('date_fin_prevue')
        
        if date_debut:
            plan_action.date_debut = datetime.strptime(date_debut, '%Y-%m-%d').date()
        if date_fin_prevue:
            plan_action.date_fin_prevue = datetime.strptime(date_fin_prevue, '%Y-%m-%d').date()
        
        # Responsable
        responsable_id = request.form.get('responsable_id')
        plan_action.responsable_id = int(responsable_id) if responsable_id else None
        
        # Pourcentage
        pourcentage = request.form.get('pourcentage_realisation')
        if pourcentage:
            plan_action.pourcentage_realisation = int(pourcentage)
        
        plan_action.updated_at = datetime.utcnow()
        db.session.commit()
        
        flash('Plan d\'action modifi√© avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la modification: {str(e)}', 'error')
    
    return redirect(url_for('detail_plan_action', plan_id=plan_id))

@app.route('/audit/rapports/comparaison')
@login_required
def rapport_comparaison_audits():
    """Rapport de comparaison entre audits"""
    audits = Audit.query.filter_by(is_archived=False).all()
    
    # Calculer les statistiques pour la comparaison
    comparaison_data = []
    
    for audit in audits:
        stats = {
            'audit': audit,
            'nb_constatations': len(audit.constatations),
            'nb_recommandations': len(audit.recommandations),
            'nb_plans_action': len(audit.plans_action),
            'taux_realisation': audit.taux_realisation_recommandations,
            'score_global': audit.score_global
        }
        comparaison_data.append(stats)
    
    return render_template('audit/rapport_comparaison.html', 
                         audits=audits,
                         comparaison_data=comparaison_data)



@app.route('/api/audit/<int:audit_id>/timeline')
@login_required
def api_timeline_audit(audit_id):
    """API pour la timeline de l'audit"""
    audit = Audit.query.get_or_404(audit_id)
    
    timeline = []
    
    # Date de cr√©ation
    timeline.append({
        'date': audit.created_at.isoformat(),
        'type': 'creation',
        'title': 'Audit cr√©√©',
        'description': f'Audit {audit.reference} cr√©√© par {audit.created_by_user.username if audit.created_by_user else "Syst√®me"}'
    })
    
    # Constatations
    for constat in audit.constatations:
        timeline.append({
            'date': constat.created_at.isoformat(),
            'type': 'constatation',
            'title': f'Constatation {constat.reference}',
            'description': constat.description[:100] + '...' if len(constat.description) > 100 else constat.description
        })
    
    # Recommandations
    for reco in audit.recommandations:
        timeline.append({
            'date': reco.created_at.isoformat(),
            'type': 'recommandation',
            'title': f'Recommandation',
            'description': reco.description[:100] + '...' if len(reco.description) > 100 else reco.description
        })
    
    # Trier par date
    timeline.sort(key=lambda x: x['date'])
    
    return jsonify({'timeline': timeline})



@app.route('/audit/<int:audit_id>/matrice-maturite/ajouter', methods=['POST'])
@csrf.exempt
@login_required
def ajouter_matrice_maturite(audit_id):
    """Ajouter une matrice de maturit√©"""
    audit = Audit.query.get_or_404(audit_id)
    
    form = MatriceMaturiteForm()
    
    # Pr√©parer les choix pour le formulaire si n√©cessaire
    # form.nom_du_champ.choices = [...]
    
    if form.validate_on_submit():
        matrice = MatriceMaturite(
            audit_id=audit_id,
            axe=form.axe.data,
            critere=form.critere.data,
            niveau_maturite=form.niveau_maturite.data,
            commentaire=form.commentaire.data,
            poids=form.poids.data or 1.0,
            created_by=current_user.id
        )
        
        db.session.add(matrice)
        db.session.commit()
        
        flash('Matrice de maturit√© ajout√©e avec succ√®s', 'success')
    else:
        # Afficher les erreurs de validation
        for field, errors in form.errors.items():
            for error in errors:
                flash(f'Erreur {field}: {error}', 'error')
    
    return redirect(url_for('matrice_maturite_audit', audit_id=audit_id))

# ============================================================================
# ROUTES POUR LA GESTION DES FICHIERS (SUPPRESSION ET MODIFICATION)
# ============================================================================

@app.route('/delete/file/<path:filename>', methods=['POST'])
@csrf.exempt
@login_required
def delete_file(filename):
    """Supprimer un fichier"""
    try:
        # D√©terminer le type de fichier et le dossier
        if filename.startswith('preuve_'):
            upload_folder = 'static/uploads/preuves'
        elif filename.startswith('audit_'):
            upload_folder = 'static/uploads/audits'
        else:
            upload_folder = 'static/uploads'
        
        file_path = os.path.join(upload_folder, filename)
        
        # V√©rifier si le fichier existe
        if not os.path.exists(file_path):
            return jsonify({'success': False, 'message': 'Fichier non trouv√©'}), 404
        
        # Supprimer le fichier
        os.remove(file_path)
        
        # Journaliser l'action
        if current_user.is_authenticated:
            print(f"üóëÔ∏è Fichier supprim√©: {filename} par {current_user.username}")
        
        return jsonify({'success': True, 'message': 'Fichier supprim√© avec succ√®s'})
        
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/delete/constatation-preuve/<int:constatation_id>/<path:filename>', methods=['POST'])
@csrf.exempt
@login_required
def delete_constatation_preuve(constatation_id, filename):
    """Supprimer une preuve d'une constatation"""
    constatation = Constatation.query.get_or_404(constatation_id)
    
    try:
        # Chemin du fichier
        upload_folder = 'static/uploads/preuves'
        file_path = os.path.join(upload_folder, filename)
        
        # V√©rifier si le fichier existe
        if not os.path.exists(file_path):
            return jsonify({'success': False, 'message': 'Fichier non trouv√©'}), 404
        
        # Supprimer le fichier physique
        os.remove(file_path)
        
        # Supprimer de la liste des preuves de la constatation
        if constatation.preuves:
            preuves_list = constatation.get_preuves_list
            preuves_list = [p for p in preuves_list if p != filename]
            constatation.preuves = ','.join(preuves_list) if preuves_list else None
            
            constatation.updated_at = datetime.utcnow()
            db.session.commit()
        
        # Journaliser
        journaliser_action_audit(
            audit_id=constatation.audit_id,
            action_type='delete_preuve_constatation',
            user_id=current_user.id,
            details={'filename': filename, 'constatation': constatation.reference}
        )
        
        return jsonify({'success': True, 'message': 'Preuve supprim√©e avec succ√®s'})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/rename/file/<path:old_filename>', methods=['POST'])
@csrf.exempt
@login_required
def rename_file(old_filename):
    """Renommer un fichier"""
    try:
        new_name = request.form.get('new_name', '').strip()
        if not new_name:
            return jsonify({'success': False, 'message': 'Nouveau nom requis'}), 400
        
        # S√©curiser le nouveau nom
        new_name = secure_filename(new_name)
        
        # D√©terminer le dossier
        if old_filename.startswith('preuve_'):
            upload_folder = 'static/uploads/preuves'
        elif old_filename.startswith('audit_'):
            upload_folder = 'static/uploads/audits'
        else:
            upload_folder = 'static/uploads'
        
        old_path = os.path.join(upload_folder, old_filename)
        new_path = os.path.join(upload_folder, new_name)
        
        # V√©rifier si l'ancien fichier existe
        if not os.path.exists(old_path):
            return jsonify({'success': False, 'message': 'Fichier non trouv√©'}), 404
        
        # V√©rifier si le nouveau nom existe d√©j√†
        if os.path.exists(new_path):
            return jsonify({'success': False, 'message': 'Un fichier avec ce nom existe d√©j√†'}), 400
        
        # Renommer le fichier
        os.rename(old_path, new_path)
        
        # Mettre √† jour les r√©f√©rences dans la base de donn√©es si n√©cessaire
        # (pour les preuves de constatations)
        if old_filename.startswith('preuve_'):
            # Trouver toutes les constatations qui r√©f√©rencent ce fichier
            constatations = Constatation.query.filter(
                Constatation.preuves.like(f'%{old_filename}%')
            ).all()
            
            for constatation in constatations:
                if constatation.preuves:
                    preuves_list = constatation.get_preuves_list
                    updated_list = []
                    for preuve in preuves_list:
                        if preuve == old_filename:
                            updated_list.append(new_name)
                        else:
                            updated_list.append(preuve)
                    
                    constatation.preuves = ','.join(updated_list)
                    constatation.updated_at = datetime.utcnow()
            
            db.session.commit()
        
        return jsonify({'success': True, 'message': 'Fichier renomm√© avec succ√®s', 'new_name': new_name})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/replace/file/<path:filename>', methods=['POST'])
@csrf.exempt
@login_required
def replace_file(filename):
    """Remplacer un fichier existant par un nouveau"""
    try:
        if 'new_file' not in request.files:
            return jsonify({'success': False, 'message': 'Aucun fichier fourni'}), 400
        
        new_file = request.files['new_file']
        
        if new_file.filename == '':
            return jsonify({'success': False, 'message': 'Aucun fichier s√©lectionn√©'}), 400
        
        # V√©rifier le type de fichier
        if not allowed_file(new_file.filename):
            return jsonify({'success': False, 'message': 'Type de fichier non autoris√©'}), 400
        
        # D√©terminer le dossier
        if filename.startswith('preuve_'):
            upload_folder = 'static/uploads/preuves'
        elif filename.startswith('audit_'):
            upload_folder = 'static/uploads/audits'
        else:
            upload_folder = 'static/uploads'
        
        old_path = os.path.join(upload_folder, filename)
        
        # V√©rifier si l'ancien fichier existe
        if not os.path.exists(old_path):
            return jsonify({'success': False, 'message': 'Fichier original non trouv√©'}), 404
        
        # Sauvegarder le chemin du fichier avant suppression
        file_dir = os.path.dirname(old_path)
        
        # Supprimer l'ancien fichier
        os.remove(old_path)
        
        # Sauvegarder le nouveau fichier avec le m√™me nom
        new_file.save(old_path)
        
        return jsonify({'success': True, 'message': 'Fichier remplac√© avec succ√®s'})
        
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


# ========================
# ROUTES PRINCIPALES QUESTIONNAIRE
# ========================



@app.route('/questionnaires')
@login_required
def liste_questionnaires():
    """Liste des questionnaires avec isolation"""
    
    # V√âRIFICATION FORMULE : v√©rifier si le client a acc√®s au module "questionnaires"
    if current_user.client and current_user.client.formule:
        formule = current_user.client.formule
        
        # V√©rifier si la formule donne acc√®s au module "questionnaires"
        if not formule.can_access_module('questionnaires'):
            # Afficher une page d'upgrade
            try:
                # R√©cup√©rer toutes les formules actives
                all_formules = FormuleAbonnement.query.filter(
                    FormuleAbonnement.is_active == True
                ).all()
                
                # Filtrer celles qui ont le module questionnaires
                upgrade_suggestions = []
                for f in all_formules:
                    if f.modules.get('questionnaires', False):
                        upgrade_suggestions.append(f)
                
                # Trier par prix
                upgrade_suggestions.sort(key=lambda x: x.prix_mensuel or 0)
                
                return render_template('errors/formule_restricted.html', 
                                     module_name='Questionnaires',
                                     current_formule=formule,
                                     upgrade_suggestions=upgrade_suggestions[:3])
                
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur recherche formules upgrade: {e}")
                flash('Ce module n\'est pas inclus dans votre formule actuelle', 'error')
                return redirect(url_for('dashboard'))
    
    # V√©rifier la permission de g√©rer les questionnaires (si applicable)
    # Note: Vous devriez avoir une permission comme 'can_manage_questionnaires'
    # if not current_user.has_permission('can_manage_questionnaires'):
    #     flash('Acc√®s refus√© : permission requise', 'error')
    #     return redirect(url_for('dashboard'))
    
    # CORRECTION : Utiliser get_client_filter
    questionnaires = get_client_filter(Questionnaire)\
        .order_by(Questionnaire.date_creation.desc())\
        .all()
    
    # V√©rifier l'acc√®s pour chaque questionnaire
    accessible_questionnaires = []
    for questionnaire in questionnaires:
        if check_client_access(questionnaire):
            accessible_questionnaires.append(questionnaire)
    
    # Calculer des statistiques (optionnel)
    # CORRECTION : Utiliser est_actif au lieu de statut
    stats = {
        'total': len(accessible_questionnaires),
        'actifs': len([q for q in accessible_questionnaires if q.est_actif]),  # Utiliser est_actif
        'publics': len([q for q in accessible_questionnaires if q.est_public]),
        # Supprimer les r√©f√©rences √† q.statut qui n'existe pas
        # Si vous voulez calculer les questionnaires en cours et termin√©s,
        # vous devrez utiliser les dates ou ajouter une propri√©t√© au mod√®le
    }
    
    return render_template('questionnaire/liste.html', 
                         questionnaires=accessible_questionnaires,
                         stats=stats,
                         current_user=current_user)


@app.route('/questionnaires/nouveau', methods=['GET', 'POST'])
@csrf.exempt
@login_required
def nouveau_questionnaire():
    """Cr√©er un nouveau questionnaire avec notification"""
    form = QuestionnaireForm()
    
    if request.method == 'POST':
        print("üìù Donn√©es POST re√ßues pour questionnaire")
        
        if form.validate_on_submit():
            print(f"‚úÖ Formulaire valid√©")
            
            try:
                # V√©rifier si le code existe d√©j√†
                questionnaire_existant = Questionnaire.query.filter_by(code=form.code.data).first()
                if questionnaire_existant:
                    flash('Ce code est d√©j√† utilis√©. Veuillez en choisir un autre.', 'error')
                    return render_template('questionnaire/nouveau.html', form=form)
                
                # Cr√©er le nouveau questionnaire
                questionnaire = Questionnaire(
                    titre=form.titre.data.strip(),
                    description=form.description.data.strip() if form.description.data else None,
                    code=form.code.data.strip().upper().replace(' ', '-'),
                    instructions=form.instructions.data.strip() if form.instructions.data else None,
                    est_actif=form.est_actif.data,
                    est_public=form.est_public.data,
                    date_debut=form.date_debut.data if form.date_debut.data else None,
                    date_fin=form.date_fin.data if form.date_fin.data else None,
                    temps_estime=form.temps_estime.data if form.temps_estime.data else None,
                    redirection_url=form.redirection_url.data.strip() if form.redirection_url.data else None,
                    autoriser_sauvegarde_partielle=form.autoriser_sauvegarde_partielle.data,
                    afficher_barre_progression=form.afficher_barre_progression.data,
                    afficher_numero_questions=form.afficher_numero_questions.data,
                    randomiser_questions=form.randomiser_questions.data,
                    randomiser_options=form.randomiser_options.data,
                    limit_une_reponse=form.limit_une_reponse.data,
                    collecter_email=form.collecter_email.data,
                    collecter_nom=form.collecter_nom.data,
                    notification_email=form.notification_email.data,
                    email_notification=form.email_notification.data.strip() if form.email_notification.data else None,
                    confirmation_message=form.confirmation_message.data.strip() if form.confirmation_message.data else None,
                    created_by=current_user.id
                )
                
                db.session.add(questionnaire)
                db.session.flush()
                
                # ==================== NOTIFICATION SUCCESS ====================
                try:
                    from services.notification_service import NotificationService
                    from models import Notification
                    
                    NotificationService.create(
                        destinataire_id=current_user.id,
                        type_notif=Notification.TYPE_SUCCESS,
                        titre=f"Questionnaire cr√©√©: {questionnaire.titre}",
                        message=f"Le questionnaire {questionnaire.code} a √©t√© cr√©√© avec succ√®s",
                        entite_type='questionnaire',
                        entite_id=questionnaire.id,
                        metadata={
                            'code': questionnaire.code,
                            'statut': 'actif' if questionnaire.est_actif else 'inactif',
                            'public': 'public' if questionnaire.est_public else 'priv√©'
                        },
                        user_id=current_user.id
                    )
                except ImportError:
                    # Ancien syst√®me
                    from models import Notification
                    notif = Notification(
                        type_notification='success',
                        titre=f"Questionnaire cr√©√©",
                        message=f"Le questionnaire {questionnaire.code} a √©t√© cr√©√© avec succ√®s",
                        destinataire_id=current_user.id,
                        entite_type='questionnaire',
                        entite_id=questionnaire.id
                    )
                    db.session.add(notif)
                # ==============================================================
                
                db.session.commit()
                
                flash('Questionnaire cr√©√© avec succ√®s! Vous pouvez maintenant ajouter des questions.', 'success')
                return redirect(url_for('editer_questionnaire', id=questionnaire.id))
                
            except Exception as e:
                db.session.rollback()
                print(f"‚ùå Exception lors de la cr√©ation: {str(e)}")
                import traceback
                print(traceback.format_exc())
                flash(f'Erreur lors de la cr√©ation: {str(e)}', 'error')
        else:
            print(f"‚ùå Validation √©chou√©e")
            if form.errors:
                for field, errors in form.errors.items():
                    for error in errors:
                        flash(f"{getattr(form, field).label.text}: {error}", 'error')
    
    # Si GET ou validation √©chou√©e
    return render_template('questionnaire/nouveau.html', form=form)


@app.route('/questionnaires/<int:id>', methods=['GET', 'POST'])
@login_required
def editer_questionnaire(id):
    """√âditer un questionnaire - Accepte GET et POST"""
    questionnaire = Questionnaire.query.get_or_404(id)
    form_categorie = CategorieQuestionnaireForm()
    
    # G√©rer la soumission du formulaire de mise √† jour si c'est un POST
    if request.method == 'POST':
        return update_questionnaire_post(id)
    
    return render_template('questionnaire/editer.html', 
                         questionnaire=questionnaire,
                         form_categorie=form_categorie)


@app.route('/questionnaires/<int:id>/supprimer', methods=['POST'])
@csrf.exempt
@login_required
def supprimer_questionnaire(id):
    """Supprimer un questionnaire"""
    questionnaire = Questionnaire.query.get_or_404(id)
    
    db.session.delete(questionnaire)
    db.session.commit()
    
    flash('Questionnaire supprim√© avec succ√®s!', 'success')
    return redirect(url_for('liste_questionnaires'))


@app.route('/questionnaires/<int:id>/categorie', methods=['POST'])
@login_required
def ajouter_categorie_questionnaire(id):
    """Ajouter une cat√©gorie au questionnaire"""
    questionnaire = Questionnaire.query.get_or_404(id)
    form = CategorieQuestionnaireForm()
    
    if form.validate_on_submit():
        # V√©rifier si une cat√©gorie avec le m√™me titre existe d√©j√†
        categorie_existante = QuestionnaireCategorie.query.filter_by(
            questionnaire_id=questionnaire.id,
            titre=form.titre.data
        ).first()
        
        if categorie_existante:
            flash('Une cat√©gorie avec ce titre existe d√©j√†.', 'warning')
            return redirect(url_for('editer_questionnaire', id=id))
        
        categorie = QuestionnaireCategorie(
            questionnaire_id=questionnaire.id,
            titre=form.titre.data,
            description=form.description.data,
            ordre=form.ordre.data
        )
        
        db.session.add(categorie)
        db.session.commit()
        
        flash('Cat√©gorie ajout√©e avec succ√®s!', 'success')
    
    return redirect(url_for('editer_questionnaire', id=id))


@app.route('/categorie/<int:id>/question', methods=['POST'])
@login_required
def ajouter_question(id):
    """Ajouter une question √† une cat√©gorie"""
    categorie = QuestionnaireCategorie.query.get_or_404(id)
    
    # Cr√©er un formulaire simple sans WTForms
    texte = request.form.get('texte')
    description = request.form.get('description', '')
    type_question = request.form.get('type', 'text')
    ordre = request.form.get('ordre', 0, type=int)
    est_obligatoire = request.form.get('est_obligatoire') == 'true'
    
    if not texte:
        flash('Le texte de la question est requis.', 'error')
        return redirect(url_for('editer_questionnaire', id=categorie.questionnaire_id))
    
    question = Question(
        categorie_id=categorie.id,
        texte=texte,
        description=description,
        type=type_question,
        ordre=ordre,
        est_obligatoire=est_obligatoire
    )
    
    db.session.add(question)
    db.session.commit()
    
    flash('Question ajout√©e avec succ√®s!', 'success')
    return redirect(url_for('editer_questionnaire', id=categorie.questionnaire_id))


@app.route('/question/<int:id>/option', methods=['POST'])
@login_required
def ajouter_option_question(id):
    """Ajouter une option √† une question"""
    question = Question.query.get_or_404(id)
    form = OptionQuestionForm()
    
    if form.validate_on_submit():
        option = OptionQuestion(
            question_id=question.id,
            valeur=form.valeur.data,
            texte=form.texte.data,
            ordre=form.ordre.data,
            score=form.score.data,
            est_autre=form.est_autre.data
        )
        
        db.session.add(option)
        db.session.commit()
        
        flash('Option ajout√©e avec succ√®s!', 'success')
    
    return redirect(url_for('editer_questionnaire', id=question.categorie.questionnaire_id))


@app.route('/question/<int:id>/condition', methods=['POST'])
@login_required
def ajouter_condition_question(id):
    """Ajouter une condition √† une question"""
    question = Question.query.get_or_404(id)
    form = ConditionQuestionForm()
    form.question_parent_id.choices = [(q.id, q.texte[:50]) 
                                     for q in Question.query.filter_by(categorie_id=question.categorie_id).all()]
    
    if form.validate_on_submit():
        condition = ConditionQuestion(
            question_id=question.id,
            question_parent_id=form.question_parent_id.data,
            operateur=form.operateur.data,
            valeur=form.valeur.data
        )
        
        db.session.add(condition)
        db.session.commit()
        
        flash('Condition ajout√©e avec succ√®s!', 'success')
    
    return redirect(url_for('editer_questionnaire', id=question.categorie.questionnaire_id))

@app.route('/questionnaires/<code>/repondre')
def questionnaire_public(code):
    """Page publique pour r√©pondre au questionnaire"""
    questionnaire = Questionnaire.query.filter_by(code=code, est_actif=True).first_or_404()
    
    if not questionnaire.est_public:
        if not current_user.is_authenticated:
            flash('Ce questionnaire n√©cessite une authentification.', 'warning')
            return redirect(url_for('login', next=request.url))
    
    # V√©rifier les dates
    now = datetime.utcnow()
    if questionnaire.date_debut and now < questionnaire.date_debut:
        flash('Ce questionnaire n\'est pas encore disponible.', 'warning')
        return redirect(url_for('index'))
    
    if questionnaire.date_fin and now > questionnaire.date_fin:
        flash('Ce questionnaire n\'est plus disponible.', 'warning')
        return redirect(url_for('index'))
    
    # G√©n√©rer une session ID
    import uuid
    session_id = request.args.get('session_id') or str(uuid.uuid4())
    
    return render_template('questionnaire/repondre.html',
                         questionnaire=questionnaire,
                         session_id=session_id)



@app.route('/api/questionnaire/<int:id>/repondre', methods=['POST'])
def soumettre_reponse(id):
    """Soumettre une r√©ponse compl√®te au questionnaire"""
    try:
        if not request.is_json:
            return jsonify({'success': False, 'error': 'Content-Type must be application/json'}), 400
            
        data = request.get_json()
        
        questionnaire = Questionnaire.query.get_or_404(id)
        session_id = data.get('session_id')
        
        if not session_id:
            return jsonify({'success': False, 'error': 'session_id requis'}), 400
        
        # Cr√©er ou r√©cup√©rer la r√©ponse
        reponse = ReponseQuestionnaire.query.filter_by(
            questionnaire_id=id,
            session_id=session_id
        ).first()
        
        if not reponse:
            reponse = ReponseQuestionnaire(
                questionnaire_id=id,
                session_id=session_id,
                ip_address=request.remote_addr,
                user_agent=request.user_agent.string,
                email_repondant=data.get('email'),
                nom_repondant=data.get('nom'),
                statut='en_cours'
            )
            db.session.add(reponse)
        
        db.session.flush()
        
        # Enregistrer les r√©ponses
        reponses = data.get('reponses', {})
        for q_id_str, reponse_data in reponses.items():
            try:
                question_id = int(q_id_str)
                question = Question.query.get(question_id)
                if not question:
                    continue
                
                # V√©rifier si une r√©ponse existe d√©j√†
                reponse_q = ReponseQuestion.query.filter_by(
                    reponse_questionnaire_id=reponse.id,
                    question_id=question.id
                ).first()
                
                if not reponse_q:
                    reponse_q = ReponseQuestion(
                        reponse_questionnaire_id=reponse.id,
                        question_id=question.id
                    )
                    db.session.add(reponse_q)
                
                # Sauvegarder selon le type de question
                if question.type in ['text', 'textarea', 'email', 'radio', 'select', 'yesno']:
                    reponse_q.valeur_texte = str(reponse_data) if reponse_data is not None else None
                elif question.type in ['number', 'rating', 'range']:
                    if reponse_data is not None and reponse_data != '':
                        try:
                            reponse_q.valeur_numerique = float(reponse_data)
                        except (ValueError, TypeError):
                            reponse_q.valeur_numerique = None
                    else:
                        reponse_q.valeur_numerique = None
                elif question.type == 'date':
                    if reponse_data:
                        try:
                            reponse_q.valeur_date = datetime.fromisoformat(reponse_data.replace('Z', '+00:00'))
                        except (ValueError, TypeError):
                            reponse_q.valeur_date = None
                    else:
                        reponse_q.valeur_date = None
                elif question.type == 'checkbox':
                    # Pour les cases √† cocher multiples
                    if isinstance(reponse_data, list):
                        # Supprimer les anciennes options
                        ReponseOption.query.filter_by(reponse_question_id=reponse_q.id).delete()
                        
                        # Ajouter les nouvelles options
                        for opt_id in reponse_data:
                            if opt_id:
                                try:
                                    reponse_option = ReponseOption(
                                        reponse_question_id=reponse_q.id,
                                        option_id=int(opt_id)
                                    )
                                    db.session.add(reponse_option)
                                except (ValueError, TypeError):
                                    continue
            except Exception as e:
                print(f"Erreur traitement question {q_id_str}: {str(e)}")
                continue
        
        # Mettre √† jour le statut
        statut = data.get('statut', 'en_cours')
        reponse.statut = statut
        if statut == 'complet':
            reponse.date_fin = datetime.utcnow()
            if reponse.date_debut:
                reponse.duree = int((reponse.date_fin - reponse.date_debut).total_seconds())
        
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'R√©ponse sauvegard√©e'})
        
    except Exception as e:
        db.session.rollback()
        print(f"Erreur soumettre_reponse: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500



@app.route('/questionnaires/<int:id>/update', methods=['POST'])
@login_required
def update_questionnaire(id):
    """Mettre √† jour un questionnaire - VERSION CORRIG√âE"""
    questionnaire = Questionnaire.query.get_or_404(id)
    
    questionnaire.titre = request.form.get('titre', questionnaire.titre)
    questionnaire.description = request.form.get('description', questionnaire.description)
    questionnaire.instructions = request.form.get('instructions', questionnaire.instructions)
    questionnaire.code = request.form.get('code', questionnaire.code)
    questionnaire.est_actif = 'est_actif' in request.form
    questionnaire.est_public = 'est_public' in request.form
    
    # CORRECTION : R√©cup√©rer les champs de collecte nom/email
    questionnaire.collecter_nom = 'collecter_nom' in request.form
    questionnaire.collecter_email = 'collecter_email' in request.form
    
    # Autres champs
    if 'date_debut' in request.form and request.form['date_debut']:
        questionnaire.date_debut = datetime.strptime(request.form['date_debut'], '%Y-%m-%dT%H:%M')
    
    if 'date_fin' in request.form and request.form['date_fin']:
        questionnaire.date_fin = datetime.strptime(request.form['date_fin'], '%Y-%m-%dT%H:%M')
    
    questionnaire.temps_estime = request.form.get('temps_estime', type=int)
    questionnaire.redirection_url = request.form.get('redirection_url')
    questionnaire.autoriser_sauvegarde_partielle = 'autoriser_sauvegarde_partielle' in request.form
    questionnaire.afficher_barre_progression = 'afficher_barre_progression' in request.form
    questionnaire.afficher_numero_questions = 'afficher_numero_questions' in request.form
    questionnaire.randomiser_questions = 'randomiser_questions' in request.form
    questionnaire.randomiser_options = 'randomiser_options' in request.form
    questionnaire.limit_une_reponse = 'limit_une_reponse' in request.form
    questionnaire.notification_email = 'notification_email' in request.form
    questionnaire.email_notification = request.form.get('email_notification')
    questionnaire.confirmation_message = request.form.get('confirmation_message')
    
    db.session.commit()
    flash('Questionnaire mis √† jour avec succ√®s!', 'success')
    return redirect(url_for('editer_questionnaire', id=questionnaire.id))

@app.route('/api/questionnaire/<int:id>/debug')
@login_required
def debug_questionnaire(id):
    """Debug: V√©rifier la configuration d'un questionnaire"""
    questionnaire = Questionnaire.query.get_or_404(id)
    
    return jsonify({
        'id': questionnaire.id,
        'titre': questionnaire.titre,
        'collecter_nom': questionnaire.collecter_nom,
        'collecter_email': questionnaire.collecter_email,
        'est_actif': questionnaire.est_actif,
        'est_public': questionnaire.est_public,
        'reponses': [
            {
                'id': r.id,
                'nom_repondant': r.nom_repondant,
                'email_repondant': r.email_repondant,
                'statut': r.statut
            }
            for r in questionnaire.reponses[:10]  # 10 premi√®res r√©ponses
        ],
        'nombre_reponses': len(questionnaire.reponses)
    })

@app.route('/questionnaires/<int:id>/reponses')
@login_required
def voir_reponses_questionnaire(id):
    """Voir les r√©ponses d'un questionnaire avec filtres"""
    questionnaire = Questionnaire.query.get_or_404(id)
    
    # R√©cup√©rer les param√®tres de filtrage
    statut = request.args.get('statut')
    date_debut = request.args.get('date_debut')
    date_fin = request.args.get('date_fin')
    page = request.args.get('page', 1, type=int)
    per_page = 20
    
    # Construire la requ√™te avec filtres
    query = ReponseQuestionnaire.query.filter_by(questionnaire_id=id)
    
    if statut:
        query = query.filter_by(statut=statut)
    
    if date_debut:
        try:
            date_obj = datetime.strptime(date_debut, '%Y-%m-%d')
            query = query.filter(ReponseQuestionnaire.date_debut >= date_obj)
        except ValueError:
            pass
    
    if date_fin:
        try:
            date_obj = datetime.strptime(date_fin, '%Y-%m-%d')
            # Ajouter un jour pour inclure toute la journ√©e
            date_obj = date_obj + timedelta(days=1)
            query = query.filter(ReponseQuestionnaire.date_debut <= date_obj)
        except ValueError:
            pass
    
    # Pagination
    reponses_paginated = query.order_by(ReponseQuestionnaire.date_debut.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    # Statistiques
    total_reponses = query.count()
    reponses_completes = query.filter_by(statut='complet').count()
    reponses_en_cours = query.filter_by(statut='en_cours').count()
    reponses_abandonnees = query.filter_by(statut='abandonne').count()
    
    return render_template('questionnaire/reponses.html',
                         questionnaire=questionnaire,
                         reponses=reponses_paginated.items,
                         page=page,
                         total_pages=reponses_paginated.pages,
                         has_next=reponses_paginated.has_next,
                         has_prev=reponses_paginated.has_prev,
                         total_reponses=total_reponses,
                         reponses_completes=reponses_completes,
                         reponses_en_cours=reponses_en_cours,
                         reponses_abandonnees=reponses_abandonnees)


@app.route('/reponse/<int:id>')
@login_required
def detail_reponse(id):
    """D√©tail d'une r√©ponse"""
    reponse = ReponseQuestionnaire.query.get_or_404(id)
    
    return render_template('questionnaire/detail_reponse.html',
                         reponse=reponse)


@app.route('/questionnaires/<int:id>/stats')
@login_required
def statistiques_questionnaire(id):
    """Afficher les statistiques d'un questionnaire"""
    questionnaire = Questionnaire.query.get_or_404(id)
    
    # R√©cup√©rer toutes les r√©ponses
    reponses = ReponseQuestionnaire.query.filter_by(
        questionnaire_id=id
    ).all()
    
    # Calculer les statistiques de base
    total_reponses = len(reponses)
    reponses_completes = sum(1 for r in reponses if r.statut == 'complet')
    
    stats = {
        'total_reponses': total_reponses,
        'reponses_completes': reponses_completes,
        'taux_completion': (reponses_completes / total_reponses * 100) if total_reponses > 0 else 0
    }
    
    # Statistiques par question
    questions_stats = []
    for categorie in questionnaire.categories:
        for question in categorie.questions:
            # R√©cup√©rer les r√©ponses pour cette question
            reponses_question = ReponseQuestion.query.join(ReponseQuestionnaire).filter(
                ReponseQuestionnaire.questionnaire_id == id,
                ReponseQuestion.question_id == question.id
            ).all()
            
            total = len(reponses_question)
            details = None
            
            if total > 0:
                if question.type in ['radio', 'select', 'checkbox']:
                    # Distribution des options
                    distribution = {}
                    for rep in reponses_question:
                        if rep.valeur_texte:
                            distribution[rep.valeur_texte] = distribution.get(rep.valeur_texte, 0) + 1
                    details = distribution
                
                elif question.type == 'number':
                    # Statistiques num√©riques
                    valeurs = [r.valeur_numerique for r in reponses_question if r.valeur_numerique is not None]
                    if valeurs:
                        details = {
                            'moyenne': sum(valeurs) / len(valeurs),
                            'min': min(valeurs),
                            'max': max(valeurs),
                            'median': sorted(valeurs)[len(valeurs) // 2] if valeurs else 0
                        }
            
            # Type d'affichage
            type_display_map = {
                'text': 'Texte court',
                'textarea': 'Texte long',
                'radio': 'Choix unique',
                'checkbox': 'Choix multiple',
                'select': 'Liste d√©roulante',
                'date': 'Date',
                'email': 'Email',
                'number': 'Nombre',
                'range': '√âchelle',
                'rating': '√âvaluation',
                'yesno': 'Oui/Non'
            }
            
            questions_stats.append({
                'question': question.texte[:100] + ('...' if len(question.texte) > 100 else ''),
                'type': question.type,
                'type_display': type_display_map.get(question.type, question.type),
                'total_reponses': total,
                'details': details
            })
    
    return render_template('questionnaire/stats.html',
                         questionnaire=questionnaire,
                         stats=stats,
                         questions_stats=questions_stats)

def exporter_json_questionnaire(questionnaire, form):
    """Exporter un questionnaire au format JSON"""
    print(f"üìä G√©n√©ration JSON pour questionnaire {questionnaire.id}")
    
    data = {
        'titre': questionnaire.titre,
        'description': questionnaire.description,
        'code': questionnaire.code,
        'instructions': questionnaire.instructions,
        'date_creation': questionnaire.date_creation.isoformat() if questionnaire.date_creation else None,
        'est_actif': questionnaire.est_actif,
        'est_public': questionnaire.est_public,
    }
    
    if form.inclure_questions.data:
        data['categories'] = []
        for categorie in questionnaire.categories:
            cat_data = {
                'titre': categorie.titre,
                'description': categorie.description,
                'ordre': categorie.ordre,
                'questions': []
            }
            
            for question in categorie.questions:
                q_data = {
                    'texte': question.texte,
                    'description': question.description,
                    'type': question.type,
                    'ordre': question.ordre,
                    'est_obligatoire': question.est_obligatoire,
                    'options': [{
                        'valeur': option.valeur,
                        'texte': option.texte,
                        'ordre': option.ordre,
                        'score': option.score
                    } for option in question.options]
                }
                cat_data['questions'].append(q_data)
            
            data['categories'].append(cat_data)
    
    if form.inclure_reponses.data:
        # Filtrer les r√©ponses par date
        reponses_filtrees = questionnaire.reponses
        if form.date_debut.data:
            reponses_filtrees = [r for r in reponses_filtrees if r.date_debut and r.date_debut.date() >= form.date_debut.data]
        if form.date_fin.data:
            reponses_filtrees = [r for r in reponses_filtrees if r.date_debut and r.date_debut.date() <= form.date_fin.data]
        
        data['reponses'] = []
        for reponse in reponses_filtrees:
            rep_data = {
                'session_id': reponse.session_id,
                'statut': reponse.statut,
                'date_debut': reponse.date_debut.isoformat() if reponse.date_debut else None,
                'date_fin': reponse.date_fin.isoformat() if reponse.date_fin else None,
                'duree': reponse.duree,
                'email_repondant': reponse.email_repondant,
                'nom_repondant': reponse.nom_repondant,
            }
            data['reponses'].append(rep_data)
    
    # Cr√©er la r√©ponse
    response = make_response(json.dumps(data, indent=2, ensure_ascii=False, default=str))
    response.headers['Content-Type'] = 'application/json'
    response.headers['Content-Disposition'] = f'attachment; filename=questionnaire_{questionnaire.code}_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json'
    return response

def exporter_csv_reponses(questionnaire, form):
    """Exporter les r√©ponses au format CSV"""
    print(f"üìä G√©n√©ration CSV pour questionnaire {questionnaire.id}")
    
    # Filtrer les r√©ponses par date
    reponses_filtrees = questionnaire.reponses
    if form.date_debut.data:
        reponses_filtrees = [r for r in reponses_filtrees if r.date_debut and r.date_debut.date() >= form.date_debut.data]
    if form.date_fin.data:
        reponses_filtrees = [r for r in reponses_filtrees if r.date_debut and r.date_debut.date() <= form.date_fin.data]
    
    # Cr√©er le CSV
    output = io.StringIO()
    writer = csv.writer(output)
    
    # En-t√™tes
    headers = ['Session ID', 'Statut', 'Date d√©but', 'Date fin', 'Dur√©e (s)', 'Email', 'Nom', 'IP']
    writer.writerow(headers)
    
    # Donn√©es
    for reponse in reponses_filtrees:
        row = [
            reponse.session_id or '',
            reponse.statut or '',
            reponse.date_debut.strftime('%Y-%m-%d %H:%M:%S') if reponse.date_debut else '',
            reponse.date_fin.strftime('%Y-%m-%d %H:%M:%S') if reponse.date_fin else '',
            reponse.duree or '',
            reponse.email_repondant or '',
            reponse.nom_repondant or '',
            reponse.ip_address or '',
        ]
        writer.writerow(row)
    
    # Cr√©er la r√©ponse
    response = make_response(output.getvalue())
    response.headers['Content-Type'] = 'text/csv; charset=utf-8'
    response.headers['Content-Disposition'] = f'attachment; filename=reponses_{questionnaire.code}_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv'
    return response

def exporter_excel_reponses_simple(questionnaire, form):
    """Exporter les r√©ponses au format Excel (CSV renomm√©)"""
    print(f"üìä G√©n√©ration Excel simplifi√©e pour questionnaire {questionnaire.id}")
    
    # Filtrer les r√©ponses par date
    reponses_filtrees = questionnaire.reponses
    if form.date_debut.data:
        reponses_filtrees = [r for r in reponses_filtrees if r.date_debut and r.date_debut.date() >= form.date_debut.data]
    if form.date_fin.data:
        reponses_filtrees = [r for r in reponses_filtrees if r.date_debut and r.date_debut.date() <= form.date_fin.data]
    
    # Cr√©er le CSV
    output = io.StringIO()
    writer = csv.writer(output, delimiter=';')  # Point-virgule pour Excel fran√ßais
    
    # En-t√™tes
    headers = ['Session ID', 'Statut', 'Date d√©but', 'Date fin', 'Dur√©e (s)', 'Email', 'Nom', 'IP']
    writer.writerow(headers)
    
    # Donn√©es
    for reponse in reponses_filtrees:
        row = [
            reponse.session_id or '',
            reponse.statut or '',
            reponse.date_debut.strftime('%d/%m/%Y %H:%M:%S') if reponse.date_debut else '',
            reponse.date_fin.strftime('%d/%m/%Y %H:%M:%S') if reponse.date_fin else '',
            reponse.duree or '',
            reponse.email_repondant or '',
            reponse.nom_repondant or '',
            reponse.ip_address or '',
        ]
        writer.writerow(row)
    
    # Cr√©er la r√©ponse
    response = make_response(output.getvalue())
    # Utiliser l'extension .xls pour ouvrir dans Excel
    response.headers['Content-Type'] = 'application/vnd.ms-excel'
    response.headers['Content-Disposition'] = f'attachment; filename=reponses_{questionnaire.code}_{datetime.now().strftime("%Y%m%d_%H%M%S")}.xls'
    return response

def exporter_pdf_questionnaire_simple(questionnaire, form):
    """Export PDF ultra simple et fiable"""
    print(f"üìä G√©n√©ration PDF simple pour questionnaire {questionnaire.id}")
    
    try:
        from io import BytesIO
        from reportlab.pdfgen import canvas
        from reportlab.lib.pagesizes import A4
        
        buffer = BytesIO()
        c = canvas.Canvas(buffer, pagesize=A4)
        width, height = A4
        
        # Position de d√©part
        y = height - 50  # 50 points du haut
        
        # Titre
        c.setFont("Helvetica-Bold", 16)
        c.drawString(50, y, f"Rapport du questionnaire: {questionnaire.titre}")
        y -= 40
        
        # Informations
        c.setFont("Helvetica", 12)
        c.drawString(50, y, f"Code: {questionnaire.code}")
        y -= 25
        
        if questionnaire.description:
            desc = questionnaire.description[:100] + ('...' if len(questionnaire.description) > 100 else '')
            c.drawString(50, y, f"Description: {desc}")
            y -= 25
        
        c.drawString(50, y, f"Statut: {'Actif' if questionnaire.est_actif else 'Inactif'} | {'Public' if questionnaire.est_public else 'Priv√©'}")
        y -= 25
        
        if questionnaire.date_creation:
            c.drawString(50, y, f"Date cr√©ation: {questionnaire.date_creation.strftime('%d/%m/%Y')}")
            y -= 25
        
        y -= 20
        
        # Ligne s√©paratrice
        c.line(50, y, width - 50, y)
        y -= 30
        
        # Statistiques
        c.setFont("Helvetica-Bold", 14)
        c.drawString(50, y, "Statistiques")
        y -= 25
        
        c.setFont("Helvetica", 11)
        
        # Filtrer les r√©ponses
        reponses_filtrees = questionnaire.reponses
        if form.date_debut.data:
            reponses_filtrees = [r for r in reponses_filtrees if r.date_debut and r.date_debut.date() >= form.date_debut.data]
        if form.date_fin.data:
            reponses_filtrees = [r for r in reponses_filtrees if r.date_debut and r.date_debut.date() <= form.date_fin.data]
        
        total = len(reponses_filtrees)
        completes = len([r for r in reponses_filtrees if r.statut == 'complet'])
        
        c.drawString(70, y, f"Total r√©ponses: {total}")
        y -= 20
        c.drawString(70, y, f"R√©ponses compl√®tes: {completes}")
        y -= 20
        
        if total > 0:
            taux = (completes / total) * 100
            c.drawString(70, y, f"Taux de compl√©tion: {taux:.1f}%")
            y -= 20
        
        y -= 20
        
        # Structure (si demand√©e)
        if form.inclure_questions.data and questionnaire.categories:
            c.setFont("Helvetica-Bold", 14)
            c.drawString(50, y, "Structure du questionnaire")
            y -= 25
            
            c.setFont("Helvetica", 10)
            for categorie in questionnaire.categories:
                # V√©rifier si on a encore de la place
                if y < 100:
                    c.showPage()
                    c.setFont("Helvetica", 10)
                    y = height - 50
                
                c.drawString(70, y, f"Cat√©gorie: {categorie.titre}")
                y -= 20
                
                for question in categorie.questions[:5]:  # Limiter √† 5 questions par cat√©gorie
                    if y < 100:
                        c.showPage()
                        c.setFont("Helvetica", 10)
                        y = height - 50
                    
                    c.drawString(90, y, f"‚Ä¢ {question.texte[:70]}{'...' if len(question.texte) > 70 else ''}")
                    y -= 15
                
                y -= 10
        
        # Pied de page
        c.setFont("Helvetica", 8)
        c.drawString(50, 30, f"G√©n√©r√© le {datetime.now().strftime('%d/%m/%Y √† %H:%M')} | Questionnaire: {questionnaire.code}")
        
        c.save()
        buffer.seek(0)
        
        response = make_response(buffer.getvalue())
        response.headers['Content-Type'] = 'application/pdf'
        response.headers['Content-Disposition'] = f'attachment; filename=rapport_{questionnaire.code}_{datetime.now().strftime("%Y%m%d_%H%M%S")}.pdf'
        return response
        
    except Exception as e:
        print(f"‚ùå Erreur g√©n√©ration PDF simple: {str(e)}")
        import traceback
        traceback.print_exc()
        
        # Derni√®re tentative : PDF minimal
        try:
            buffer = BytesIO()
            c = canvas.Canvas(buffer, pagesize=A4)
            c.drawString(100, 750, f"Rapport: {questionnaire.titre}")
            c.drawString(100, 730, f"Code: {questionnaire.code}")
            c.drawString(100, 710, f"Total r√©ponses: {len(questionnaire.reponses)}")
            c.drawString(100, 690, f"G√©n√©r√© le: {datetime.now().strftime('%d/%m/%Y')}")
            c.save()
            buffer.seek(0)
            
            response = make_response(buffer.getvalue())
            response.headers['Content-Type'] = 'application/pdf'
            response.headers['Content-Disposition'] = f'attachment; filename=rapport_minimal_{questionnaire.code}.pdf'
            return response
            
        except:
            # Si m√™me le PDF minimal √©choue, retourner un CSV
            return exporter_csv_reponses(questionnaire, form)

@app.route('/questionnaires/<int:id>/export', methods=['GET', 'POST'])
@login_required
def exporter_questionnaire(id):
    """Exporter les donn√©es du questionnaire - VERSION CORRIG√âE"""
    from forms import ExportQuestionnaireForm
    questionnaire = Questionnaire.query.get_or_404(id)
    form = ExportQuestionnaireForm()
    
    # Remplir avec les valeurs par d√©faut
    if request.method == 'GET':
        form.format.data = 'csv_reponses'  # Valeur par d√©faut
    
    if form.validate_on_submit():
        print(f"üì§ Export questionnaire {id} - M√©thode: {request.method}")
        print(f"üì• Format choisi: {form.format.data}")
        
        try:
            if form.format.data == 'json':
                return exporter_json_questionnaire(questionnaire, form)
            elif form.format.data == 'csv_reponses':
                return exporter_csv_reponses(questionnaire, form)
            elif form.format.data == 'excel_reponses':
                return exporter_excel_reponses_simple(questionnaire, form)
            elif form.format.data == 'pdf':
                return exporter_pdf_questionnaire_simple(questionnaire, form)
            else:
                flash(f'Format {form.format.data} non pris en charge', 'error')
                return redirect(url_for('exporter_questionnaire', id=id))
                
        except Exception as e:
            print(f"‚ùå Erreur lors de l'export: {e}")
            import traceback
            traceback.print_exc()
            flash(f'Erreur lors de la g√©n√©ration de l\'export: {str(e)}', 'error')
            return redirect(url_for('exporter_questionnaire', id=id))
    
    # Afficher les erreurs de validation
    if form.errors:
        print(f"‚ùå Erreurs de validation: {form.errors}")
        for field, errors in form.errors.items():
            for error in errors:
                flash(f"{getattr(form, field).label.text}: {error}", 'error')
    
    return render_template('questionnaire/export.html',
                         questionnaire=questionnaire,
                         form=form)

@app.route('/questionnaires/<int:id>/repondre', methods=['POST'])
def questionnaire_repondre_post(id):
    """Traiter la soumission directe du formulaire"""
    try:
        questionnaire = Questionnaire.query.get_or_404(id)
        
        # R√©cup√©rer les donn√©es du formulaire
        session_id = request.form.get('session_id')
        if not session_id:
            return redirect(url_for('questionnaire_public', code=questionnaire.code))
        
        # Cr√©er une r√©ponse
        reponse = ReponseQuestionnaire(
            questionnaire_id=questionnaire.id,
            session_id=session_id,
            ip_address=request.remote_addr,
            user_agent=request.user_agent.string,
            statut='complet'
        )
        
        db.session.add(reponse)
        db.session.commit()
        
        flash('Votre r√©ponse a √©t√© enregistr√©e avec succ√®s!', 'success')
        return redirect(url_for('questionnaire_public', code=questionnaire.code, session_id=session_id))
        
    except Exception as e:
        db.session.rollback()
        flash('Une erreur est survenue lors de l\'enregistrement de votre r√©ponse.', 'error')
        return redirect(url_for('questionnaire_public', code=questionnaire.code))
    

@app.route('/questionnaires/import', methods=['GET', 'POST'])
@login_required
def importer_questionnaire():
    """Importer un questionnaire depuis un fichier"""
    form = ImportQuestionnaireForm()
    
    if form.validate_on_submit():
        import json
        fichier = form.fichier.data
        data = json.load(fichier)
        
        # Cr√©er le questionnaire
        questionnaire = Questionnaire(
            titre=data.get('titre'),
            description=data.get('description'),
            code=data.get('code') or f"import-{datetime.now().strftime('%Y%m%d-%H%M%S')}",
            instructions=data.get('instructions'),
            created_by=current_user.id
        )
        db.session.add(questionnaire)
        db.session.commit()
        
        # Importer les cat√©gories
        if form.importer_categories.data:
            for cat_data in data.get('categories', []):
                categorie = QuestionnaireCategorie(
                    questionnaire_id=questionnaire.id,
                    titre=cat_data.get('titre'),
                    description=cat_data.get('description'),
                    ordre=cat_data.get('ordre', 0)
                )
                db.session.add(categorie)
                db.session.commit()
                
                # Importer les questions
                if form.importer_questions.data:
                    for q_data in cat_data.get('questions', []):
                        question = Question(
                            categorie_id=categorie.id,
                            texte=q_data.get('texte'),
                            description=q_data.get('description'),
                            type=q_data.get('type', 'text'),
                            ordre=q_data.get('ordre', 0),
                            est_obligatoire=q_data.get('est_obligatoire', False)
                        )
                        db.session.add(question)
                        db.session.commit()
                        
                        # Importer les options
                        if form.importer_options.data and q_data.get('options'):
                            for opt_data in q_data.get('options'):
                                option = OptionQuestion(
                                    question_id=question.id,
                                    valeur=opt_data.get('valeur'),
                                    texte=opt_data.get('texte'),
                                    ordre=opt_data.get('ordre', 0)
                                )
                                db.session.add(option)
        
        db.session.commit()
        flash('Questionnaire import√© avec succ√®s!', 'success')
        return redirect(url_for('editer_questionnaire', id=questionnaire.id))
    
    return render_template('questionnaire/importer.html', form=form)


# ========================
# FONCTIONS UTILITAIRES
# ========================

def calculer_stats_question(question):
    """Calcule les statistiques pour une question"""
    import statistics
    stats = {
        'question': question.texte,
        'type': question.type,
        'total_reponses': 0,
        'details': {}
    }
    
    # R√©cup√©rer toutes les r√©ponses pour cette question
    reponses = ReponseQuestion.query.filter_by(question_id=question.id).all()
    stats['total_reponses'] = len(reponses)
    
    if question.type in ['radio', 'select', 'checkbox']:
        # Compter les choix
        compteur = {}
        for option in question.options:
            compteur[option.texte] = 0
        
        for reponse in reponses:
            if question.type == 'checkbox':
                # Pour les cases √† cocher multiples
                for rep_option in reponse.options_selectionnees:
                    compteur[rep_option.option.texte] += 1
            else:
                # Pour les choix uniques
                if reponse.valeur_texte:
                    option = OptionQuestion.query.filter_by(
                        question_id=question.id,
                        valeur=reponse.valeur_texte
                    ).first()
                    if option:
                        compteur[option.texte] += 1
        
        stats['details'] = compteur
    
    elif question.type == 'number':
        # Statistiques num√©riques
        valeurs = [r.valeur_numerique for r in reponses if r.valeur_numerique is not None]
        if valeurs:
            stats['details'] = {
                'moyenne': sum(valeurs) / len(valeurs),
                'min': min(valeurs),
                'max': max(valeurs),
                'median': statistics.median(valeurs) if len(valeurs) > 1 else valeurs[0]
            }
    
    return stats


def exporter_json_questionnaire(questionnaire, form):
    """Exporter un questionnaire au format JSON"""
    import json
    from flask import make_response
    
    data = {
        'titre': questionnaire.titre,
        'description': questionnaire.description,
        'code': questionnaire.code,
        'instructions': questionnaire.instructions,
        'categories': []
    }
    
    for categorie in questionnaire.categories:
        cat_data = {
            'titre': categorie.titre,
            'description': categorie.description,
            'ordre': categorie.ordre,
            'questions': []
        }
        
        for question in categorie.questions:
            q_data = {
                'texte': question.texte,
                'description': question.description,
                'type': question.type,
                'ordre': question.ordre,
                'est_obligatoire': question.est_obligatoire,
                'options': []
            }
            
            for option in question.options:
                q_data['options'].append({
                    'valeur': option.valeur,
                    'texte': option.texte,
                    'ordre': option.ordre
                })
            
            cat_data['questions'].append(q_data)
        
        data['categories'].append(cat_data)
    
    response = make_response(json.dumps(data, indent=2, ensure_ascii=False))
    response.headers['Content-Type'] = 'application/json'
    response.headers['Content-Disposition'] = f'attachment; filename=questionnaire_{questionnaire.code}.json'
    return response


# ========================
# API ROUTES QUESTIONNAIRE
# ========================
@app.route('/api/question/<int:id>', methods=['GET'])
@login_required
def api_get_question(id):
    """API: R√©cup√©rer une question"""
    try:
        question = Question.query.get_or_404(id)
        return jsonify({
            'success': True,
            'id': question.id,
            'categorie_id': question.categorie_id,
            'texte': question.texte,
            'description': question.description or '',
            'type': question.type,
            'ordre': question.ordre,
            'est_obligatoire': question.est_obligatoire,
            'options': [{
                'id': option.id,
                'valeur': option.valeur,
                'texte': option.texte,
                'ordre': option.ordre,
                'score': option.score
            } for option in question.options]
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    

@app.route('/api/question', methods=['POST'])
@login_required
def api_create_question():
    """API: Cr√©er une nouvelle question"""
    try:
        if not request.is_json:
            return jsonify({'success': False, 'error': 'Content-Type must be application/json'}), 400
            
        data = request.get_json()
        
        if not data.get('texte'):
            return jsonify({'success': False, 'error': 'Le texte de la question est requis'}), 400
        
        if not data.get('categorie_id'):
            return jsonify({'success': False, 'error': 'L\'ID de cat√©gorie est requis'}), 400
        
        # V√©rifier que la cat√©gorie existe
        categorie = QuestionnaireCategorie.query.get_or_404(data.get('categorie_id'))
        
        question = Question(
            categorie_id=categorie.id,
            texte=data.get('texte'),
            description=data.get('description', ''),
            type=data.get('type', 'text'),
            ordre=data.get('ordre', 0),
            est_obligatoire=data.get('est_obligatoire', False)
        )
        
        db.session.add(question)
        db.session.flush()
        
        # Ajouter les options si fournies
        options = data.get('options', [])
        for i, opt_data in enumerate(options):
            option = OptionQuestion(
                question_id=question.id,
                valeur=opt_data.get('valeur', f'option_{i+1}'),
                texte=opt_data.get('texte', f'Option {i+1}'),
                ordre=opt_data.get('ordre', i)
            )
            db.session.add(option)
        
        db.session.commit()
        
        return jsonify({'success': True, 'question_id': question.id})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/question/<int:id>', methods=['PUT'])
@login_required
def api_update_question(id):
    """API: Mettre √† jour une question"""
    try:
        if not request.is_json:
            return jsonify({'success': False, 'error': 'Content-Type must be application/json'}), 400
            
        data = request.get_json()
        question = Question.query.get_or_404(id)
        
        question.texte = data.get('texte', question.texte)
        question.description = data.get('description', question.description)
        question.type = data.get('type', question.type)
        question.ordre = data.get('ordre', question.ordre)
        question.est_obligatoire = data.get('est_obligatoire', question.est_obligatoire)
        
        # Mettre √† jour les options si fournies
        if 'options' in data:
            # Supprimer les anciennes options
            OptionQuestion.query.filter_by(question_id=question.id).delete()
            
            # Ajouter les nouvelles options
            for i, opt_data in enumerate(data['options']):
                option = OptionQuestion(
                    question_id=question.id,
                    valeur=opt_data.get('valeur', f'option_{i+1}'),
                    texte=opt_data.get('texte', f'Option {i+1}'),
                    ordre=opt_data.get('ordre', i)
                )
                db.session.add(option)
        
        db.session.commit()
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500
    
@app.route('/api/categorie/<int:id>/question', methods=['POST'])
@login_required
def api_add_question(id):
    """API: Ajouter une question via AJAX"""
    try:
        if not request.is_json:
            return jsonify({'success': False, 'error': 'Content-Type must be application/json'}), 400
            
        data = request.get_json()
        
        if not data.get('texte'):
            return jsonify({'success': False, 'error': 'Le texte de la question est requis'}), 400
        
        # V√©rifier que la cat√©gorie existe
        categorie = QuestionnaireCategorie.query.get_or_404(id)
        
        question = Question(
            categorie_id=id,
            texte=data.get('texte'),
            description=data.get('description', ''),
            type=data.get('type', 'text'),
            ordre=data.get('ordre', 0),
            est_obligatoire=data.get('est_obligatoire', False)
        )
        
        db.session.add(question)
        db.session.flush()
        
        # Ajouter les options si fournies
        options = data.get('options', [])
        for i, opt_data in enumerate(options):
            option = OptionQuestion(
                question_id=question.id,
                valeur=opt_data.get('valeur', f'option_{i+1}'),
                texte=opt_data.get('texte', f'Option {i+1}'),
                ordre=opt_data.get('ordre', i)
            )
            db.session.add(option)
        
        db.session.commit()
        
        return jsonify({'success': True, 'question_id': question.id})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


# ========================
# ROUTES API QUESTIONNAIRE
# ========================

# ========================
# ROUTES QUESTIONNAIRE API
# ========================

@app.route('/api/questionnaire/<int:id>/reponse', methods=['POST', 'OPTIONS'])
@csrf.exempt
def api_save_response_route(id):
    """API: Sauvegarder une r√©ponse individuelle - VERSION CORRIG√âE"""
    
    # G√©rer les pr√©-requ√™tes CORS
    if request.method == 'OPTIONS':
        response = make_response()
        response.headers.add('Access-Control-Allow-Origin', '*')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')
        response.headers.add('Access-Control-Allow-Methods', 'POST, OPTIONS')
        return response, 200
    
    try:
        print(f"üì• API SAVE RESPONSE pour questionnaire {id}")
        
        # V√©rifier le Content-Type
        if not request.is_json:
            return jsonify({
                'success': False, 
                'error': 'Content-Type must be application/json'
            }), 400
        
        data = request.get_json()
        print(f"üìä Donn√©es re√ßues: {json.dumps(data, indent=2)}")
        
        # Extraction des champs
        session_id = data.get('session_id')
        question_id = data.get('question_id')
        valeur = data.get('valeur')
        
        if not session_id:
            return jsonify({'success': False, 'error': 'session_id requis'}), 400
        
        if question_id is None:
            return jsonify({'success': False, 'error': 'question_id requis'}), 400
        
        # Convertir question_id en int
        try:
            question_id = int(question_id)
        except (ValueError, TypeError):
            return jsonify({'success': False, 'error': 'question_id doit √™tre un nombre'}), 400
        
        # V√©rifier que le questionnaire existe (m√©thode moderne)
        questionnaire = db.session.get(Questionnaire, id)
        if not questionnaire:
            return jsonify({'success': False, 'error': f'Questionnaire {id} non trouv√©'}), 404
        
        # V√©rifier que la question existe (m√©thode moderne)
        question = db.session.get(Question, question_id)
        if not question:
            return jsonify({'success': False, 'error': f'Question {question_id} non trouv√©e'}), 404
        
        # V√©rifier que la question appartient au questionnaire
        if question.categorie.questionnaire_id != id:
            return jsonify({'success': False, 'error': f'Question {question_id} n\'appartient pas au questionnaire {id}'}), 400
        
        # CORRECTION : Utiliser datetime.now avec timezone
        from datetime import datetime, timezone
        
        # Cr√©er ou r√©cup√©rer la r√©ponse globale
        reponse_questionnaire = ReponseQuestionnaire.query.filter_by(
            questionnaire_id=id,
            session_id=session_id
        ).first()
        
        if not reponse_questionnaire:
            reponse_questionnaire = ReponseQuestionnaire(
                questionnaire_id=id,
                session_id=session_id,
                ip_address=request.remote_addr or '0.0.0.0',
                user_agent=request.user_agent.string[:200] if request.user_agent else '',
                statut='en_cours',
                date_debut=datetime.now(timezone.utc)
            )
            db.session.add(reponse_questionnaire)
            db.session.flush()
            print(f"‚ûï Nouvelle r√©ponse cr√©√©e: {reponse_questionnaire.id}")
        else:
            print(f"üìù R√©ponse existante: {reponse_questionnaire.id}")
        
        # CORRECTION : V√©rifier d'abord si une r√©ponse existe d√©j√† pour cette question
        reponse_question = ReponseQuestion.query.filter_by(
            reponse_questionnaire_id=reponse_questionnaire.id,
            question_id=question_id
        ).first()
        
        if reponse_question:
            print(f"üìù Mise √† jour r√©ponse existante pour Q{question_id}")
        else:
            reponse_question = ReponseQuestion(
                reponse_questionnaire_id=reponse_questionnaire.id,
                question_id=question_id
            )
            db.session.add(reponse_question)
            print(f"‚ûï Nouvelle r√©ponse question cr√©√©e pour Q{question_id}")
        
        # Mettre √† jour la valeur selon le type de question
        if question.type in ['text', 'textarea', 'email', 'radio', 'select', 'yesno']:
            reponse_question.valeur_texte = str(valeur) if valeur is not None else None
        elif question.type in ['number', 'rating', 'range']:
            if valeur is not None and str(valeur).strip() != '':
                try:
                    reponse_question.valeur_numerique = float(valeur)
                except (ValueError, TypeError):
                    reponse_question.valeur_numerique = None
            else:
                reponse_question.valeur_numerique = None
        elif question.type == 'date':
            if valeur:
                try:
                    # G√©rer diff√©rents formats de date
                    if 'T' in str(valeur):
                        reponse_question.valeur_date = datetime.fromisoformat(
                            str(valeur).replace('Z', '+00:00')
                        ).date()
                    else:
                        reponse_question.valeur_date = datetime.strptime(str(valeur), '%Y-%m-%d').date()
                except Exception:
                    reponse_question.valeur_date = None
            else:
                reponse_question.valeur_date = None
        elif question.type == 'checkbox':
            # Supprimer les anciennes options
            ReponseOption.query.filter_by(reponse_question_id=reponse_question.id).delete()
            
            if isinstance(valeur, list):
                for opt_val in valeur:
                    if opt_val:
                        try:
                            option_id = int(opt_val)
                            option = db.session.get(OptionQuestion, option_id)
                            if option and option.question_id == question_id:
                                reponse_option = ReponseOption(
                                    reponse_question_id=reponse_question.id,
                                    option_id=option_id
                                )
                                db.session.add(reponse_option)
                        except (ValueError, TypeError):
                            continue
        
        db.session.commit()
        
        print(f"‚úÖ R√©ponse sauvegard√©e: Q{question_id} = {valeur}")
        
        return jsonify({
            'success': True,
            'message': 'R√©ponse sauvegard√©e',
            'question_id': question_id,
            'session_id': session_id,
            'reponse_id': reponse_questionnaire.id
        }), 200
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur api_save_response: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False, 
            'error': f'Erreur serveur: {str(e)}'
        }), 500



@app.route('/api/questionnaire/<int:id>/repondant', methods=['POST', 'OPTIONS'])
@csrf.exempt
def api_save_respondant(id):
    """API: Sauvegarder les informations du r√©pondant"""
    
    if request.method == 'OPTIONS':
        response = make_response()
        response.headers.add('Access-Control-Allow-Origin', '*')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')
        response.headers.add('Access-Control-Allow-Methods', 'POST, OPTIONS')
        return response, 200
    
    try:
        print(f"üë§ API SAVE RESPONDANT - Questionnaire {id}")
        
        if not request.is_json:
            return jsonify({'success': False, 'error': 'Content-Type must be application/json'}), 400
        
        data = request.get_json()
        print(f"üìä Donn√©es re√ßues: {data}")
        
        session_id = data.get('session_id')
        nom = data.get('nom', '')
        email = data.get('email', '')
        
        if not session_id:
            return jsonify({'success': False, 'error': 'session_id requis'}), 400
        
        # V√©rifier que le questionnaire existe
        questionnaire = db.session.get(Questionnaire, id)
        if not questionnaire:
            return jsonify({'success': False, 'error': f'Questionnaire {id} non trouv√©'}), 404
        
        print(f"üìã Questionnaire: {questionnaire.titre}")
        print(f"‚öôÔ∏è Configuration: collecter_nom={questionnaire.collecter_nom}, collecter_email={questionnaire.collecter_email}")
        
        # Cr√©er ou r√©cup√©rer la r√©ponse
        reponse = ReponseQuestionnaire.query.filter_by(
            questionnaire_id=id,
            session_id=session_id
        ).first()
        
        if not reponse:
            reponse = ReponseQuestionnaire(
                questionnaire_id=id,
                session_id=session_id,
                ip_address=request.remote_addr or '0.0.0.0',
                user_agent=request.user_agent.string[:200] if request.user_agent else '',
                statut='en_cours',
                date_debut=datetime.utcnow()
            )
            db.session.add(reponse)
            print(f"‚ûï Nouvelle r√©ponse cr√©√©e pour r√©pondant")
        
        # Mettre √† jour les infos
        if nom:
            reponse.nom_repondant = nom.strip()
        if email:
            reponse.email_repondant = email.strip()
        
        db.session.commit()
        
        print(f"‚úÖ Infos r√©pondant sauvegard√©es: nom='{nom}', email='{email}'")
        
        return jsonify({
            'success': True,
            'message': 'Informations du r√©pondant sauvegard√©es',
            'nom': nom,
            'email': email,
            'reponse_id': reponse.id
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur api_save_respondant: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/questionnaire/<int:id>/reponses/<session_id>', methods=['GET'])
def api_get_responses(id, session_id):
    """API: R√©cup√©rer les r√©ponses d'une session"""
    try:
        print(f"üì• GET RESPONSES - Questionnaire {id}, Session {session_id}")
        
        reponse = ReponseQuestionnaire.query.filter_by(
            questionnaire_id=id,
            session_id=session_id
        ).first()
        
        if not reponse:
            return jsonify([])
        
        reponses_data = []
        for rep in reponse.reponses:
            rep_data = {
                'question_id': rep.question_id,
                'valeur_texte': rep.valeur_texte,
                'valeur_numerique': rep.valeur_numerique,
                'valeur_date': rep.valeur_date.isoformat() if rep.valeur_date else None
            }
            
            # Pour les questions √† choix multiples
            if rep.question and rep.question.type == 'checkbox' and rep.options_selectionnees:
                rep_data['options'] = [ro.option_id for ro in rep.options_selectionnees]
            
            reponses_data.append(rep_data)
        
        print(f"‚úÖ Retourne {len(reponses_data)} r√©ponses")
        return jsonify(reponses_data)
        
    except Exception as e:
        print(f"‚ùå Erreur api_get_responses: {str(e)}")
        return jsonify([])


@app.route('/api/questionnaire/<int:id>/reponses/<session_id>/statut', methods=['GET'])
def api_statut_reponse(id, session_id):
    """API: V√©rifier le statut d'une r√©ponse"""
    try:
        print(f"üìä GET STATUS - Questionnaire {id}, Session {session_id}")
        
        reponse = ReponseQuestionnaire.query.filter_by(
            questionnaire_id=id,
            session_id=session_id
        ).first()
        
        if not reponse:
            return jsonify({
                'success': True,
                'statut': 'non_trouve',
                'message': 'Aucune r√©ponse trouv√©e pour cette session'
            })
        
        return jsonify({
            'success': True,
            'statut': reponse.statut,
            'nom': reponse.nom_repondant or '',
            'email': reponse.email_repondant or '',
            'date_debut': reponse.date_debut.isoformat() if reponse.date_debut else None,
            'date_fin': reponse.date_fin.isoformat() if reponse.date_fin else None,
            'duree': reponse.duree,
            'reponse_id': reponse.id
        })
        
    except Exception as e:
        print(f"‚ùå Erreur api_statut_reponse: {str(e)}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500
    
@app.route('/api/debug/submit-400', methods=['POST'])
@csrf.exempt
def debug_submit_400():
    """Debug: Pour voir pourquoi la soumission retourne 400"""
    try:
        print("üîç DEBUG SUBMIT 400")
        print(f"üì• Method: {request.method}")
        print(f"üì¶ Content-Type: {request.content_type}")
        print(f"üì¶ Headers: {dict(request.headers)}")
        
        raw_data = request.get_data(as_text=True)
        print(f"üìÑ Donn√©es brutes: {raw_data}")
        
        try:
            data = request.get_json(force=True, silent=True)
            if data:
                print(f"‚úÖ JSON pars√©: {json.dumps(data, indent=2)}")
            else:
                print("‚ùå Impossible de parser JSON")
                data = {}
        except Exception as e:
            print(f"‚ùå Erreur parsing JSON: {e}")
            data = {}
        
        return jsonify({
            'success': True,
            'message': 'Debug OK',
            'content_type': request.content_type,
            'data_received': data,
            'raw_data': raw_data[:500] if raw_data else None
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    
@app.route('/api/questionnaire/<int:id>/repondre', methods=['POST', 'OPTIONS'])
@csrf.exempt
def api_submit_questionnaire(id):
    """API: Soumettre un questionnaire - VERSION ULTRA SIMPLE ET ROBUSTE"""
    
    if request.method == 'OPTIONS':
        response = make_response()
        response.headers.add('Access-Control-Allow-Origin', '*')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')
        response.headers.add('Access-Control-Allow-Methods', 'POST, OPTIONS')
        return response, 200
    
    try:
        print("=" * 80)
        print(f"üöÄ API SUBMIT QUESTIONNAIRE {id} - ULTRA SIMPLE")
        print("=" * 80)
        
        # DEBUG: Montrer ce qui arrive
        print(f"üì¶ Content-Type: {request.content_type}")
        
        # 1. Lire les donn√©es
        data = {}
        try:
            if request.is_json:
                data = request.get_json()
            else:
                raw = request.get_data(as_text=True)
                if raw:
                    data = json.loads(raw)
        except Exception as e:
            print(f"‚ùå JSON error: {e}")
            return jsonify({'success': False, 'error': f'Invalid JSON: {str(e)}'}), 400
        
        print(f"üìä Data received keys: {list(data.keys())}")
        
        # 2. Extraire les champs basiques
        session_id = data.get('session_id', '')
        statut = data.get('statut', 'en_cours')
        nom = data.get('nom', '')
        email = data.get('email', '')
        
        print(f"üìù Extracted: session_id='{session_id}', statut='{statut}', nom='{nom}', email='{email}'")
        
        # 3. Validation minimale
        if not session_id:
            print("‚ùå Missing session_id")
            return jsonify({'success': False, 'error': 'session_id requis'}), 400
        
        # 4. V√©rifier le questionnaire
        questionnaire = Questionnaire.query.get(id)
        if not questionnaire:
            print(f"‚ùå Questionnaire {id} not found")
            return jsonify({'success': False, 'error': f'Questionnaire {id} non trouv√©'}), 404
        
        print(f"‚úÖ Questionnaire: {questionnaire.titre}")
        
        # 5. Validation conditionnelle (SEULEMENT si collecter_nom/email est TRUE)
        if statut == 'complet':
            print("üîç Validation for COMPLETE submission")
            if questionnaire.collecter_nom and not nom:
                print("‚ùå Nom requis mais manquant")
                return jsonify({'success': False, 'error': 'Le nom est requis', 'code': 'NOM_REQUIRED'}), 400
            if questionnaire.collecter_email:
                if not email:
                    print("‚ùå Email requis mais manquant")
                    return jsonify({'success': False, 'error': 'L\'email est requis', 'code': 'EMAIL_REQUIRED'}), 400
                # Validation email simple
                if '@' not in email or '.' not in email:
                    print(f"‚ùå Email invalide: {email}")
                    return jsonify({'success': False, 'error': 'Email invalide', 'code': 'EMAIL_INVALID'}), 400
        
        # 6. Utiliser datetime.now avec timezone
        from datetime import datetime, timezone
        
        # 7. Cr√©er ou r√©cup√©rer la r√©ponse
        reponse = ReponseQuestionnaire.query.filter_by(
            questionnaire_id=id,
            session_id=session_id
        ).first()
        
        if reponse:
            print(f"üìù Existing response: {reponse.id}")
        else:
            reponse = ReponseQuestionnaire(
                questionnaire_id=id,
                session_id=session_id,
                ip_address=request.remote_addr or '0.0.0.0',
                user_agent=request.user_agent.string[:200] if request.user_agent else '',
                statut=statut,
                date_debut=datetime.now(timezone.utc)
            )
            db.session.add(reponse)
            print(f"‚ûï New response created")
        
        # 8. Mettre √† jour les infos
        if nom:
            reponse.nom_repondant = nom.strip()
        if email:
            reponse.email_repondant = email.strip()
        
        reponse.statut = statut
        
        # 9. Si complet, mettre date_fin
        if statut == 'complet':
            reponse.date_fin = datetime.now(timezone.utc)
            if reponse.date_debut:
                reponse.duree = int((reponse.date_fin - reponse.date_debut).total_seconds())
            print(f"‚úÖ Marked as COMPLETE")
        
        # 10. Sauvegarder les r√©ponses si pr√©sentes
        reponses_data = data.get('reponses', {})
        if reponses_data:
            print(f"üíæ Saving {len(reponses_data)} responses...")
            for q_id_str, q_data in reponses_data.items():
                try:
                    q_id = int(q_id_str)
                    valeur = q_data.get('valeur') if isinstance(q_data, dict) else q_data
                    
                    # Chercher r√©ponse existante
                    rep_q = ReponseQuestion.query.filter_by(
                        reponse_questionnaire_id=reponse.id,
                        question_id=q_id
                    ).first()
                    
                    if not rep_q:
                        rep_q = ReponseQuestion(
                            reponse_questionnaire_id=reponse.id,
                            question_id=q_id
                        )
                        db.session.add(rep_q)
                    
                    # Sauvegarder valeur
                    if isinstance(valeur, (list, dict)):
                        rep_q.valeur_texte = json.dumps(valeur)
                    elif valeur is not None:
                        rep_q.valeur_texte = str(valeur)
                    
                    print(f"üìù Q{q_id} saved: {valeur}")
                    
                except Exception as e:
                    print(f"‚ö†Ô∏è Error Q{q_id_str}: {e}")
                    continue
        
        # 11. COMMIT
        db.session.commit()
        
        print(f"üéâ SUCCESS! Response ID: {reponse.id}, Status: {statut}")
        print(f"üìã Info saved - Nom: '{reponse.nom_repondant}', Email: '{reponse.email_repondant}'")
        print("=" * 80)
        
        return jsonify({
            'success': True,
            'message': f'Questionnaire {statut} avec succ√®s',
            'reponse_id': reponse.id,
            'statut': statut,
            'nom': reponse.nom_repondant or '',
            'email': reponse.email_repondant or '',
            'details': {
                'questions_saved': len(reponses_data),
                'duration': reponse.duree if statut == 'complet' else None
            }
        }), 200
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå CRITICAL ERROR: {str(e)}")
        import traceback
        traceback.print_exc()
        print("=" * 80)
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/questionnaire/submit', methods=['POST', 'OPTIONS'])
@csrf.exempt
def api_submit_generic():
    """API g√©n√©rique: Soumettre sans sp√©cifier l'ID dans l'URL - VERSION AM√âLIOR√âE"""
    
    if request.method == 'OPTIONS':
        response = make_response()
        response.headers.add('Access-Control-Allow-Origin', '*')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')
        response.headers.add('Access-Control-Allow-Methods', 'POST, OPTIONS')
        return response, 200
    
    try:
        print("=" * 80)
        print("üöÄ API GENERIC SUBMIT - VERSION AM√âLIOR√âE")
        print("=" * 80)
        
        if not request.is_json:
            return jsonify({'success': False, 'error': 'Content-Type must be application/json'}), 400
        
        data = request.get_json()
        print(f"üìä Donn√©es re√ßues: {json.dumps(data, indent=2)}")
        
        # Extraire l'ID du questionnaire
        questionnaire_id = data.get('questionnaire_id')
        if not questionnaire_id:
            # Essayer de l'extraire du Referer
            referer = request.headers.get('Referer', '')
            import re
            match = re.search(r'/questionnaires/(\d+)/', referer)
            if match:
                questionnaire_id = int(match.group(1))
                print(f"üîç ID extrait du Referer: {questionnaire_id}")
            else:
                return jsonify({'success': False, 'error': 'questionnaire_id requis'}), 400
        
        session_id = data.get('session_id')
        statut = data.get('statut', 'en_cours')
        nom = data.get('nom', '')
        email = data.get('email', '')
        reponses = data.get('reponses', {})
        
        if not session_id:
            return jsonify({'success': False, 'error': 'session_id requis'}), 400
        
        # V√©rifier que le questionnaire existe
        questionnaire = db.session.get(Questionnaire, questionnaire_id)
        if not questionnaire:
            print(f"‚ùå Questionnaire {questionnaire_id} non trouv√©")
            return jsonify({'success': False, 'error': f'Questionnaire {questionnaire_id} non trouv√©'}), 404
        
        print(f"üìã Questionnaire: {questionnaire.titre}")
        print(f"‚öôÔ∏è Configuration: collecter_nom={questionnaire.collecter_nom}, collecter_email={questionnaire.collecter_email}")
        
        from datetime import datetime, timezone
        
        # Cr√©er ou r√©cup√©rer la r√©ponse
        reponse = ReponseQuestionnaire.query.filter_by(
            questionnaire_id=questionnaire_id,
            session_id=session_id
        ).first()
        
        if reponse:
            print(f"üìù R√©ponse existante: {reponse.id}")
            existing_date_debut = reponse.date_debut
        else:
            reponse = ReponseQuestionnaire(
                questionnaire_id=questionnaire_id,
                session_id=session_id,
                ip_address=request.remote_addr or '0.0.0.0',
                user_agent=request.user_agent.string[:200] if request.user_agent else '',
                statut=statut,
                date_debut=datetime.now(timezone.utc)
            )
            db.session.add(reponse)
            existing_date_debut = reponse.date_debut
            print(f"‚ûï Nouvelle r√©ponse cr√©√©e")
        
        # CORRECTION: Toujours mettre √† jour nom et email si fournis
        # Mais ne pas les valider si le questionnaire ne les collecte pas
        if nom:
            reponse.nom_repondant = nom.strip()
        if email:
            reponse.email_repondant = email.strip()
        
        reponse.statut = statut
        
        # Validation conditionnelle UNIQUEMENT pour les soumissions compl√®tes
        if statut == 'complet':
            # V√©rifier les champs requis selon la configuration du questionnaire
            if questionnaire.collecter_nom and not nom:
                print("‚ùå Nom requis mais manquant")
                return jsonify({
                    'success': False, 
                    'error': 'Le nom est requis pour ce questionnaire',
                    'code': 'NOM_REQUIRED'
                }), 400
            
            if questionnaire.collecter_email:
                if not email:
                    print("‚ùå Email requis mais manquant")
                    return jsonify({
                        'success': False, 
                        'error': 'L\'email est requis pour ce questionnaire',
                        'code': 'EMAIL_REQUIRED'
                    }), 400
                # Validation email simple
                if '@' not in email or '.' not in email:
                    print(f"‚ùå Email invalide: {email}")
                    return jsonify({
                        'success': False, 
                        'error': 'Email invalide',
                        'code': 'EMAIL_INVALID'
                    }), 400
            
            # Si validation pass√©e, marquer comme complet
            reponse.date_fin = datetime.now(timezone.utc)
            
            # Calculer la dur√©e
            if existing_date_debut:
                # Assurer que les deux datetimes sont timezone-aware
                if existing_date_debut.tzinfo is None:
                    existing_date_debut = existing_date_debut.replace(tzinfo=timezone.utc)
                
                try:
                    duree = (reponse.date_fin - existing_date_debut).total_seconds()
                    reponse.duree = int(duree)
                    print(f"‚úÖ Dur√©e calcul√©e: {reponse.duree} secondes")
                except Exception as e:
                    print(f"‚ö†Ô∏è Erreur calcul dur√©e: {e}")
                    reponse.duree = 0
            else:
                reponse.duree = 0
                
            print(f"‚úÖ Marqu√© comme COMPLET")
        
        # Sauvegarder les r√©ponses
        for q_id_str, q_data in reponses.items():
            try:
                q_id = int(q_id_str)
                # G√©rer les diff√©rents formats de donn√©es
                if isinstance(q_data, dict):
                    valeur = q_data.get('valeur', q_data)
                else:
                    valeur = q_data
                
                # Chercher r√©ponse existante
                rep_q = ReponseQuestion.query.filter_by(
                    reponse_questionnaire_id=reponse.id,
                    question_id=q_id
                ).first()
                
                if not rep_q:
                    rep_q = ReponseQuestion(
                        reponse_questionnaire_id=reponse.id,
                        question_id=q_id
                    )
                    db.session.add(rep_q)
                
                # Sauvegarder valeur
                if valeur is not None:
                    if isinstance(valeur, (list, dict)):
                        rep_q.valeur_texte = json.dumps(valeur)
                    else:
                        rep_q.valeur_texte = str(valeur)
                else:
                    rep_q.valeur_texte = None
                
                print(f"üìù Q{q_id} sauvegard√©: {valeur}")
                
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur Q{q_id_str}: {e}")
                continue
        
        db.session.commit()
        
        print(f"üéâ SUCC√àS! R√©ponse ID: {reponse.id}")
        print(f"üìã Info - Nom: '{reponse.nom_repondant}', Email: '{reponse.email_repondant}'")
        print("=" * 80)
        
        return jsonify({
            'success': True,
            'message': 'Questionnaire soumis avec succ√®s',
            'reponse_id': reponse.id,
            'statut': statut,
            'nom': reponse.nom_repondant or '',
            'email': reponse.email_repondant or '',
            'details': {
                'questions_saved': len(reponses),
                'duration': reponse.duree if statut == 'complet' else None
            }
        }), 200
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå ERREUR CRITIQUE: {str(e)}")
        import traceback
        traceback.print_exc()
        print("=" * 80)
        return jsonify({'success': False, 'error': str(e)}), 500@app.route('/api/questionnaire/submit', methods=['POST', 'OPTIONS'])
@csrf.exempt
def api_submit_generic():
    """API g√©n√©rique: Soumettre sans sp√©cifier l'ID dans l'URL - VERSION AM√âLIOR√âE"""
    
    if request.method == 'OPTIONS':
        response = make_response()
        response.headers.add('Access-Control-Allow-Origin', '*')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')
        response.headers.add('Access-Control-Allow-Methods', 'POST, OPTIONS')
        return response, 200
    
    try:
        print("=" * 80)
        print("üöÄ API GENERIC SUBMIT - VERSION AM√âLIOR√âE")
        print("=" * 80)
        
        if not request.is_json:
            return jsonify({'success': False, 'error': 'Content-Type must be application/json'}), 400
        
        data = request.get_json()
        print(f"üìä Donn√©es re√ßues: {json.dumps(data, indent=2)}")
        
        # Extraire l'ID du questionnaire
        questionnaire_id = data.get('questionnaire_id')
        if not questionnaire_id:
            # Essayer de l'extraire du Referer
            referer = request.headers.get('Referer', '')
            import re
            match = re.search(r'/questionnaires/(\d+)/', referer)
            if match:
                questionnaire_id = int(match.group(1))
                print(f"üîç ID extrait du Referer: {questionnaire_id}")
            else:
                return jsonify({'success': False, 'error': 'questionnaire_id requis'}), 400
        
        session_id = data.get('session_id')
        statut = data.get('statut', 'en_cours')
        nom = data.get('nom', '')
        email = data.get('email', '')
        reponses = data.get('reponses', {})
        
        if not session_id:
            return jsonify({'success': False, 'error': 'session_id requis'}), 400
        
        # V√©rifier que le questionnaire existe
        questionnaire = db.session.get(Questionnaire, questionnaire_id)
        if not questionnaire:
            print(f"‚ùå Questionnaire {questionnaire_id} non trouv√©")
            return jsonify({'success': False, 'error': f'Questionnaire {questionnaire_id} non trouv√©'}), 404
        
        print(f"üìã Questionnaire: {questionnaire.titre}")
        print(f"‚öôÔ∏è Configuration: collecter_nom={questionnaire.collecter_nom}, collecter_email={questionnaire.collecter_email}")
        
        from datetime import datetime, timezone
        
        # Cr√©er ou r√©cup√©rer la r√©ponse
        reponse = ReponseQuestionnaire.query.filter_by(
            questionnaire_id=questionnaire_id,
            session_id=session_id
        ).first()
        
        if reponse:
            print(f"üìù R√©ponse existante: {reponse.id}")
            existing_date_debut = reponse.date_debut
        else:
            reponse = ReponseQuestionnaire(
                questionnaire_id=questionnaire_id,
                session_id=session_id,
                ip_address=request.remote_addr or '0.0.0.0',
                user_agent=request.user_agent.string[:200] if request.user_agent else '',
                statut=statut,
                date_debut=datetime.now(timezone.utc)
            )
            db.session.add(reponse)
            existing_date_debut = reponse.date_debut
            print(f"‚ûï Nouvelle r√©ponse cr√©√©e")
        
        # CORRECTION: Toujours mettre √† jour nom et email si fournis
        # Mais ne pas les valider si le questionnaire ne les collecte pas
        if nom:
            reponse.nom_repondant = nom.strip()
        if email:
            reponse.email_repondant = email.strip()
        
        reponse.statut = statut
        
        # Validation conditionnelle UNIQUEMENT pour les soumissions compl√®tes
        if statut == 'complet':
            # V√©rifier les champs requis selon la configuration du questionnaire
            if questionnaire.collecter_nom and not nom:
                print("‚ùå Nom requis mais manquant")
                return jsonify({
                    'success': False, 
                    'error': 'Le nom est requis pour ce questionnaire',
                    'code': 'NOM_REQUIRED'
                }), 400
            
            if questionnaire.collecter_email:
                if not email:
                    print("‚ùå Email requis mais manquant")
                    return jsonify({
                        'success': False, 
                        'error': 'L\'email est requis pour ce questionnaire',
                        'code': 'EMAIL_REQUIRED'
                    }), 400
                # Validation email simple
                if '@' not in email or '.' not in email:
                    print(f"‚ùå Email invalide: {email}")
                    return jsonify({
                        'success': False, 
                        'error': 'Email invalide',
                        'code': 'EMAIL_INVALID'
                    }), 400
            
            # Si validation pass√©e, marquer comme complet
            reponse.date_fin = datetime.now(timezone.utc)
            
            # Calculer la dur√©e
            if existing_date_debut:
                # Assurer que les deux datetimes sont timezone-aware
                if existing_date_debut.tzinfo is None:
                    existing_date_debut = existing_date_debut.replace(tzinfo=timezone.utc)
                
                try:
                    duree = (reponse.date_fin - existing_date_debut).total_seconds()
                    reponse.duree = int(duree)
                    print(f"‚úÖ Dur√©e calcul√©e: {reponse.duree} secondes")
                except Exception as e:
                    print(f"‚ö†Ô∏è Erreur calcul dur√©e: {e}")
                    reponse.duree = 0
            else:
                reponse.duree = 0
                
            print(f"‚úÖ Marqu√© comme COMPLET")
        
        # Sauvegarder les r√©ponses
        for q_id_str, q_data in reponses.items():
            try:
                q_id = int(q_id_str)
                # G√©rer les diff√©rents formats de donn√©es
                if isinstance(q_data, dict):
                    valeur = q_data.get('valeur', q_data)
                else:
                    valeur = q_data
                
                # Chercher r√©ponse existante
                rep_q = ReponseQuestion.query.filter_by(
                    reponse_questionnaire_id=reponse.id,
                    question_id=q_id
                ).first()
                
                if not rep_q:
                    rep_q = ReponseQuestion(
                        reponse_questionnaire_id=reponse.id,
                        question_id=q_id
                    )
                    db.session.add(rep_q)
                
                # Sauvegarder valeur
                if valeur is not None:
                    if isinstance(valeur, (list, dict)):
                        rep_q.valeur_texte = json.dumps(valeur)
                    else:
                        rep_q.valeur_texte = str(valeur)
                else:
                    rep_q.valeur_texte = None
                
                print(f"üìù Q{q_id} sauvegard√©: {valeur}")
                
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur Q{q_id_str}: {e}")
                continue
        
        db.session.commit()
        
        print(f"üéâ SUCC√àS! R√©ponse ID: {reponse.id}")
        print(f"üìã Info - Nom: '{reponse.nom_repondant}', Email: '{reponse.email_repondant}'")
        print("=" * 80)
        
        return jsonify({
            'success': True,
            'message': 'Questionnaire soumis avec succ√®s',
            'reponse_id': reponse.id,
            'statut': statut,
            'nom': reponse.nom_repondant or '',
            'email': reponse.email_repondant or '',
            'details': {
                'questions_saved': len(reponses),
                'duration': reponse.duree if statut == 'complet' else None
            }
        }), 200
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå ERREUR CRITIQUE: {str(e)}")
        import traceback
        traceback.print_exc()
        print("=" * 80)
        return jsonify({'success': False, 'error': str(e)}), 500
    
@app.route('/api/debug/response-format', methods=['POST'])
@csrf.exempt
def debug_response_format():
    """Debug: Voir exactement ce que retourne l'API"""
    print("=" * 80)
    print("üîç DEBUG RESPONSE FORMAT")
    print("=" * 80)
    
    # Simuler la soumission pour voir ce que l'API retourne
    questionnaire_id = 4  # Votre questionnaire ID
    
    try:
        # Essayer d'ex√©cuter la vraie route
        from flask import request as original_request
        import io
        from contextlib import redirect_stdout
        
        # Capturer la sortie
        f = io.StringIO()
        
        with redirect_stdout(f):
            # Appeler la route r√©elle
            result = api_submit_questionnaire(questionnaire_id)
        
        output = f.getvalue()
        print("üìù Output de l'API:")
        print(output)
        
        return jsonify({
            'success': True,
            'debug': True,
            'api_output': output,
            'result_type': type(result).__name__,
            'result': str(result)[:500] if result else 'None'
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e),
            'traceback': traceback.format_exc()
        }), 500

@app.route('/api/test/all-routes', methods=['GET'])
def test_all_routes():
    """Test: V√©rifier que toutes les routes API fonctionnent"""
    routes = [
        ('GET', f'/api/questionnaire/{1}/reponses/test-session'),
        ('POST', f'/api/questionnaire/{1}/reponse'),
        ('POST', f'/api/questionnaire/{1}/repondant'),
        ('POST', f'/api/questionnaire/{1}/repondre'),
        ('GET', f'/api/questionnaire/{1}/reponses/test-session/statut'),
    ]
    
    results = []
    for method, route in routes:
        try:
            if method == 'GET':
                with app.test_client() as client:
                    response = client.get(route)
                    results.append({
                        'route': route,
                        'method': method,
                        'status': response.status_code,
                        'working': response.status_code < 400
                    })
        except Exception as e:
            results.append({
                'route': route,
                'method': method,
                'status': 'ERROR',
                'working': False,
                'error': str(e)
            })
    
    return jsonify({
        'success': True,
        'routes_tested': len(routes),
        'working_routes': len([r for r in results if r['working']]),
        'results': results
    })

@app.route('/api/debug/submit-test', methods=['POST', 'OPTIONS'])
@csrf.exempt
def debug_submit_test():
    """Debug: Analyser les donn√©es de soumission - VERSION CORRIG√âE"""
    print("=" * 80)
    print("üîç DEBUG SUBMIT TEST - Analyse compl√®te")
    print("=" * 80)
    
    try:
        print(f"üìã Method: {request.method}")
        print(f"üì¶ Content-Type: {request.content_type}")
        print(f"üì¶ Headers: {dict(request.headers)}")
        
        # Lire les donn√©es brutes
        raw_data = request.get_data(as_text=True)
        print(f"üìÑ Raw data (preview): {raw_data[:500]}...")
        
        # Essayer de parser JSON
        data = {}
        try:
            if request.is_json:
                data = request.get_json()
                print("‚úÖ JSON parsed successfully:")
                print(json.dumps(data, indent=2))
            else:
                # Essayer de parser quand m√™me
                data = json.loads(raw_data) if raw_data.strip() else {}
                print("‚úÖ JSON parsed (forced):")
                print(json.dumps(data, indent=2))
        except Exception as e:
            print(f"‚ùå Error parsing JSON: {e}")
            data = {}
        
        print(f"\nüîç Data analysis:")
        print(f"  session_id: {data.get('session_id', 'NOT FOUND')}")
        print(f"  statut: {data.get('statut', 'NOT FOUND')}")
        print(f"  nom: '{data.get('nom', 'NOT FOUND')}'")
        print(f"  email: '{data.get('email', 'NOT FOUND')}'")
        print(f"  reponses: {len(data.get('reponses', {}))} items")
        
        # CORRECTION: Initialiser questionnaire √† None au d√©but
        questionnaire = None
        questionnaire_id = None
        
        # Essayer de trouver le questionnaire
        # M√©thode 1: Depuis les donn√©es
        if 'questionnaire_id' in data:
            questionnaire_id = data.get('questionnaire_id')
            print(f"üîç Questionnaire ID from data: {questionnaire_id}")
            questionnaire = Questionnaire.query.get(questionnaire_id)
        
        # M√©thode 2: Depuis le Referer
        if not questionnaire:
            referer = request.headers.get('Referer', '')
            print(f"üîç Referer: {referer}")
            
            import re
            match = re.search(r'/questionnaires/(\d+)/', referer)
            if match:
                questionnaire_id = int(match.group(1))
                print(f"üîç Questionnaire ID from Referer (numeric): {questionnaire_id}")
                questionnaire = Questionnaire.query.get(questionnaire_id)
            else:
                # Essayer avec un code (comme "K")
                match = re.search(r'/questionnaires/([^/]+)/', referer)
                if match:
                    code = match.group(1)
                    print(f"üîç Questionnaire Code from Referer: {code}")
                    questionnaire = Questionnaire.query.filter_by(code=code).first()
                    if questionnaire:
                        questionnaire_id = questionnaire.id
        
        # Afficher le r√©sultat
        if questionnaire:
            print(f"‚úÖ Questionnaire found: {questionnaire.titre} (ID: {questionnaire.id})")
            print(f"‚öôÔ∏è Configuration: collecter_nom={questionnaire.collecter_nom}, collecter_email={questionnaire.collecter_email}")
            collecter_nom = questionnaire.collecter_nom
            collecter_email = questionnaire.collecter_email
        else:
            print(f"‚ùå Questionnaire not found in database")
            print(f"‚ÑπÔ∏è Will use default configuration for validation")
            # CORRECTION: D√©finir des valeurs par d√©faut si questionnaire non trouv√©
            collecter_nom = False
            collecter_email = False
        
        # Valider les donn√©es
        errors = []
        
        # Validation session_id
        if not data.get('session_id'):
            errors.append('session_id manquant')
        
        # Validation pour soumission compl√®te
        if data.get('statut') == 'complet':
            # CORRECTION: Utiliser les variables locales, pas l'objet questionnaire directement
            if collecter_nom and not data.get('nom'):
                errors.append('nom requis mais manquant')
            if collecter_email:
                if not data.get('email'):
                    errors.append('email requis mais manquant')
                elif '@' not in str(data.get('email', '')):
                    errors.append('email invalide')
        
        if errors:
            print(f"‚ùå Validation errors: {errors}")
        else:
            print("‚úÖ Data validation passed")
        
        # Simuler la r√©ponse
        return jsonify({
            'success': True,
            'debug': True,
            'message': 'Debug analysis completed',
            'data_received': {
                'session_id': data.get('session_id'),
                'statut': data.get('statut'),
                'nom': data.get('nom'),
                'email': data.get('email'),
                'reponses_count': len(data.get('reponses', {}))
            },
            'validation': {
                'passed': len(errors) == 0,
                'errors': errors,
                'questionnaire_found': questionnaire is not None,
                'collecter_nom': collecter_nom if 'collecter_nom' in locals() else False,
                'collecter_email': collecter_email if 'collecter_email' in locals() else False
            },
            'recommendation': 'Data looks good for submission' if len(errors) == 0 else 'Fix validation errors first'
        }), 200
        
    except Exception as e:
        print(f"‚ùå Error in debug: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': str(e),
            'traceback': traceback.format_exc()
        }), 500

@app.after_request
def after_request(response):
    """Ajouter les headers CORS √† toutes les r√©ponses"""
    response.headers.add('Access-Control-Allow-Origin', '*')
    response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')
    response.headers.add('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS')
    return response

# ROUTE TEST API
# ========================

@app.route('/api/questionnaire/<int:id>/reponse/test', methods=['POST'])
def test_api_route(id):
    """Route de test pour l'API"""
    print(f"üß™ Test API pour questionnaire {id}")
    print(f"Donn√©es: {request.get_json()}")
    
    return jsonify({
        'success': True,
        'message': 'API fonctionne',
        'questionnaire_id': id,
        'timestamp': datetime.utcnow().isoformat()
    }), 200


@app.route('/questionnaires/<string:code>/repondre')
def repondre_questionnaire(code):
    """Page pour r√©pondre √† un questionnaire public"""
    questionnaire = Questionnaire.query.filter_by(code=code, est_actif=True).first_or_404()
    
    # V√©rifier les dates
    now = datetime.utcnow()
    if questionnaire.date_debut and now < questionnaire.date_debut:
        flash('Ce questionnaire n\'est pas encore disponible.', 'warning')
        return redirect(url_for('index'))
    
    if questionnaire.date_fin and now > questionnaire.date_fin:
        flash('Ce questionnaire n\'est plus disponible.', 'warning')
        return redirect(url_for('index'))
    
    # G√©n√©rer un ID de session unique
    session_id = request.args.get('session_id')
    if not session_id:
        session_id = str(uuid.uuid4())
    
    # V√©rifier si une r√©ponse existe d√©j√† avec cette session
    reponse_existante = ReponseQuestionnaire.query.filter_by(
        questionnaire_id=questionnaire.id,
        session_id=session_id
    ).first()
    
    # Si limit√© √† une r√©ponse par IP
    if questionnaire.limit_une_reponse and not reponse_existante:
        ip_reponse = ReponseQuestionnaire.query.filter_by(
            questionnaire_id=questionnaire.id,
            ip_address=request.remote_addr,
            statut='complet'
        ).first()
        if ip_reponse:
            flash('Vous avez d√©j√† r√©pondu √† ce questionnaire.', 'warning')
            return redirect(url_for('index'))
    
    # Pr√©parer les donn√©es pour le template
    questionnaire_data = {
        'id': questionnaire.id,
        'titre': questionnaire.titre,
        'description': questionnaire.description,
        'instructions': questionnaire.instructions,
        'code': questionnaire.code,
        'confirmation_message': questionnaire.confirmation_message,
        'redirection_url': questionnaire.redirection_url,
        'afficher_barre_progression': questionnaire.afficher_barre_progression,
        'afficher_numero_questions': questionnaire.afficher_numero_questions,
        'autoriser_sauvegarde_partielle': questionnaire.autoriser_sauvegarde_partielle,
        'collecter_nom': questionnaire.collecter_nom,
        'collecter_email': questionnaire.collecter_email,
        'categories': []
    }
    
    # Pr√©parer les cat√©gories et questions
    for categorie in questionnaire.categories:
        categorie_data = {
            'id': categorie.id,
            'titre': categorie.titre,
            'description': categorie.description,
            'ordre': categorie.ordre,
            'questions': []
        }
        
        for question in categorie.questions:
            question_data = {
                'id': question.id,
                'texte': question.texte,
                'description': question.description,
                'type': question.type,
                'ordre': question.ordre,
                'est_obligatoire': question.est_obligatoire,
                'placeholder': question.placeholder,
                'taille_min': question.taille_min,
                'taille_max': question.taille_max,
                'valeurs_min': question.valeurs_min,
                'valeurs_max': question.valeurs_max,
                'pas': question.pas,
                'unite': question.unite,
                'echelle_min': question.echelle_min,
                'echelle_max': question.echelle_max,
                'libelle_min': question.libelle_min,
                'libelle_max': question.libelle_max,
                'options': [{
                    'id': option.id,
                    'valeur': option.valeur,
                    'texte': option.texte,
                    'ordre': option.ordre,
                    'score': option.score
                } for option in question.options]
            }
            categorie_data['questions'].append(question_data)
        
        questionnaire_data['categories'].append(categorie_data)
    
    return render_template('repondre.html', 
                         questionnaire=questionnaire_data,
                         session_id=session_id)


@app.route('/api/question/<int:id>', methods=['DELETE'])
@login_required
def api_delete_question(id):
    """API: Supprimer une question"""
    try:
        question = Question.query.get_or_404(id)
        db.session.delete(question)
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/question/<int:id>/delete', methods=['POST'])
@login_required
def api_delete_question_post(id):
    """API: Supprimer une question (POST)"""
    try:
        question = Question.query.get_or_404(id)
        db.session.delete(question)
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500



@app.route('/api/categorie/<int:id>/update', methods=['PUT'])
@app.route('/api/categorie/<int:id>/update', methods=['PUT', 'POST'])  # <-- AJOUT DE POST
@login_required
def api_update_categorie(id):
    """API: Mettre √† jour une cat√©gorie - Accepte PUT et POST"""
    try:
        if not request.is_json:
            return jsonify({'success': False, 'error': 'Content-Type must be application/json'}), 400
            
        data = request.get_json()
        categorie = QuestionnaireCategorie.query.get_or_404(id)
        
        # V√©rifier l'acc√®s (si vous avez une fonction check_client_access)
        if not check_client_access(categorie):
            return jsonify({'success': False, 'error': 'Acc√®s non autoris√©'}), 403
        
        categorie.titre = data.get('titre', categorie.titre)
        categorie.description = data.get('description', categorie.description)
        categorie.ordre = data.get('ordre', categorie.ordre)
        
        db.session.commit()
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/categorie/<int:id>/delete', methods=['DELETE', 'POST'])
@login_required
def api_delete_categorie(id):
    """API: Supprimer une cat√©gorie"""
    try:
        # R√©cup√©rer la cat√©gorie
        categorie = QuestionnaireCategorie.query.get_or_404(id)
        questionnaire_id = categorie.questionnaire_id
        
        # V√©rifier les permissions
        questionnaire = Questionnaire.query.get_or_404(questionnaire_id)
        if not check_client_access(questionnaire):
            return jsonify({
                'success': False, 
                'error': 'Acc√®s non autoris√©'
            }), 403
        
        # Supprimer la cat√©gorie (et ses questions par cascade si configur√©)
        db.session.delete(categorie)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Cat√©gorie supprim√©e avec succ√®s'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur suppression cat√©gorie {id}: {e}")
        return jsonify({
            'success': False, 
            'error': str(e)
        }), 500

@app.route('/api/questionnaire/<int:id>/reorder-categories', methods=['POST'])
@login_required
def api_reorder_categories(id):
    """API: R√©organiser l'ordre des cat√©gories"""
    try:
        if not request.is_json:
            return jsonify({'success': False, 'error': 'Content-Type must be application/json'}), 400
            
        data = request.get_json()
        order = data.get('order', [])
        
        for i, categorie_id in enumerate(order):
            try:
                categorie_id_int = int(categorie_id)
                categorie = QuestionnaireCategorie.query.get(categorie_id_int)
                if categorie and categorie.questionnaire_id == id:
                    categorie.ordre = i
                    db.session.add(categorie)
            except (ValueError, TypeError):
                continue
        
        db.session.commit()
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/categorie/<int:id>/reorder-questions', methods=['POST'])
@login_required
def api_reorder_questions(id):
    """API: R√©organiser l'ordre des questions"""
    try:
        if not request.is_json:
            return jsonify({'success': False, 'error': 'Content-Type must be application/json'}), 400
            
        data = request.get_json()
        order = data.get('order', [])
        
        for i, question_id in enumerate(order):
            try:
                question_id_int = int(question_id)
                question = Question.query.get(question_id_int)
                if question and question.categorie_id == id:
                    question.ordre = i
                    db.session.add(question)
            except (ValueError, TypeError):
                continue
        
        db.session.commit()
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

# ========================
# FONCTIONS API QUESTIONNAIRE
# ========================

def api_save_response(id):
    """API: Sauvegarder une r√©ponse individuelle"""
    try:
        print(f"=== DEBUT api_save_response ===")
        print(f"URL: /api/questionnaire/{id}/reponse")
        print(f"M√©thode: {request.method}")
        print(f"Content-Type: {request.content_type}")
        
        if not request.is_json:
            return jsonify({
                'success': False, 
                'error': 'Content-Type must be application/json',
                'received': request.content_type
            }), 400
        
        try:
            data = request.get_json()
            print(f"‚úÖ Donn√©es JSON re√ßues: {data}")
        except Exception as e:
            return jsonify({
                'success': False, 
                'error': f'Invalid JSON: {str(e)}'
            }), 400
            
        session_id = data.get('session_id')
        question_id = data.get('question_id')
        valeur = data.get('valeur')
        
        if not session_id or not question_id:
            return jsonify({
                'success': False, 
                'error': 'session_id et question_id requis'
            }), 400
        
        try:
            question_id = int(question_id)
        except (ValueError, TypeError):
            return jsonify({
                'success': False, 
                'error': f'question_id doit √™tre un nombre, re√ßu: {question_id}'
            }), 400
        
        # Utiliser db.session.get() au lieu de Model.query.get()
        questionnaire = db.session.get(Questionnaire, id)
        if not questionnaire:
            return jsonify({
                'success': False, 
                'error': f'Questionnaire {id} non trouv√©'
            }), 404
        
        question = db.session.get(Question, question_id)
        if not question:
            return jsonify({
                'success': False, 
                'error': f'Question {question_id} non trouv√©e'
            }), 404
        
        # Cr√©er ou r√©cup√©rer la r√©ponse globale
        reponse = ReponseQuestionnaire.query.filter_by(
            questionnaire_id=id,
            session_id=session_id
        ).first()
        
        if not reponse:
            reponse = ReponseQuestionnaire(
                questionnaire_id=id,
                session_id=session_id,
                ip_address=request.remote_addr or '0.0.0.0',
                user_agent=request.user_agent.string[:200] if request.user_agent else '',
                statut='en_cours',
                date_debut=datetime.utcnow()
            )
            db.session.add(reponse)
            db.session.flush()
        
        # Sauvegarder la r√©ponse individuelle
        reponse_q = ReponseQuestion.query.filter_by(
            reponse_questionnaire_id=reponse.id,
            question_id=question_id
        ).first()
        
        if not reponse_q:
            reponse_q = ReponseQuestion(
                reponse_questionnaire_id=reponse.id,
                question_id=question_id
            )
            db.session.add(reponse_q)
        
        # Mettre √† jour la valeur selon le type
        if question.type in ['text', 'textarea', 'email', 'radio', 'select', 'yesno']:
            reponse_q.valeur_texte = str(valeur) if valeur is not None else None
            
        elif question.type in ['number', 'rating', 'range']:
            if valeur is not None and str(valeur).strip() != '':
                try:
                    reponse_q.valeur_numerique = float(valeur)
                except (ValueError, TypeError):
                    reponse_q.valeur_numerique = None
            else:
                reponse_q.valeur_numerique = None
                
        elif question.type == 'date':
            if valeur:
                try:
                    date_str = str(valeur).strip()
                    try:
                        valeur_date = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
                    except ValueError:
                        try:
                            valeur_date = datetime.strptime(date_str, '%Y-%m-%dT%H:%M:%S')
                        except ValueError:
                            valeur_date = datetime.strptime(date_str, '%Y-%m-%d')
                    reponse_q.valeur_date = valeur_date
                except Exception:
                    reponse_q.valeur_date = None
            else:
                reponse_q.valeur_date = None
                
        elif question.type == 'checkbox':
            # Supprimer les anciennes options
            ReponseOption.query.filter_by(reponse_question_id=reponse_q.id).delete()
            
            # Ajouter les nouvelles options
            if isinstance(valeur, list):
                for opt_val in valeur:
                    if opt_val:
                        try:
                            option = None
                            if isinstance(opt_val, int) or (isinstance(opt_val, str) and opt_val.isdigit()):
                                option = db.session.get(OptionQuestion, int(opt_val))
                            else:
                                option = OptionQuestion.query.filter_by(
                                    question_id=question_id,
                                    valeur=str(opt_val)
                                ).first()
                            
                            if option:
                                reponse_option = ReponseOption(
                                    reponse_question_id=reponse_q.id,
                                    option_id=option.id
                                )
                                db.session.add(reponse_option)
                        except (ValueError, TypeError):
                            continue
            elif valeur:
                try:
                    option = None
                    if isinstance(valeur, int) or (isinstance(valeur, str) and valeur.isdigit()):
                        option = db.session.get(OptionQuestion, int(valeur))
                    else:
                        option = OptionQuestion.query.filter_by(
                            question_id=question_id,
                            valeur=str(valeur)
                        ).first()
                    
                    if option:
                        reponse_option = ReponseOption(
                            reponse_question_id=reponse_q.id,
                            option_id=option.id
                        )
                        db.session.add(reponse_option)
                except (ValueError, TypeError):
                    pass
        
        db.session.commit()
        
        result = {
            'success': True,
            'message': 'R√©ponse sauvegard√©e',
            'data': {
                'questionnaire_id': id,
                'session_id': session_id,
                'question_id': question_id
            }
        }
        
        print(f"‚úÖ R√©ponse API: {result}")
        return jsonify(result), 200
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur api_save_response: {str(e)}")
        import traceback
        print(traceback.format_exc())
        return jsonify({
            'success': False, 
            'error': str(e)
        }), 500
    finally:
        print(f"=== FIN api_save_response ===\n")

@app.route('/questionnaires/<int:id>/lien')
@login_required
def generer_lien_questionnaire(id):
    """G√©n√©rer le lien public d'un questionnaire avec v√©rification d'acc√®s"""
    
    # CORRECTION : R√©cup√©rer avec v√©rification d'acc√®s
    questionnaire = Questionnaire.query.get_or_404(id)
    
    # V√©rifier que l'utilisateur a acc√®s √† ce questionnaire
    if not check_client_access(questionnaire):
        flash('Acc√®s non autoris√© √† ce questionnaire', 'error')
        return redirect(url_for('liste_questionnaires'))
    
    if not questionnaire.est_actif:
        flash('Le questionnaire doit √™tre activ√© pour g√©n√©rer un lien', 'warning')
        return redirect(url_for('liste_questionnaires'))
    
    # V√©rifier que le questionnaire appartient au bon client
    # (s√©curit√© suppl√©mentaire)
    if current_user.role != 'super_admin':
        if hasattr(questionnaire, 'client_id') and questionnaire.client_id != current_user.client_id:
            flash('Acc√®s non autoris√©', 'error')
            return redirect(url_for('liste_questionnaires'))
    
    # G√©n√©rer l'URL publique
    lien_public = url_for('questionnaire_public', code=questionnaire.code, _external=True)
    
    # Loguer l'action
    log_activity(current_user.id, 'generation_lien_questionnaire',
                f"G√©n√©ration lien public pour questionnaire: {questionnaire.titre}",
                'questionnaire', questionnaire.id)
    
    return render_template('questionnaire/lien.html', 
                         questionnaire=questionnaire,
                         lien_public=lien_public,
                         current_user=current_user)

@app.route('/api/reponse/<int:id>/delete', methods=['DELETE', 'OPTIONS'])
@csrf.exempt  # Ajouter cette ligne pour d√©sactiver CSRF pour cette route API
@login_required
def api_delete_reponse(id):
    """API: Supprimer une r√©ponse compl√®te avec v√©rification d'acc√®s"""
    
    # G√©rer les pr√©-requ√™tes CORS
    if request.method == 'OPTIONS':
        response = make_response()
        response.headers.add('Access-Control-Allow-Origin', '*')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')
        response.headers.add('Access-Control-Allow-Methods', 'DELETE, OPTIONS')
        return response, 200
    
    try:
        print(f"üîç Tentative de suppression r√©ponse ID: {id}")
        print(f"üìä Utilisateur: {current_user.id} ({current_user.email})")
        
        # CORRECTION : R√©cup√©rer la r√©ponse avec v√©rification d'acc√®s
        reponse = ReponseQuestionnaire.query.get_or_404(id)
        
        # Log des informations de la r√©ponse
        print(f"üìã R√©ponse trouv√©e: ID={reponse.id}, Questionnaire={reponse.questionnaire_id}, Session={reponse.session_id}")
        
        # V√©rifier l'acc√®s
        if not check_client_access(reponse):
            print("‚õî Acc√®s refus√© par check_client_access")
            return jsonify({
                'success': False, 
                'error': 'Acc√®s non autoris√© √† cette r√©ponse'
            }), 403
        
        # Pour plus de s√©curit√©, v√©rifier aussi via le questionnaire
        if hasattr(reponse, 'questionnaire_id') and reponse.questionnaire_id:
            questionnaire = Questionnaire.query.get(reponse.questionnaire_id)
            if questionnaire:
                print(f"üìä Questionnaire: {questionnaire.id} - {questionnaire.titre}")
                if not check_client_access(questionnaire):
                    print("‚õî Acc√®s refus√© par check_client_access sur questionnaire")
                    return jsonify({
                        'success': False, 
                        'error': 'Acc√®s non autoris√© au questionnaire'
                    }), 403
        
        # Journaliser avant suppression
        try:
            log_activity(current_user.id, 'suppression_reponse_questionnaire',
                        f"Suppression r√©ponse ID: {reponse.id} (Questionnaire: {reponse.questionnaire.titre if hasattr(reponse, 'questionnaire') else 'N/A'})",
                        'reponse_questionnaire', reponse.id)
        except Exception as log_error:
            print(f"‚ö†Ô∏è Erreur journalisation: {log_error}")
        
        # Supprimer √©galement les r√©ponses associ√©es (cascade manuelle)
        try:
            # Supprimer les r√©ponses individuelles
            reponses_questions = ReponseQuestion.query.filter_by(
                reponse_questionnaire_id=reponse.id
            ).all()
            
            for rq in reponses_questions:
                # Supprimer les options s√©lectionn√©es
                ReponseOption.query.filter_by(reponse_question_id=rq.id).delete()
                # Supprimer la r√©ponse individuelle
                db.session.delete(rq)
            
            print(f"üóëÔ∏è {len(reponses_questions)} r√©ponses individuelles supprim√©es")
        except Exception as cascade_error:
            print(f"‚ö†Ô∏è Erreur suppression cascade: {cascade_error}")
        
        # Supprimer la r√©ponse principale
        db.session.delete(reponse)
        db.session.commit()
        
        print(f"‚úÖ R√©ponse {id} supprim√©e avec succ√®s")
        
        return jsonify({
            'success': True,
            'message': 'R√©ponse supprim√©e avec succ√®s',
            'id': id
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Erreur suppression r√©ponse {id}: {e}")
        import traceback
        traceback.print_exc()
        
        # Journaliser l'erreur
        try:
            log_activity(current_user.id, 'erreur_suppression_reponse',
                        f"Erreur suppression r√©ponse {id}: {str(e)}",
                        'reponse_questionnaire', id if 'id' in locals() else None)
        except:
            pass
        
        return jsonify({
            'success': False, 
            'error': str(e)
        }), 500


@app.route('/api/audit/<int:audit_id>/statistiques')
@login_required
def api_statistiques_audit(audit_id):
    """API pour les statistiques d'audit"""
    audit = Audit.query.get_or_404(audit_id)
    rapport = generer_rapport_audit_complet(audit_id)
    
    return jsonify(rapport['statistiques'])

@app.route('/api/risques/processus/<int:processus_id>')
@login_required
def api_risques_par_processus(processus_id):
    processus = Processus.query.get_or_404(processus_id)
    risques = Risque.query.filter(Risque.processus_concerne.ilike(f"%{processus.nom}%")).all()
    return jsonify([{'id': r.id, 'reference': r.reference, 'intitule': r.intitule} for r in risques])

# Ajoutez cette fonction apr√®s toutes vos routes
@app.after_request
def after_request(response):
    """Ajouter les headers CORS √† toutes les r√©ponses"""
    response.headers.add('Access-Control-Allow-Origin', '*')
    response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')
    response.headers.add('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS')
    return response
def configurer_hooks_multi_tenant():
    """
    Configure tous les hooks n√©cessaires pour le multi-tenant
    Doit √™tre appel√©e APR√àS la cr√©ation de tous les mod√®les
    """
    try:
        print("üîß Configuration des hooks multi-tenant...")
        
        # Liste des mod√®les √† hooker (s√©curis√©e)
        models_to_hook = []
        
        # R√©cup√©rer dynamiquement les mod√®les depuis SQLAlchemy
        from sqlalchemy.inspection import inspect
        import sys
        
        # Chercher tous les mod√®les d√©finis dans le scope
        for name, obj in list(sys.modules[__name__].__dict__.items()):
            try:
                if hasattr(obj, '__tablename__') and hasattr(obj, '__table__'):
                    # C'est un mod√®le SQLAlchemy
                    models_to_hook.append(obj)
                    print(f"  ‚úì Mod√®le d√©tect√©: {obj.__name__}")
            except:
                continue
        
        # Liste explicite en backup
        if not models_to_hook:
            # Noms des mod√®les √† chercher
            model_names = [
                'Cartographie', 'Risque', 'EvaluationRisque', 'KRI', 'MesureKRI',
                'Processus', 'EtapeProcessus', 'SousEtapeProcessus', 'Audit',
                'Constatation', 'Recommandation', 'PlanAction', 'EtapePlanAction',
                'VeilleReglementaire', 'ActionConformite', 'ProcessusActivite',
                'Questionnaire', 'Question', 'CampagneEvaluation'
            ]
            
            # Chercher chaque mod√®le
            for name in model_names:
                if name in globals():
                    models_to_hook.append(globals()[name])
                    print(f"  ‚úì Mod√®le trouv√©: {name}")
        
        # Appliquer les hooks
        hook_count = 0
        for model in models_to_hook:
            try:
                # V√©rifier que le mod√®le a besoin du hook
                if hasattr(model, 'client_id') or hasattr(model, 'created_by'):
                    event.listen(model, 'before_insert', apply_client_id_before_insert)
                    hook_count += 1
                    print(f"  ‚úì Hook appliqu√© √†: {model.__name__}")
            except Exception as e:
                print(f"  ‚ö†Ô∏è Erreur hook {model}: {e}")
        
        print(f"‚úÖ {hook_count} hooks multi-tenant configur√©s")
        
    except Exception as e:
        print(f"‚ùå Erreur configuration hooks: {e}")
        import traceback
        traceback.print_exc()

# Appeler la fonction au d√©marrage
with app.app_context():
    configurer_hooks_multi_tenant()

# Dans app.py, apr√®s les routes existantes pour les audits

@app.route('/audit/<int:audit_id>/upload-rapport-fichier', methods=['POST'])
@login_required
@csrf.exempt
def upload_fichier_rapport(audit_id):
    """Uploader un fichier pour le rapport d'audit"""
    audit = Audit.query.get_or_404(audit_id)
    
    # V√©rifier les permissions
    if not current_user.has_permission('can_manage_audit') and not check_client_access(audit):
        flash('Vous n\'avez pas les permissions pour ajouter des fichiers', 'error')
        return redirect(url_for('rapport_audit_complet', audit_id=audit_id))
    
    if 'fichier' not in request.files:
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(url_for('rapport_audit_complet', audit_id=audit_id))
    
    fichier = request.files['fichier']
    description = request.form.get('description', '').strip()
    
    if fichier.filename == '':
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(url_for('rapport_audit_complet', audit_id=audit_id))
    
    # V√©rifier l'extension
    allowed_extensions = {'pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 
                         'jpg', 'jpeg', 'png', 'txt', 'zip', 'rar'}
    if not ('.' in fichier.filename and 
            fichier.filename.rsplit('.', 1)[1].lower() in allowed_extensions):
        flash('Type de fichier non autoris√©', 'error')
        return redirect(url_for('rapport_audit_complet', audit_id=audit_id))
    
    try:
        # Cr√©er le dossier sp√©cifique pour cet audit
        upload_dir = os.path.join('static', 'uploads', 'rapports_audit', str(audit_id))
        os.makedirs(upload_dir, exist_ok=True)
        
        # G√©n√©rer un nom de fichier unique
        timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
        nom_original = secure_filename(fichier.filename)
        nom_unique = f"{timestamp}_{nom_original}"
        chemin_complet = os.path.join(upload_dir, nom_unique)
        
        # Sauvegarder le fichier
        fichier.save(chemin_complet)
        
        # Enregistrer dans la base de donn√©es
        fichier_rapport = FichierRapport(
            audit_id=audit_id,
            nom_fichier=nom_original,
            chemin=chemin_complet,
            type_fichier=nom_original.rsplit('.', 1)[1].lower() if '.' in nom_original else 'unknown',
            taille=os.path.getsize(chemin_complet),
            description=description if description else None,
            uploaded_by=current_user.id
        )
        
        db.session.add(fichier_rapport)
        db.session.commit()
        
        # Journaliser l'action
        log_activity(current_user.id, 'upload_fichier_rapport',
                    f"Fichier {nom_original} upload√© pour l'audit {audit.reference}",
                    'audit', audit_id)
        
        flash(f'Fichier "{nom_original}" upload√© avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de l\'upload: {str(e)}', 'error')
    
    return redirect(url_for('rapport_audit_complet', audit_id=audit_id))

@app.route('/fichier-rapport/<int:fichier_id>/telecharger')
@login_required
def telecharger_fichier_rapport(fichier_id):
    """T√©l√©charger un fichier de rapport"""
    fichier = FichierRapport.query.get_or_404(fichier_id)
    audit = fichier.audit
    
    # V√©rifier les permissions
    if not check_client_access(audit):
        flash('Acc√®s non autoris√©', 'error')
        return redirect(url_for('liste_audits'))
    
    # V√©rifier que le fichier existe
    if not os.path.exists(fichier.chemin):
        flash('Fichier non trouv√©', 'error')
        return redirect(url_for('rapport_audit_complet', audit_id=audit.id))
    
    return send_file(fichier.chemin, 
                    as_attachment=True, 
                    download_name=fichier.nom_fichier)

@app.route('/fichier-rapport/<int:fichier_id>/supprimer', methods=['POST'])
@login_required
@csrf.exempt
def supprimer_fichier_rapport(fichier_id):
    """Supprimer un fichier de rapport"""
    fichier = FichierRapport.query.get_or_404(fichier_id)
    audit = fichier.audit
    
    # V√©rifier les permissions
    if not (current_user.has_permission('can_manage_audit') or 
            current_user.id == audit.created_by or 
            current_user.id == audit.responsable_id):
        flash('Vous n\'avez pas les permissions pour supprimer ce fichier', 'error')
        return redirect(url_for('rapport_audit_complet', audit_id=audit.id))
    
    try:
        # Supprimer le fichier physique
        if os.path.exists(fichier.chemin):
            os.remove(fichier.chemin)
        
        # Supprimer de la base de donn√©es
        db.session.delete(fichier)
        db.session.commit()
        
        # Journaliser
        log_activity(current_user.id, 'suppression_fichier_rapport',
                    f"Fichier {fichier.nom_fichier} supprim√© pour l'audit {audit.reference}",
                    'audit', audit.id)
        
        flash('Fichier supprim√© avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la suppression: {str(e)}', 'error')
    
    return redirect(url_for('rapport_audit_complet', audit_id=audit.id))

@app.route('/audit/<int:audit_id>/upload-fichier-rapport', methods=['GET', 'POST'])
@login_required
@csrf.exempt
def upload_fichier_rapport_audit(audit_id):
    """Uploader un fichier pour le rapport d'audit"""
    
    # V√©rifier l'acc√®s √† l'audit
    audit = get_client_object_or_404(Audit, audit_id)
    
    # V√©rifier les permissions
    peut_uploader = (
        current_user.role == 'super_admin' or
        current_user.id == audit.created_by or
        current_user.id == audit.responsable_id or
        (audit.equipe_audit_ids and str(current_user.id) in audit.equipe_audit_ids.split(','))
    )
    
    if not peut_uploader:
        flash('Vous n\'avez pas les permissions pour ajouter des fichiers', 'error')
        return redirect(url_for('rapport_audit_complet', audit_id=audit_id))
    
    # Si c'est une requ√™te GET, afficher le formulaire
    if request.method == 'GET':
        return render_template('audit/upload_fichier.html', 
                             audit=audit,
                             title=f"Ajouter un fichier - {audit.reference}")
    
    # Si c'est une requ√™te POST, traiter l'upload
    if 'fichier' not in request.files:
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(url_for('rapport_audit_complet', audit_id=audit_id))
    
    fichier = request.files['fichier']
    description = request.form.get('description', '').strip()
    
    if fichier.filename == '':
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(url_for('rapport_audit_complet', audit_id=audit_id))
    
    # V√©rifier l'extension
    allowed_extensions = app.config['ALLOWED_EXTENSIONS']
    if not ('.' in fichier.filename and 
            fichier.filename.rsplit('.', 1)[1].lower() in allowed_extensions):
        flash('Type de fichier non autoris√©', 'error')
        return redirect(url_for('rapport_audit_complet', audit_id=audit_id))
    
    try:
        # D√©terminer le dossier d'upload selon le client
        if current_user.role == 'super_admin' and session.get('viewing_client_id'):
            client_id = session['viewing_client_id']
        else:
            client_id = current_user.client_id
        
        # Cr√©er le dossier sp√©cifique pour cet audit
        base_dir = 'static/uploads'
        upload_dir = os.path.join(base_dir, 'rapports_audit', str(client_id), str(audit_id))
        os.makedirs(upload_dir, exist_ok=True)
        
        # G√©n√©rer un nom de fichier unique
        timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
        nom_original = secure_filename(fichier.filename)
        nom_unique = f"{timestamp}_{nom_original}"
        chemin_complet = os.path.join(upload_dir, nom_unique)
        
        # Sauvegarder le fichier
        fichier.save(chemin_complet)
        
        # Enregistrer dans la base de donn√©es
        fichier_rapport = FichierRapport(
            audit_id=audit_id,
            nom_fichier=nom_original,
            chemin=chemin_complet.replace('\\', '/'),  # Normaliser les chemins
            type_fichier=nom_original.rsplit('.', 1)[1].lower() if '.' in nom_original else 'unknown',
            taille=os.path.getsize(chemin_complet),
            description=description if description else None,
            uploaded_by=current_user.id,
            client_id=client_id
        )
        
        db.session.add(fichier_rapport)
        db.session.commit()
        
        # Journaliser l'action
        log_activity(current_user.id, 'upload_fichier_rapport',
                    f"Fichier {nom_original} upload√© pour l'audit {audit.reference}",
                    'audit', audit_id)
        
        flash(f'‚úÖ Fichier "{nom_original}" upload√© avec succ√®s', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur lors de l\'upload: {str(e)}', 'error')
        print(f"‚ùå Erreur upload: {e}")
    
    return redirect(url_for('rapport_audit_complet', audit_id=audit_id))


@app.route('/fichier-rapport-audit/<int:fichier_id>/supprimer', methods=['POST'])
@login_required
@csrf.exempt  # Temporairement pour tester
def supprimer_fichier_rapport_audit(fichier_id):
    """Supprimer un fichier de rapport"""
    try:
        print(f"[DEBUG] Tentative suppression fichier {fichier_id}")
        
        # R√©cup√©rer le fichier
        fichier = FichierRapport.query.get_or_404(fichier_id)
        
        print(f"[DEBUG] Fichier trouv√©: {fichier.nom_fichier}")
        print(f"[DEBUG] Chemin: {fichier.chemin}")
        print(f"[DEBUG] Upload√© par: {fichier.uploaded_by}")
        print(f"[DEBUG] Current user: {current_user.id}")
        
        # V√©rifier les permissions
        peut_supprimer = (
            current_user.role == 'super_admin' or
            current_user.id == fichier.uploaded_by
        )
        
        # Si pas directement l'uploader, v√©rifier les permissions sur l'audit
        if not peut_supprimer and fichier.audit:
            audit = fichier.audit
            peut_supprimer = (
                current_user.id == audit.created_by or 
                current_user.id == audit.responsable_id
            )
        
        if not peut_supprimer:
            print(f"[ERROR] Permission refus√©e pour user {current_user.id}")
            return jsonify({
                'success': False,
                'message': 'Vous n\'avez pas les permissions pour supprimer ce fichier'
            }), 403
        
        # Sauvegarder les infos pour le message
        nom_fichier = fichier.nom_fichier
        audit_id = fichier.audit_id
        
        # Supprimer le fichier physique
        file_deleted = False
        if fichier.chemin and os.path.exists(fichier.chemin):
            try:
                os.remove(fichier.chemin)
                file_deleted = True
                print(f"[DEBUG] Fichier physique supprim√©: {fichier.chemin}")
            except Exception as e:
                print(f"[WARNING] Erreur suppression fichier physique: {e}")
        else:
            print(f"[WARNING] Fichier physique non trouv√©: {fichier.chemin}")
        
        # Supprimer de la base de donn√©es
        db.session.delete(fichier)
        db.session.commit()
        
        print(f"[SUCCESS] Fichier {nom_fichier} supprim√© de la BD")
        
        return jsonify({
            'success': True,
            'message': f'Fichier "{nom_fichier}" supprim√© avec succ√®s',
            'file_deleted': file_deleted
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"[ERROR] Erreur suppression fichier: {e}")
        import traceback
        traceback.print_exc()
        
        return jsonify({
            'success': False,
            'message': f'Erreur lors de la suppression: {str(e)}'
        }), 500
    

@app.route('/upload-fichier-rapport-global', methods=['POST'])
@csrf.exempt
@login_required
def upload_fichier_rapport_global():
    """Uploader un fichier depuis la page globale des rapports"""
    
    print(f"[DEBUG] D√©but upload_fichier_rapport_global")
    print(f"[DEBUG] M√©thode: {request.method}")
    print(f"[DEBUG] Form data: {request.form}")
    print(f"[DEBUG] Fichier dans request.files: {'fichier' in request.files}")
    
    audit_id = request.form.get('audit_id')
    if not audit_id:
        flash('Veuillez s√©lectionner un audit', 'error')
        print(f"[ERROR] Audit ID manquant")
        return redirect(url_for('rapports_audits'))  # Redirige vers la page liste
    
    # V√©rifier l'acc√®s √† l'audit
    audit = get_client_object_or_404(Audit, audit_id)
    
    # V√©rifier les permissions
    peut_uploader = (
        current_user.role == 'super_admin' or
        current_user.id == audit.created_by or
        current_user.id == audit.responsable_id or
        (audit.equipe_audit_ids and str(current_user.id) in audit.equipe_audit_ids.split(','))
    )
    
    if not peut_uploader:
        flash('Vous n\'avez pas les permissions pour ajouter des fichiers', 'error')
        return redirect(url_for('rapports_audits'))
    
    # V√©rifier si un fichier a √©t√© envoy√©
    if 'fichier' not in request.files:
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(url_for('rapports_audits'))
    
    fichier = request.files['fichier']
    description = request.form.get('description', '').strip()
    
    if fichier.filename == '':
        flash('Aucun fichier s√©lectionn√©', 'error')
        return redirect(url_for('rapports_audits'))
    
    # V√©rifier l'extension
    allowed_extensions = {'pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'jpg', 'jpeg', 'png', 'txt'}
    if not ('.' in fichier.filename and 
            fichier.filename.rsplit('.', 1)[1].lower() in allowed_extensions):
        flash('Type de fichier non autoris√©', 'error')
        return redirect(url_for('rapports_audits'))
    
    try:
        # D√©terminer le dossier d'upload selon le client
        if current_user.role == 'super_admin' and session.get('viewing_client_id'):
            client_id = session['viewing_client_id']
        else:
            client_id = current_user.client_id
        
        # Cr√©er le dossier sp√©cifique pour cet audit
        base_dir = 'static/uploads'
        upload_dir = os.path.join(base_dir, 'rapports_audit', str(client_id), str(audit_id))
        os.makedirs(upload_dir, exist_ok=True)
        print(f"[DEBUG] Dossier cr√©√©: {upload_dir}")
        
        # G√©n√©rer un nom de fichier unique
        timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
        nom_original = secure_filename(fichier.filename)
        nom_unique = f"{timestamp}_{nom_original}"
        chemin_complet = os.path.join(upload_dir, nom_unique)
        
        # Sauvegarder le fichier
        fichier.save(chemin_complet)
        print(f"[DEBUG] Fichier sauvegard√©: {chemin_complet}")
        print(f"[DEBUG] Taille: {os.path.getsize(chemin_complet)} octets")
        
        # Enregistrer dans la base de donn√©es
        fichier_rapport = FichierRapport(
            audit_id=audit_id,
            nom_fichier=nom_original,
            chemin=chemin_complet.replace('\\', '/'),  # Normaliser les chemins
            type_fichier=nom_original.rsplit('.', 1)[1].lower() if '.' in nom_original else 'unknown',
            taille=os.path.getsize(chemin_complet),
            description=description if description else None,
            uploaded_by=current_user.id,
            client_id=client_id
        )
        
        db.session.add(fichier_rapport)
        db.session.commit()
        print(f"[DEBUG] Fichier enregistr√© en BD avec ID: {fichier_rapport.id}")
        
        # Journaliser l'action
        try:
            log_activity(current_user.id, 'upload_fichier_rapport',
                        f"Fichier {nom_original} upload√© pour l'audit {audit.reference}",
                        'audit', audit_id)
        except Exception as log_error:
            print(f"[WARNING] Erreur journalisation: {log_error}")
        
        flash(f'‚úÖ Fichier "{nom_original}" upload√© avec succ√®s', 'success')
        print(f"[SUCCESS] Fichier upload√© avec succ√®s")
        
        # CORRECTION CRITIQUE : Rediriger vers la PAGE LISTE, pas vers le rapport complet
        return redirect(url_for('rapports_audits'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Erreur lors de l\'upload: {str(e)}', 'error')
        print(f"[ERROR] Erreur upload: {e}")
        import traceback
        traceback.print_exc()
        return redirect(url_for('rapports_audits'))

@app.route('/audits/rapports')
@login_required
def rapports_audits():
    """Page principale des rapports d'audit avec gestion des fichiers"""
    
    # V√©rification FORMULE : acc√®s au module audit
    if current_user.client and current_user.client.formule:
        formule = current_user.client.formule
        
        if not formule.can_access_module('audit_interne'):
            try:
                all_formules = FormuleAbonnement.query.filter(
                    FormuleAbonnement.is_active == True
                ).all()
                
                upgrade_suggestions = []
                for f in all_formules:
                    if f.modules.get('audit', False):
                        upgrade_suggestions.append(f)
                
                upgrade_suggestions.sort(key=lambda x: x.prix_mensuel or 0)
                
                return render_template('errors/formule_restricted.html',
                                     module_name='Rapports d\'Audit',
                                     current_formule=formule,
                                     upgrade_suggestions=upgrade_suggestions[:3])
                
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur recherche formules: {e}")
                flash('Ce module n\'est pas inclus dans votre formule', 'error')
                return redirect(url_for('dashboard'))
    
    # V√©rifier permission de voir les rapports
    if not current_user.has_permission('can_view_reports'):
        flash('Acc√®s refus√© : permission de voir les rapports requise', 'error')
        return redirect(url_for('dashboard'))
    
    # R√©cup√©rer les audits avec filtrage client
    audits = get_client_filter(Audit).filter_by(is_archived=False)\
        .order_by(Audit.created_at.desc()).all()
    
    # Statistiques
    constatations_total = sum(len(a.constatations) for a in audits)
    recommandations_total = sum(len(a.recommandations) for a in audits)
    plans_action_total = sum(len(a.plans_action) for a in audits)
    
    # R√©cup√©rer tous les fichiers de rapport
    fichiers_rapport = get_client_filter(FichierRapport)\
        .order_by(FichierRapport.created_at.desc()).all()
    
    # Grouper par audit pour l'affichage
    fichiers_par_audit = {}
    for fichier in fichiers_rapport:
        if fichier.audit_id not in fichiers_par_audit:
            fichiers_par_audit[fichier.audit_id] = []
        fichiers_par_audit[fichier.audit_id].append(fichier)
    
    # Cr√©er un dictionnaire d'audits pour r√©f√©rence rapide
    audits_dict = {audit.id: audit for audit in audits}
    
    # Statistiques pour graphiques - CORRECTION ICI
    types_audit_counts = {}
    statuts_audit_counts = {}
    
    for audit in audits:
        # Types
        type_key = audit.type_audit or 'Non sp√©cifi√©'
        types_audit_counts[type_key] = types_audit_counts.get(type_key, 0) + 1
        
        # Statuts
        statut_key = audit.statut or 'Non sp√©cifi√©'
        statuts_audit_counts[statut_key] = statuts_audit_counts.get(statut_key, 0) + 1
    
    # Couleurs par d√©faut pour les graphiques
    colors_palette = [
        '#007bff', '#6f42c1', '#e83e8c', '#fd7e14', 
        '#20c997', '#6610f2', '#6c757d', '#ffc107'
    ]
    
    # Pr√©parer les donn√©es pour les graphiques - ASSUREZ-VOUS QUE TOUTES LES CL√âS EXISTENT
    types_audit_data = {
        'labels': list(types_audit_counts.keys()),
        'data': list(types_audit_counts.values()),
        'colors': colors_palette[:len(types_audit_counts)]
    }
    
    statuts_audit_data = {
        'labels': list(statuts_audit_counts.keys()),
        'data': list(statuts_audit_counts.values()),
        'colors': ['#6c757d', '#ffc107', '#28a745', '#dc3545'][:len(statuts_audit_counts)]
    }
    
    # Statistiques fichiers
    total_fichiers = len(fichiers_rapport)
    
    return render_template('audit/rapports.html',  # CORRECTION : 'rapports.html' pas 'rapport.html'
                         audits=audits,
                         audits_dict=audits_dict,
                         constatations_total=constatations_total,
                         recommandations_total=recommandations_total,
                         plans_action_total=plans_action_total,
                         fichiers_par_audit=fichiers_par_audit,
                         total_fichiers_rapport=total_fichiers,
                         types_audit=types_audit_data,  # CORRECTION : types_audit au lieu de stats
                         statuts_audit=statuts_audit_data,  # CORRECTION : statuts_audit au lieu de stats
                         current_user=current_user,
                         now=datetime.utcnow())


@app.route('/fichier-rapport-audit/<int:fichier_id>/telecharger')
@login_required
def telecharger_fichier_rapport_audit(fichier_id):
    """T√©l√©charger un fichier de rapport"""
    
    # R√©cup√©rer le fichier
    fichier = FichierRapport.query.get_or_404(fichier_id)
    
    # V√©rifier les permissions
    audit = fichier.audit
    peut_telecharger = (
        current_user.role == 'super_admin' or
        current_user.id == audit.created_by or
        current_user.id == audit.responsable_id or
        (audit.equipe_audit_ids and str(current_user.id) in audit.equipe_audit_ids.split(',')) or
        (audit.observateurs_ids and str(current_user.id) in audit.observateurs_ids.split(','))
    )
    
    if not peut_telecharger:
        flash('Vous n\'avez pas les permissions pour t√©l√©charger ce fichier', 'error')
        return redirect(url_for('rapport_audit_complet', audit_id=audit.id))
    
    # V√©rifier que le fichier existe
    if not os.path.exists(fichier.chemin):
        flash('Fichier non trouv√©', 'error')
        return redirect(url_for('rapport_audit_complet', audit_id=audit.id))
    
    return send_file(
        fichier.chemin,
        as_attachment=True,
        download_name=fichier.nom_fichier,
        mimetype=None
    )

# ========================
# ROUTES PAGES PUBLIQUES
# ========================

# Page d'accueil principale (landing page)
@app.route('/home')
def home():
    """Page de couverture principale"""
    # Si l'utilisateur est connect√©, rediriger vers le dashboard
    if current_user.is_authenticated:
        return redirect(url_for('dashboard'))
    
    # Afficher la nouvelle page de couverture
    return render_template('home.html')



# Page de login - redirection vers auth/login_fullscreen
@app.route('/login', methods=['GET', 'POST'])
@csrf.exempt
def login():
    """Page de connexion - Redirection vers login fullscreen"""
    
    # Si d√©j√† connect√©, rediriger vers dashboard
    if current_user.is_authenticated:
        return redirect(url_for('dashboard'))
    
    # Rediriger vers la page de login fullscreen
    return redirect(url_for('login_fullscreen'))


# Page de login fullscreen (votre page de login existante)
@app.route('/auth/login_fullscreen', methods=['GET', 'POST'])
@csrf.exempt
def login_fullscreen():
    """Page de connexion fullscreen"""
    
    # Si d√©j√† connect√©, rediriger vers dashboard
    if current_user.is_authenticated:
        return redirect(url_for('dashboard'))
    
    form = LoginForm()
    
    if request.method == 'POST' and form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        
        if user and user.check_password(form.password.data):
            if not user.is_active:
                flash('Ce compte est d√©sactiv√©', 'error')
                return render_template('auth/login_fullscreen.html', form=form)
            
            login_user(user, remember=form.remember_me.data)
            next_page = request.args.get('next')
            
            # Journaliser la connexion
            log_activity(user.id, 'connexion', f"Utilisateur {user.username} connect√©")
            
            flash(f'Bienvenue {user.username}!', 'success')
            return redirect(next_page or url_for('dashboard'))
        else:
            flash('Nom d\'utilisateur ou mot de passe incorrect', 'error')
    
    return render_template('auth/login_fullscreen.html', form=form)


# Logout
@app.route('/logout')
@login_required
def logout():
    """D√©connexion avec redirection vers la page d'accueil"""
    logout_user()
    flash('Vous avez √©t√© d√©connect√© avec succ√®s.', 'info')
    return redirect(url_for('home'))  # Redirige vers la nouvelle page d'accueil

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5005)
